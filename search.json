[{"title":"分盘","url":"/2024/12/28/分盘/","content":"\n# 新电脑如何从C盘分出D盘？其实很简单！\n\n新购买的电脑通常只有一个分区，也就是[只有C盘](https://www.disktool.cn/jiaocheng-new/how-to-partition-hard-drive-in-windows10.html)，这意味着系统和软件都会被安装在这个盘上，文件也会存储在同一个位置，这样使用起来并不方便。如果电脑遭受病毒攻击或者系统故障需要重新安装系统，很可能会导致重要文件的丢失。此外，文件的存储和管理也会变得不便，难以进行有效的分类、查找和浏览。\n\n新电脑如何从C盘分出D盘？其实很简单！操作也并不复杂，即便是电脑小白也能轻松完成。接下来，我们来看一下具体的步骤，而且操作完成后无需重启电脑，只需几分钟就能搞定。\n\n## 方法一：使用磁盘管理从C盘分出D盘\n\n[磁盘管理](https://www.disktool.cn/content-center/win10-comes-with-hard-disk-partition-369.html)是Windows中自带系统实用程序，可以帮助我们管理磁盘和分区。我们可以通过它对分区进行一些简单的基础调整，比如压缩卷、扩展卷、删除卷、更改盘符等。\n\n1. 同时按**Win+R**输入**diskmgmt.msc**并按**回车**键打开磁盘管理。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/diskmgmt.png)\n\n\n2. 选择一个空闲空间比较大的磁盘进行压缩，比如我们希望把D盘的一些磁盘空间调整到C盘，那么我们可以选中D盘，然后再其上点击鼠标右键，在弹出的菜单中选择**“压缩卷”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/ys1.png)\n\n3. 然后在输入压缩空间量（MB）里填写要压缩出的空间，然后点击**“压缩”**即可。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/ys2.png)\n\n\n**✍ 公式：** 输入压缩空间总量=压缩前的总计大小-压缩后的总计大小（C 盘空间大小），1GB=1024MB，举例：总大小 1000GB，预留C盘 200GB，输入压缩空间量=1000GB-200GB=800GB=1024MBx800=819200MB。\n\n4. 压缩完后，我们可以看到磁盘卷中会多出一个黑色分区的**“未分区磁盘”**；然后我们只需要将该未分区磁盘空间分配给C盘即可。右键点击需要扩充容量的盘符，然后在弹出的菜单中选择**“扩展卷”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/kz1.png)\n\n\n**✍ 注意：** 扩展卷只能合并相邻的未分配空间，若压缩出的未分配空间与你想要合并的分区不相邻，你可以[移动分区](https://www.disktool.cn/jiaocheng-new/2019/how-to-move-partition.html)将未分配空间移动到相邻的位置。\n\n5. 之后会弹出如下扩展卷操作向导对话框界面，选择你想要将多少未分配空间用于扩展分区，设置完毕后单击**“下一步”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/kz2.png)\n\n\n6. 按照提示流程操作完毕之后，单击**“完成”**以退出扩展卷向导即可。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/kz3.png)\n\n\n## 方法二：使用分区助手从C盘分出D盘\n\n如果你觉得磁盘管理创建分区步骤太多，可以使用免费的磁盘分区管理软件--[傲梅分区助手](https://www.disktool.cn/feature.html)，它的“拆分分区”功能可以直接拆分C盘，创建新的分区。轻松的将大分区拆分为一个或多个小分区。\n\n1. 下载安装启动傲梅分区助手，右键单击有多余空间的C盘，选择**“拆分分区”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/1.png)\n\n2. 左右移动中间的圆圈调整分区大小，点击**“高级”**设置分区卷标等，无误后点击**“确认”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/2.png)\n\n**✍ 注意：**如果分区存在于SSD上，你可以点击高级，勾选**“允许分区对齐以优化SSD的性能”**。\n\n3. 返回主界面，点击**“提交”**以查看操作预览，无误后点击**“执行”**开始创建新分区。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/3.png)\n\n\n## 方法三：使用Diskpart分区磁盘\n\nDiskpart是Windows中的命令提示符，使用这个命令去分区后不用重启系统也可以生效。通过Diskpart也可以对[硬盘进行重新分区](https://www.disktool.cn/content-center/hard-disk-repartition-method-369.html)，不过需要掌握一定的知识才能操作。具体的步骤如下：\n\n1.按**“Windows + R”**键，在弹出的**“运行”**对话框中输入**“diskpart”**，并按**“回车”**键。\n\n2.输入**“list disk”**命令，查看电脑磁盘的所有磁盘的情况。\n\n3.输入**“select disk A”**命令，其中A代表需要创建的分区的编号。\n\n4.输入**“clean”**命令，清空A磁盘分区，使之成为未分配磁盘分区。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/clean.png)\n\n\n5.根据实际的创建磁盘分区的需求键入以下命令。\n\n🧰 **create partition primary size=n**(创建主分区)\n🧰 **create partition primary size=n**(创建主分区)\n🧰 **create partition logical size=n**(创建逻辑分区)\n\n## 结语\n\n以上就是新电脑从C盘分出D盘的3种方法，建议使用分区助手新建D盘，简单有效。希望本文对你有所帮助！傲梅分区助手除了可以新建分区。它还提供了很多Windows自带磁盘管理工具无法完成的分区功能，比如制作启动光盘、[无损转换MBR与GPT](https://www.disktool.cn/content-center/gpt-mbr/how-to-convert-gpt-to-mbr-without-data-loss.html)、磁盘测速等。赶紧下载试一试吧！\n","tags":["分盘"]},{"title":"AlexNet 图像分类（PyTorch框架）","url":"/2024/12/26/AlexNet图像分类（PyTorch框架）/","content":"\n# [手撸代码：从零开始的 AlexNet 图像分类（PyTorch框架） ](https://www.cnblogs.com/xing9/p/18002038/AlexNet-PyTorch \"发布于 2024-02-03 14:16\")\n\n## 摘要：\n\n本文在 PyTorch 框架下搭建了 AlexNet ，并在 CIFAR10 上完成了图片分类。同时，更正了一些原论文中的小错误（如：输入图像尺寸）。由于 CIFAR10 没有验证集，本文将训练集的 10% 当作验证集。\n\n完整代码已上传至 GitHub：<https://github.com/TiezhuXing01/AlexNet_in_PyTorch>\n\n***\n\n## 1. 引入库\n\n```python\n    import torch\n    import torch.nn as nn\n    import numpy as np\n    from torchvision import datasets\n    from torchvision import transforms\n    from torch.utils.data.sampler import SubsetRandomSampler\n```\n\n`SubsetRandomSampler` 是 PyTorch 中的一个采样器（sampler）。\n具体可以看这篇文章：[SubsetRandomSampler 是什么？](https://www.cnblogs.com/xing9/articles/18004465/SubsetRandomSampler)\n\n***\n\n## 2. 选择设备\n\n```python\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n```\n\n通常情况下，我们都会选择在GPU上训练网络模型，因为神经网络的训练需要大量的计算，而英伟达的GPU提供了CUDA（一个加速计算库）。但如果你的电脑显卡是AMD的，那么有很大概率不支持使用CUDA，此时只能用CPU训练。但在CPU上训练模型是十分缓慢的。如果你暂时没法换电脑，那我建议你去租一个服务器。或者使用阿里云、百度飞桨、谷歌Colab等平台。\n\n***\n\n## 3. 加载数据集\n\nCIFAR-10 是一个经典的计算机视觉数据集，用于图像分类任务。它包含了来自 10 个不同类别的 60,000 张彩色图像，每个类别有 6,000 张图像。数据集被分为训练集和测试集，其中训练集包含 50,000 张图像，测试集包含 10,000 张图像。本文拿出训练集的 10% 作为验证集。\n\n### 3.1 定义获取训练集和验证集的数据加载器\n\n```python\ndef get_train_val_loader(data_dir, batch_size, augment,\n                         random_seed, valid_size = 0.1, shuffle = True):\n \n  # ------------- 设置图像变换 ------------- #\n  # (1) 归一化\n  normalize = transforms.Normalize(mean = [0.4914, 0.4822, 0.4465],\n                                   std = [0.2023, 0.1994, 0.2010])\n  # (2) 验证集图像变换\n  val_transform = transforms.Compose([transforms.Resize(227),\n                                   transforms.ToTensor(),\n                                   normalize])\n  # (3) 训练集是否数据增强\n  if augment:\n    train_transform = transforms.Compose([transforms.RandomHorizontalFlip(),\n                                      transforms.Resize(227),\n                                      transforms.ToTensor(),\n                                      normalize])\n  else:\n    train_transform = transforms.Compose([transforms.Resize(227),\n                                       transforms.ToTensor(),\n                                       normalize])\n  # ---------- 👆 数据变换设置完毕 -------------- #\n \n  # 下载并加载训练集\n  train_dataset = datasets.CIFAR10(root = data_dir,\n                                  train = True,\n                                  download = True,\n                                  transform = train_transform)\n  val_dataset = datasets.CIFAR10(root = data_dir,\n                                  train = True,\n                                  download = True,\n                                  transform = val_transform)\n \n  # ---------- 划分验证集和训练集 ----------  #\n  # (1) 计算训练集图片数量\n  num_train = len(train_dataset)\n  # (2) 计算验证集数量，并向下取整\n  num_val = np.floor(valid_size * num_train)\n  # (3) 设置训练集和验证集的划分界限\n  split = int(num_val)\n  # (4) 生成一个列表索引，其内容为 0 ~ (num_train - 1) 的全部整数\n  indices = list(range(num_train))    # 为数据\"洗牌\"做准备\n  if shuffle:\n    np.random.seed(random_seed) # 根据种子生成随机数\n    np.random.shuffle(indices)  # 根据随机数打乱图片\n  # (5) 划分验证集和训练集(根据索引列表 indices 和划分界限 split 划分)\n  val_idx = indices[:split]     # 验证集索引列别\n  train_idx = indices[split:]   # 训练集索引列表\n  # (6) 根据验证集和训练集的索引列表采样数据\n  train_sampler = SubsetRandomSampler(train_idx)\n  val_sampler = SubsetRandomSampler(val_idx)\n  # ---------- 👆 训练集和验证集划分完毕 ---------- #\n \n  # 设置数据加载器\n  train_loader = torch.utils.data.DataLoader(train_dataset,\n                                             batch_size = batch_size,\n                                             sampler = train_sampler)\n  val_loader = torch.utils.data.DataLoader(val_dataset,\n                                           batch_size = batch_size,\n                                           sampler = val_sampler)\n \n  return (train_loader, val_loader)\n```\n\n***\n\n### 3.2 定义获取测试集的数据加载器\n\n```python\ndef get_test_loader(data_dir, batch_size, shuffle = True):\n \n  # ------------- 设置图像变换 ------------- #\n  # 归一化\n  normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                  std=[0.229, 0.224, 0.225],)\n  # 图像变换\n  test_transform = transforms.Compose([transforms.Resize(227),\n                                transforms.ToTensor(),\n                                normalize])\n \n  # 下载并加载测试集\n  test_dataset = datasets.CIFAR10(root = data_dir,\n                                  train = False,\n                                  download = True,\n                                  transform = test_transform)\n \n  # 加载测试数据\n  test_loader = torch.utils.data.DataLoader(test_dataset,\n                                            batch_size = batch_size,\n                                            shuffle = shuffle)\n \n  return test_loader\n```\n\n***\n\n### 3.3 调用函数，加载数据\n\n```python\n# 设置数据集下载路径\ndata_dir = \"./data\"\n# 设置批尺寸\nbatch_size = 64\n# 调用训练集和验证集的 DataLoader\ntrain_loader, val_loader = get_train_val_loader(data_dir = data_dir,\n                                                batch_size = batch_size,\n                                                augment = True,\n                                                random_seed = 1)\n# 调用测试集的 DataLoader\ntest_loader = get_test_loader(data_dir = data_dir,\n                              batch_size = batch_size,\n                              shuffle = False)\n```\n\n***\n\n## 4. 认识网络\n\n![AlexNet 结构图](<https://s2.loli.net/2024/12/26/6yosugXcIEOVGFl.png>)\n\nAlexNet 是卷积神经网络的奠基之作，发表时间较早，所以今天看来有一些错误或者局限性：\n\n(1) 在2012年 AlexNet 被提出时，GPU 的算力相对今天来说非常小。为了训练这个网络，他们把 AlexNet **从中间切开**，使用多 GPU 训练，分别在 2 块 GTX 580 3G 上花了五、六天时间。\n\n(2) 这种切割只是一种**技术细节**，以后几年的模型大多都不会这么切割，多 GPU 训练也不是通过切割模型来实现。所以本文的代码并**没有切割**网络，也没有用到多 GPU 训练。\n\n(3) 论文中写到，输入图片的尺寸是 $24*24*3$ ，即 3 个通道的 $24*24$ 图片。但事实上，这是作者的小错误。正确尺寸应为 $27*27*3$ .\n\n如果按照论文说的输入尺寸做，会出现错误。可以来算一下， 卷积输出尺寸公式为：  \n$output size=\\frac{input size-kernel size+2*padding}{stride}+1$\n第一次卷积后：$output size=\\frac{224-11+2*0}{4}+1=54.25$ 出现小数了。\n\n***\n\n在一块 GPU 上训练的正确 AlexNet 结构及其输入输出尺寸应为下表。\n\n|                  |                  |                  |            |          |          |                                 |\n| ---------------- | ---------------- | ---------------- | ---------- | -------- | -------- | ------------------------------- |\n| **操作**<br>**名称** | **输入**<br>**通道** | **输出**<br>**通道** | **核尺寸** | **步幅** | **填充** | **输出尺寸**<br>**输入: 227×227×3** |\n| conv1            | 3                | 96               | 11×11      | 4        | 0        | 55×55×96                        |\n| pool             |                  |                  | 3 × 3      | 2        |          | 27×27×96                        |\n| conv2            | 96               | 256              | 5 × 5      | 1        | 2        | 27×27×256                       |\n| pool             |                  |                  | 3 × 3      | 2        |          | 13×13×256                       |\n| conv3            | 256              | 384              | 3 × 3      | 1        | 1        | 13×13×384                       |\n| conv4            | 384              | 384              | 3 × 3      | 1        | 1        | 13×13×384                       |\n| conv5            | 384              | 256              | 3 × 3      | 1        | 1        | 13×13×256                       |\n| pool             |                  |                  | 3 × 3      | 2        |          | 6×6×256                         |\n| fc1              |                  |                  |            |          |          | 9216                            |\n| fc2              |                  |                  |            |          |          | 4096                            |\n| fc3              |                  |                  |            |          |          | num_classes(=10)               |\n\n***\n\n## 5. 搭建网络\n\n```python\nclass AlexNet(nn.Module):\n    def __init__(self, num_classes=10):\n        super(AlexNet, self).__init__()\n        self.conv_block1 = nn.Sequential(\n                        nn.Conv2d(3, 96, kernel_size=11, stride=4, padding=0),\n                        nn.BatchNorm2d(96),\n                        nn.ReLU()\n                        )\n        self.conv_block2 = nn.Sequential(\n                        nn.Conv2d(96, 256, kernel_size=5, stride=1, padding=2),\n                        nn.BatchNorm2d(256),\n                        nn.ReLU()\n                        )\n        self.conv_block3 = nn.Sequential(\n                        nn.Conv2d(256, 384, kernel_size=3, stride=1, padding=1),\n                        nn.BatchNorm2d(384),\n                        nn.ReLU()\n                        )\n        self.conv_block4 = nn.Sequential(\n                        nn.Conv2d(384, 384, kernel_size=3, stride=1, padding=1),\n                        nn.BatchNorm2d(384),\n                        nn.ReLU()\n                        )\n        self.conv_block5 = nn.Sequential(\n                        nn.Conv2d(384, 256, kernel_size=3, stride=1, padding=1),\n                        nn.BatchNorm2d(256),\n                        nn.ReLU()\n                        )\n        self.pool = nn.MaxPool2d(kernel_size = 3, stride = 2)\n        self.fc1 = nn.Sequential(nn.Dropout(0.5),nn.Linear(9216, 4096),nn.ReLU())\n        self.fc2 = nn.Sequential(nn.Dropout(0.5),nn.Linear(4096, 4096),nn.ReLU())\n        self.fc3 = nn.Sequential(nn.Linear(4096, num_classes))\n \n    def forward(self, x):\n        out = self.conv_block1(x)\n        out = self.pool(out)\n        out = self.conv_block2(out)\n        out = self.pool(out)\n        out = self.conv_block3(out)\n        out = self.conv_block4(out)\n        out = self.conv_block5(out)\n        out = self.pool(out)\n        out = out.reshape(out.size(0), -1)\n        out = self.fc1(out)\n        out = self.fc2(out)\n        out = self.fc3(out)\n        return out\n```\n\n* `Dropout`：让一部分神经元输出为0. 目前认为它是一个正则项，防止过拟合。由于目前很少使用全连接了，所以`Dropout`不是那么重要了。\n\n***\n\n## 6. 设置超参数\n\n```python\nnum_classes = 10\nepochs = 20\nlearning_rate = 0.005\n \nmodel = AlexNet(num_classes).to(device)\n \n# 设置损失函数\ncost = nn.CrossEntropyLoss()\n \n# 设置优化器\noptimizer = torch.optim.SGD(model.parameters(),     # SGD 随机梯度下降\n                            lr = learning_rate,\n                            weight_decay = 0.005,   # 正则化项的权重是 0.005\n                            momentum = 0.9)\n \n# 一个 epoch 训练的总 step 数\ntrain_step = len(train_loader)\n```\n\n* `len(train_loader)`返回加载器中的批次数量。$\\frac{5000*(1-0.1)}{64}=703.125$，结果出现小数，向上取整为704.\n\n* 随机梯度下降（SGD）现在是深度学习最主流的优化算法，因为其内部的噪声使模型有更好的泛化能力。\n\n* `weight_decay`：是 L2 的正则项。\n\n* **正则化**：在机器学习中，正则化是一种用于**防止过拟合**的技术。限制模型的复杂性，防止模型对训练数据中的噪声过于敏感，从而提高其在未知数据上的泛化能力。在 AlexNet 提出那年（2012），人们普遍认为正则化对解决模型过拟合问题是很重要的。但在后期，这个观点被推翻了。取而代之的是，网络的**设计**对防止过拟合更重要的。\n\n* `momentum`：动量是一种优化算法中常用的技术，通常与随机梯度下降（SGD）结合使用，用于加速模型的训练过程。它的功能是**避免因下降曲线不平滑而落入局部最优解中。**动量的引入主要是为了解决随机梯度下降的一些问题，例如在梯度更新中存在的震荡和收敛速度慢的问题。动量算法引入了一个指数衰减的累积变量，用来持续跟踪梯度的历史信息。这个累积变量就是动量。动量在更新参数时不仅考虑当前梯度，还考虑了之前梯度的方向。这有助于平滑更新过程，减少参数更新的震荡，提高模型训练的稳定性和速度。\n\n***\n\n## 7. 训练和验证\n\n训练需要 2 个循环的嵌套：外部循环用于循环 epoch ；内部循环用于循环每个 epoch 中的每个 batch 的图片，一个 batch 一步（step）。\n\n```python\nfor epoch in range(epochs):\n  for i, (images, labels) in enumerate(train_loader):\n    images = images.to(device)\n    labels = labels.to(device)\n \n    outputs = model(images)\n    loss = cost(outputs, labels)\n \n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n \n  print(\"Epoch [{}/{}], Step [{}/{}], Loss:{:.4f}\".format(\n      epoch+1, epochs, i+1, train_step, loss.item()))   # loss是张量，需要.item()转为浮点型\n \n  # 一个epoch完成之后，进入验证\n  with torch.no_grad():\n    correct = 0\n    total = 0\n    for images, labels in val_loader:\n      images = images.to(device)\n      labels = labels.to(device)\n      outputs = model(images)\n      _, predicted = torch.max(outputs.data, 1)\n      total += labels.size(0)\n      correct += (predicted == labels).sum().item()\n      # del images, labels, outputs   # 删除变量以释放内存\n \n    # 输出验证结果\n    print(\"Accuracy on validation: {} %\".format(100 * (correct / total)))\n```\n\n* **注意**：`enumerate(train_loader)` 返回的是 `(index, (images, labels))` 的元组，所以`for i, images, labels in enumerate(train_loader):`是错的，应该为`for i, (images, labels) in enumerate(train_loader):`. 相关文章：[enumerate(train_loader) 返回什么？](https://www.cnblogs.com/xing9/articles/18004447/enumerate)\n\n* `torch.max(outputs.data, 1)`返回每一行的最大值以及这些最大值所在的索引。第一个返回值（`_`）是最大值，第二个返回值（`predicted`）是最大值的索引。在这种情况下，我们只关心索引，因为它表示了模型的预测类别。\n\n* `labels.size(0)`返回的是当前批次中标签的数量。[如何理解 labels.size(0)](https://www.cnblogs.com/xing9/articles/18004411/labels_size)\n\n* `del images, labels, outputs` 是手动删除变量以释放内存。在Python中，这通常是不必要的，因为Python的垃圾回收器会自动处理不再使用的对象。\n\n* `for images, labels in val_loader:`不需要`numerate(val_loader)`是因为验证阶段不需要索引，看的是验证集整体的准确度。\n\n训练结果如下图：\n![](https://s2.loli.net/2024/12/26/sT6eduMPiQboJXZ.png)\n\n***\n\n## 8.测试\n\n```python\nwith torch.no_grad():\n  correct = 0\n  total = 0\n  for images, labels in test_loader:\n    images = images.to(device)\n    labels = labels.to(device)\n    outputs = model(images)\n    _, predicted = torch.max(outputs.data, 1)\n    total += labels.size(0)\n    correct += (predicted == labels).sum().item()\n    # del images, labels, outputs   # 删除变量以释放内存\n \n  # 输出测试结果\n  print(\"Accuracy on test: {} %\".format(100 * (correct / total)))\n```\n\n测试结果如下图：\n![](<https://s2.loli.net/2024/12/26/Ut3OzesQmKc8wJI.png>)\n\n***\n\n以上，就是 AlexNet 实现图像分类的全部内容。\n","tags":["AlexNet","PyTorch"]},{"title":"LeNet5 图像分类（PyTorch 框架）","url":"/2024/12/26/LeNet5 图像分类（PyTorch 框架）/","content":"# [手撸代码：从零开始的 LeNet5 图像分类（PyTorch 框架） ](https://www.cnblogs.com/xing9/p/17997507/LeNet5-PyTorch \"发布于 2024-01-31 14:13\")\n\n## **摘要：**\n\n本文介绍了如何从0开始构建 LeNet5 去识别手写数字（在MNIST数据集上）。代码包括三大部分：**网络**结构部分、**训练**部分、**测试**部分。在编LeNet5部分代码之前，本文详细地梳理了LeNet5的结构，对于初学者十分友好。训练和测试部分也都有详细的代码说明。\n\n在实现 LeNet5 手写数字识别的同时，补充了很多CNN的基础概念和Python编程知识。包括：PyTorch中的常用库和其中的模块，特征图在卷积过程中尺寸如何变化，如何把数据加载进训练程序等。\n\n本文不是通过复制粘贴代码介绍如何实现 LeNet5 的手写数字识别，而是通过内在逻辑，深层次地阐述这一过程，力求“知其然，知其所以然。”\n\n完整代码已经上传至GitHub：<https://github.com/TiezhuXing01/LeNet5_in_PyTorch.git>\n\n***\n\n**温馨提示：**\n（1）本文主要介绍如何从0实现LeNet5，注重编程思路的讲解，对于一些前置知识不做赘述。\n（2）请确保你已经**配置好**并进入了深度学习**环境**。\n（3）目录导航见页面**右上角**黄色方块。\n**前置知识：**\n（1）概念：PyTorch、卷积、池化、全连接、ReLU、前向传播、反向传播\n（2）对python语法有基本的了解\n\n***\n\n在从0开始编程前，我们首先思考一下，一个由LeNet5完成的图像分类任务（如：手写数字识别），都需要哪些组成部分？\n\n首先，肯定要有**LeNet5**网络结构的代码。\n其次，还要有在训练集上**训练**的代码，让网络学习特征表示。\n最后，训练完要在测试集上**测试**，不然咋知道训练得效果怎样呢？\n\n***\n\n## 1. 引入库（Import the Libraries）\n\n“库”是一组已经写好的代码，可以理解为一个“工具箱”。对于某些功能的实现，开发者可以从引入的“工具箱”中拿出工具直接使用，而不是从头开始“造工具”（即编代码）。所以在所有工作之前，要把“工具箱”引入进来，以方便后续编程。但有时候，我们引入库时可能会漏掉一些库，在编程到后面才意识到。不用担心，我们再回到开头这里引入库就好了。\n\n```haskell\n    import torch\n    import torch.nn as nn\n    import torchvision\n    import torchvision.transforms as transforms\n```\n\n* `torch`库提供了各种用于张量（tensor）操作、神经网络搭建、优化算法等方面的函数。\n  什么是张量？如果你对张量（tensor）不了解，不用担心，你只需要记住这是图片经过某种处理之后的一种形式，就像你已知的图片有.jpg和.png格式一样。但对于.jpg和.png格式的图像，神经网络并不喜欢，无法直接处理它们。而张量（tensor）这种形式，适用于神经网络的处理。\n\n* `torch.nn`库可以理解为大工具箱`torch`里面的小工具箱`nn`。这个模块里包含构建神经网络层和模型的类和函数。`import torch.nn as nn`表示，引入之后，模块`torch.nn`的名字就可以简称`nn`了。\n\n* `torchvision`库提供了一系列用于图像处理、计算机视觉数据集加载、图像变换、以及许多流行的计算机视觉模型的实现。\n\n* `torchvision.transforms`模块用于进行图像的变换和预处理。这个模块包含了一系列用于处理图像的转换函数，可用于数据增强、数据清理和准备图像数据以输入神经网络等任务。\n\n***\n\n## 2. 选择在哪个设备上训练模型（GPU或CPU）\n\n通常情况下，我们都会选择在GPU上训练网络模型，因为神经网络的训练需要大量的计算，而英伟达的GPU提供了CUDA（一个加速计算库）。但如果你的电脑显卡是AMD的，那么有很大概率不支持使用CUDA，此时只能用CPU训练。但在CPU上训练模型是十分缓慢的。如果你暂时没法换电脑，那我建议你去租一个服务器。或者使用阿里云、百度飞桨、谷歌Colab等平台。\n\n```ini\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n```\n\n* `torch.cuda.is_available()`函数的功能是检查系统中是否安装了可用的 CUDA并且 GPU 是可用的。如果 GPU 可用，返回 True，否则返回 False。\n\n* `'cuda' if torch.cuda.is_available() else 'cpu'`表示如果GPU可用，则返回字符串`'cuda'`。如果不可用，则返回字符串`'cpu'`。\n\n* 如果函数`torch.device(...)`接收到的是`'cuda'`，则选择在GPU上计算，如果接收到的是`'cpu'`，则选择在CPU上进行计算。\n\n***\n\n## 3. 认识网络\n\n充分地认识网络，才能在编程时思路清晰、游刃有余。下图是LeNet5的结构图，请你直观地认识一下LeNet5。如果你不想了解，可以直接去 4. 构建网络，不过我不建议你这样。\n本例中LeNet5处理的MNIST数据集图片尺寸都是32×32. 所以下图的输入图片是32×32.\n\n![image](<https://s2.loli.net/2024/12/26/QN6wUGncvDbgiyY.png>)\n\n我把上图的网络结构具体为下面的表格，以便我们后续编程。注意：画表格并不是编程所需的必要步骤，只是我希望表达得更清晰。\n\n| 层的名称  | 具体操作 | 输入通道数 | 输出通道数 | 核或池的尺寸 | 步幅 |\n| --------- | -------- | ---------- | ---------- | ------------ | ---- |\n| 卷积层1   | 卷积     | 1          | 6          | 5×5          | 1    |\n|           | 批归一化 | 6          | 6          | --           | --   |\n|           | ReLU     | 6          | 6          | --           | --   |\n| 下采样    | 最大池化 | 6          | 6          | 2×2          | 2    |\n| 卷积层2   | 卷积     | 6          | 16         | 5×5          | 1    |\n|           | 批归一化 | 16         | 16         | --           | --   |\n|           | ReLU     | 16         | 16         | --           | --   |\n| 下采样    | 最大池化 | 16         | 16         | 2×2          | 2    |\n| 全连接层1 | 全连接   | 400        | 120        | --           | --   |\n|           | ReLU     | 120        | 120        | --           | --   |\n| 全连接层2 | 全连接   | 120        | 84         | --           | --   |\n|           | ReLU     | 84         | 84         | --           | --   |\n| 高斯连接  | 全连接   | 84         | 类别总数10 | --           | --   |\n\n下面我们梳理一下LeNet5的详细流程，这样到后面编程的时候不会懵。\n\n***\n\n### （1）卷积层1：提取低级特征\n\n#### a) 第一次卷积\n\n在图中可以看到，第一次卷积操作之后，不仅通道**由1变6**，原图32×32的尺寸也变成了28×28，这与卷积核大小、步幅和 $padding$ 有关（LeNet5中，2次卷积padding都为0）。输出特征图像尺寸公式如下：\n$output size=\\frac{W-kernel size+2*padding}{stride}+1$\n其中， $W$ 表示输入图像的宽度。\n\n将数代入公式：\n$output size=\\frac{35-5+2*0}{1}+1=28$\n#### b) 批归一化\n\n批归一化 (Batch Normalization) 是一种用于提高神经网络训练稳定性和加速收敛的方法。在卷积神经网络中，每个通道都有一个独立的归一化参数。因此输入是6通道，输出还是**6**通道。\n\n#### c) ReLU激活函数\n\n产生非线性映射，通道数还是**6**，不变。\n\n***\n\n### （2）下采样\n\n最大池化，通道数不变，还是**6**，特征图尺寸由28×28下降到14×14. 计算公式如下：\n$output size=\\frac{W-pool size}{stride}+1=\\frac{28-2}{2}+1=14$\n***\n\n### （3）卷积层2：提取高级特征\n\n#### a) 第二次卷积\n\n通道由6变**16**，输出特征图尺寸为10×10.具体计算公式如下：\n$output size=\\frac{W-kernel size+2*padding}{stride}+1=\\frac{14-5+2*0}{1}+1=10$\n#### b) 批归一化+ReLU\n\n输出通道还是**16**。\n\n***\n\n### （4）下采样\n\n特征图尺寸由10×10变成5×5，输出通道还是**16**。\n$output size=\\frac{W-pool size}{stride}+1=\\frac{10-2}{2}+1=5$\n***\n\n### （5）全连接层1\n\n将输入维度为 400 的向量（一维数组）映射到维度为 120 的输出向量。\n其中，400为16个通道的5×5大小的所有像素数量。$16*5*5=400$\n120是研究人员通过在实验中不断调整得到的。\n\n### （6）全连接层2\n\n将前一层的 120 个节点映射到 84 个节点。\n\n### （7）高斯连接（全连接层3）\n\n将84个节点映射到10个具体类别上，即0~9这10个数字上。\n\n***\n\n## 4. 搭建网络\n\n在搭建之前，我将介绍一个“工具”。`nn.Sequential()`是 PyTorch 中用于构建容器（container）的类。通俗地讲，这个工具的作用就是把好几个操作串到一起，按顺序执行。\n\n```python\n    # 定义名为 LeNet5 的类，该类继承自 nn.Module\n    class LeNet5(nn.Module):\n        def __init__(self, num_classes):\n            super(LeNet5, self).__init__()\n            # 卷积层 1\n            self.layer1 = nn.Sequential(\n                nn.Conv2d(1, 6, kernel_size=5, stride=1, padding=0),    # 卷积\n                nn.BatchNorm2d(6),      # 批归一化\n                nn.ReLU(),)\n            # 下采样\n            self.subsampel1 = nn.MaxPool2d(kernel_size = 2, stride = 2)     # 最大池化\n            # 卷积层 2\n            self.layer2 = nn.Sequential(\n                nn.Conv2d(6, 16, kernel_size=5, stride=1, padding=0),\n                nn.BatchNorm2d(16),\n                nn.ReLU(),)\n            # 下采样\n            self.subsampel2 = nn.MaxPool2d(kernel_size = 2, stride = 2)\n            # 全连接\n            self.L1 = nn.Linear(400, 120)\n            self.relu = nn.ReLU()\n            self.L2 = nn.Linear(120, 84)\n            self.relu1 = nn.ReLU()\n            self.L3 = nn.Linear(84, num_classes)\n        # 前向传播\n        def forward(self, x):\n            out = self.layer1(x)\n            out = self.subsampel1(out)\n            out = self.layer2(out)\n            out = self.subsampel2(out)\n            # 将上一步输出的16个5×5特征图中的400个像素展平成一维向量，以便下一步全连接\n            out = out.reshape(out.size(0), -1)\n            # 全连接\n            out = self.L1(out)\n            out = self.relu(out)\n            out = self.L2(out)\n            out = self.relu1(out)\n            out = self.L3(out)\n            return out\n```\n\n发现没有？套路就是：先self.各种层，一顿定义。然后到前向传播（`forward`）那里，开始用上一步定义的`self.something()`。最后，`return out`返回输出值。\n\n对于初学者而言，如果Python基础不牢，最开始那三行代码理解起来可能比较吃力。其实用多了就会发现，这就是个套路，不理解也不耽误编程。\n\n***\n\n此处展开前三行代码\n\n```haskell\n    class LeNet5(nn.Module):\n        def __init__(self, num_classes):\n            super(LeNet5, self).__init__()\n```\n\n* 我们来看第一行代码。这行代码定义了一个名为 `LeNet5` 的类，它继承自 `nn.Module`（别忘了，在最开始引入库时，引入过`nn`），说明这是一个 PyTorch 框架中神经网络模型的基类。所有的神经网络模型都应该继承自 `nn.Module`，这样它们就能够利用 PyTorch 提供的模型管理和训练的功能。\n\n* 第二行代码：是类的构造函数（initializer）。构造函数用于初始化类的实例。`num_classes`是类别数，这里是我们构造的网络所接收的参数，后续要用到这个参数。\n\n* 第三行代码：调用了父类 `nn.Module` 的构造函数，确保正确地初始化 LeNet5 类的父类部分。这是 Python 中用于调用父类方法的一种方式。\n\n如果读完这些解释还是不理解，没关系，你可以把这三行当作一个套路，用多了自然就会记住。\n\n套路如下：\n\n```ruby\n    class 网络名字(nn.Module):\n        def __init__(self, 需要接受的参数)：\n            super(网络名字, self).__init__()\n```\n\n***\n\n## 5. 准备（加载）数据集\n\n在上一步中，LeNet5已经搭建好了，现在该编写训练部分的程序了。但是在这之前有一步不能落下，那就是数据加载。\n\n要把数据集里的一堆数据“码好”了，一批一批地“喂”给LeNet5.\n\nMNIST 数据集是一个手写数字图像数据集，包含了大量的手写数字图片，每张图片都标注了对应的数字。\n`torchvision.datasets.MNIST(...)`是 PyTorch 中用于加载 MNIST 数据集的类。\n`torch.utils.data.DataLoader(...)` 是 PyTorch 中用于批量加载数据的工具类，是一个数据加载器。\n\n注意：前者用于加载数据**集**，后者用于加载数据，不要混淆。\n\n把一个数据集比作一副扑克牌，那么一张扑克牌就是一个数据。把DataLoader比作神经网络的手，手去抓牌。一次抓几张，抓牌有没有顺序，等等，这些都是通过设置DataLoader的参数决定的。batch_size等于几就是一次抓几张牌，即一次“喂”给神经网络几张图片。\n\n```ini\n    # 加载训练集\n    train_dataset = torchvision.datasets.MNIST(root = './data', # 数据集保存路径\n                                               train = True,    # 是否为训练集\n                                               # 数据预处理\n                                               transform = transforms.Compose([\n                                                      transforms.Resize((32,32)),\n                                                      transforms.ToTensor(),\n                                                      transforms.Normalize(mean = (0.1307,), \n                                                                         std = (0.3081,))]),\n                                               download = True) #是否下载\n\n    # 加载测试集\n    test_dataset = torchvision.datasets.MNIST(root = './data',\n                                              train = False,\n                                              transform = transforms.Compose([\n                                                      transforms.Resize((32,32)),\n                                                      transforms.ToTensor(),\n                                                      transforms.Normalize(mean = (0.1325,), \n                                                                         std = (0.3105,))]),\n                                              download=True)\n    # 一次抓64张牌\n    batch_size = 64\n    # 加载训练数据\n    train_loader = torch.utils.data.DataLoader(dataset = train_dataset,\n                                               batch_size = batch_size,\n                                               shuffle = True)  # 是否打乱\n    # 加载测试数据\n    test_loader = torch.utils.data.DataLoader(dataset = test_dataset,\n                                               batch_size = batch_size,\n                                               shuffle = False) # 是否打乱\n```\n\n* 训练阶段的`shuffle=True`：将数据集打乱顺序，有助于模型学习更泛化的特征。通过打乱数据顺序，模型在每个 epoch 中都能够看到不同的样本，防止模型过度拟合训练集中的特定顺序。\n\n* 测试阶段的`shuffle=False`：在测试阶段，通常不需要打乱数据的顺序。测试时模型是在未见过的数据上进行评估，因此希望模型看到的是原始数据的有序顺序，以便能够更好地评估模型的泛化性能。如果在测试时也打乱数据，可能会导致模型在评估时看到的数据分布与实际场景不一致。（其实如果是`True`影响也不大）\n\n***\n\n## 6. 设置超参数\n\n在训练之前，我们需要设置一些超参数，为训练阶段要用到的模型、损失函数、优化器做准备。\n\n### （1）创建 LeNet5 模型\n\n```ini\n    num_classes = 10\n    model = LeNet5(num_classes).to(device)\n```\n\n* `LeNet5(num_classes)`：创建一个 LeNet5 类的实例。还记得么？前文提到过，该类是继承自 nn.Module 的神经网络模型，接受 num_classes 参数，表示模型输出的类别数目。\n* `to(device)`：将模型移动到指定的设备上，其中 `device` 是一个设备对象，可以是 `'cuda'`（GPU）或者 `'cpu'`。这一步是为了确保模型在训练和推理时使用的是正确的计算设备。\n* `model = ...`：将创建并移动到指定设备的模型赋值给变量 model，以便后续对模型的引用和操作。\n\n### （2）创建损失函数\n\n在这里，损失函数设置为交叉熵损失函数\n\n```ini\n    cost = nn.CrossEntropyLoss()\n```\n\n* `nn.CrossEntropyLoss()`是 PyTorch 中用于计算多类别交叉熵损失的损失函数。交叉熵损失通常用于分类问题，特别是当目标是多类别标签时。它的计算涉及到模型的预测值和实际类别标签之间的比较，以衡量模型输出与真实标签之间的差异。\n\n### （3）创建优化器\n\n```ini\n    learning_rate = 0.001\n\n    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\n```\n\n* `torch.optim.Adam`：这是 PyTorch 中提供的 Adam 优化器的实现。Adam 是一种常用的随机梯度下降算法的变体，它通过自适应地调整学习率来优化模型参数。\n* `model.parameters()`：指定要被优化的参数，就是告诉优化器去优化谁，这里选择了模型 model 中的所有参数。\n* `lr=learning_rate`：设置学习率，即每次参数更新时的步进大小。\n\n### （4）确定每轮共需几步\n\n```ini\n    total_step = len(train_loader)\n```\n\n* `len(train_loader) `返回加载器中的批次数量。\n* MNIST数据集中有 60000 张图片作为训练集。我们每次抓64张牌，那么一共要抓 $\\frac{60000}{64}=937.5$ ，937.5 向上取整是 938 个批次。也就是说，由于数据加载器DataLoader的存在，LeNet5 把训练集所有图片遍历一遍要 938 步（step）。训练一轮（epoch）需要 938 步（step）。总结一下，一轮需要很多步，**一步就是一个批次**。\n\n***\n\n## 7. 训练\n\n我们将用 2 个 for 循环的嵌套来实现训练过程。\n\n先让我们梳理一下应该如何训练。首先，训练分很多轮（epoch），每轮训练都需要把全部训练集过一遍。所以需要一个 for 循环，一轮一轮地进行循环。这个“过一遍”是通过数据加载器 DataLoader 实现的。其次，在一轮训练中，完整遍历一次训练集需要一个 for 循环，去循环从 DataLoader 加载过来的每个批次的图片（本例为64张图）。\n\n在本例中，我设置共训练 10 轮。\n\n```python\n    # 设置一共训练几轮（epoch）\n    num_epochs = 10\n    # 外部循环用于遍历轮次\n    for epoch in range(num_epochs):\n        # 内部循环用于遍历每轮中的所有批次\n        for i, (images, labels) in enumerate(train_loader):  \n            images = images.to(device)\n            labels = labels.to(device)\n\n            # 前向传播\n            outputs = model(images)   # 通过模型进行前向传播，得到模型的预测结果 outputs\n            loss = cost(outputs, labels)    # 计算模型预测与真实标签之间的损失\n\n            # 反向传播和优化\n            optimizer.zero_grad()   # 清零梯度，以便在下一次反向传播中不累积之前的梯度\n            loss.backward()     # 进行反向传播，计算梯度\n            optimizer.step()    # 根据梯度更新（优化）模型参数\n\n            # 定期输出训练信息\n            # 在每经过一定数量的批次后，输出当前训练轮次、总周轮数、当前批次、总批次数和损失值\n            if (i+1) % 400 == 0:\n                print ('Epoch [{}/{}], Step [{}/{}], Loss: {:.4f}' \n                               .format(epoch+1, num_epochs, i+1, total_step, loss.item()))\n```\n\n* 在内部循环`for i, (images, labels) in enumerate(train_loader):`中`enumerate(train_loader)` 返回一个可迭代的对象，其中包含每个批次的图像和标签。\n\n* `images = images.to(device)` 和 `labels = labels.to(device)`：将加载的图像和标签移动到设备（通常是 GPU），以便在设备上执行模型的前向和后向传播。\n\n* 对初学者而言，“定期输出训练信息”部分的代码用`print`输出即可，后期熟练了可以尝试用`tqdm`库显示进度条。这不是本文重点，有兴趣的可以自行了解。\n\n***\n\n训练时输出的结果：\n![image](<https://s2.loli.net/2024/12/26/iecCf3X6SpkQIz4.png>)\n938 跟我们之前手动计算的总批次数（步数）数是吻合的。\n\n## 8. 测试\n\n```python\n    with torch.no_grad():   # 指示 PyTorch 在接下来的代码块中不要计算梯度\n        # 初始化计数器\n        correct = 0     # 正确分类的样本数\n        total = 0       # 总样本数\n\n        # 遍历测试数据集的每个批次\n        for images, labels in test_loader:\n            # 将加载的图像和标签移动到设备（通常是 GPU）上\n            images = images.to(device)\n            labels = labels.to(device)\n\n            # 模型预测\n            outputs = model(images)\n\n            # 计算准确率\n            # 从模型输出中获取每个样本预测的类别\n            _, predicted = torch.max(outputs.data, 1)\n            # 累积总样本数\n            total += labels.size(0)\n            # 累积正确分类的样本数\n            correct += (predicted == labels).sum().item()\n\n        # 输出准确率，正确的 / 总的\n        print('Accuracy of the network on the 10000 test images: {} %'.format(100 * correct / total))\n```\n\n* 在测试阶段，我们通常不需要计算梯度，以提高内存效率。\n\n* 注意看 `_, predicted = torch.max(outputs.data, 1)` 中的 `torch.max(xxx, 1)`表示对于每个输入 `xxx` 而言，`torch.max` 返回一个元组，其中包含两个张量，第一个张量是最大值，第二个张量是最大值所在的索引（也就是属于哪一类）。\n  举个例子，在图像处理中，神经网络通常输出一个二维张量。什么样的二维张量呢？在3分类问题中输出二维张量：\n\n  ```lua\n    tensor([[0.1, 0.8, 0.3],\n            [0.4, 0.2, 0.9],\n            [0.7, 0.5, 0.2],\n            [0.6, 0.2, 0.4]])\n  ```\n\n  上面的二维张量，由 4 个长度为 3 的一维张量构成。`torch.max(xxx, 1)`在每一行中寻找最大值。\n  `torch.max(xxx, 1)`返回结果为元组：\n\n  ```scss\n    (tensor([0.8, 0.9, 0.7, 0.6]), tensor([1, 2, 0, 0]))\n  ```\n\n  其中，0.8, 0.9, 0.7, 0.6 分别为属于索引（类别）1, 2, 0, 0 的概率（或得分）。\n\n* 而 `_, predicted = torch.max(outputs.data, 1)` 中的 `_` 。它是一个通常用作占位符的变量名。在 Python 中，通常使用 `_` 表示一个临时或不使用的变量。在本例中，我们不要属于索引（类别）的概率（或得分），只要最终结果，即属于哪个索引（类别），把它的值赋给`predicted`\n  测试阶段运行的结果：\n  ![image](<https://s2.loli.net/2024/12/26/DI6rmZHU3cbkysE.png>)\n  可以看到达到了99.12%\n\n***\n\n以上，就是从0开始敲LeNet5的全部过程。\n","tags":["PyTorch","LeNet5"]},{"title":"entertainment","url":"/2024/12/20/entertainment/","content":"```C++\n/*\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠣⡀⠀⣀⣀⣤⣤⣤⣶⣶⣶⣶⣶⣶⣶⣶⣶⣦⣤⣤⣤⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣦⣤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠤⠤⣄⣀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⢿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⣠⠋⣸⣷⣤⡀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠋⠉⠉⠛⠓⠦⡀⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠐⠂⠉⠉⠉⠉⠁⠒⠂⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣠⢁⣼⣿⣿⣿⣿⣦⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⠉⠉⠁⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⡈⢆⠀⠀⠀⠀⠠⠊⠁⠀⠀⠀⠀⣀⣠⣤⠤⠤⠤⠤⣈⠐⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢⣧⠀⠀⡔⠁⠀⠀⠀⣠⣴⡿⠿⠭⠤⣄⡀⠀⠀⠀⠉⢺⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠁⠀⠙⠻⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⡰⠀⠀⠀⣠⠞⠋⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠋⠙⢄⠀⠀⠀⠀⠀⠀⠈⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠐⠢⠤⢀⣰⡆⣀⣀⣀⠀⢀⡃⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⢀⣴⣿⣿⣿⣿⡿⠙⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠋⠉⢣⠀⠀⠀⠀⠀⠱⢄⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀⠐⡀⠀⠀⠀⠀⠀⠀⡴⠥⣷⠎⠉⠀⠀⠀⠈⠑⢴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣿⣿⣿⣿⣿⡟⠁⠀⠀⢠⠃⠀⠀⠀⠀⠀⠈⣹⣿⡿⣿⣿⠿⠟⠛⠋⡟⠁⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠈⠳⡀⠀⠀⠀⠀⠀⠀⠈⢢⠀⠀⠀⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⡌⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⢛⢿⣿⣿⠟⠀⠀⠀⢀⠇⠀⡞⠀⠀⠀⠀⠀⣿⠏⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠙⡄⠀⠀⠀⠀⠀⠙⣦⡀⠀⠀⠀⠀⠀⠀⡑⡄⠀⠀⠀⠀⢳⠀⠀⠀⠀⢀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣄⡀⠀⠀⠀⠀⠀⠀⠀⣀⠊⠀⠀⠀⡐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣠⠶⠋⠁⠀⠀⠀⠀⠎⠀⣸⠃⠀⠀⠀⠀⢰⡟⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣄⠀⠀⠀⠀⠀⠘⢿⣦⡀⠀⠀⠀⠀⠘⡌⢆⠀⠀⠀⠈⢏⠉⠁⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⢠⣏⠉⠉⠑⠒⠤⠤⠤⠤⠊⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⡰⠀⢠⣿⠀⠀⠀⠀⠀⣿⠃⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡄⠀⠀⠀⠀⠀⠀⠹⣿⣄⠀⠀⠀⠀⠱⡜⣧⡱⠀⠀⠘⡄⠀⠀⠀⠀⠀⠑⠦⣀⡀⠀⢀⣠⣴⢿⢿⣷⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⡠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢠⠃⠀⣾⡇⠀⠀⠀⠀⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡈⢆⠀⠀⠀⠀⠀⠹⣿⣦⡀⠀⠀⠀⢱⠬⣷⣅⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⣸⡿⠋⠉⠁⡿⠈⢮⢻⡻⠿⣿⣶⣒⡒⠒⠒⠂⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⡈⠀⣸⣿⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠸⡄⠀⠀⠀⠀⠀⢹⡄⠉⠇⠂⠤⣀⠃⠘⣿⡄⠀⠈⡆⠀⠀⠀⠀⢠⡾⠋⠀⠀⠀⠀⠇⠀⢸⠧⡝⢦⡀⠀⠀⠀⠉⠐⠒⠂⠀⢀⣀⠲⠖⠊⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢀⠇⠀⡿⡇⠀⠀⠀⠀⠀⡿⡇⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⢱⡀⠀⠀⠀⠀⠀⢳⠀⠸⡄⠀⠀⠉⢢⣸⣿⡀⠀⢸⠀⠀⢀⠴⠋⠀⠀⠀⠀⢀⡸⠀⠀⠈⡇⠈⠲⣌⠲⢄⡀⠀⠉⠉⠭⣉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢸⠀⠀⡇⡇⠀⠀⠀⠀⠀⡇⡇⠀⠀⠀⠰⠀⠀⠀⠀⢸⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⣇⠀⠀⠀⠀⠀⠈⡇⠀⠈⠑⠲⢤⣤⣽⡏⢃⠀⠈⡄⠐⠀⠀⠀⠀⠀⠀⠀⣾⠃⠀⠀⠀⢳⠀⠀⠀⠙⠢⣝⡲⢤⣀⣀⠀⠉⠀⠒⠠⠤⠄⠀⠀⢤⠔⠀⠀⠀\n⠀⠀⠀⠀⠀⡇⠀⢠⢰⢠⠀⠀⠀⠀⢠⡇⡇⠀⠀⠀⠀⡄⠀⠀⠀⠘⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠸⡄⠀⠀⢸⡀⠀⢻⠀⠀⠀⠀⠀⢫⡩⠵⣮⡆⠀⢱⠐⢄⣀⡀⣀⣀⣀⡾⠃⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠉⠛⠲⠯⣭⡭⠛⠋⠁⢀⣀⠤⠐⠁⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⡇⠀⢸⣸⡘⠀⠀⠀⠀⠀⣧⠃⠀⠀⠀⠀⣇⠀⠀⠀⠀⡟⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⣇⠀⠀⢸⡇⠀⠈⡇⠀⣀⠄⠂⠁⠳⣄⠈⢻⠀⠈⡆⠢⢽⣄⢀⣀⡙⢦⡒⠒⠦⢔⡊⠉⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢸⡇⡇⠀⠀⠀⣀⣀⣿⣰⠀⠀⠀⠀⢸⠀⠀⠀⠀⣇⠘⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣿⠀⠀⢸⣿⠀⣀⣷⠊⠀⠀⠀⠀⠀⠀⠉⠉⡇⡀⣧⣤⣼⠿⢇⡤⠀⠑⣇⠐⠒⢒⣡⣀⣱⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⡀⠀⢸⡇⡇⠀⢯⠭⠭⠵⢶⡞⡇⠀⠀⠀⠈⡇⠀⠀⠀⢸⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣿⠀⠀⢸⣿⡟⠁⢸⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣷⢻⡿⠁⠀⠛⠀⠀⠀⠈⣖⢶⣿⣿⡿⠿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⡇⠀⢸⡇⢧⠀⠀⠀⠀⣀⣤⣷⣿⠀⠀⠀⠀⣿⡀⠀⠀⠘⡆⠀⠈⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⡏⠀⠀⠊⡻⢸⠀⣼⠀⠀⣠⣶⣿⣿⣿⣿⣟⢛⠉⡎⡁⠀⠀⠀⠀⠀⠀⠀⣘⠀⠀⠀⠀⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢃⠀⢸⢹⠸⠀⠀⢰⣿⢿⣛⣿⣽⡦⠀⠀⠀⢹⣷⠀⠀⠀⢱⠀⠀⠀⠳⡀⠀⠀⠰⡀⠀⠀⠀⠀⡼⢰⢧⡀⠀⠀⡇⠸⡎⡇⣴⣿⡿⢛⣿⣿⣿⣿⣿⠸⠀⠇⡇⠀⠀⠀⠀⠀⠀⠀⣿⡆⠀⠀⠀⠀⠘⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠸⡀⠈⢸⠀⠇⠀⠀⠰⠟⠋⠉⣧⠹⡄⠀⠀⠸⣿⢳⡒⠉⠙⡍⠉⠉⠉⠛⣆⠀⠀⠘⢦⡀⠀⢠⢧⡟⠀⢳⡀⢠⠃⢠⢣⢳⡿⠛⢶⣿⣿⣿⣿⣿⣿⠃⡏⠀⢡⠀⠀⠀⠀⢀⠇⢸⡏⣿⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢃⠀⡘⡀⢸⠀⠀⠀⠀⠀⠀⠸⡄⢧⠀⠀⠀⣿⠀⠱⡄⠀⠘⡄⠀⠀⠀⠈⠳⡄⠀⠈⠻⡢⣼⣿⠁⠀⠀⠑⣼⠀⢸⡎⠀⠀⠀⠀⠻⢿⣿⣿⣿⠿⠂⢣⠀⢺⠀⠀⠀⠐⠋⣠⣿⠇⢹⡆⠀⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⢆⡇⡇⠀⣆⠀⠀⠀⠀⠀⠀⢳⡈⢧⠀⠀⢸⠀⠀⠈⠢⡀⠙⣄⠀⠀⠒⠒⠨⠳⢄⣀⡼⠫⣙⡦⢄⣀⠀⠈⠳⢯⠁⠀⠀⠀⠀⠀⠈⠉⠁⠀⠀⠀⢸⠀⢸⠀⠀⣾⣐⡴⠟⠉⠀⠀⣧⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠘⣇⢿⡀⢸⡄⠀⠀⠀⠀⠀⠈⢧⠘⢆⠀⠘⡇⠀⠀⠀⠈⠓⠬⣢⡀⠀⠀⠀⠀⠐⠉⠑⠲⢬⠷⣦⣞⡉⠒⠲⠿⠭⠶⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡀⢸⠀⣰⣿⣿⣄⠀⠀⠀⠀⢿⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢀⣸⡼⣗⢺⣿⡛⠛⠛⠛⠲⢦⢸⣧⠈⢆⠀⢱⣄⠀⠀⠀⠀⠀⠀⣉⣑⣢⣤⣤⡤⠀⠀⢠⢇⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⣸⢰⣿⡏⢸⣿⣧⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⢱⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⣠⡶⠋⠑⡌⡟⣿⡿⣧⠀⠀⠀⠀⠀⠀⢻⣷⡈⢣⠈⣿⣷⣤⣴⣿⠿⠿⠛⠟⠛⠉⠀⠀⠀⠠⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⣿⢿⣿⡇⣿⣿⣿⣧⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⣰⠋⠀⠀⠀⠇⢰⡇⢧⠹⣧⠀⠀⠀⠀⠀⠀⢻⣷⣄⠳⡹⣿⣸⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡿⠘⣿⣷⣿⣿⣿⣿⣦⠀⠘⣿⡆⠠⡀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⡀⠠⠁⠀⠀⠀⠀⠸⡘⣇⢸⠀⠘⣷⡀⠀⠀⠀⠀⠀⢻⡎⠢⡙⢿⣿⢿⠙⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⡇⡇⠀⣿⣿⣿⣿⣿⠿⠛⠀⠀⣿⣧⠀⠱⡀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠠⣾⢛⣷⠶⠀⠀⠀⠀⠀⢱⠘⣼⠀⠀⣿⡷⣄⠀⠀⠀⠀⠀⠹⡄⠙⢮⡹⣇⠉⣦⣵⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠂⠀⠀⠀⠀⠀⣠⣾⣦⢁⡇⢰⣿⡟⠋⠉⠀⠀⠀⠀⠀⢸⠈⣇⠀⠘⣆⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⣿⠟⠸⠀⠀⠀⠀⠀⠀⣾⣧⢹⡄⢠⡟⣷⡘⢦⡀⠀⠀⠀⠀⠹⡄⠀⠈⠪⣷⢽⠀⠻⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠤⠐⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⢸⣿⢸⠀⠸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠸⠀⠘⢆⠀⠈⢷⡀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠁⠀⠀⠀⠀⠀⠀⠀⢰⠛⣿⣇⠹⣼⠃⠹⣷⠀⠙⢦⠀⠀⠀⠀⠙⣄⠀⠀⠈⢹⠿⣦⣈⠑⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠈⡇⣾⠀⠀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠈⢿⣦⡀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⡌⠀⠸⣿⣷⡘⢦⡀⠹⡇⠀⠀⢹⣦⡀⠀⠀⠈⢢⡀⠀⢸⠀⠈⠉⠛⠦⣭⡙⠓⠶⢤⠤⣠⣤⣀⣀⣀⣀⣀⣀⣀⡀⠀⣀⠜⠁⠀⠀⠀⠀⢰⢣⣧⡀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⢀⠃⠀⣸⣿⡿⣿⠶⣝⢦⣽⣆⠀⠀⢿⣏⠲⢤⡀⠀⠙⠢⣼⡀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠘⣿⡄⠀⠀⢘⣿⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⡼⡘⠋⠳⣄⢸⡀⠀⠀⠀⡆⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠘⣎⠢⣄⠘⢦⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⡎⠀⢠⣿⡟⠀⠈⠳⣮⣹⣿⠛⢧⡄⠈⢻⡀⠀⠉⠓⠦⢤⣈⣙⡓⠦⣄⣀⣀⡀⠀⠀⠀⢧⠀⠸⡷⠀⣴⠟⢿⡀⠀⠀⠀⠀⠀⠀⠀⣀⡴⡿⣹⠃⠀⠀⠘⢧⡇⠀⠀⠀⡇⠀⠀⠀⠀⡇⠀⠀⠀⢀⣀⣀⣀⣀⣀⣈⣆⠀⠑⢤⡙⢿⣷⣦⣄⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢰⠀⢠⣿⡟⠀⠀⠀⠀⠈⣿⡟⠀⠀⠙⣦⡀⠱⡄⠀⠀⠀⠀⠀⢻⠉⠉⠉⠉⠉⠁⠀⠀⠀⢸⠀⠀⢱⡞⠁⠀⠀⠉⠓⠶⢤⣄⣀⡠⠞⠁⣰⡿⠁⠀⠀⠀⠀⠨⡇⠀⠀⠀⡇⠀⠀⠀⠀⣿⠁⠈⠉⠁⠀⠀⠀⠀⠀⠀⠉⠳⢄⠀⠈⠲⣿⣿⣿⣿⣶⣤⣀⠀\n⠀⠀⠀⠀⠀⠀⢠⢃⠔⣻⡿⠀⠀⠀⠀⠀⢰⣿⠀⡇⠀⢠⣿⣿⠦⣘⢦⡀⠀⠀⠀⠸⡦⠴⠶⠶⠶⠶⠶⠶⠶⠞⠒⠺⣏⠀⠀⠀⠀⠀⠀⢰⡟⠉⠀⠑⣶⣼⠟⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀⢠⠁⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠣⡀⠀⠀⠙⠿⣿⣿⡧⠈⠓\n⠀⠀⠀⠀⠀⠀⡞⠀⣰⣿⠁⠀⠀⠀⠀⠀⢸⡏⠀⡇⠀⢸⣿⣿⠀⠈⠙⠛⠲⠤⡀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡆⠀⠀⠀⠀⢠⣏⡀⠀⢠⡴⠟⣷⡀⠀⠀⠀⠀⠀⠀⣸⢇⠀⠀⣸⠀⠀⠀⠀⡀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⠀⠀⠀⠀⠈⠻⢿⡀⠀\n⠀⠀⠀⠀⠀⡜⠀⢠⢻⠇⠀⠀⠀⠀⠀⠀⢸⠃⠀⢣⠀⢸⣿⢿⠀⠀⠀⢀⠀⠀⠀⠀⡞⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣷⡀⠀⠀⠀⣿⣿⣿⣦⣀⣀⣴⣿⣷⡄⠀⠀⠀⠀⢠⣿⠈⢦⠀⡇⠀⠀⠀⢸⡇⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⠀⠀⠀⠀⠀⠀⠙⢦\n⠀⠀⠀⠀⢰⠀⠠⠃⡞⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠈⡆⡿⣿⠘⡇⠀⠀⣨⠀⠀⠀⠀⢷⡹⡀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣧⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⢀⣾⡇⠠⡈⢠⠃⠀⠀⠀⢸⣧⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⢠⠃⡠⠃⢀⡇⠀⠀⠀⠀⢀⡄⠀⡇⠀⠀⠀⢸⡇⡏⠀⢧⠀⠀⣿⡆⠀⠀⠀⠘⡗⣝⣄⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣀⣼⣿⣿⣿⣿⡿⠟⠉⢿⣿⣿⣿⣿⣆⢀⣾⣿⠃⠀⢡⡏⠀⠀⠀⠀⢸⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢆⠀⠀⠀⠀⠀⠀\n⠀⠀⢀⠆⡰⠁⠀⢸⠁⠀⠀⠀⠀⢸⡇⠀⡇⠀⠀⠀⠀⣧⡇⠀⠸⡀⠀⣿⣷⡀⠀⠀⠀⢹⡀⠙⠳⠦⣄⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⡏⠀⢀⡼⠀⠀⠀⠀⠀⣾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣦⡀⠀⠀⠀⠀\n⠀⠀⡌⡐⠁⠀⠀⡾⠀⠀⠀⠀⠀⢸⢻⠀⣧⠀⠀⠀⠀⣾⡇⠀⠀⡇⠀⢻⣿⣧⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⣀⣀⠀⣼⣿⣿⣿⣿⣿⡿⠀⢀⣾⠃⠀⠀⠀⠀⣰⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡝⢦⡀⠀⠀\n⠀⡰⡜⠁⠀⠀⢀⡇⠀⠀⠀⠀⠀⡏⠘⡇⢹⠀⠀⠀⢸⣿⢸⠀⠀⠘⡄⠘⣿⣿⣧⠀⠀⠀⠀⢣⡀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠿⣿⡟⠻⣿⣿⣿⣿⣿⣿⠃⣠⣿⠏⠀⠀⠀⠀⢀⣿⣿⠇⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⣆⡙⠢⡀\n⢰⡵⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⢠⠇⠀⢳⡘⡆⠀⢀⠇⢻⡼⡀⠀⠀⠱⡀⠹⡟⣿⣧⡀⠀⠀⠀⠳⡀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⢿⣿⠀⢸⣿⣿⣿⣿⣧⣾⣿⠏⠀⠀⠀⠀⢀⣾⣿⣿⡄⠀⠀⢸⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠤⠒⠉⠀⠀⢳⠀⠈                                \n*/\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=2e6+10;\nconst int mod=1e9+7;\nint r,c;\nvector<int>sum[N],edge[N];\nstring s;\nint vis[N];\nbool dfs(int u,int fa){\n\t//cout<<u<<endl;\n\tfor(auto v:edge[u]){\n\t\tif(v==fa)continue;\n\t\tif(vis[v]==vis[u])return 0;\n\t\telse {\n\t\t\tif(vis[v]==0){\n\t\t\t\tif(vis[u]==1)vis[v]=2;\n\t\t\t\telse vis[v]=1;\n\t\t\t\tdfs(v,u);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nvoid solve(){\n\tcin>>r>>c;\n\tfor(int i=1;i<=c;i++)sum[i].clear();\n\tfor(int i=1;i<=2*r;i++)vis[i]=0,edge[i].clear();\n    for(int i=1;i<=r;i++){\n\t\tcin>>s;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(s[j]=='1')sum[j+1].push_back(i);\n\t\t}\n\t}\n\tif(c&1){\n\t\tif(sum[(c+1)/2].size()>1){\n\t\t\tcout<<0<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor(int i=1;i<=r;i++){\n\t\tedge[i].push_back(i+r);\n\t\tedge[i+r].push_back(i);\n\t}//连边代表不共存\n\tfor(int i=1;i<=c/2;i++){\n\t\tif(sum[i].size()+sum[c-i+1].size()>2){\n\t\t\tcout<<0<<endl;\n\t\t\treturn;\n\t\t}\n\t\tif(sum[i].size()+sum[c-i+1].size()==2){\n\t\t\tif(sum[i].size()==1){//一起翻\n\t\t\t//cout<<\"s\";\n\t\t\t\tint u=sum[i][0],v=sum[c-i+1][0];\n\t\t\t\t//cout<<i<<\" \"<<c-i+1<<\" \"<<u<<\" \"<<v<<endl;\n\t\t\t\tedge[u].push_back(v+r);\n\t\t\t\tedge[v+r].push_back(u);\n\t\t\t\tedge[v].push_back(u+r);\n\t\t\t\tedge[u+r].push_back(v);\n\t\t\t}\n\t\t\telse {//一个翻一个不翻\n\t\t\t\tint u,v;\n\t\t\t\tif(sum[i].size())u=sum[i][0],v=sum[i][1];\n\t\t\t\telse u=sum[c-i+1][0],v=sum[c-i+1][1];\n\t\t\t\tedge[u].push_back(v);\n\t\t\t\tedge[v].push_back(u);\n\t\t\t\tedge[v+r].push_back(u+r);\n\t\t\t\tedge[u+r].push_back(v+r);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1;\n\t/*for(int i=1;i<=2*r;i++){\n\t\tcout<<i<<\"i: \";\n\t\tfor(auto v:edge[i]){\n\t\t\tcout<<v<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=1;i<=2*r;i++){\n\t\tif(vis[i])continue;\n\t\tvis[i]=1;\n\t\tif(dfs(i,i)){\n\t\t\tans=(ans*2)%mod;\n\t\t}\n\t\telse {\n\t\t\tcout<<0<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint T=1;\n\tcin>>T;\n\twhile(T--){solve();}\n}\n\n```"},{"title":"面向智慧驾驶座舱的情感交互平台设计","url":"/2024/12/18/面向智慧驾驶座舱的情感交互平台设计/","content":"## 安卓端开发\n[IDE下载](https://developer.android.google.cn/studio?hl=zh-cn)\n**配置注意事项**\n① jdk改为11版本。\n② 在顶层build.gradle文件添加url加速下载 。\n③ 切换摄像头使得虚拟机能用上电脑的摄像头。","tags":["大创"]},{"title":"习概重点","url":"/2024/12/17/习概重点/","content":"\n**声明：根据2023年@tjuSE重点整理，由@zhy摘取重合重点而来。**\n\n## 第二章 以中国式现代化全面推进中华民族伟大复兴\n\n### 第二节 中国式现代化是强国建设、民族复兴的唯一正确道路\n\n#### Ⅰ 中国式现代化是中国共产党领导人民长期探索和实践的重大成果\n\n**(问：如何理解中国式现代化是中国共产党领导人民长期探索和实践的重大成果?)**\n① **新民主主义革命时期，**我们党团结带领人民进行革命斗争，取得新民主主义革命的胜利，为实现现代化创造了**根本社会条件**。\n② **改革开放和社会主义现代化建设新时期，**我们党作出把党和国家工作中心转移到经济建设上来、实行改革开放的历史性决策，开启了中国式现代化的**新长征**。\n③ **进入新时代，** 我们党围绕解决现代化建设中存在的突出矛盾和问题，不断实现理论和实践上的 **创新突破，** 成功推进和拓展了中国式现代化。\n\n#### Ⅱ 中国式现代化的中国特色\n\n**(问：中国式现代化中国特色的含义?)**\n① 中国式现代化是**人口规模巨大的现代化**。\n② 中国式现代化是**全体人民共同富裕的现代化**。\n③ 中国式现代化是**物质文明和精神文明相协调的现代化**。\n④ 中国式现代化是**人与自然和谐共生的现代化**。\n⑤ 中国式现代化是**走和平发展道路的现代化**。\n\n#### Ⅲ 中国式现代化的本质要求\n\n**(问一：中国式现代化的本质要求是什么?)**\n**坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。**\n**(问二：为什么要强调党在中国式现代化建设中的领导地位?)**\n① 党的领导决定中国式现代化的根本性质。\n② 党的领导确保中国式现代化锚定奋斗目标行稳致远。\n③ 党的领导激发建设中国式现代化的强劲动力。\n④ 党的领导凝聚建设中国式现代化的磅礴力量。\n\n#### Ⅳ中国式现代化创造了人类文明新形态\n\n**(问：为什么说中国式现代化创造了人类文明新形态?)**\n① 中国式现代化提供了一种**全新的现代化模式**。\n② 中国式现代化是对**西方式现代化理论和实践**的重大超越。\n③ 中国式现代化为**广大发展中国家**提供了全新选择。\n\n## 第六章 推动高质量发展\n\n### 第一节 完整、准确、全面贯彻新发展理念\n\n#### Ⅰ我国进入新发展阶段\n\n**(问：新发展阶段的含义?)**\n① 我国**经济增长速度**从高速转向中高速，**发展方式**从规模速度型转向质量效率型，**经济结构**调整从增量扩能为主转向调整存量、做优增量并举，**发展动力**从主要依靠资源和低成本劳动力等要素投入转向创新驱动。\n② 新发展阶段是我国**社会主义初级阶段历史进程中**的一个重要阶段，是中国共产党带领人民迎来从站起来、富起来到强起来**历史性跨越**的新阶段，是**全面建设社会主义现代化国家、向第二个百年奋斗目标进军**的重要阶段。\n③ 进入新发展阶段，我国发展的国内外环境进一步发生深刻变化，面对新的战略机遇、新的战略任务新的战略要求、新的战略环境，**需要解决的矛盾和问题比以往更加错综复杂**。\n\n#### Ⅱ 贯彻新发展理念是关系我国发展全局的一场深刻变革\n\n**(问一：为什么贯彻新发展理念是关系我国发展全局的一场深刻变革?如何理解?)**\n**贯彻新发展理念是新时代我国发展壮大的必由之路。**\n① 发展理念是发展行动的先导，是管全局、管根本、管方向、管长远的东西，是发展思路、发展方式发展着力点的集中体现。\n② 新发展理念具有**丰富的科学内涵**和具体的实践要求。**(创新、协调、绿色、开放、共享)**\n③ 新发展理念是指挥棒、红绿灯，是引领我国发展全局深刻变革的科学指引，必须完整、准确、全面地理解和把握。\n**(问二：新发展理念的丰富科学内涵?)**\n① **创新**是引领发展的第一动力\n② **协调**是持续健康发展的内在要求\n③ **绿色**是永续发展的必要条件和人民对美好生活追求的重要体现\n④ **开放**是国家繁荣发展的必由之路\n⑤ **共享**是中国特色社会主义的本质要求\n**(问三：如何把新发展理念?)**\n① 要**从根本宗旨上**把握新发展理念，坚持以人民为中心的发展思想。\n② 要**从问题导向上**把握新发展理念，切实解决发展不平衡不充分问题，\n③ 要**从忧患意识上**把握新发展理念，积极主动、未雨缪。\n\n#### Ⅲ 以新发展理念引领高质量发展\n\n**(问一：高质量发展的含义?)**\n高质量发展，是能够很好**满足人民日益增长的美好生活需要**的发展，是**体现新发展理念**的发展，是**创新**成为第一动力、**协调**成为内生特点、**绿色**成为普遍形态、**开放**成为必由之路、**共享**成为根本目的的发展。\n**(问二：高质量发展的重大战略意义?)**\n① 高质量发展为全面建设社会主义现代化国家提供更为**坚实的物质基础**。\n② 高质量发展是不断满足人民对美好生活需要的**重要保证**。\n③ 高质量发展是维护国家长治久安的**必然要求**。\n**(问三：如何推动高质量发展?)**\n① 要更好统筹质的有效提升和量的合理增长。\n② 要保持经济社会发展稳定性。\n③ 要以改革创新为根本动力。\n\n### 第二节 坚持和完善社会主义基本经济制度(问:如何坚持和完善社会主义基本经济制度?怎么做?)\n\n#### Ⅰ 坚持和完善社会主义基本经济制度是实现高质量发展的保障\n\n**(问：社会主义基本经济制度的内容?)**\n答:将公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等共同作为社会主义基本经济制度。\n\n#### Ⅱ 坚持“两个毫不动摇”\n\n**(问：“两个毫不动摇”的含义?)**\n答:要毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展。\n\n#### Ⅲ 坚持按劳分配为主体、多种分配方式并存\n\n考点一:基本分配制度是由我国社会主义性质和基本国情决定的。\n考点二:坚持和完善基本分配制度，要努力推动居民收入增长和经济增长同步、劳动报酬提高和劳动生产率提高同步。\n**(问：坚持和完善基本分配制度怎么做?)**\n① 健全工资决定和正常增长机制\n② 健全生产要素由市场评价贡献、按贡献决定报酬的机制。\n\n#### Ⅳ 构建高水平社会主义市场经济体制\n\n**(问：如何构建高水平社会主义市场经济体制?怎么做?)**\n① 构建高水平社会主义市场经济体制，关键是要处理好政府和市场的关系。(市场在资源配置中起决定性作用，更好地发挥政府作用。)\n② 加快建设高标准市场体系。(统一开放、竞争有序、制度完备、治理完善的高标准市场体系)③ 推进宏观经济治理体系和治理能力现代化。\n④ 依法规范和引导资本健康发展。\n\n## 第九章 全面依法治国\n\n### 第一节 坚持中国特色社会主义法治道路\n\n#### Ⅰ全面依法治国是国家治理的一场深刻革命\n\n**问：全面依法治国是国家治理的一场深刻革命，我们党是如何推进的?(全面依法治国具体体现在哪些方面?如何理解“革命\"?)**\n\n① 坚持依宪治国\n② 完善立法体制\n③ 推进法治政府建设\n④ 深化司法体制改革\n⑤ 实行国家机关普法责任制\n⑥ 深入推进依规治党\n\n#### Ⅱ 全面依法治国的唯一正确道路\n\n我们党领导人民长期探索走出的中国特色社会主义法治道路，是全面依法治国的唯一正确道路。\n\n**问：坚持和拓展中国特色社会主义法治道路要把握的核心要义以及坚持的原则?(走中国特色社会主义法治道路怎么做?中国特色社会主义法治道路的要求?)**\n① 中国特色社会主义法治道路的核心要义，就是要坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论。\n② 坚持中国共产党的领导。\n③ 坚持以人民为中心。\n④ 坚持法律面前人人平等。\n⑤ 坚持依法治国和以德治国相结合。\n⑥ 坚持从中国实际出发。\n\n#### Ⅲ 统筹处理全面依法治国的重大关系\n\n**问：全面依法治国要正确处理哪些重大关系?**\n① 正确处理政治和法治的关系。\n②正确处理改革和法治的关系，\n③正确处理依法治国和以德治国的关系\n④ 正确处理依法治国和依规治党的关系。\n\n## 第十六章 中国特色大国外交和推动构建人类命运共同体\n\n### 第二节 全面推进中国特色大国外交(问:全面推进中国特色大国外交怎么做?)\n\n#### Ⅰ 坚持走和平发展道路\n\n**(问一：中国为什么坚持走和平发展道路?)**\n① 走和平发展道路是由中国共产党性质宗旨和我国社会主义制度决定的。\n② 走和平发展道路是基于中国历史文化传统作出的必然选择。\n③ 走和平发展道路符合历史潮流、顺应世界大势。\n**(问二：如何理解坚持走和平发展道路?)**\n① 走和平发展道路，是对国际社会关注中国发展走向的回应，更是中国人民对实现自身发展目标的自信和自觉。\n怎么做: ② 走和平发展道路，就要坚定奉行独立自主的和平外交政策。\n             ③ 走和平发展道路，既要通过维护世界和平发展自己，又要通过自身发展维护世界和平\n\n#### Ⅱ 推动构建新型国际关系\n\n**(问：推动构建新型国际关系怎么做?)**\n① 推进大国协调合作，构建和平共处、总体稳定、均衡发展的大国关系格局，是中国对外关系的重要内容。\n② 坚持亲诚惠容和与邻为善、以邻为伴周边外交方针，深化同周边国家友好互信和利益融合。\n③ 秉持真实亲诚理念和正确义利观，加强同发展中国家团结合作。\n④ 秉持求同存异、相互尊重、互学互鉴理念，构建新型政党关系。\n\n#### Ⅲ 坚决维护国家主权、安全、发展利益\n\n① 我国外交工作始终站在维护国家利益和民族尊严的前线。\n② 维护国家主权、安全、发展利益，必须敢于斗争、善于斗争。\n\n#### Ⅳ 坚持外交为民\n\n**(问：怎么做?)**\n① 坚持外交为民，就要坚定维护我国海外公民和法人正当权益。\n② 积极开展民间外交。\n\n## 第十七章 全面从严治党\n\n### 第二节 以政治建设为统领深入推进党的建设(问:党的建设的总体布局是什么?)\n\n#### Ⅰ 把党的政治建设摆在首位\n\n**(问：党的政治建设摆在首位，该怎么做?)**\n旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。\n① 保证全党服从中央，维护党中央权威和集中统一领导，是党的政治建设的首要任务。\n② 发挥党的政治建设的统领性作用，必须把准政治方向、站稳政治立场、营造良好政治生态、提高政治\n能力。\n\n#### Ⅱ 思想建设是党的基础性建设\n\n**(问：为什么要加强党的思想建设?)**\n① 加强思想建设是坚守理想信念、坚定革命意志的前提。\n② 加强思想建设是保持政治上清醒坚定、行动上团结统一的要求。\n③ 加强思想建设是贯彻党的理论和路线方针政策、推进党和国家事业发展的重要保障。\n\n#### Ⅲ 贯彻新时代党的组织路线\n\n**(问：如何贯彻新时代党的组织路线?怎么做?)**\n① 严密党的组织体系是重点。\n② 建设高素质专业化干部队伍是关键。\n\n#### Ⅳ 以严的基调强化正风肃纪\n\n**(问：强化正风肃纪的含义?)**\n① 作风问题核心是党同人民群众的关系问题。加强作风建设，必须紧紧围绕保持党同人民群众的血肉联系。\n② 党要管党、从严治党，就要靠严明纪律和规矩。\n\n#### Ⅴ 把制度建设贯穿到党的各项建设之中\n\n**(问：把制度建设贯穿到党的各项建设之中，该怎么做?)**\n① 坚持制度治党、依规治党，就是靠制度管权、管事、官人。\n② 制定制度很重要，更重要的是抓落实。\n","tags":["复习","习概"]},{"title":"数据库课程实践","url":"/2024/12/06/数据库课程实践/","content":"---\n- 天津大学 2024 数据库课程实践\n- Lab Member：海棠未雨，梨花先雪，流萤染夏\n- 最终成绩 +∞ 分捏 😋\n---","tags":["数据库","实践"]},{"title":"ICPC算法模版","url":"/2024/11/29/ICPC算法模版/","content":"# Part 1. 数据结构\n\n## 1.线段树（Segment Trees)\n\n关键词：定长序列操作，区间修改与查询。\n\n**ACLibrary对懒标记线段树适配的定义，不涉及区间懒标记的普通线段树没有$F$的限制：**\n\nIt is the data structure for the pair of a monoid $(<S, \\cdot>: S \\cdot S \\to S, e \\in S)$ and a set $F$ of $S \\to S$​ mappings that satisfies the following properties.\n\n1. $F$ contains the identity map $\\mathrm{id}$, where the identity map is the map that satisfies $\\mathrm{id}(x) = x$ for all $x \\in S$.\n2. $F$ is closed under composition, i.e., $f \\circ g \\in F$ holds for all $f, g \\in F$​.\n3. $f(x \\cdot y) = f(x) \\cdot f(y)$ holds for all $f \\in F$ and $x, y \\in S$.\n\nGiven an array $S$ of length $N$, it processes the following queries in $O(\\log N)$ time. \n\n1. Acting the map $f\\in F$ (cf. $x = f(x)$) on all the elements of an interval\n2. Calculating the product of the elements of an interval\n\n**中文翻译：**\n\n懒标记线段树是适配于满足以下条件的***幺半群***$(<S, \\cdot>: S \\cdot S \\to S, e \\in S)$和属于***线性空间*** $V:S\\to S$的子空间$F$:\n\n1. $F$有单位映射$f\\in F,s.t.\\ \\forall x\\in S, f(x)=x$\n2. 代数系统$<F,\\circ>$封闭，其中$\\circ$表函数复合，不满足交换律，复合顺序从右到左，即$(f\\circ g)(x)=f(g(x))$​\n3. $F$必须是线性空间，即$\\forall f \\in F,$ $\\forall x, y \\in S, $  $f(x \\cdot y) = f(x) \\cdot f(y)$​.\n\n给定一个长度为$N$的$S$类型的数组，要求在$O(log\\ N)$的时间内完成以下类型操作：\n\n1. 对一个或者一段区间的值应用线性映射$f$​，并改为对应结果。\n\n   $\\forall x_i\\in S,\\ i\\in[l,r), \\ x_i:=f(x_i)$\n\n2. 求一个或者一段区间的值对幺半群乘法 （$\\cdot$） 运算的结果。\n   $$\n   \\large ans=\\prod_{i=l}^r x_i \\in S\n   $$\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.1 普通线段树（静态开点区间加，永久化懒标记，当心爆标记问题，码量小）\n\n**切记单点修改的if-else必须写全！！！**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int sum;\n    int lazy;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nvoid update(int pos, int val, int rt, int cl, int cr)\n{\n    tree[rt].sum += val;\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(pos, val, rt << 1, cl, mid);\n    else\n        update(pos, val, rt << 1 | 1, mid + 1, cr);\n    return;\n}\nvoid update(int l, int r, int val, int rt, int cl, int cr)\n{\n    tree[rt].sum += val * (min(r, cr) - max(l, cl) + 1);\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].lazy += val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, val, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, val, rt << 1 | 1, mid + 1, cr);\n}\nint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    int res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res + tree[rt].lazy * (min(r, cr) - max(l, cl) + 1);\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        update(i, x, 1, 1, n);\n    }\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, n);\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.2 普通线段树(静态开点区间加，标记永久化)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int sum;\n    int lazy;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nint a[maxn];\nvoid pushup(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid pushdown(int rt, int cl, int cr)\n{\n    int mid = (cl + cr) >> 1;\n    if (tree[rt].lazy)\n    {\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1].sum += tree[rt].lazy * (mid - cl + 1);\n        tree[rt << 1 | 1].sum += tree[rt].lazy * (cr - mid);\n        tree[rt].lazy = 0;\n    }\n    return;\n}\nvoid build(int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt] = {a[cl], 0};\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    build(rt << 1, cl, mid);\n    build(rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nvoid update(int pos, int val, int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt].sum += val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(pos, val, rt << 1, cl, mid);\n    else\n        update(pos, val, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nvoid update(int l, int r, int val, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].sum += val * (cr - cl + 1);\n        tree[rt].lazy += val;\n        return;\n    }\n    pushdown(rt, cl, cr);\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, val, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, val, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    pushdown(rt, cl, cr);\n    int res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        update(i, x, 1, 1, n);\n    }\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, n);\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.3 普通线段树（静态区间加、区间乘，非永久化）\n\n贴出来记得懒标记顺序思考问题。注意，懒标记下传的时候是$f_{rt}\\ \\circ \\ f_{sons}$的复合函数顺序。根据Segtrees.h思想思考。\n\n```cpp\n#include <bits/stdc++.h>\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nusing namespace std;\n#define int long long\nusing mint = MLong<0>;\nstruct node\n{\n    mint sum;\n    mint lazyadd = 0;\n    mint lazymul = 1;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nmint a[maxn];\nvoid pushup(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid pushdown(int rt, int cl, int cr)\n{\n    // 儿子节点已有ax+b,传下来c(ax+b)+d=cax+cb+d);\n    int mid = (cl + cr) >> 1;\n    if (tree[rt].lazyadd != 0 || tree[rt].lazymul != 1)\n    {\n        tree[rt << 1].lazyadd *= tree[rt].lazymul;\n        tree[rt << 1].lazyadd += tree[rt].lazyadd;\n\n        tree[rt << 1 | 1].lazyadd *= tree[rt].lazymul;\n        tree[rt << 1 | 1].lazyadd += tree[rt].lazyadd;\n\n        tree[rt << 1].lazymul *= tree[rt].lazymul;\n        tree[rt << 1 | 1].lazymul *= tree[rt].lazymul;\n\n        tree[rt << 1].sum = tree[rt << 1].sum * tree[rt].lazymul + tree[rt].lazyadd * (mid - cl + 1);\n        tree[rt << 1 | 1].sum = tree[rt << 1 | 1].sum * tree[rt].lazymul + tree[rt].lazyadd * (cr - mid);\n        tree[rt].lazyadd = 0;\n        tree[rt].lazymul = 1;\n    }\n\n    return;\n}\nvoid build(int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt].sum = a[cl];\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    build(rt << 1, cl, mid);\n    build(rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nvoid update(int l, int r, int add, int mul, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].sum *= mul;\n        tree[rt].sum += add * (cr - cl + 1);\n\n        tree[rt].lazyadd *= mul;\n        tree[rt].lazyadd += add;\n\n        tree[rt].lazymul *= mul;\n\n        return;\n    }\n    pushdown(rt, cl, cr);\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, add, mul, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, add, mul, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nmint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    pushdown(rt, cl, cr);\n    mint res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    int m;\n    cin >> m;\n    mint::setMod(m);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, 0, d, 1, 1, n);\n            /*for (int i = 1; i <= n; i++)\n            {\n                cout << query(i, i, 1, 1, n) << \" \";\n            }\n            cout << endl;*/\n        }\n        else if (op == 2)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, 1, n);\n            /*for (int i = 1; i <= n; i++)\n            {\n                cout << query(i, i, 1, 1, n) << \" \";\n            }\n            cout << endl;*/\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.4 Segtree.h/lazy_segtree\n\nACLibrary线段树，非递归模式，线段树下标从0开始。下文所提及区间默认左闭右开。\n\n函数列表\n\n`bit_ceil` : 取比参数大的最近的$2^n$\n\n`countr_zero` : 取参数的二进制结尾有多少个$0$\n\n`pushup` : 字面含义\n\n`upd` : 修改完整线段树节点所代表区间\n\n`pushdown` ： 字面含义\n\n`explicit lazy_segtree(const vector<S> &v)` : 构造函数\n\n`void set(int p, S x)` : 单点修改为$x$（***单点改为***）\n\n`S get(int p)` : 单点查询\n\n`S query(int l, int r)` : 查询区间$[l,r)$进行$op$的结果\n\n`void modify(int p, F f)` : 单点应用修改（***单点加***）\n\n`void modify(int l, int r, F f)` : 区间$[l,r)$应用修改 (***区间加***)\n\n`template <bool (*g)(S)> int max_right(int l)` : 线段树二分查询从$l$开始的最右端点$r$，满足$g(op[l,l+1,\\cdots,\\textcolor{red}{r-1}])=true$.\n\n`template <bool (*g)(S)> int min_left(int r)` : 线段树二分查询到$r$的最左端点$l$，满足$g(op[l,l+1,\\cdots,\\textcolor{red}{r-1}])=true$.\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Segtrees\n{\n    int bit_ceil(int n)\n    {\n        int x = 1;\n        while (x < n)\n            x *= 2;\n        return x;\n    }\n    int countr_zero(unsigned int n)\n    {\n        return __builtin_ctz(n);\n    }\n    template <class S,S (*op)(S, S),S (*e)(),class F,S (*mp)(F, S),F (*comp)(F, F),F (*id)()>\n    struct lazy_segtree\n    {\n    private:\n        int _n, size, log;\n        vector<S> d;\n        vector<F> lz;\n        void pushup(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }\n        void upd(int k, F f)\n        {\n            d[k] = mp(f, d[k]);\n            if (k < size)\n                lz[k] = comp(f, lz[k]);\n        }\n        void pushdown(int k)\n        {\n            upd(k << 1, lz[k]);\n            upd(k << 1 | 1, lz[k]);\n            lz[k] = id();\n        }\n\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        explicit lazy_segtree(int n) : lazy_segtree(vector<S>(n, e())) {}\n        explicit lazy_segtree(const vector<S> &v) : _n(int(v.size()))\n        {\n            size = bit_ceil((_n));\n            log = countr_zero(size);\n            d = vector<S>(2 * size, e());\n            lz = vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                pushup(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            return d[p];\n        }\n        /*查询区间[l,r)的结果,l=r时返回幺元*/\n        S query(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    pushdown(l >> i);\n                if (((r >> i) << i) != r)\n                    pushdown((r - 1) >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_query() { return d[1]; }\n        void modify(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            d[p] = mp(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        void modify(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    pushdown(l >> i);\n                if (((r >> i) << i) != r)\n                    pushdown((r - 1) >> i);\n            }\n            int l2 = l, r2 = r;\n            while (l < r)\n            {\n                if (l & 1)\n                    upd(l++, f);\n                if (r & 1)\n                    upd(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    pushup(l >> i);\n                if (((r >> i) << i) != r)\n                    pushup((r - 1) >> i);\n            }\n        }\n        /*\n         * @brief 线段树二分，查询区间[l,n)满足g的最右端点r\n         * @tparam G 查询函数g，参数类型S\n         * @param l 区间左端点\n         * @return 区间[l,n)满足g( op([l,l+1,···,r) )的最右端点r\n         */\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x)\n                             { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        pushdown(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x)\n                            { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                pushdown((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        pushdown(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.5 Segtree.h/segtree\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Segtrees\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        explicit segtree(int n) : segtree(vector<S>(n, e())) {}\n        explicit segtree(const vector<S> &v) : _n(v.size())\n        {\n            size = bit_ceil(_n);\n            log = countr_zero(size);\n            d = vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                pushup(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        S get(int p) const\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S query(int l, int r) const\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_query() const { return d[1]; }\n        template <bool (*f)(S)>\n        int max_right(int l) const\n        {\n            return max_right(l, [](S x)\n                             { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f) const\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)>\n        int min_left(int r) const\n        {\n            return min_left(r, [](S x)\n                            { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f) const\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        vector<S> d;\n        void pushup(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.6 线段树合并\n\n动态开点线段树合并，常出现于树上问题，父亲节点继承子节点信息。树上差分结合线段树合并维护路径上信息。\n\n示例是非永久化标记的写法。核心就这一个，具体可参考主席树写法。\n\n```cpp\nint merge(int rt1, int rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n        return rt1 | rt2;\n    if (cl == cr)\n    {\n        tree[rt1].maxnum += tree[rt2].maxnum;\n        return rt1;\n    }\n    int mid = (cl + cr) >> 1;\n    tree[rt1].l = merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    tree[rt1].r = merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    pushup(rt1);\n    return rt1;\n}\n```\n\n裸模板见下面线段树分裂中，有线段树合并部分。\n\n自己风格的主席树是用线段树合并写的，思路更清晰。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.7 线段树分裂\n\n八辈子碰不上一个。\n\n给出一个可重集 $a$（编号为 $1$），它支持以下操作：\n\n`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。\n\n`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。\n\n`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。\n\n`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。\n\n`4 p k`：查询在 $p$ 这个可重集中第 $k$​ 小的数，不存在时输出 `-1`。\n\n```cpp\n// 线段树分裂\n// 线段树合并逆向操作\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n// #define DEBUG 1\nconst int maxn = 3e5 + 9;\nint n, m, tot = 0, root[maxn], a[maxn];\nstruct node\n{\n    int l, r, sum;\n    int cl, cr;\n} tree[maxn << 5];\n#define ls(rt) tree[rt].l\n#define rs(rt) tree[rt].r\n#define rcl(rt) tree[rt].cl\n#define rcr(rt) tree[rt].cr\n#define sum(rt) tree[rt].sum\nvoid pushup(int rt)\n{\n    sum(rt) = sum(ls(rt)) + sum(rs(rt));\n}\nvoid update(int &rt, int num, int pos, int cl = 1, int cr = n) // 单点修改权值线段树\n{\n    if (!rt)\n    {\n        rt = ++tot;\n        rcl(rt) = cl, rcr(rt) = cr;\n    }\n    if (cl == cr)\n    {\n        sum(rt) += num;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(ls(rt), num, pos, cl, mid);\n    else\n        update(rs(rt), num, pos, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nint querykth(int &rt, int k, int cl = 1, int cr = n) // 查询区间第k小，线段树上二分\n{\n    if (!rt)\n        return -1;\n    if (cl == cr)\n        return cl;\n    int mid = (cl + cr) >> 1LL;\n    if (sum(ls(rt)) >= k)\n        return querykth(ls(rt), k, cl, mid);\n    else\n        return querykth(rs(rt), k - sum(ls(rt)), mid + 1, cr);\n}\nint queryinterval(int &rt, int l, int r, int cl = 1, int cr = n) // 查询大于等于x小于等于y的元素个数\n{\n    if (l <= cl && cr <= r)\n        return sum(rt);\n    int mid = (cl + cr) >> 1LL, ans = 0;\n    if (l <= mid)\n        ans += queryinterval(ls(rt), l, r, cl, mid);\n    if (r > mid)\n        ans += queryinterval(rs(rt), l, r, mid + 1, cr);\n    return ans;\n}\nvoid segmerge(int &rt1, int &rt2, int cl = 1, int cr = n)\n{\n    if (!rt1 || !rt2)\n        return void(rt1 = rt1 + rt2);\n    if (cl == cr)\n        return void(sum(rt1) += sum(rt2));\n    int mid = (cl + cr) >> 1;\n    segmerge(ls(rt1), ls(rt2), cl, mid);\n    segmerge(rs(rt1), rs(rt2), mid + 1, cr);\n    pushup(rt1);\n    return;\n}\nvoid segsplit(int &rt1, int &rt2, int l, int r, int cl = 1, int cr = n)\n{\n    if (!rt1)\n    {\n        return;\n    }\n    if (l <= cl && cr <= r)\n    {\n        rt2 = rt1;\n        rt1 = 0;\n        return;\n    }\n    if (!rt2)\n    {\n        rt2 = ++tot;\n        rcl(rt2) = cl, rcr(rt2) = cr;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        segsplit(ls(rt1), ls(rt2), l, r, cl, mid);\n    if (r > mid)\n        segsplit(rs(rt1), rs(rt2), l, r, mid + 1, cr);\n    pushup(rt1);\n    pushup(rt2);\n    return;\n}\nint cnt = 1;\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        update(root[1], a[i], i);\n    }\n    while (m--)\n    {\n        int op, x, y, z;\n        cin >> op;\n        switch (op)\n        {\n        case 0:\n            cnt++;\n            cin >> x >> y >> z;\n            segsplit(root[x], root[cnt], y, z);\n            break;\n        case 1:\n            cin >> x >> y;\n            segmerge(root[x], root[y]);\n            break;\n        case 2:\n            cin >> x >> y >> z;\n            update(root[x], y, z);\n            break;\n        case 3:\n            cin >> x >> y >> z;\n            cout << queryinterval(root[x], y, z) << endl;\n            break;\n        case 4:\n            cin >> x >> y;\n            cout << querykth(root[x], y) << endl;\n            break;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.8 扫描线\n\n#### 1.8.1 求矩形面积的并\n\n扫描线问题 ***切记切记*** 维护好***什么时候扫过，扫过的部分怎么算，已经扫完的部分如何删除的边界问题***，也是重点DEBUG部分.\n\n求矩形面积的并每次查询的是整个区间内线段的长度。\n\n***Codeforces***上有一道维护线段的加入和删除，区间查询某个区间是否有线段覆盖的题，***注意，如果涉及到此问题***，**仅**扫描线思想中**标记不下传只维护当前线段树结点所表示的完整区间是否有线段**的类线段树分治思想***还需要额外判定以下内容：***\n\n***如果目标区间$[l,r]$已经被某条长线段完整覆盖，直接返回$true$​​即可。***\n\n```cpp\n// 扫描线模板\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nstruct segtrees\n{\n    int l, r;\n    i64 sum = 0;\n    int tags = 0;\n};\nconst int maxn = 4e5 + 9;\nsegtrees tree[maxn << 2];\nint n, m;\ni64 points[maxn];\nvoid update(int rt, int cl, int cr)\n{\n    if (tree[rt].tags)\n    {\n        tree[rt].sum = points[cr + 1] - points[cl];\n        return;\n    }\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid modifytags(int l, int r, int d, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].tags += d;\n        update(rt, cl, cr);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        modifytags(l, r, d, rt << 1, cl, mid);\n    if (r > mid)\n        modifytags(l, r, d, rt << 1 | 1, mid + 1, cr);\n    update(rt, cl, cr);\n    return;\n}\nstruct node\n{\n    int x1, y1, x2, y2;\n} rem[maxn];\nvector<tuple<int, int, int, int>> op;\nsigned main()\n{\n    cin >> n;\n    int cnt = 0;\n    int S = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 > x2)\n            swap(x1, x2);\n        if (y1 > y2)\n            swap(y1, y2);\n        rem[i] = {x1, y1, x2, y2};\n        points[++cnt] = x1;\n        points[++cnt] = x2;\n    }\n    sort(points + 1, points + 1 + cnt);\n    S = unique(points + 1, points + 1 + cnt) - points - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int x1 = lower_bound(points + 1, points + 1 + S, rem[i].x1) - points;\n        int x2 = lower_bound(points + 1, points + 1 + S, rem[i].x2) - points;\n        op.push_back({rem[i].y1, x1, x2 - 1, 1});\n        op.push_back({rem[i].y2, x1, x2 - 1, -1});\n    }\n    sort(op.begin(), op.end());\n    i64 ans = 0;\n    i64 last = 0;\n    for (auto [y, x1, x2, d] : op)\n    {\n        ans += (y - last) * tree[1].sum;\n        modifytags(x1, x2, d, 1, 1, S);\n        last = y;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.8.2 维护线段的并\n\n其实有点废话，本质上不是扫描线，但是确实是通过维护线段区间的并判断此时有多少个合法情况，来源于牛客多校的$Interval Selection$:\n\n\n\n有一个长度为 $n$ 的数组，当且仅当 $a_l,a_{l+1},\\dots a_r$ 中的每个元素在当前区间内恰好出现 $k$ 次时，数组中的子数组 $[l,r]$ 才是好数组。  \n\n例如，对于$a=[1,1,2,3,2,3,1]$和$k=2$，区间$[1,2]$、$[3,6]$、$[1,6]$等都是好的。但是，$[1,3]$不符合条件，因为元素$2$只出现了一次；$[1,7]$不符合条件，因为元素$1$出现了$3$次。  \n\n请找出可以选择的好区间的个数。\n\n\n\n通过线段并维护不合法区间数量即可，线段交过于难以维护。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\n#define IOS                      \\\n    ios::sync_with_stdio(false); \\\n    cin.tie(0);                  \\\n    cout.tie(0);\nconst int maxn = 2e5 + 9;\nint a[maxn], b[maxn];\nstruct node\n{\n    int l;\n    int r;\n    int cover;\n    int sum;\n} tree[maxn << 2LL];\nint n;\n#define ls(rt) tree[rt << 1LL]\n#define rs(rt) tree[rt << 1LL | 1]\n#define cover(rt) tree[rt].cover\n#define sum(rt) tree[rt].sum\n#define getl(rt) tree[rt].l\n#define getr(rt) tree[rt].r\nvoid pushup(int rt)\n{\n    if (cover(rt))\n        sum(rt) = 0;\n    else if (getl(rt) == getr(rt))\n    {\n        sum(rt) = 1;\n    }\n    else\n        sum(rt) = sum(rt << 1LL) + sum(rt << 1LL | 1);\n    return;\n}\nvoid modify(int l, int r, int d, int rt = 1, int cl = 1, int cr = n)\n{\n    if (l <= cl && cr <= r)\n    {\n        cover(rt) += d;\n        pushup(rt);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        modify(l, r, d, rt << 1LL, cl, mid);\n    if (r > mid)\n        modify(l, r, d, rt << 1LL | 1, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nint querysum(int l, int r, int rt = 1, int cl = 1, int cr = n)\n{\n    if (cover(rt))\n        return 0;\n    if (l <= cl && cr <= r)\n    {\n        return sum(rt);\n    }\n    int mid = (cl + cr) >> 1;\n    int ans = 0;\n    if (l <= mid)\n        ans += querysum(l, r, rt << 1LL, cl, mid);\n    if (r > mid)\n        ans += querysum(l, r, rt << 1LL | 1, mid + 1, cr);\n    return ans;\n}\nvoid build(int rt = 1, int l = 1, int r = n)\n{\n    getl(rt) = l;\n    getr(rt) = r;\n    cover(rt) = 0;\n    if (l == r)\n    {\n        sum(rt) = 1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(rt << 1LL, l, mid);\n    build(rt << 1LL | 1, mid + 1, r);\n    pushup(rt);\n    return;\n}\nint k;\nvector<int> rem[maxn];\nvoid solve()\n{\n    cin >> n >> k;\n    build();\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        b[i] = a[i];\n    }\n    sort(b + 1, b + n + 1);\n    int m = unique(b + 1, b + n + 1) - b - 1;\n    for (int i = 1; i <= m; i++)\n    {\n        rem[i].clear();\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (rem[a[i]].empty())\n        {\n            rem[a[i]].push_back(0);\n        }\n        rem[a[i]].push_back(i);\n        int t = rem[a[i]].size() - 1;\n        int l = rem[a[i]][t - 1] + 1, r = rem[a[i]][t];\n        modify(l, r, 1);\n        if (t >= k)\n        {\n            l = rem[a[i]][t - k] + 1;\n            r = rem[a[i]][t - k + 1];\n            modify(l, r, -1);\n            if (l >= 2)\n                modify(1, l - 1, 1);\n            ans += querysum(l, r);\n        }\n    }\n    cout << ans << endl;\n    return;\n}\nsigned main()\n{\n    IOS;\n    int t = 1;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.9 主席树（静态区间第k小、小于等于第k小的和、小于等于前k小有多少个数）\n\n记住主席树的根本思想在于维护前缀和。\n\n另外，主席树复杂度$O(Knlogn)$，常数较大，$n\\le 5e5$时如果确定必须用到主席树，算法复杂度必须严格纯$O(nlogn)$，$O(nlog^2n)$可能会$\\color{red}TLE$​\n\n***附议：其实主席树根本就不需要离散化，动态开点的属性确保了树深度最多 $logV$，一共 $10^5$级别的数字确保了最多$O(nlogV)$的空间复杂度，一定不会超，就是常数稍微大一点而已。这意味着主席树可以完全做到平替 $01Trie$求异或最值问题。***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nstruct node\n{\n    int l, r;\n    i64 sum;\n    i64 cnt;\n};\nint tot = 0;\nconst int maxn = 5e5 + 9;\ni64 bs[maxn]; // 离散化数组，下标离散化，内存为原数字\ni64 a[maxn];\nnode tree[maxn << 5];\nint root[maxn];\nvoid init(int n)\n{\n    for (int i = 0; i <= n; i++)\n    {\n        root[i] = 0;\n    }\n    tot = 0;\n    return;\n}\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0, 0};\n    return tot;\n}\nvoid update(int &rt, int pos, int cl, int cr)\n{\n    if (!rt)\n    {\n        rt = newnode();\n    }\n    tree[rt].cnt++;\n    tree[rt].sum += bs[pos];\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(tree[rt].l, pos, cl, mid);\n    else\n        update(tree[rt].r, pos, mid + 1, cr);\n}\nvoid merge(int &rt1, int &rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n    {\n        rt1 |= rt2;\n        return;\n    }\n    tree[rt1].cnt += tree[rt2].cnt;\n    tree[rt1].sum += tree[rt2].sum;\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    return;\n}\ntuple<i64, i64, int> querykth(int rt1, int rt2, int k, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        return {bs[cl], tree[rt2].sum - tree[rt1].sum, tree[rt2].cnt - tree[rt1].cnt};\n    }\n    int mid = (cl + cr) >> 1;\n    int nowcnt = tree[tree[rt2].l].cnt - tree[tree[rt1].l].cnt;\n    i64 nowsum = tree[tree[rt2].l].sum - tree[tree[rt1].l].sum;\n    if (nowcnt >= k)\n        return querykth(tree[rt1].l, tree[rt2].l, k, cl, mid);\n    auto [kthrl, rsum, rcnt] = querykth(tree[rt1].r, tree[rt2].r, k - nowcnt, mid + 1, cr);\n    return {kthrl, nowsum + rsum, nowcnt + rcnt};\n}\nint sz = 0;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n附：关于主席树的内存回收问题\n\n需要打标记，一个想删除的点可以被删除当且仅当任何版本都没有再使用这个点。尤其注意`merge`函数的处理问题。理论上涉及主席树老版本删除删除的题目，不应当在内存上进行卡制无内存回收无法通过的数据。\n\n```cpp\nint newnode()\n{\n    if (tot + 1 < inf)\n        tot++;\n    else\n        tot = qs.front(), qs.pop();\n    viscnt[tot]++;\n    tree[tot] = {0, 0, 0};\n    return tot;\n}\nvoid del_tree(int rt)\n{\n    if (!rt)\n        return;\n    del_tree(tree[rt].l);\n    del_tree(tree[rt].r);\n    viscnt[rt]--;\n    if (!viscnt[rt])\n    {\n        qs.push(rt);\n        tree[rt] = {0, 0, 0};\n    }\n    return;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.10 主席树维护区间本质不同的元素个数（HH的项链）\n\n给定数组$a$，每次询问$[l,r]$中有多少个不同元素的值出现？\n\n一个$trival$的做法是数每个元素最后一次出现的那一个。主席树下标开位置，记录该位置是否有颜色。\n\n记录***颜色$k$最后一次出现的位置为 $pre_k$***，当前为$i$位置，颜色为$k$，则将$pos=pre_k$位置的线段树节点$-1$表示该位置不再计算，$pos=i$位置节点$+1$表示该节点计算颜色，更新$pre_k=i$。询问$[l,r]$时查询$root[r]$版本主席树。\n\n第一种做法有点像树状数组离线扫描线，不再写。\n\n***第二个更Trival的主席树做法***：\n\n数每个元素数最左侧出现的那一个。思考，$[l,r]$中位置$i$上的元素如果做出贡献，那么记$pre_i$为***位置 $i$上的颜色在 $i$前最后一次出现的位置***，第一次出现时记作$pre_i=0$，则必然有$pre_i<l$.\n\n对位置开权值树桶，维护$pre$数组中值$v=pre[i]$出现了多少次。查询区间$[l,r]$，则主席树查询$root[l-1]$和$root[r]$的差中，小于$l$的值的和。注意，权树下标从$0$开始，因保证$pre_i=0$表示位置$i$​​上的颜色在整个序列中第一次出现。\n\n第二种方法更方便于维护一些被求和的东西。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.11 主席树二维数点（HEOI2017, SuperBig常数，不推荐，建议离线树状数组扫描线，这里主要贴出来主席树构建时有区间update标记永久化）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Segtree_presistent\n{\n    struct node\n    {\n        int l = 0, r = 0;\n        int sum = 0;\n        int lazy = 0;\n    };\n    vector<node> t;\n    vector<int> root;\n    int cnt = 0, n = 0;\n    void init(int _n)\n    {\n        n = _n;\n        cnt = 0;\n        root.assign(n + 1, 0);\n        t.assign(32 * n + 10, node());\n    }\n    void modify(int &rt, int l, int r, int d, int cl, int cr)\n    {\n        if (!rt)\n        {\n            rt = ++cnt;\n        }\n        t[rt].sum += 1ll * d * (min(r, cr) - max(l, cl) + 1);\n        if (l <= cl && cr <= r)\n        {\n            t[rt].lazy += d;\n            return;\n        }\n        int mid = (cl + cr) >> 1ll;\n        if (l <= mid)\n            modify(t[rt].l, l, r, d, cl, mid);\n        if (r > mid)\n            modify(t[rt].r, l, r, d, mid + 1, cr);\n        return;\n    }\n    int query(int rt, int l, int r, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (l <= cl && cr <= r)\n        {\n            return t[rt].sum;\n        }\n        int mid = (cl + cr) >> 1ll;\n        int res = 0;\n        if (l <= mid)\n            res += query(t[rt].l, l, r, cl, mid);\n        if (r > mid)\n            res += query(t[rt].r, l, r, mid + 1, cr);\n        return res + 1ll * (min(r, cr) - max(l, cl) + 1) * t[rt].lazy;\n    }\n    void merge(int &rt1, int &rt2, int cl, int cr)\n    {\n        if (!rt1 || !rt2)\n        {\n            rt1 = rt1 + rt2;\n            return;\n        }\n        t[rt1].sum += t[rt2].sum;\n        t[rt1].lazy += t[rt2].lazy;\n        if (cl == cr)\n            return;\n        int mid = (cl + cr) >> 1ll;\n        merge(t[rt1].l, t[rt2].l, cl, mid);\n        merge(t[rt1].r, t[rt2].r, mid + 1, cr);\n        return;\n    }\n};\nSegtree_presistent seg;\nconst int maxn = 1e6 + 9;\nstruct interval\n{\n    int l, r;\n    int w;\n};\nstruct Edge\n{\n    int n;\n    vector<vector<interval>> G;\n    void init(int _n)\n    {\n        n = _n;\n        G.assign(n + 1, vector<interval>());\n    }\n    void add_edge(int u, int l, int r, int w)\n    {\n        G[u].push_back({l, r, w});\n    }\n};\nEdge G;\nint a[maxn];\nint l[maxn], r[maxn];\nstack<int> s;\nint n, m, p, q;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> p >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        l[i] = 0, r[i] = n + 1;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        while (!s.empty() && a[s.top()] < a[i])\n        {\n            s.pop();\n        }\n        l[i] = s.empty() ? 0ll : s.top();\n        s.push(i);\n    }\n    while (!s.empty())\n    {\n        s.pop();\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        while (!s.empty() && a[s.top()] < a[i])\n        {\n            s.pop();\n        }\n        r[i] = s.empty() ? 1ll * n + 1 : s.top();\n        s.push(i);\n    }\n    seg.init(n);\n    G.init(n);\n    for (int i = 1; i <= n; i++)\n    {\n        if (i != n)\n        {\n            G.add_edge(i, i + 1, i + 1, p);\n        }\n        if (l[i] && r[i] <= n)\n            G.add_edge(l[i], r[i], r[i], p);\n        if (l[i] && i + 1 <= r[i] - 1)\n        {\n            G.add_edge(l[i], i + 1, r[i] - 1, q);\n        }\n        if (r[i] <= n && l[i] + 1 <= i - 1)\n        {\n            G.add_edge(r[i], l[i] + 1, i - 1, q);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto [l, r, w] : G.G[i])\n        {\n            seg.modify(seg.root[i], l, r, w, 1, seg.n);\n        }\n        seg.merge(seg.root[i], seg.root[i - 1], 1, seg.n);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        cout << seg.query(seg.root[r], l, r, 1, seg.n) - seg.query(seg.root[l - 1], l, r, 1, seg.n) << endl;\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.12 带修主席树/树套树（动态区间第k小，单点修改）\n\n#### 1.12.1 动态区间第k小\n\n这个看怎么理解了，严格意义上根本不算主席树，属于树状数组套权值线段树。但是如果按前缀和理解主席树，`merge`函数视作对各个独立根的树求前缀和，树状数组就像是之前暴力预处理前缀和变成了将树直接绑在树状数组上，用树状数组求前缀和，也算说得过去。\n\n理论上区间修改也可以？\n\n注意潜在的空间爆炸问题。\n\n(显然可以，具体实现参考1.11区间加，1.2区间乘，相同逻辑)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 9;\n#define int long long\nint n;\nstruct node\n{\n    int l, r;\n    int sum;\n};\nnode tree[maxn << 5];\nint tot = 0;\nint root[maxn];\nint sz;\nint bs[maxn];\nint a[maxn];\nint q;\nint cnt = 0;\nint lowbit(int x)\n{\n    return (x & -x);\n}\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0ll};\n    return tot;\n}\nvoid upd(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n    {\n        rt = newnode();\n    }\n    tree[rt].sum += val;\n    if (cl == cr)\n        return;\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        upd(tree[rt].l, pos, val, cl, mid);\n    else\n        upd(tree[rt].r, pos, val, mid + 1, cr);\n    return;\n}\nvoid update(int realrt, int val)\n{\n    for (int i = realrt; i <= n; i += lowbit(i))\n    {\n        upd(root[i], a[realrt], val, 1, sz);\n    }\n}\nint query(vector<int> &rt1s, vector<int> &rt2s, int k, int cl, int cr)\n{\n    if (cl == cr)\n        return cl;\n    int mid = (cl + cr) >> 1;\n    int sums = 0;\n    for (auto j : rt2s)\n        sums += tree[tree[j].l].sum;\n    for (auto j : rt1s)\n        sums -= tree[tree[j].l].sum;\n    if (sums >= k)\n    {\n        for (auto &j : rt2s)\n            j = tree[j].l;\n        for (auto &j : rt1s)\n            j = tree[j].l;\n        return query(rt1s, rt2s, k, cl, mid);\n    }\n    else\n    {\n        for (auto &j : rt2s)\n            j = tree[j].r;\n        for (auto &j : rt1s)\n            j = tree[j].r;\n        return query(rt1s, rt2s, k - sums, mid + 1, cr);\n    }\n}\nint querykth(int l, int r, int k)\n{\n    vector<int> rt1, rt2;\n    for (int i = r; i; i -= lowbit(i))\n    {\n        rt2.push_back(root[i]);\n    }\n    for (int i = l - 1; i; i -= lowbit(i))\n    {\n        rt1.push_back(root[i]);\n    }\n    return query(rt1, rt2, k, 1, sz);\n}\n\nstruct qs\n{\n    int l, r, k;\n};\nstruct cs\n{\n    int pos, val;\n};\nsigned main()\n{\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        bs[++cnt] = a[i];\n    }\n    vector<tuple<char, qs, cs>> v(q + 1);\n    for (int i = 1; i <= q; i++)\n    {\n        char c;\n        cin >> c;\n        if (c == 'Q')\n        {\n            int l, r, k;\n            cin >> l >> r >> k;\n            v[i] = {c, {l, r, k}, {}};\n        }\n        else\n        {\n            int pos, val;\n            cin >> pos >> val;\n            bs[++cnt] = val;\n            v[i] = {c, {}, {pos, val}};\n        }\n    }\n    sort(bs + 1, bs + 1 + cnt);\n    sz = unique(bs + 1, bs + 1 + cnt) - bs - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = lower_bound(bs + 1, bs + 1 + sz, a[i]) - bs;\n        update(i, 1);\n    }\n    for (int i = 1; i <= q; i++)\n    {\n        auto [ch, qss, css] = v[i];\n        if (ch == 'Q')\n        {\n            cout << bs[querykth(qss.l, qss.r, qss.k)] << endl;\n        }\n        else\n        {\n            update(css.pos, -1);\n            a[css.pos] = lower_bound(bs + 1, bs + 1 + sz, css.val) - bs;\n            update(css.pos, 1);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.12.2 静态二维矩形第k小\n\n空间复杂度极高。看数据范围是否选择范围分治。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct node\n{\n    int l, r;\n    int sum;\n    int cnt;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 7];\nint tot = 0;\nconst int sz = 1009;\nint update(int rt, int pos, int cl, int cr)\n{\n    if (!rt)\n        rt = ++tot;\n    tree[rt].cnt++;\n    tree[rt].sum += pos;\n    if (cl == cr)\n    {\n        return rt;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        tree[rt].l = update(tree[rt].l, pos, cl, mid);\n    else\n        tree[rt].r = update(tree[rt].r, pos, mid + 1, cr);\n    return rt;\n}\nint querysum(int &rt, int l, int r, int cl, int cr)\n{\n    if (!rt)\n        return 0;\n    if (l <= cl && cr <= r)\n        return tree[rt].sum;\n    int mid = (cl + cr) >> 1;\n    int res = 0;\n    if (l <= mid)\n        res += querysum(tree[rt].l, l, r, cl, mid);\n    if (r > mid)\n        res += querysum(tree[rt].r, l, r, mid + 1, cr);\n    return res;\n}\nstruct Fenwick\n{\nprivate:\n    int n, m;\n    vector<vector<i64>> c;\n    int lowbit(int x) { return x & -x; }\n\npublic:\n    Fenwick(int n, int m) : n(n), m(m), c(n + 1, vector<i64>(m + 1, 0)) {}\n    Fenwick() : n(0), m(0) {}\n    void init(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        c.assign(n + 1, vector<i64>(m + 1, 0));\n    }\n    void add(int x, int y, i64 v)\n    {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = y; j <= m; j += lowbit(j))\n                c[i][j] = update(c[i][j], v, 1, sz);\n    }\n    vector<int> query(int x, int y)\n    {\n        vector<int> res;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = y; j; j -= lowbit(j))\n                res.push_back(c[i][j]);\n        return res;\n    }\n};\nint querysum(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[j].sum;\n    }\n    return sum;\n}\nint querycnt(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[j].cnt;\n    }\n    return sum;\n}\nint queryrcnt(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[tree[j].r].cnt;\n    }\n    return sum;\n}\nint queryrsum(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[tree[j].r].sum;\n    }\n    return sum;\n}\nvoid didl(vector<int> &rt)\n{\n    for (auto &j : rt)\n    {\n        j = tree[j].l;\n    }\n}\nvoid didr(vector<int> &rt)\n{\n    for (auto &j : rt)\n    {\n        j = tree[j].r;\n    }\n}\nint queryans(int h, int cl, int cr,\n             vector<int> &rt1, vector<int> &rt2, vector<int> &rt3, vector<int> &rt4, int cnts)\n{\n    if (cl == cr)\n    {\n        int sums = querysum(rt1) + querysum(rt4) - querysum(rt2) - querysum(rt3);\n        if (sums >= h)\n        {\n            int nowcnt = querycnt(rt1) + querycnt(rt4) - querycnt(rt2) - querycnt(rt3);\n            while (nowcnt && sums - cl >= h)\n                nowcnt--, sums -= cl;\n            return cnts + nowcnt;\n        }\n        return -1;\n    }\n    int mid = (cl + cr) >> 1;\n    int sum = queryrsum(rt1) + queryrsum(rt4) - queryrsum(rt2) - queryrsum(rt3);\n    int newcnt = queryrcnt(rt1) + queryrcnt(rt4) - queryrcnt(rt2) - queryrcnt(rt3);\n    if (sum >= h)\n    {\n        didr(rt1), didr(rt2), didr(rt3), didr(rt4);\n        return queryans(h, mid + 1, cr, rt1, rt2, rt3, rt4, cnts);\n    }\n    else\n    {\n        didl(rt1), didl(rt2), didl(rt3), didl(rt4);\n        return queryans(h - sum, cl, mid, rt1, rt2, rt3, rt4, cnts + newcnt);\n    }\n}\nFenwick fw;\nint queryfinal(int x1, int x2, int y1, int y2, int h)\n{\n    vector<int> rt1, rt2, rt3, rt4;\n    rt1 = fw.query(x1 - 1, y1 - 1);\n    rt2 = fw.query(x2, y1 - 1);\n    rt3 = fw.query(x1 - 1, y2);\n    rt4 = fw.query(x2, y2);\n    return queryans(h, 1, sz, rt1, rt2, rt3, rt4, 0);\n}\nsigned main()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    fw.init(n + 10, m + 10);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n        {\n            int x;\n            cin >> x;\n            fw.add(i, j, x);\n        }\n    while (k--)\n    {\n        int x1, x2, y1, y2, h;\n        cin >> x1 >> y1 >> x2 >> y2 >> h;\n        int ans = queryfinal(x1, x2, y1, y2, h);\n        if (ans > 0)\n            cout << ans << endl;\n        else\n            cout << \"Poor QLW\" << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.13 主席树可持久化数组\n\n维护这样的一个长度为 $ N $ 的数组，支持如下几种操作\n\n```\n1. 对于操作1，格式为$ v_i \\ 1 \\ {loc}_i \\ {value}_i $，即为在版本$ v_i $的基础上，将 $ a_{{loc}_i} $ 修改为 $ {value}_i $。\n\n2. 对于操作2，格式为$ v_i \\ 2 \\ {loc}_i $，即访问版本$ v_i $中的 $ a_{{loc}_i} $的值，注意：**生成一样版本的对象应为 $v_i$**。\n```\n此外，每进行一次操作（**对于操作2，即为生成一个完全一样的版本，不作任何改动**），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）\n\n***注意和主席树不一样的地方，merge函数不赋值（因为是把剩下未变动的部分直接merge过来），修改时先改再merge，查询时先merge再改***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 2e6 + 9;\nint tot = 0;\nint sz;\nstruct node\n{\n    int l, r;\n    int num;\n};\nnode tree[maxn << 5];\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0};\n    return tot;\n}\nvoid merge(int &rt1, int &rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n    {\n        rt1 |= rt2;\n        return;\n    }\n    if (cl == cr)\n    {\n        // tree[rt1].num = tree[rt2].num;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    return;\n}\nvoid update(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n        rt = newnode();\n    if (cl == cr)\n    {\n        tree[rt].num = val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(tree[rt].l, pos, val, cl, mid);\n    else\n        update(tree[rt].r, pos, val, mid + 1, cr);\n}\nint query(const int rt, int pos, int cl, int cr)\n{\n    if (!rt)\n        return 0;\n    if (cl == cr)\n    {\n        return tree[rt].num;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        return query(tree[rt].l, pos, cl, mid);\n    else\n        return query(tree[rt].r, pos, mid + 1, cr);\n}\nvoid printtree(int rt, int cl = 1, int cr = sz)\n{\n    if (!rt)\n    {\n        cout << 0 << endl;\n        return;\n    }\n    if (cl == cr)\n    {\n        cout << tree[rt].num << endl;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    printtree(tree[rt].l, cl, mid);\n    printtree(tree[rt].r, mid + 1, cr);\n}\nint root[maxn];\nint n, m;\nint ver = 0;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    sz = n;\n    for (int i = 1; i <= n; i++)\n    {\n        int val;\n        cin >> val;\n        update(root[0], i, val, 1, sz);\n    }\n    while (m--)\n    {\n        ver++;\n        int v, op, pos, val;\n        cin >> v >> op >> pos;\n        if (op == 1)\n        {\n            cin >> val;\n            update(root[ver], pos, val, 1, sz);\n            merge(root[ver], root[v], 1, sz);\n        }\n        else\n        {\n            merge(root[ver], root[v], 1, sz);\n            cout << query(root[ver], pos, 1, sz) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.14 主席树可持久化并查集\n\n给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。\n\n有 $m$ 次操作。操作分为 $3$ 种：\n\n - `1 a b` 合并 $a,b$ 所在集合；\n - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；\n - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。\n\n$n\\le 10^5,m\\le 10^5$\n\n只需注意一个点，路径压缩并查集复杂度是均摊的，恶劣情况下单次合并会是$O(n)$​的复杂度。所以要上按秩合并（启发式合并）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 2e5 + 9;\nstruct presistent_array\n{\n    int tot = 0;\n    int sz;\n    struct node\n    {\n        int l, r;\n        int num;\n    };\n    node tree[maxn << 5];\n    int newnode()\n    {\n        tot++;\n        tree[tot] = {0, 0, 0};\n        return tot;\n    }\n    void merge(int &rt1, int &rt2, int cl, int cr)\n    {\n        if (!rt1 || !rt2)\n        {\n            rt1 |= rt2;\n            return;\n        }\n        if (cl == cr)\n        {\n            // tree[rt1].num = tree[rt2].num;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        merge(tree[rt1].l, tree[rt2].l, cl, mid);\n        merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n        return;\n    }\n    void update(int &rt, int pos, int val, int cl, int cr)\n    {\n        if (!rt)\n            rt = newnode();\n        if (cl == cr)\n        {\n            tree[rt].num = val;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            update(tree[rt].l, pos, val, cl, mid);\n        else\n            update(tree[rt].r, pos, val, mid + 1, cr);\n    }\n    int query(const int rt, int pos, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (cl == cr)\n        {\n            return tree[rt].num;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            return query(tree[rt].l, pos, cl, mid);\n        else\n            return query(tree[rt].r, pos, mid + 1, cr);\n    }\n    void printtree(const int rt)\n    {\n        for (int i = 1; i <= sz; i++)\n        {\n            cout << query(rt, i, 1, sz) << \" \";\n        }\n        cout << endl;\n    }\n    int root[maxn];\n};\narray<int, 2> vers[maxn];\nint n, m;\nint ver = 0;\nint verfa = 0, versiz = 0;\npresistent_array fa, siz; // 开两个数组，直接就是可持久化数组封起来\nint getfather(int fart, int x)\n{\n    int getf = fa.query(fart, x, 1, n);\n    if (x == getf)\n        return x;\n    else\n        return getfather(fart, getf);\n}\nbool same(int fart, int u, int v)\n{\n    return getfather(fart, u) == getfather(fart, v);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    fa.sz = siz.sz = n;\n    vers[0] = {0, 0};\n    for (int i = 1; i <= n; i++)\n    {\n        fa.update(fa.root[vers[0][0]], i, i, 1, n);\n        siz.update(siz.root[vers[0][1]], i, 1, 1, n);\n    }\n    // fa.printtree(fa.root[0]);\n    // siz.printtree(siz.root[0]);\n    while (m--)\n    {\n        ver++;\n        vers[ver][0] = vers[ver][1] = ver;\n        int op, k;\n        cin >> op;\n        if (op == 2)\n        {\n            cin >> k;\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[k][0]], 1, n); // 版本回滚\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[k][1]], 1, n);\n        }\n        else if (op == 3)\n        {\n            int u, v;\n            cin >> u >> v;\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[ver - 1][0]], 1, n); // 版本复制\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[ver - 1][1]], 1, n);\n            cout << same(fa.root[vers[ver][0]], u, v) << endl;\n        }\n        else\n        {\n            int u, v;\n            cin >> u >> v;\n            u = getfather(fa.root[vers[ver - 1][0]], u);\n            v = getfather(fa.root[vers[ver - 1][0]], v);\n            if (u != v)\n            {\n                int szu = siz.query(siz.root[vers[ver - 1][1]], u, 1, n);\n                int szv = siz.query(siz.root[vers[ver - 1][1]], v, 1, n);\n                if (szu < szv)\n                {\n                    swap(szu, szv);\n                    swap(u, v);\n                }\n                fa.update(fa.root[vers[ver][0]], v, u, 1, n);           // fa[v]=u,小向大合并\n                siz.update(siz.root[vers[ver][1]], u, szu + szv, 1, n); // siz[u]+=sizv\n            }\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[ver - 1][0]], 1, n); // 先改再复制\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[ver - 1][1]], 1, n);\n        }\n        // fa.printtree(fa.root[vers[ver][0]]);\n        // siz.printtree(siz.root[vers[ver][1]]);\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.15 Li-Chao Tree\n\n要求在平面直角坐标系下维护两个操作：\n\n1. 在平面上加入一条线段。记第 $i$ 条被插入的线段的标号为 $i$。\n2. 给定一个数 $k$，询问与直线 $x = k$ 相交的线段中，交点纵坐标最大的线段的编号。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq k, x_0, x_1 \\leq 39989$，$1 \\leq y_0, y_1 \\leq 10^9$​。\n\n李超树可以优秀的维护平面内添加线性函数线段以及查询$max{f_i(x)}$，可用于斜率优化$dp$​等。不支持加入线段后删除，如有必要，考虑***线段树分治+李超树实现***。\n\n李超树的核心为$upd$函数，更新线段树***完整节点***区间内的信息。\n\n具体来说，设当前区间的中点为$mid$，我们拿新线段$f$在中点处的值与原最优线段$g$在中点处的值作比较。\n\n如果新线段$f$更优，则将$f$和$g$交换。那么现在考虑在中点处$f$不如$g$优的情况：\n\n1. 若在左端点处$f$更优，那么$f$和$g$必然在左半区间中产生了交点，$f$只有在左区间才可能优于 $g$，递归到左儿子中进行下传；\n2. 若在右端点处$f$更优，那么$f$和$g$必然在右半区间中产生了交点，$f$只有在右区间才可能优于 $g$，递归到右儿子中进行下传；\n3. 若在左右端点处$g$都更优，那么$f$不可能成为答案，不需要继续下传。\n\n除了这两种情况之外，还有一种情况是$f$和$g$刚好交于中点，在程序实现时可以归入中点处$f$不如$g$优的的情况，结果会往$f$更优的一个端点进行递归下传。\n\n最后将$g$作为当前区间的懒标记。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\n#define d64 long double\n// #define MOD1 39989\n#define MOD1 39989\n#define MOD2 1000000000\nconst int maxn = 2e5 + 5;\nstruct node\n{\n    // int l, r;\n    int bestcnt;\n} tree[maxn << 2LL];\nint n, m;\nint lastans = 0;\nint cnt = 0;\nstruct segments\n{\n    // int l, r;\n    d64 k, b;\n} segs[maxn];\nint cmp(d64 x, d64 y)\n{\n    if (x - y > 1e-9)\n        return 1;\n    if (y - x > 1e-9)\n        return -1;\n    return 0;\n}\nd64 calc(int id, int x)\n{\n    return segs[id].k * x + segs[id].b;\n}\nvoid add(int x0, int y0, int x1, int y1)\n{\n    cnt++;\n    if (x0 == x1)\n        segs[cnt].k = 0, segs[cnt].b = max(y0, y1);\n    else\n        segs[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), segs[cnt].b = y0 - segs[cnt].k * x0;\n}\nvoid upd(int now, int rt, int cl, int cr)\n{\n    int mid = (cl + cr) >> 1LL;\n    int &v = tree[rt].bestcnt;\n    int bmid = cmp(calc(now, mid), calc(v, mid));\n    if (bmid == 1 || (!bmid && now < v))\n        swap(now, v);\n    int bl = cmp(calc(now, cl), calc(v, cl)), br = cmp(calc(now, cr), calc(v, cr));\n    if (bl == 1 || (!bl && now < v))\n        upd(now, rt << 1LL, cl, mid);\n    if (br == 1 || (!br && now < v))\n        upd(now, rt << 1LL | 1LL, mid + 1, cr);\n    return;\n}\nvoid update(int now, int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        upd(now, rt, cl, cr);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (l <= mid)\n        update(now, l, r, rt << 1LL, cl, mid);\n    if (r > mid)\n        update(now, l, r, rt << 1LL | 1LL, mid + 1, cr);\n    return;\n}\npair<double, int> max(pair<double, int> a, pair<double, int> b)\n{\n    if (cmp(a.first, b.first) == 1)\n        return a;\n    if (cmp(a.first, b.first) == -1)\n        return b;\n    return a.second < b.second ? a : b;\n}\npair<double, int> query(int d, int rt, int cl, int cr)\n{\n    if (cr < d || cl > d)\n        return {0, 0};\n    int mid = (cl + cr) >> 1LL;\n    double res = calc(tree[rt].bestcnt, d);\n    if (cl == cr)\n        return {res, tree[rt].bestcnt};\n    return max({res, tree[rt].bestcnt}, max(query(d, rt << 1LL, cl, mid), query(d, rt << 1LL | 1LL, mid + 1, cr)));\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int opt;\n        cin >> opt;\n        if (opt == 1)\n        {\n            int l, r, a, b;\n            cin >> l >> a >> r >> b;\n            l = (l + lastans - 1) % MOD1 + 1;\n            r = (r + lastans - 1) % MOD1 + 1;\n            a = (a + lastans - 1) % MOD2 + 1;\n            b = (b + lastans - 1) % MOD2 + 1;\n            if (l > r)\n                swap(l, r), swap(a, b);\n            add(l, a, r, b);\n            update(cnt, l, r, 1, 1, MOD1);\n        }\n        else\n        {\n            int x;\n            cin >> x;\n            x = (x + lastans - 1) % MOD1 + 1;\n            pair<double, int> ans = query(x, 1, 1, MOD1);\n            cout << ans.second << endl;\n            lastans = ans.second;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.16 类Li-Chao Tree  /  递归区间合并\n\n思维，和李超树没有关系，在于两个区间合并`pushup`的时候比较困难，需要像李超树的`upd`一样递归处理的情况。\n\n```cpp\nvoid pushup1(int rt)\n{\n    tree[rt].maxn = max(tree[rt << 1].maxn, tree[rt << 1 | 1].maxn);\n}\nint pushup2(d32 tar, int rt, int cl, int cr)\n{\n    if (tree[rt].maxn <= tar)\n        return 0;\n    if (a[cl] > tar)\n        return tree[rt].len;\n    if (cl == cr)\n    {\n        return (a[cl] > tar);\n    }\n    int mid = (cl + cr) >> 1;\n    if (tree[rt << 1].maxn <= tar)\n        return pushup2(tar, rt << 1 | 1, mid + 1, cr);\n    return pushup2(tar, rt << 1, cl, mid) + tree[rt].len - tree[rt << 1].len;\n}\nvoid pushup(int rt, int cl, int cr)\n{\n    pushup1(rt);\n    int mid = (cl + cr) >> 1;\n    tree[rt].len = tree[rt << 1].len + pushup2(tree[rt << 1].maxn, rt << 1 | 1, mid + 1, cr);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.17 线段树分治\n\n假如你需要维护一些信息，这些信息会在某一个时间段内出现，要求在离线的前提下回答某一个时刻的信息并，则可以考虑使用线段树分治的技巧。\n\n实际上线段树分治常有以下用途：\n\n1. 用原本不支持删除但是支持撤销的数据结构来模拟删除操作。如朴素的并查集无法高效支持删边操作。\n2. 不同属性的数据分别计算。如需要求出除了某一种颜色外，其他颜色数据的答案。\n\n首先我们建立一个线段树来维护时刻，每一个节点维护一个 `vector` 来存储位于这一段时刻的信息。\n\n插入一个信息到线段树中和普通线段树的区间修改是类似的。\n\n然后我们考虑如何处理每一个时间段的信息并。考虑从根节点开始分治，维护当前的信息并，然后每到一个节点的时候将这个节点的所有信息进行合并。回溯时撤销这一部分的贡献。最后到达叶子节点时的信息并就是对应的答案。\n\n如果更改信息的时间复杂度为$O(T(n))$，可以通过设置一个栈保留更改，以$O(T(n))$的时间复杂度撤销。撤销不维持均摊复杂度。\n\n整个分治流程的总时间复杂度是$O(nlogn(T(n)+M(n)))$的，其中$O(M(n))$为合并信息的时间复杂度，空间复杂度为$O(nlogn)$​。\n\n并查集不嫌麻烦最好写可持久化，不用栈，速度还偏快一点,缺点是码量确实高，而且一旦抄错了不好DEBUG。***如果写普通并查集，必须写按秩合并，路径压缩因为均摊复杂度不被支持***。撤销时，直接通过栈所记录的`merge`前的信息直接复原即可。\n\n```cpp\n#define ls (i << 1)\n#define rs (i << 1 | 1)\n#define mid ((l + r) >> 1)\n\nvector<Object> tree[N << 2];  // 线段树\n\nvoid update(int ql, int qr, Object obj, int i, int l, int r) {  // 插入\n  if (ql <= l && r <= qr) {\n    tree[i].push_back(obj);\n    return;\n  }\n  if (ql <= mid) update(ql, qr, obj, ls, l, mid);\n  if (qr > mid) update(ql, qr, obj, rs, mid + 1, r);\n}\n\nstack<Object> sta;  // 用于撤销的栈\nObject now;         // 当前的信息并\nObject ans[N];      // 答案\n\nvoid solve(int i, int l, int r) {\n  auto lvl = sta.size();  // 记录一下应当撤销到第几个\n  for (Object x : tree[i]) sta.push(now), now = Merge(now, x);  // 合并信息\n  if (l == r)\n    ans[i] = now;  // 记录一下答案\n  else\n    solve(ls, l, mid), solve(rs, mid + 1, r);  // 分治\n  while (sta.size() != lvl) {                  // 撤销信息\n    now = sta.top();\n    sta.pop();\n  }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.18 线段树维护最大子段和\n\n线段树结点维护区间最值，区间前缀和最值，区间后缀和最值，区间$op$​​的时候比较一下两个区间的区间最大子段和以及前段后缀+后段前缀的和即可。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nconst int maxn = 5e5 + 9;\nstruct segtree\n{\n    struct node\n    {\n        i64 sum, pre, suf, maxans;\n    };\n    node tree[maxn << 2];\n    i64 a[maxn];\n    void pushup(int rt)\n    {\n        int lson = rt << 1, rson = rt << 1 | 1;\n        i64 interval = tree[lson].suf + tree[rson].pre;\n        tree[rt].sum = tree[lson].sum + tree[rson].sum;\n        tree[rt].pre = max(tree[lson].pre, tree[lson].sum + tree[rson].pre);\n        tree[rt].suf = max(tree[rson].suf, tree[rson].sum + tree[lson].suf);\n        tree[rt].maxans = max(max(tree[lson].maxans, tree[rson].maxans), interval);\n        return;\n    }\n    void build(int rt, int cl, int cr)\n    {\n        if (cl == cr)\n        {\n            tree[rt].sum = tree[rt].pre = tree[rt].suf = tree[rt].maxans = a[cl];\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        build(rt << 1, cl, mid);\n        build(rt << 1 | 1, mid + 1, cr);\n        pushup(rt);\n        return;\n    }\n    void modify(int pos, int val, int rt, int cl, int cr)\n    {\n        if (cl == cr)\n        {\n            tree[rt].sum = tree[rt].pre = tree[rt].suf = tree[rt].maxans = val;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            modify(pos, val, rt << 1, cl, mid);\n        else\n            modify(pos, val, rt << 1 | 1, mid + 1, cr);\n        pushup(rt);\n        return;\n    }\n    node query(int l, int r, int rt, int cl, int cr)\n    {\n        if (l <= cl && cr <= r)\n        {\n            return tree[rt];\n        }\n        int mid = (cl + cr) >> 1;\n        if (r <= mid)\n            return query(l, r, rt << 1, cl, mid);\n        if (l > mid)\n            return query(l, r, rt << 1 | 1, mid + 1, cr);\n        node lson = query(l, r, rt << 1, cl, mid);\n        node rson = query(l, r, rt << 1 | 1, mid + 1, cr);\n        node ret;\n        i64 interval = lson.suf + rson.pre;\n        ret.sum = lson.sum + rson.sum;\n        ret.pre = max(lson.pre, lson.sum + rson.pre);\n        ret.suf = max(rson.suf, rson.sum + lson.suf);\n        ret.maxans = max(max(lson.maxans, rson.maxans), interval);\n        return ret;\n    }\n};\nsegtree seg;\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> seg.a[i];\n    }\n    seg.build(1, 1, n);\n    for (int i = 1; i <= m; i++)\n    {\n        int op, x, y;\n        cin >> op >> x >> y;\n        if (op == 1)\n        {\n            if (x > y)\n                swap(x, y);\n            cout << seg.query(x, y, 1, 1, n).maxans << endl;\n        }\n        else\n        {\n            seg.modify(x, y, 1, 1, n);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.19 权值树维护区间有多少个不同的数\n\n$HH$的项链，碰到相同的数就把前面那个出现的位置删掉（权值树-1），后面新出现的位置加上（权值树+1）\n\n这玩意儿没求前缀和，不能算主席树。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n        x = x * 10 + ch - '0', ch = getchar();\n    return x * f;\n}\nvoid write(int x)\n{\n    if (x < 0)\n        putchar('-'), x = -x;\n    if (x > 9)\n        write(x / 10);\n    putchar(x % 10 + '0');\n    return;\n}\nstruct Persistant_segtree\n{\nprivate:\n    struct node\n    {\n        int l = 0, r = 0;\n        int sum = 0;\n    };\n    vector<node> tree;\n    int tot;\n    int n;\n\npublic:\n    Persistant_segtree(int n) : n(n), tot(0)\n    {\n        tree.assign((n << 5) + 9, node());\n    }\n    Persistant_segtree() : n(0), tot(0)\n    {\n        tree.clear();\n    }\n    void init(int n)\n    {\n        this->n = n;\n        tot = 0;\n        tree = vector<node>((n << 5) + 9);\n    }\n    void update(int &rt1, int rt2, int pos, int val, int cl, int cr)\n    {\n        if (!rt1)\n            rt1 = ++tot;\n        tree[rt1].sum = tree[rt2].sum + val;\n        if (cl == cr)\n        {\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            update(tree[rt1].l, tree[rt2].l, pos, val, cl, mid), tree[rt1].r = tree[rt2].r;\n        else\n            update(tree[rt1].r, tree[rt2].r, pos, val, mid + 1, cr), tree[rt1].l = tree[rt2].l;\n    }\n    int query(int &rt, int l, int r, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (l <= cl && cr <= r)\n            return tree[rt].sum;\n        int mid = (cl + cr) >> 1;\n        int res = 0;\n        if (l <= mid)\n            res += query(tree[rt].l, l, r, cl, mid);\n        if (r > mid)\n            res += query(tree[rt].r, l, r, mid + 1, cr);\n        return res;\n    }\n};\nPersistant_segtree pst;\nconst int maxn = 1e6 + 9;\nint a[maxn], lastpos[maxn], root[maxn];\n#define endl '\\n'\nint main()\n{\n    int n, m;\n    n = read();\n    pst.init(maxn);\n    for (int i = 1; i <= n; i++)\n        a[i] = read();\n    for (int i = 1; i <= n; i++)\n    {\n        if (lastpos[a[i]])\n        {\n            pst.update(root[i], root[i - 1], lastpos[a[i]], -1, 1, n);\n            pst.update(root[i], root[i], i, 1, 1, n);\n            lastpos[a[i]] = i;\n        }\n        else\n        {\n            pst.update(root[i], root[i - 1], i, 1, 1, n);\n            lastpos[a[i]] = i;\n        }\n    }\n    m = read();\n    while (m--)\n    {\n        int l, r;\n        l = read(), r = read();\n        write(pst.query(root[r], l, r, 1, n));\n        putchar(endl);\n    }\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.20  线段树优化建图\n\n通过线段树区间的性质实现线段树区间连边建图。需要注意的是，从区间连出需要走出树，向区间连入需要走入树，必须保证建立两棵树，出树向根有向边$(sons\\to fa)$，入树从根向下有向边$(fa\\to sons)$，不可以串行。叶子结点两棵树倒是可以共享，不共享的话叶子结点要做好无向边联通，详情见示例。\n\n<img src=\"https://oi-wiki.org/ds/images/segt6.svg\" alt=\"出树\" style=\"zoom:50%;\" />\n\n<img src=\"https://oi-wiki.org/ds/images/segt5.svg\" alt=\"入树\" style=\"zoom:50%;\" />\n\n有$n$个点、$q$次操作。每一种操作为以下三种类型中的一种:\n\n1. 连一条$u→v$的有向边,权值为$w$。\n2. 对于所有$i∈[l,r]$连一条$u→i$的有向边,权值为$ω$。\n3. 对于所有$i∈[l,r]$连一条$i→u$的有向边,权值为$ω$。\n\n求从点$s$到其他点的最短路。\n\n$1≤n,q≤10^5,1≤w≤10^9$​。\n\n```cpp\n// 线段树优化建图\n// 区间对区间连边，区间对单点连边，单点对区间连边\n// 显然的，需要动态开点线段树，建立的虚点参与跑最短路\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF = 1e18;\nint tottree = 0, cnt = 0;\nint root1 = 0, root2 = 0;\nint n;\nconst int maxn = 4e5 + 9;\nint head[maxn << 3LL], to[maxn << 3LL], nxt[maxn << 3LL], w[maxn << 3LL];\nint rtnum1[maxn], rtnum2[maxn];\nstruct node\n{\n    int l, r;\n    int cl, cr;\n};\nnode tree[maxn << 3LL];\nvoid add_edge(int u, int v, int w)\n{\n    to[++cnt] = v;\n    ::w[cnt] = w;\n    nxt[cnt] = head[u];\n    head[u] = cnt;\n}\nvoid build1(int &rt, int cl = 1, int cr = n) // 出树，区间连出\n{\n    if (!rt)\n        rt = ++tottree;\n    tree[rt].cl = cl;\n    tree[rt].cr = cr;\n    if (cl == cr)\n    {\n        rtnum1[cl] = rt;\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    build1(tree[rt].l, cl, mid);\n    build1(tree[rt].r, mid + 1, cr);\n    add_edge(tree[rt].l, rt, 0);\n    add_edge(tree[rt].r, rt, 0);\n    return;\n}\nvoid build2(int &rt, int cl = 1, int cr = n) // 入树，区间连入\n{\n    if (!rt)\n        rt = ++tottree;\n    tree[rt].cl = cl;\n    tree[rt].cr = cr;\n    if (cl == cr)\n    {\n        rtnum2[cl] = rt;\n        add_edge(rt, rtnum1[cl], 0);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    build2(tree[rt].l, cl, mid);\n    build2(tree[rt].r, mid + 1, cr);\n    add_edge(rt, tree[rt].l, 0);\n    add_edge(rt, tree[rt].r, 0);\n    return;\n}\nvoid update1(int &rt, int u, int vl, int vr, int w, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (vl <= cl && cr <= vr)\n    {\n        add_edge(rtnum1[u], rt, w);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (vl <= mid)\n        update1(tree[rt].l, u, vl, vr, w, cl, mid);\n    if (vr > mid)\n        update1(tree[rt].r, u, vl, vr, w, mid + 1, cr);\n}\nvoid update2(int &rt, int v, int ul, int ur, int w, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (ul <= cl && cr <= ur)\n    {\n        add_edge(rt, rtnum2[v], w);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (ul <= mid)\n        update2(tree[rt].l, v, ul, ur, w, cl, mid);\n    if (ur > mid)\n        update2(tree[rt].r, v, ul, ur, w, mid + 1, cr);\n}\nint dist[maxn << 3LL];\nbool vis[maxn << 3LL];\nvoid updist(int &rt, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (cl == cr)\n        return;\n    int mid = (cl + cr) >> 1LL;\n    dist[tree[rt].l] = min(dist[rt], dist[tree[rt].l]);\n    dist[tree[rt].r] = min(dist[rt], dist[tree[rt].r]);\n    updist(tree[rt].l, cl, mid);\n    updist(tree[rt].r, mid + 1, cr);\n    return;\n}\nvoid dijkstra(int s)\n{\n    // memset(dist, 0x3f3f3f3f, sizeof(int) * (tottree + 10));\n    for (int i = 1; i <= tottree + 10; i++)\n        dist[i] = INF, vis[i] = 0;\n    struct qu\n    {\n        int dis, pos;\n        bool operator<(const qu &x) const\n        {\n            return x.dis < dis;\n        }\n    };\n    priority_queue<qu> q;\n    dist[rtnum1[s]] = 0;\n    q.push({0, rtnum1[s]});\n    while (!q.empty())\n    {\n        auto [disu, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (int i = head[u]; i; i = nxt[i])\n        {\n            int v = to[i];\n            if (dist[v] > dist[u] + w[i])\n            {\n                dist[v] = dist[u] + w[i];\n                q.push({dist[v], v});\n            }\n        }\n    }\n    // updist(root);\n    return;\n}\nvoid clear()\n{\n    memset(head, 0, sizeof(int) * (tottree + 10));\n    cnt = 0, tottree = 0;\n    root1 = 0, root2 = 0;\n    return;\n}\nvoid solve()\n{\n    int q, s;\n    cin >> n >> q >> s;\n    build1(root1);\n    build2(root2);\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        int u, v, w, l, r;\n        switch (op)\n        {\n        case 1:\n            cin >> u >> v >> w;\n            add_edge(rtnum1[u], rtnum2[v], w);\n            break;\n        case 2:\n            cin >> u >> l >> r >> w;\n            update1(root2, u, l, r, w);\n            break;\n        case 3:\n            cin >> v >> l >> r >> w;\n            update2(root1, v, l, r, w);\n            break;\n        }\n    }\n    dijkstra(s);\n    for (int i = 1; i <= n; i++)\n    {\n        if (i == s)\n        {\n            cout << \"0 \";\n            continue;\n        }\n        if (dist[rtnum2[i]] == INF)\n            cout << \"-1 \";\n        else\n            cout << dist[rtnum2[i]] << \" \";\n    }\n    cout << endl;\n    clear();\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *1.21 吉司机线段树\n\n线段树维护区间最值操作与区间历史最值的模板。\n\n给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：\n\n- `1 l r k`：对于所有的 $i\\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。\n- `2 l r v`：对于所有的 $i\\in[l,r]$，将 $A_i$ 变成 $\\min(A_i,v)$。\n- `3 l r`：求 $\\sum_{i=l}^{r}A_i$。\n- `4 l r`：对于所有的 $i\\in[l,r]$，求 $A_i$ 的最大值。\n- `5 l r`：对于所有的 $i\\in[l,r]$，求 $B_i$ 的最大值。\n\n在每一次操作后，我们都进行一次更新，让 $B_i\\gets\\max(B_i,A_i)$。\n\n保证 $1\\leq n,m\\leq 5\\times 10^5$,$-5\\times10^8\\leq A_i\\leq 5\\times10^8$,\n\n$op\\in[1,5]$,$1 \\leq l\\leq r \\leq n$,$-2000\\leq k\\leq 2000$,\n\n$-5\\times10^8\\leq v\\leq 5\\times10^8$​​。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*o=obuf;\n#define g()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ninline int read()\n{\n    int s=0,f=1;char c=g();\n    for(;!isdigit(c);c=g())\n        if(c=='-')f=-1;\n    for(;isdigit(c);c=g())\n        s=s*10+c-'0';\n    return s*f;\n}\ninline void write(ll x)\n{\n    static char buf[20];\n    static int len=-1;\n    if(x<0)putchar('-'),x=-x;\n    do buf[++len]=x%10,x/=10;while(x);\n    while(len>=0)putchar(buf[len--]+'0');\n    putchar('\\n');\n}\nint n,m,op,l,r,k,v;\nstruct segment_tree{\n    ll sum;\n    int l,r,maxa,cnt,se,maxb;\n    int add1,add2,add3,add4;\n}s[2000005];\ninline void push_up(int p)\n{\n    s[p].sum=s[p*2].sum+s[p*2+1].sum;\n    s[p].maxa=max(s[p*2].maxa,s[p*2+1].maxa);\n    s[p].maxb=max(s[p*2].maxb,s[p*2+1].maxb);\n    if(s[p*2].maxa==s[p*2+1].maxa)\n    {\n        s[p].se=max(s[p*2].se,s[p*2+1].se);\n        s[p].cnt=s[p*2].cnt+s[p*2+1].cnt;\n    }\n    else if(s[p*2].maxa>s[p*2+1].maxa)\n    {\n        s[p].se=max(s[p*2].se,s[p*2+1].maxa);\n        s[p].cnt=s[p*2].cnt;\n    }\n    else\n    {\n        s[p].se=max(s[p*2].maxa,s[p*2+1].se);\n        s[p].cnt=s[p*2+1].cnt;\n    }\n}\nvoid build(int l,int r,int p)\n{\n    s[p].l=l,s[p].r=r;\n    if(l==r)\n    {\n        s[p].sum=s[p].maxa=s[p].maxb=read();\n        s[p].cnt=1,s[p].se=-2e9;\n        return;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,p*2);\n    build(mid+1,r,p*2+1);\n    push_up(p);\n}\ninline void change(int k1,int k2,int k3,int k4,int p)\n{\n    s[p].sum+=1ll*k1*s[p].cnt+1ll*k2*(s[p].r-s[p].l+1-s[p].cnt);\n    s[p].maxb=max(s[p].maxb,s[p].maxa+k3);\n    s[p].maxa+=k1;\n    if(s[p].se!=-2e9)s[p].se+=k2;\n    s[p].add3=max(s[p].add3,s[p].add1+k3);\n    s[p].add4=max(s[p].add4,s[p].add2+k4);\n    s[p].add1+=k1,s[p].add2+=k2;\n}\ninline void push_down(int p)\n{\n    int maxn=max(s[p*2].maxa,s[p*2+1].maxa);\n    if(s[p*2].maxa==maxn)\n        change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2);\n    else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2);\n    if(s[p*2+1].maxa==maxn)\n        change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2+1);\n    else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2+1);\n    s[p].add1=s[p].add2=s[p].add3=s[p].add4=0;\n}\nvoid update_add(int p)\n{\n    if(l>s[p].r||r<s[p].l)return;\n    if(l<=s[p].l&&s[p].r<=r)\n    {\t\n        s[p].sum+=1ll*k*s[p].cnt+1ll*k*(s[p].r-s[p].l+1-s[p].cnt);\n        s[p].maxa+=k;\n        s[p].maxb=max(s[p].maxb,s[p].maxa);\n        if(s[p].se!=-2e9)s[p].se+=k;\n        s[p].add1+=k,s[p].add2+=k;\n        s[p].add3=max(s[p].add3,s[p].add1);\n        s[p].add4=max(s[p].add4,s[p].add2);\n        return;\n    }\n    push_down(p);\n    update_add(p*2),update_add(p*2+1);\n    push_up(p);\n}\nvoid update_min(int p)\n{\n    if(l>s[p].r||r<s[p].l||v>=s[p].maxa)return;\n    if(l<=s[p].l&&s[p].r<=r&&s[p].se<v)\n    {\n        int k=s[p].maxa-v;\n        s[p].sum-=1ll*s[p].cnt*k;\n        s[p].maxa=v,s[p].add1-=k;\n        return;\n    }\n    push_down(p);\n    update_min(p*2),update_min(p*2+1);\n    push_up(p);\n}\nll query_sum(int p)\n{\n    if(l>s[p].r||r<s[p].l)return 0;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].sum;\n    push_down(p);\n    return query_sum(p*2)+query_sum(p*2+1);\n}\nint query_maxa(int p)\n{\n    if(l>s[p].r||r<s[p].l)return -2e9;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].maxa;\n    push_down(p);\n    return max(query_maxa(p*2),query_maxa(p*2+1));\n}\nint query_maxb(int p)\n{\n    if(l>s[p].r||r<s[p].l)return -2e9;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].maxb;\n    push_down(p);\n    return max(query_maxb(p*2),query_maxb(p*2+1));\n}\nint main()\n{\n    n=read(),m=read();\n    build(1,n,1);\n    while(m--)\n    {\n        op=read(),l=read(),r=read();\n        if(op==1)k=read(),update_add(1);\n        else if(op==2)v=read(),update_min(1);\n        else if(op==3)write(query_sum(1));\n        else if(op==4)printf(\"%d\\n\",query_maxa(1));\n        else printf(\"%d\\n\",query_maxb(1));\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *1.22 树上数据结构警示（树上线段树）\n\n一般而言，树上数据结构主要是树上权值树以及树上动态开点线段树。这里提及两个**需要注意的点**\n\n1. 主席树/线段树合并写法的$merge$函数在向父节点合并的时候会有拷贝节点（主席树原理），**如果有多个儿子节点，这种行为会导致父节点信息合并完全之后，子节点的主席树信息被污染。**如果要这么做，涉及到子树信息查询，需要合并dfs的同时进行离线处理，保证污染之后不再查询。\n\n   解决方法是树链剖分，尤其是子树信息维护，更是树剖为重中之重。\n\n   树上差分不会因为这个受影响的原因在于，树上差分的信息合并是父节点向子节点合并，子节点继承父节点的信息以记录**从自己直到根**路径上的所有数信息，子节点只有一个父节点可以继承，意味着父节点的信息不会被污染。\n\n   （ABC239E 树上子树第$K$​大因为这个问题导致WA）\n\n2. 树上合并，**一定检查有没有写**`cl==cr`里面的$\\color{red}return$\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.堆(Heap)\n\n关键词：有序序列，只关心最值\n\n### 2.1 可并堆（左偏树）\n\n定义左偏树中左儿子结点的$dist_l$一定大于等于右儿子节点的$dist_r$.\n\n定义某节点$u$的$dist_u$为其到$u$​​所在子树中最近的外节点（没有左儿子或者右儿子）的距离。\n\n一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：\n\n1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在同一个堆内，则无视此操作）。\n\n2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$​ 并无视删除操作）。\n\n***注意，这个题需要查某个数在哪个堆，需要并查集，而且因为路径压缩的不成样子，但凡涉及到弹出堆顶，必须连被删除元素一起调整而不是将删除元素简简单单的 fa 归0就可以。***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct heap\n{\n    int dis, l, r, fa, val;\n};\nconst int maxn = 1e5 + 9;\nheap tr[maxn << 5];\nint n, m;\nint getfather(int x)\n{\n    return tr[x].fa == x ? x : tr[x].fa = getfather(tr[x].fa);\n}\nint merge(int x, int y)\n{\n    if (!x || !y)\n        return x | y;\n    if (tr[x].val > tr[y].val)\n        swap(x, y);\n    tr[x].r = merge(tr[x].r, y);\n    if (tr[tr[x].l].dis < tr[tr[x].r].dis)\n        swap(tr[x].l, tr[x].r);\n    tr[x].dis = tr[tr[x].r].dis + 1;\n    tr[tr[x].l].fa = tr[tr[x].r].fa = tr[x].fa = x;\n    return x;\n}\nint pop(int x)\n{\n    tr[x].val = -1;\n    tr[tr[x].l].fa = tr[x].l;\n    tr[tr[x].r].fa = tr[x].r;\n    tr[x].fa = merge(tr[x].l, tr[x].r);\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i)\n        tr[i].fa = i, cin >> tr[i].val;\n    int t, x, y;\n    for (int i = 1; i <= m; ++i)\n    {\n        cin >> t >> x;\n        if (t == 1)\n        {\n            cin >> y;\n            if (tr[x].val == -1 || tr[y].val == -1)\n                continue;\n            int l = getfather(x), r = getfather(y);\n            if (l != r)\n                tr[l].fa = tr[r].fa = merge(l, r);\n        }\n        else\n        {\n            if (tr[x].val == -1)\n                cout << -1 << endl;\n            else\n                cout << tr[getfather(x)].val << endl, pop(getfather(x));\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 带懒标记左偏树\n\n像动态开点线段树一样，合并时注意标记下传问题\n\n```cpp\nstruct node\n{\n    int dis, val; int ch[2]; int fa; int lazyadd = 0, lazymul = 1;\n    int id; int cnt; int lazyc = 0;\n};\nint &rs(int rt) {return tree[rt].ch[tree[tree[rt].ch[0]].dis > tree[tree[rt].ch[1]].dis];/*注意rs写法*/}\nint &ls(int rt) {return tree[rt].ch[1 ^ (tree[tree[rt].ch[0]].dis > tree[tree[rt].ch[1]].dis)];/*更注意ls写法*/}\nint &dis(int rt) {return tree[rt].dis;}\nint &val(int rt) {return tree[rt].val;}\nint &fa(int rt) {return tree[rt].fa;}\nint &lazyadd(int rt) {return tree[rt].lazyadd;}\nint &lazymul(int rt) {return tree[rt].lazymul;}\nint &lazyc(int rt) {return tree[rt].lazyc;}\nint &vcnt(int rt) {return tree[rt].cnt;}\nint &id(int rt) {return tree[rt].id;}\nvoid pushdown(int rt)\n{\n    if (!rt)\n        return;\n    if (lazyadd(rt) != 0 || lazymul(rt) != 1 || lazyc(rt) != 0)\n    {\n        if (ls(rt))\n        {\n            val(ls(rt)) = val(ls(rt)) * lazymul(rt) + lazyadd(rt);\n            vcnt(ls(rt)) += lazyc(rt);\n            lazymul(ls(rt)) *= lazymul(rt);\n            lazyadd(ls(rt)) = lazyadd(ls(rt)) * lazymul(rt) + lazyadd(rt);\n            lazyc(ls(rt)) += lazyc(rt);\n        }\n        if (rs(rt))\n        {\n            val(rs(rt)) = val(rs(rt)) * lazymul(rt) + lazyadd(rt);\n            vcnt(rs(rt)) += lazyc(rt);\n            lazymul(rs(rt)) *= lazymul(rt);\n            lazyadd(rs(rt)) = lazyadd(rs(rt)) * lazymul(rt) + lazyadd(rt);\n            lazyc(rs(rt)) += lazyc(rt);\n        }\n        lazyadd(rt) = 0;\n        lazymul(rt) = 1;\n        lazyc(rt) = 0;\n    }\n    return;\n}\nint merge(int rt1, int rt2)\n{\n    if (!rt1 || !rt2)\n        return rt1 | rt2;\n    if (val(rt1) > val(rt2))\n        swap(rt1, rt2);\n    pushdown(rt1);\n    int &r = rs(rt1);\n    r = merge(r, rt2);\n    fa(r) = rt1;\n    dis(rt1) = dis(rs(rt1)) + 1; // 严禁使用pushup于此，pushup只用于删除任意非根节点时使用，删除根节点要pop\n    return rt1;\n}\nint pop(int rt1)\n{\n    pushdown(rt1);\n    return merge(ls(rt1), rs(rt1));\n}\nint tot = 0;\nint push(int rt1, int val, int id)\n{\n    tree[++tot].val = val;\n    tree[tot].id = id;\n    return merge(rt1, tot);\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *2.3 支持删除任意节点可并堆\n\n没有专门的题，有涉及到可并堆删对应节点的理论上主席树都可以做，而且复杂度是一样的，优先写自己顺手的。\n\n这里是OI-wiki的\n\n```cpp\nvoid erase(int x) {\n  int y = merge(ls(x), rs(x));\n  fa(y) = fa(x);\n  if (ls(fa(x)) == x)\n    ls(fa(x)) = y;\n  else if (rs(fa(x)) == x)\n    rs(fa(x)) = y;\n  pushup(fa(y));\n}\n```\n\n### *2.4 GNU/GCC pb_ds库\n\n`pb_ds`库提供了五种可并堆，默认大根堆，`greater`标签使用和普通$STL$一致。\n\n```cpp\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n__gnu_pbds::priority_queue<int>q;//因为放置和std重复，故需要带上命名空间\n__gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> q;//最快\n__gnu_pbds::priority_queue<int,greater<int>,binary_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,binomial_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,rc_binomial_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,thin_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int> > q;\n```\n\n`pairing_heap_tag` : `push`和`join`为$O(1)$,其余为均摊$O(logn)$。\n\n`binary_heap_tag`:只支持`push`和`pop`,均为均摊$O(logn)$。\n\n`binomial_heap_tag`:`push`为均摊$O(1)$,其余为$O(logn)$。\n\n`rc_binomial_heap_tag`: `push`为$O(1)$,其余为$O(logn)$。\n\n`thin_heap_tag`: `push`为$O(1)$,不支持`join`,其余为$O(logn)$;但是如果只有`increase_key`,那么`modify`为均摊$O(1)$​。“不支持”不是不能用,而是用起来很慢\n\n操作表：\n\n- `size()`用法同std\n\n- `empty()`用法同std\n\n- `push(const_reference r_val)`注意`push`返回`point_iterator`，被`push`元素入堆后位置\n\n- `top()`没区别…\n\n- `pop()`弹出堆顶\n\n- `point_iterator`对应某元素的迭代器\n\n- `erase(point_iterator it)`删除对应点\n\n- `modify(point_iterator it,const_reference r_new_val)`修改对应点的值\n\n  这是优化$dijkstra$神方法,均摊复杂度$O(1)$​\n\n  优化$dijkstra$的思路就是在前面提到的$std$优先队列优化的基础上,维护一个`point_iterator`数组,`push`的时候存下`push`时返回的迭代器,更新`dis`是判断是否存在此迭代器,若存在$O(1)$`modify`,不存在均摊$O(1)$`push`\n\n- `clear()`基本没什么用,还不如重新定义一个…\n\n- `join(priority_queue &other)`可并堆啊,还是$O(1)$的,注意合并后`other`会被清空\n\n- 其他迭代器同std\n\n使用示例：\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n#define int long long\nusing mergeable_priority_queue = __gnu_pbds::priority_queue<int, less<int>, __gnu_pbds::pairing_heap_tag>;\nconst int maxn = 2e5 + 9;\nint ans = 0;\nvector<int> connects[maxn];\nmergeable_priority_queue qs[maxn];\nint sum[maxn];\nint L[maxn];\nint n, m;\nvoid dfs(int u, int fa)\n{\n    for (auto v : connects[u])\n    {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n        qs[u].join(qs[v]);\n        sum[u] += sum[v];\n    }\n    while (!qs[u].empty() && sum[u] > m)\n    {\n        sum[u] -= qs[u].top();\n        qs[u].pop();\n    }\n    ans = max(ans, (int)(qs[u].size()) * L[u]);\n    return;\n}\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        int fa, c, l;\n        cin >> fa >> c >> l;\n        qs[i].push(c);\n        sum[i] += c, L[i] = l;\n        connects[fa].push_back(i);\n        connects[i].push_back(fa);\n    }\n    dfs(0, 0);\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 3.ST表（Sparse Table）\n\n关键词：静态区间，可重复贡献\n\n稀疏表，倍增，可以解决可重复贡献问题：\n\n代数系统$<S,\\cdot >$满足以下条件：\n\n1. 该代数系统为半群。\n2. 对于$\\forall x\\in S,x\\cdot x=x$​（可重复贡献）\n\n除 RMQ 以外，还有其它的「可重复贡献问题」。例如「区间按位与」、「区间按位或」、「区间 GCD」，ST 表都能高效地解决。\n\n如果碰到恶心的卡内存的，考虑ST表存对应答案在原数组的下标，节省空间。\n\n### 3.1 静态区间最值，一维ST表\n\n```cpp\n// ST表，静态区间最大值\n#include <bits/stdc++.h>\nusing namespace std;\nint getlog(int n)\n{\n    int ans = 0;\n    while (n)\n    {\n        n >>= 1;\n        ans++;\n    }\n    return ans - 1;\n}\nconst int maxn = 5e5 + 10;\nint st[maxn][20];\n#define endl '\\n'\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    int logn = getlog(n);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> st[i][0];\n    }\n    for (int j = 1; j <= logn; j++)\n    {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        {\n            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n    while (q--)\n    {\n        int l, r;\n        cin >> l >> r;\n        int dis = r - l + 1;\n        int k = getlog(dis);\n        cout << max(st[l][k], st[r - (1 << k) + 1][k]) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.2 静态区间最值，二维ST表\n\n类比一维$ST$ 表，我们定义数组$st[i][j][k][p]$表示从$(i,j)$往下$2^k$个元素，往右$2^p$个元素的最值。\n\n建表的话，同样类比一维$ST$表，外层两个循环$k$ 和$p$ , 然后内层取最值就行了。要注意的是，$k$ 和$p$要从$0$​开始循环，因为一行或者一列的情况也要维护。\n\n复杂度$O(n^2log^2n)$\n\n```cpp\nvoid build_st()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            if (i == 0 && j == 0)\n                continue;\n            for (int k = 1; k <= n - (1 << i) + 1; k++)\n            {\n                for (int p = 1; p <= n - (1 << j) + 1; p++)\n                {\n                    if (i == 0)\n                        st[k][p][i][j] = min(st[k][p][i][j - 1], st[k][p + (1 << j - 1)][i][j - 1]);\n                    else\n                        st[k][p][i][j] = min(st[k][p][i - 1][j], st[k + (1 << i - 1)][p][i - 1][j]);\n                }\n            }\n        }\n    }\n}\n\nint query(int r1, int c1, int r2, int c2)\n{\n    int k1 = log2(r2 - r1 + 1);\n    int k2 = log2(c2 - c1 + 1);\n    return min(st[r1][c1][k1][k2], min(st[r2 - (1 << k1) + 1][c1][k1][k2], min(st[r1][c2 - (1 << k2) + 1][k1][k2], st[r2 - (1 << k1) + 1][c2 - (1 << k2) + 1][k1][k2])));\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.3 倍增ST表求解LCA问题\n\n倍增优化求$LCA$，$dfs$预处理祖先信息，然后查询时先跳到同一高度，再一起暴力向上跳。暴力向上跳必须从大向小枚举。预处理$O(nlogn)$，单次查询$O(n)$.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 9;\nvector<int> connects[maxn];\nint fa[maxn][21];\nint dep[maxn];\ninline void dfs(int u, int fas)\n{\n    dep[u] = dep[fas] + 1;\n    fa[u][0] = fas;\n    for (int j = 1; j <= 20; j++)\n    {\n        fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    }\n    for (auto v : connects[u])\n    {\n        if (v == fas)\n            continue;\n        dfs(v, u);\n    }\n    return;\n}\ninline int lca(int u, int v)\n{\n    if (dep[u] < dep[v])\n        swap(u, v);\n    int tmp = dep[u] - dep[v];\n    for (int j = 0; j <= 20; j++)\n    {\n        if ((tmp >> j) & 1)\n            u = fa[u][j];\n    }\n    if (u == v)\n        return u;\n    for (int j = 20; j >= 0; j--)\n    {\t\t\n        if (fa[u][j] != fa[v][j])\n        {\n            u = fa[u][j], v = fa[v][j];\n        }\n    }\n    return fa[u][0];\n}\nint main()\n{\n    int n, m, rt;\n    cin >> n >> m >> rt;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        connects[u].push_back(v);\n        connects[v].push_back(u);\n    }\n    dfs(rt, rt);\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.4 欧拉序ST表求LCA问题\n\n问题转化成$dfs$遍历路径记录下结点的$dfn$序号上$RMQ$问题，两个节点的$lca$一定是欧拉序遍历下序号区间内深度最浅的结点。可以做到$O(nlogn)$预处理，单次询问$O(1)$.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 9;\nvector<int> connects[maxn];\nint st[maxn << 1][25];\nint dep[maxn];\nint pos[maxn];\nint logs[maxn << 1];\nvoid add_edge(int u, int v)\n{\n    connects[u].push_back(v);\n    connects[v].push_back(u);\n}\nint cnt = 0;\nvoid dfs1(int u, int fa)\n{\n    st[++cnt][0] = u;\n    dep[u] = dep[fa] + 1;\n    pos[u] = cnt;\n    for (auto v : connects[u])\n    {\n        if (v == fa)\n            continue;\n        dfs1(v, u);\n        st[++cnt][0] = u;//欧拉序记录\n    }\n    return;\n}\nvoid build_st()\n{\n    for (int j = 1; j < 25; j++)\n        for (int i = 1; i + (1 << j) - 1 <= cnt; i++)\n        {\n            int l = st[i][j - 1], r = st[i + (1 << (j - 1))][j - 1];//st维护结点序号\n            if (dep[l] < dep[r])\n                st[i][j] = l;\n            else\n                st[i][j] = r;\n        }\n    logs[1] = 0;\n    for (int i = 2; i <= cnt; i++)\n    {\n        logs[i] = logs[i / 2] + 1;\n    }\n    return;\n}\nint lcas(int u, int v)\n{\n    int l = pos[u], r = pos[v];\n    if (l > r)\n        swap(l, r);\n    int k = logs[r - l + 1];\n    int ansl = st[l][k];\n    int ansr = st[r - (1 << k) + 1][k];\n    if (dep[ansl] < dep[ansr])\n        return ansl;\n    else\n        return ansr;\n}\nint main()\n{\n    int n, m, rt;\n    cin >> n >> m >> rt;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    dfs1(rt, rt);\n    build_st();\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lcas(u, v) << endl;\n    }\n    return 0;\n}\n```\n\n\n\n<div style=\"page-break-after: always;\"></div>\n\n## 4.并查集(Disjoint Sets)\n\n关键词：同属性分类\n\n### 4.1 带权并查集\n\n维护路径权值信息，常见用路径压缩均摊复杂度。merge时搞不清就画向量图表示，一下就懂。\n\n```cpp\nint getfather(int x)\n{\n    int fa = father[x];\n    if (x != father[x])\n    {\n        father[x] = getfather(father[x]);\n        val[x] += val[fa];\n        return father[x];\n    }\n    return x;\n}\nvoid merge(int x, int y, int value)\n{\n    int fx = getfather(x);\n    int fy = getfather(y);\n    father[fx] = fy;\n    val[fx] = value + val[y] - val[x];\n}\n```\n\n### 4.2 种类并查集\n\n一个点拆成多个点维护对立矛盾等信息。\n\n```cpp\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int maxn = 1e6 + 1;\nint father[maxn];\nint ran[maxn];\nint n;\nint getfather(int x)\n{\n    if (x == father[x])\n        return x;\n    return father[x] = getfather(father[x]);\n}\nvoid merge(int x, int y)\n{\n    int fx = getfather(x);\n    int fy = getfather(y);\n    father[fx]=fy;\n}\nvoid eat(int x, int y)\n{\n    merge(x, n + y);\n    merge(n + x, 2 * n + y);\n    merge(2 * n + x, y);\n}\nvoid same(int x, int y)\n{\n    merge(x, y);\n    merge(n + x, n + y);\n    merge(2 * n + x, 2 * n + y);\n}\nbool checkeat(int x, int y)\n{\n    return getfather(x) == getfather(y + n) || getfather(x) == getfather(y + 2 * n); // 查询捕食和被捕食关系\n}\nbool checksame(int x, int y)\n{\n    return (getfather(x) == getfather(y)) || x == y;\n}\nvoid init(int n)\n{\n    for (int i = 1; i <= 3 * n; i++)\n    {\n        father[i] = i;\n    }\n}\n```\n\n### 4.3 可持久化并查集\n\n见1.14\n\n<div style=\"page-break-after: always;\"></div>\n\n## 5.树状数组(Fenwick Trees)\n\n关键词：二进制枚举，前缀和\n\n树状数组维护类似前缀和的东西。核心操作为lowbit。\n\n### 5.1 二维树状数组（模板，子矩形所有元素和）\n\n一维的树状数组都会写。下面的是二维的。维护矩形前缀和\n\n```cpp\n// 高位树状数组，没啥大区别，开多个\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct Fenwick\n{\nprivate:\n    int n, m;\n    vector<vector<i64>> c;\n    int lowbit(int x) { return x & -x; }\n\npublic:\n    Fenwick(int n, int m) : n(n), m(m), c(n + 1, vector<i64>(m + 1, 0)) {}\n    Fenwick() : n(0), m(0) {}\n    void init(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        c.assign(n + 1, vector<i64>(m + 1, 0));\n    }\n    void add(int x, int y, i64 v)\n    {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = y; j <= m; j += lowbit(j))\n                c[i][j] += v;\n    }\n    i64 query(int x, int y)\n    {\n        i64 res = 0;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = y; j; j -= lowbit(j))\n                res += c[i][j];\n        return res;\n    }\n};\n```\n\n### 5.2 离线二维数点\n\n求$[l,r]$内小于等于$x$的点有多少个。\n\n```cpp\n// 离线二维数点，扫描线离线版本\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct Fenwick\n{\nprivate:\n    int _n;\n    vector<i64> c;\n\npublic:\n    void init(int n)\n    {\n        _n = n;\n        c = vector<i64>(n + 1, 0);\n    }\n    void add(int x, i64 d)\n    {\n        for (; x <= _n; x += (x & -x))\n            c[x] += d;\n    }\n    i64 query(int x)\n    {\n        i64 res = 0;\n        for (; x; x -= (x & -x))\n            res += c[x];\n        return res;\n    }\n};\nFenwick fw;\nconst int maxn = 2e6 + 10;\nvector<pair<int, int>> mp[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 1);\n    int maxs = 0;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], maxs = max(maxs, a[i]);\n    vector<tuple<int, int, int>> query(q + 1);\n    vector<int> ans(q + 1);\n    for (int i = 1; i <= q; i++)\n    {\n        int l, r, x;\n        cin >> l >> r >> x;\n        query[i] = {l, r, x};\n        mp[r].push_back({i, 1});\n        mp[l - 1].push_back({i, -1});\n    }\n    fw.init(maxs + 100);\n    for (int i = 1; i <= n; i++)\n    {\n        fw.add(a[i], 1);\n        for (auto &j : mp[i])\n        {\n            ans[j.first] += j.second * fw.query(get<2>(query[j.first]));\n        }\n    }\n    for (int i = 1; i <= q; i++)\n        cout << ans[i] << '\\n';\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 6.平衡树（Bindary Search AVL Tree）\n\n关键词：有序序列，动态插入与删除。\n\n### 6.1 普通平衡树\n\n说实话，裸平衡树用的真不多，能用$set$、$multiset$等$STL$​​实现的东西为啥要自己写。\n\n更新：需要知道排名就别尼玛想你的multiset了，赶紧给我滚去写$Treap$!\n\n***平衡树可提供以下操作：***\n\n1. 插入一个数 $x$。\n2. 删除一个数 $x$（若有多个相同的数，应只删除一个）。\n3. 定义**排名**为比当前数小的数的个数 $+1$。查询 $x$ 的排名。\n4. 查询数据结构中排名为 $x$ 的数。\n5. 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。\n6. 求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。\n\n对于操作 3,5,6，**不保证**当前数据结构中存在数 $x$，$1\\le n \\le 10^5$.\n\n#### 6.1.1 替罪羊树（ScapeGoat Tree）\n\n替罪羊树是一个很暴力的思想，每次插入一个数动态检查插入后某些节点是否需要暴力进行平衡重构。一般选择平衡因子$\\alpha=0.7-0.8$。如果某个子树的左儿子所管辖子树大小占比例超过平衡因子就重构。重构就是中序遍历暴力重构即可。\n\n复杂度均摊$O(nlogn)$，树高均摊$O(logn)$\n\n下面示例中，重复点算作新开点，点总数不得超过$1e5$级别。平衡树构建时，默认左儿子权值必须严格小于自身，即相同权值结点必定是全部挂载于右儿子上。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (1 << 30);\ntypedef long long ll;\nconst int maxn = 1e6 + 5;\nvector<int> vec;\nstruct node\n{\n    int ls, rs, w; // 左儿子，有儿子，节点权值\n    bool exist;    // 该节点所代表元素是否存在\n    int sizx;      // 该节点下属子树大小\n    int fact;      // 该节点下属子树中尚存在元素个数\n} tr[maxn];\nint cnt, root;\nvoid pushup(int now) // 维护节点信息\n{\n    tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;\n    tr[now].fact = tr[tr[now].ls].fact + tr[tr[now].rs].fact + 1;\n}\nvoid newnode(int &now, int w) // 开新点\n{\n    now = ++cnt;\n    tr[now].w = w, tr[now].sizx = tr[now].fact = 1;\n    tr[now].exist = true;\n}\nbool judge(int now) // 判断是否平衡\n{\n    if (max(tr[tr[now].ls].sizx, tr[tr[now].rs].sizx) > tr[now].sizx * 0.75)\n        return true;\n    if ((tr[now].sizx - tr[now].fact) > tr[now].sizx * 0.3)\n        return true;\n    return false;\n}\nvoid mds(int now) // 中序遍历\n{\n    if (!now)\n        return;\n    mds(tr[now].ls);\n    if (tr[now].exist)\n        vec.push_back(now);\n    mds(tr[now].rs);\n}\nvoid cre(int L, int R, int &now) // 构造标准平衡树\n{\n    if (L == R)\n    {\n        now = vec[L];\n        tr[now].ls = tr[now].rs = 0;\n        tr[now].sizx = tr[now].fact = 1;\n        return;\n    }\n    int mid = (L + R) >> 1;\n    while (L < mid && tr[vec[mid]].w == tr[vec[mid - 1]].w)\n        mid--;\n    now = vec[mid];\n    if (L < mid)\n        cre(L, mid - 1, tr[now].ls);\n    else\n        tr[now].ls = 0;\n    cre(mid + 1, R, tr[now].rs);\n    pushup(now);\n}\nvoid update(int now, int en) // 维护父辈节点\n{\n    if (!now)\n        return;\n    if (tr[now].w > tr[en].w)\n        update(tr[now].ls, en);\n    else\n        update(tr[now].rs, en);\n    tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;\n}\nvoid rebuild(int &now) // 重构树\n{\n    vec.clear();\n    mds(now);\n    if (vec.empty())\n    {\n        now = 0;\n        return;\n    }\n    cre(0, vec.size() - 1, now);\n}\nvoid check(int &now, int en) // 检查，并重构子树\n{\n    if (now == en)\n        return;\n    if (judge(now))\n    {\n        rebuild(now);\n        update(root, now);\n        return;\n    }\n    if (tr[en].w < tr[now].w)\n        check(tr[now].ls, en);\n    else\n        check(tr[now].rs, en);\n}\nvoid inser(int &now, int w) // 插入\n{\n    if (!now)\n    {\n        newnode(now, w);\n        check(root, now);\n        return;\n    }\n    tr[now].sizx++, tr[now].fact++;\n    if (w < tr[now].w)\n        inser(tr[now].ls, w);\n    else\n        inser(tr[now].rs, w);\n}\nvoid del(int now, int w) // 删除\n{\n    if (tr[now].exist && tr[now].w == w)\n    {\n        tr[now].exist = false;\n        tr[now].fact--;\n        check(root, now);\n        return;\n    }\n    tr[now].fact--;\n    if (w < tr[now].w)\n        del(tr[now].ls, w);\n    else\n        del(tr[now].rs, w);\n}\nint getrank(int w) // 求w的排名\n{\n    int now = root, rank = 1;\n    while (now)\n    {\n        if (w <= tr[now].w)\n            now = tr[now].ls;\n        else\n        {\n            rank += tr[now].exist + tr[tr[now].ls].fact, now = tr[now].rs;\n        }\n    }\n    return rank;\n}\nint getnum(int rank) // 求排名为rank的树数\n{\n    int now = root;\n    while (now)\n    {\n        if (tr[now].exist && tr[tr[now].ls].fact + tr[now].exist == rank)\n            break;\n        else if (rank <= tr[tr[now].ls].fact)\n            now = tr[now].ls;\n        else\n        {\n            rank -= tr[now].exist + tr[tr[now].ls].fact, now = tr[now].rs;\n        }\n    }\n    return tr[now].w;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int op, x;\n        cin >> op >> x;\n        switch (op)\n        {\n        case 1:\n            inser(root, x);\n            break;\n        case 2:\n            del(root, x);\n            break;\n        case 3:\n            cout << getrank(x) << endl;\n            break;\n        case 4:\n            cout << getnum(x) << endl;\n            break;\n        case 5:\n            cout << getnum(getrank(x) - 1) << endl;\n            break;\n        case 6:\n\n            cout << getnum(getrank(x + 1)) << endl;\n            break;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.2 树堆（Treap）\n\n$Treap=Tree+Heap$，是一种弱平衡性质的平衡树，***均摊***树深度$O(logn)$。\n\n每一个树节点多赋值一个***随机***权值，使得该树***既满足平衡树性质***（$val_{lson}<val_{rt}< val_{rson}$），***又满足堆的性质***（$w_{lson}<w_{rt},w_{rt}>w_{rson}$​）\n\n复杂度正确性由随机数保证。\n\n关于更多的Treap，详见***6.2 笛卡尔树***\n\n***此处的示例因题目保证前驱后继必定存在故没有特判，如果前驱后继不存在对应函数必定卡死，解决方案参见6.3.1可持久化Treap中的解决方式。***\n\n##### 6.1.2.1 有旋Treap\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nconst int inf = 0x3f3f3f3f;\nunsigned int seed;\nrandom_device rd;\nmt19937 ran;\nstruct Treap\n{\n    struct node\n    {\n        int val, rnd, lc, rc, size, num;\n    };\n    int cnt = 0;\n    node tr[MAXN];\n    void init()\n    {\n        cnt = 0;\n    }\n    int _rand()\n    {\n        ran.seed(rd());\n        return ran();\n    }\n    void pushup(int p)\n    {\n        tr[p].size = tr[tr[p].lc].size + tr[tr[p].rc].size + tr[p].num;\n    }\n    void right(int &k)\n    {\n        int tmp = tr[k].lc;\n        tr[k].lc = tr[tmp].rc;\n        tr[tmp].rc = k;\n        tr[tmp].size = tr[k].size;\n        pushup(k);\n        k = tmp;\n    }\n    void left(int &k)\n    {\n        int tmp = tr[k].rc;\n        tr[k].rc = tr[tmp].lc;\n        tr[tmp].lc = k;\n        tr[tmp].size = tr[k].size;\n        pushup(k);\n        k = tmp;\n    }\n    void insert(int &p, int x)\n    {\n        if (p == 0)\n        {\n            p = ++cnt;\n            tr[p].val = x;\n            tr[p].num = tr[p].size = 1;\n            tr[p].lc = tr[p].rc = 0;\n            tr[p].rnd = _rand();\n            return;\n        }\n        ++tr[p].size;\n        if (x == tr[p].val)\n            ++tr[p].num;\n        else if (x < tr[p].val)\n        {\n            insert(tr[p].lc, x);\n            if (tr[tr[p].lc].rnd < tr[p].rnd)\n                right(p);\n        }\n        else if (x > tr[p].val)\n        {\n            insert(tr[p].rc, x);\n            if (tr[tr[p].rc].rnd < tr[p].rnd)\n                left(p);\n        }\n    }\n    void del(int &p, int x)\n    {\n        if (p == 0)\n            return;\n        if (tr[p].val == x)\n        {\n            if (tr[p].num > 1)\n                --tr[p].num, --tr[p].size;\n            else\n            {\n                if (tr[p].lc == 0 || tr[p].rc == 0)\n                    p = tr[p].lc + tr[p].rc;\n                else if (tr[tr[p].lc].rnd < tr[tr[p].rc].rnd)\n                    right(p), del(p, x);\n                else if (tr[tr[p].lc].rnd > tr[tr[p].rc].rnd)\n                    left(p), del(p, x);\n            }\n        }\n        else if (tr[p].val < x)\n            --tr[p].size, del(tr[p].rc, x);\n        else\n            --tr[p].size, del(tr[p].lc, x);\n    }\n    int queryrnk(int &p, int x)\n    {\n        if (p == 0)\n            return 0;\n        else if (tr[p].val == x)\n            return tr[tr[p].lc].size;\n        else if (tr[p].val < x)\n            return tr[tr[p].lc].size + tr[p].num + queryrnk(tr[p].rc, x);\n        else\n            return queryrnk(tr[p].lc, x);\n    }\n    int querynum(int &p, int rnk)\n    {\n        if (p == 0)\n            return 0;\n        if (tr[tr[p].lc].size >= rnk)\n            return querynum(tr[p].lc, rnk);\n        rnk -= tr[tr[p].lc].size;\n        if (rnk <= tr[p].num)\n            return tr[p].val;\n        rnk -= tr[p].num;\n        return querynum(tr[p].rc, rnk);\n    }\n    int queryfront(int &p, int x)\n    {\n        if (p == 0)\n            return -inf;\n        if (tr[p].val < x)\n            return max(tr[p].val, queryfront(tr[p].rc, x));\n        else if (tr[p].val >= x)\n            return queryfront(tr[p].lc, x);\n    }\n    int queryback(int &p, int x)\n    {\n        if (p == 0)\n            return inf;\n        if (tr[p].val > x)\n            return min(tr[p].val, queryback(tr[p].lc, x));\n        else if (tr[p].val <= x)\n            return queryback(tr[p].rc, x);\n    }\n};\nint pos;\nTreap tr;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int m, k;\n    tr.init();\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d%d\", &m, &k);\n        if (m == 1)\n            tr.insert(pos, k);\n        else if (m == 2)\n            tr.del(pos, k);\n        else if (m == 3)\n            printf(\"%d\\n\", tr.queryrnk(pos, k) + 1);\n        else if (m == 4)\n            printf(\"%d\\n\", tr.querynum(pos, k));\n        else if (m == 5)\n            printf(\"%d\\n\", tr.queryfront(pos, k));\n        else if (m == 6)\n            printf(\"%d\\n\", tr.queryback(pos, k));\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n##### 6.1.2.2 无旋Treap（FHQ-Treap)\n\n无旋转$Treap$​​通过树分裂和合并实现节点的添加以及删除。可以支持固定区间操作，支持可持久化操作。\n\n###### 6.1.2.2.1 单个节点只有一个值，相同值使用多个节点，可支持split_sz\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int w;\n        int val;\n        int sz;\n        node() : l(0), r(0), w(0), val(0), sz(0) {};\n        node(int val) : l(0), r(0), w(ran()), val(val), sz(1) {};\n    };\n    const static int maxn = 5e5 + 9;\n    node tree[maxn];\n    int root;\n    int tot = 0;\n    int newnode(int val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    inline void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n        return;\n    }\n    inline void split_val(const int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[rt].val <= val) // 叶子权值比目标值小，必定属于左侧。\n        {\n            l = rt;\n            split_val(tree[rt].r, tree[rt].r, r, val);\n        }\n        else\n        {\n            r = rt;\n            split_val(tree[rt].l, l, tree[rt].l, val);\n        }\n        pushup(rt);\n    }\n    inline void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            l = rt;\n            split_sz(tree[rt].r, tree[rt].r, r, sz - (tree[tree[rt].l].sz + 1));\n        }\n        else\n        {\n            r = rt;\n            split_sz(tree[rt].l, l, tree[rt].l, sz);\n        }\n        pushup(rt);\n    }\n    inline void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        if (tree[l].w > tree[r].w) // 大根堆形式，小根堆换个号就行\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n    }\n    inline void insert(int x)\n    {\n        int rt1, rt2;\n        split_val(root, rt1, rt2, x - 1);\n        merge(rt1, rt1, newnode(x));\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline void del(int val)\n    {\n        int x, y, z;\n        split_val(root, x, y, val);\n        split_val(x, x, z, val - 1);\n        merge(z, tree[z].l, tree[z].r);\n        merge(x, x, z);\n        merge(root, x, y);\n    }\n    inline int rnk(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        merge(root, x, y);\n        return ans;\n    }\n    inline int kth(int root, int k)\n    {\n        int x = root;\n        while (true)\n        {\n            if (k == tree[tree[x].l].sz + 1)\n                return tree[x].val;\n            if (k <= tree[tree[x].l].sz)\n                x = tree[x].l;\n            else\n                k -= tree[tree[x].l].sz + 1, x = tree[x].r;\n        }\n    }\n    inline int kth(int k)\n    {\n        return kth(root, k);\n    }\n    inline int pre(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = kth(x, tree[x].sz);\n        merge(root, x, y);\n        return ans;\n    }\n    inline int suf(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val);\n        int ans = kth(y, 1);\n        merge(root, x, y);\n        return ans;\n    }\n};\nTreap tr;\nsigned main()\n{\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int op, x;\n        cin >> op >> x;\n        if (op == 1)\n        {\n            tr.insert(x);\n        }\n        else if (op == 2)\n        {\n            tr.del(x);\n        }\n        else if (op == 3)\n        {\n            cout << tr.rnk(x) << endl;\n        }\n        else if (op == 4)\n        {\n            cout << tr.kth(x) << endl;\n        }\n        else if (op == 5)\n        {\n            cout << tr.pre(x) << endl;\n        }\n        else\n            cout << tr.suf(x) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n###### 6.1.2.2.2 单个节点有多个值，相同值使用同一个个节点，不支持split_sz\n\n```cpp\nrandom_device rd;\nmt19937 ran(rd());\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int val;\n        int sz;\n        int cnt;\n        int w;\n        node() : l(0), r(0), val(0), sz(0), cnt(0), w(0) {};\n        node(int val) : l(0), r(0), val(val), sz(1), cnt(1), w(ran()) {};\n    };\n    const static int N = 2e6 + 9;\n    int tot = 0;\n    int root = 0;\n    node tree[N];\n    int newnode(int val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + tree[rt].cnt;\n        return;\n    }\n    void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        if (tree[l].w > tree[r].w)\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n        return;\n    }\n    void split_val(const int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[rt].val <= val)\n        {\n            l = rt;\n            split_val(tree[rt].r, tree[rt].r, r, val);\n        }\n        else\n        {\n            r = rt;\n            split_val(tree[rt].l, l, tree[rt].l, val);\n        }\n        pushup(rt);\n    }\n    inline void insert(int x)\n    {\n        int rt1, rt2, rt3;\n        split_val(root, rt1, rt2, x - 1);\n        split_val(rt2, rt2, rt3, x);\n        if (!rt2)\n            rt2 = newnode(x);\n        else\n            tree[rt2].cnt++, tree[rt2].sz++;\n        merge(rt2, rt2, rt3);\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline void del(int val)\n    {\n        int rt1, rt2, rt3;\n        split_val(root, rt1, rt2, val);\n        split_val(rt1, rt1, rt3, val - 1);\n        assert(rt3 != 0);\n        tree[rt3].cnt--, tree[rt3].sz--;\n        if (!tree[rt3].cnt)\n            merge(rt3, tree[rt3].l, tree[rt3].r);\n        merge(rt1, rt1, rt3);\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline int rnk(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        merge(root, x, y);\n        return ans;\n    }\n    inline int kth(int root, int k)\n    {\n        int x = root;\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int kth(int k)\n    {\n        return kth(root, k);\n    }\n    inline int pre(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = kth(x, tree[x].sz);\n        merge(root, x, y);\n        return ans;\n    }\n    inline int suf(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val);\n        int ans = kth(y, 1);\n        merge(root, x, y);\n        return ans;\n    }\n};\nTreap tr;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.3 伸展树（Splay Tree）\n\n通过 **$Splay$/伸展操作** 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在均摊$O(logN)$​​时间内完成插入，查找和删除操作，并且保持平衡而不至于退化为链。\n\n每次操作之后，被操作数均在根节点。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 100005;\nint rt, tot, fa[N], ch[N][2], val[N], cnt[N], sz[N];\nstruct Splay\n{\n    void maintain(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x]; }\n\n    bool get(int x) { return x == ch[fa[x]][1]; }\n\n    void clear(int x)\n    {\n        ch[x][0] = ch[x][1] = fa[x] = val[x] = sz[x] = cnt[x] = 0;\n    }\n\n    void rotate(int x)\n    {\n        int y = fa[x], z = fa[y], chk = get(x);\n        ch[y][chk] = ch[x][chk ^ 1];\n        if (ch[x][chk ^ 1])\n            fa[ch[x][chk ^ 1]] = y;\n        ch[x][chk ^ 1] = y;\n        fa[y] = x;\n        fa[x] = z;\n        if (z)\n            ch[z][y == ch[z][1]] = x;\n        maintain(y);\n        maintain(x);\n    }\n\n    void splay(int x, int goal = 0)\n    {\n        if (goal == 0)\n            rt = x;\n        while (fa[x] != goal)\n        {\n            int f = fa[x], g = fa[fa[x]];\n            if (g != goal)\n            {\n                if (get(f) == get(x))\n                    rotate(f);\n                else\n                    rotate(x);\n            }\n            rotate(x);\n        }\n    }\n\n    void ins(int k)\n    {\n        if (!rt)\n        {\n            val[++tot] = k;\n            cnt[tot]++;\n            rt = tot;\n            maintain(rt);\n            return;\n        }\n        int cur = rt, f = 0;\n        while (1)\n        {\n            if (val[cur] == k)\n            {\n                cnt[cur]++;\n                maintain(cur);\n                maintain(f);\n                splay(cur);\n                break;\n            }\n            f = cur;\n            cur = ch[cur][val[cur] < k];\n            if (!cur)\n            {\n                val[++tot] = k;\n                cnt[tot]++;\n                fa[tot] = f;\n                ch[f][val[f] < k] = tot;\n                maintain(tot);\n                maintain(f);\n                splay(tot);\n                break;\n            }\n        }\n    }\n\n    int rk(int k)\n    {\n        int res = 0, cur = rt;\n        while (1)\n        {\n            if (k < val[cur])\n            {\n                cur = ch[cur][0];\n            }\n            else\n            {\n                res += sz[ch[cur][0]];\n                if (!cur)\n                    return res + 1;\n                if (k == val[cur])\n                {\n                    splay(cur);\n                    return res + 1;\n                }\n                res += cnt[cur];\n                cur = ch[cur][1];\n            }\n        }\n    }\n\n    int kth(int k)\n    {\n        int cur = rt;\n        while (1)\n        {\n            if (ch[cur][0] && k <= sz[ch[cur][0]])\n            {\n                cur = ch[cur][0];\n            }\n            else\n            {\n                k -= cnt[cur] + sz[ch[cur][0]];\n                if (k <= 0)\n                {\n                    splay(cur);\n                    return val[cur];\n                }\n                cur = ch[cur][1];\n            }\n        }\n    }\n    // 返回前驱结点根编号\n    int pre()\n    {\n        int cur = ch[rt][0];\n        if (!cur)\n            return cur;\n        while (ch[cur][1])\n            cur = ch[cur][1];\n        splay(cur);\n        return cur;\n    }\n    // 返回后继结点根编号\n    int nxt()\n    {\n        int cur = ch[rt][1];\n        if (!cur)\n            return cur;\n        while (ch[cur][0])\n            cur = ch[cur][0];\n        splay(cur);\n        return cur;\n    }\n\n    void del(int k)\n    {\n        rk(k);\n        if (cnt[rt] > 1)\n        {\n            cnt[rt]--;\n            maintain(rt);\n            return;\n        }\n        if (!ch[rt][0] && !ch[rt][1])\n        {\n            clear(rt);\n            rt = 0;\n            return;\n        }\n        if (!ch[rt][0])\n        {\n            int cur = rt;\n            rt = ch[rt][1];\n            fa[rt] = 0;\n            clear(cur);\n            return;\n        }\n        if (!ch[rt][1])\n        {\n            int cur = rt;\n            rt = ch[rt][0];\n            fa[rt] = 0;\n            clear(cur);\n            return;\n        }\n        int cur = rt;\n        int x = pre();\n        fa[ch[cur][1]] = x;\n        ch[x][1] = ch[cur][1];\n        clear(cur);\n        maintain(rt);\n    }\n} tree;\n\nint main()\n{\n    int n, opt, x;\n    for (scanf(\"%d\", &n); n; --n)\n    {\n        scanf(\"%d%d\", &opt, &x);\n        if (opt == 1)\n            tree.ins(x);\n        else if (opt == 2)\n            tree.del(x);\n        else if (opt == 3)\n            printf(\"%d\\n\", tree.rk(x));\n        else if (opt == 4)\n            printf(\"%d\\n\", tree.kth(x));\n        else if (opt == 5)\n            tree.ins(x), printf(\"%d\\n\", val[tree.pre()]), tree.del(x);\n        else\n            tree.ins(x), printf(\"%d\\n\", val[tree.nxt()]), tree.del(x);\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.2 文艺平衡树\n\n文艺平衡树，指借助平衡树中序遍历是从小到大的性质将其略作修改，用于***维护高级区间操作***行为（例如，***维护区间 $[l,r]$​ 翻转***），不支持一切传统平衡树操作。\n\n请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：\n\n| 编号 |     名称     |                             格式                             | 说明                                                         |\n| :--: | :----------: | :----------------------------------------------------------: | :----------------------------------------------------------- |\n|  1   |     插入     | $\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}$ | 在当前数列的第 $posi$ 个数字后插入 $tot$ 个数字：$c_1, c_2 \\cdots c_{tot}$；若在数列首插入，则 $posi$ 为 $0$ |\n|  2   |     删除     |             $\\operatorname{DELETE} \\ posi \\ tot$             | 从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字        |\n|  3   |     修改     |         $\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c$          | 从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字统一修改为 $c$ |\n|  4   |     翻转     |            $\\operatorname{REVERSE} \\ posi \\ tot$             | 取出从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字，翻转后放入原来的位置 |\n|  5   |     求和     |            $\\operatorname{GET-SUM} \\ posi \\ tot$             | 计算从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字的和并输出 |\n|  6   | 求最大子列和 |                   $\\operatorname{MAX-SUM}$                   | 求出当前数列中和最大的一段子列，并输出最大和                 |\n\n- 对于 $100\\%$ 的数据，任何时刻数列中最多含有 $5 \\times 10^5$ 个数，任何时刻数列中任何一个数字均在 $[-10^3, 10^3]$ 内，$1 \\le M \\le 2 \\times 10^4$，插入的数字总数不超过 $4 \\times 10^6$。\n\n#### 6.2.1 无旋Treap实现文艺平衡树\n\n懒标记和线段树的想法一样，这样处理不容易错。\n\n分裂要按`size`，交换是整个子树内的所有节点的$lson,rson$​全部交换，所以需要懒标记。交换儿子并不会影响堆的性质，所以不需要管。\n\n更复杂的懒标记一定要搞清楚。搞不清楚懒标记极其容易错且相当难以调试（因为树结构的随机性）\n\n这个题标记的坑点就在于子段长度非空，全负数就要输出最大的那个负数。所以维护区间中值（区间最大子段）的时候需要额外带一次`tree[rt].val`，详情见懒标记。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\n#define int long long\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int w;\n        int val;\n        int sz;\n        int lazytag;\n        int sum;\n        int maxsum;\n        int maxpresum;\n        int maxsufsum;\n        bool sametag;\n        int sames;\n        node() : l(0), r(0), w(0), val(0),\n                 sz(0), lazytag(0), sum(0), maxpresum(0), maxsufsum(0),\n                 sametag(0), sames(0), maxsum(0) {};\n        node(int val) : l(0), r(0), w(ran()), val(val),\n                        sz(1), lazytag(0), sum(val), maxpresum(max(val, 0ll)),\n                        maxsufsum(max(val, 0ll)), sametag(0), sames(0), maxsum(val) {};\n    };\n    const static int maxn = 5e5 + 9;\n    node tree[maxn];\n    int root;\n    queue<int> q;\n    inline void init()\n    {\n        for (int i = 1; i < maxn; i++)\n        {\n            q.push(i);\n        }\n    }\n    Treap() { init(); }\n    int newnode(int val)\n    {\n        int tot = q.front();\n        q.pop();\n        tree[tot] = node(val);\n        return tot;\n    }\n    void getrub(int rt)\n    {\n        if (!rt)\n            return;\n        getrub(tree[rt].l);\n        getrub(tree[rt].r);\n        q.push(rt);\n        tree[rt] = node();\n        return;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n\n        tree[rt].sum = tree[tree[rt].l].sum + tree[tree[rt].r].sum + tree[rt].val;\n\n        tree[rt].maxpresum = max(tree[tree[rt].l].maxpresum, tree[tree[rt].l].sum + tree[rt].val + tree[tree[rt].r].maxpresum);\n\n        tree[rt].maxsufsum = max(tree[tree[rt].r].maxsufsum, tree[tree[rt].r].sum + tree[rt].val + tree[tree[rt].l].maxsufsum);\n\n        tree[rt].maxsum = max(tree[rt].val, tree[tree[rt].l].maxsufsum + tree[rt].val + tree[tree[rt].r].maxpresum);\n\n        if (tree[rt].l)\n        {\n            tree[rt].maxsum = max(tree[rt].maxsum, tree[tree[rt].l].maxsum);\n        }\n        if (tree[rt].r)\n        {\n            tree[rt].maxsum = max(tree[rt].maxsum, tree[tree[rt].r].maxsum);\n        }\n\n        return;\n    }\n    void Reverse(int x)\n    {\n        if (!x)\n            return;\n        swap(tree[x].l, tree[x].r);\n        swap(tree[x].maxpresum, tree[x].maxsufsum);\n        tree[x].lazytag ^= 1;\n    }\n    void Cover(int rt, int ci)\n    {\n        tree[rt].val = tree[rt].sames = ci;\n        tree[rt].sum = tree[rt].sz * ci;\n        tree[rt].maxpresum = tree[rt].maxsufsum = max(0ll, tree[rt].sum);\n        tree[rt].maxsum = max(ci, tree[rt].sum);\n        tree[rt].sametag = 1;\n    }\n    void pushdown(int rt)\n    {\n        if (!rt)\n            return;\n        if (tree[rt].lazytag)\n        {\n            if (tree[rt].l)\n                Reverse(tree[rt].l);\n            if (tree[rt].r)\n                Reverse(tree[rt].r);\n            tree[rt].lazytag = 0;\n        }\n        if (tree[rt].sametag)\n        {\n            if (tree[rt].l)\n            {\n                Cover(tree[rt].l, tree[rt].sames);\n            }\n            if (tree[rt].r)\n            {\n                Cover(tree[rt].r, tree[rt].sames);\n            }\n            tree[rt].sametag = 0;\n            tree[rt].sames = 0;\n        }\n    }\n    void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        pushdown(rt);\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            l = rt;\n            split_sz(tree[rt].r, tree[rt].r, r, sz - (tree[tree[rt].l].sz + 1));\n        }\n        else\n        {\n            r = rt;\n            split_sz(tree[rt].l, l, tree[rt].l, sz);\n        }\n        pushup(rt);\n    }\n    void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        pushdown(l);\n        pushdown(r);\n        if (tree[l].w > tree[r].w) // 大根堆形式，小根堆换个号就行\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n    }\n    void insert(int pos, vector<int> &a)\n    {\n        int rt1, rt2;\n        split_sz(root, rt1, rt2, pos);\n        for (auto j : a)\n        {\n            merge(rt1, rt1, newnode(j));\n        }\n        merge(root, rt1, rt2);\n    }\n    void del(int pos, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt1, rt3, pos + tot - 1);\n        split_sz(rt1, rt1, rt2, pos - 1);\n        getrub(rt2);\n        merge(root, rt1, rt3);\n    }\n    void reverse(int l, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt2, rt3, l + tot - 1);\n        split_sz(rt2, rt1, rt2, l - 1);\n        Reverse(rt2);\n        merge(rt2, rt1, rt2);\n        merge(root, rt2, rt3);\n    }\n    int getsum(int pos, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt1, rt3, pos + tot - 1);\n        split_sz(rt1, rt1, rt2, pos - 1);\n        int ans = tree[rt2].sum;\n        merge(rt1, rt1, rt2);\n        merge(root, rt1, rt3);\n        return ans;\n    }\n    int getmaxsum()\n    {\n        return tree[root].maxsum;\n    }\n    void make_same(int l, int tot, int c)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt2, rt3, l + tot - 1);\n        split_sz(rt2, rt1, rt2, l - 1);\n        Cover(rt2, c);\n        merge(rt2, rt1, rt2);\n        merge(root, rt2, rt3);\n    }\n    void print(int rt)\n    {\n        if (!rt)\n            return;\n        pushdown(rt);\n        print(tree[rt].l);\n        cout << tree[rt].val << \" \";\n        print(tree[rt].r);\n    }\n    void print()\n    {\n        print(root);\n        cout << endl;\n        return;\n    }\n};\nTreap tr;\nsigned main()\n{\n    // freopen(\"data.in\", \"r\", stdin);\n    // freopen(\"data.out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (auto &i : a)\n        cin >> i;\n    tr.insert(0, a);\n    while (m--)\n    {\n        string s;\n        cin >> s;\n        if (s == \"GET-SUM\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            cout << tr.getsum(pos, cnt) << endl;\n        }\n        else if (s == \"MAX-SUM\")\n        {\n            cout << tr.getmaxsum() << endl;\n        }\n        else if (s == \"INSERT\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            vector<int> b(cnt);\n            for (auto &j : b)\n                cin >> j;\n            tr.insert(pos, b);\n        }\n        else if (s == \"DELETE\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            tr.del(pos, cnt);\n        }\n        else if (s == \"MAKE-SAME\")\n        {\n            int pos, tot, c;\n            cin >> pos >> tot >> c;\n            tr.make_same(pos, tot, c);\n        }\n        else\n        {\n            int pos, tot;\n            cin >> pos >> tot;\n            tr.reverse(pos, tot);\n        }\n        // tr.print();\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.3 可持久化平衡树\n\n如题，可持久化数据结构。\n\n需要注意一点，平衡树可持久化消耗无用内存更大，建议空间倍数`<<6`以上\n\n#### 6.3.1 可持久化无旋Treap\n\n和非可持久化无旋$Treap$​​几乎没有区别，小简单的差异出在`merge`和`split_val`函数上，每次要分裂或者要合并的时候都必须新开结点，将复制一份旧结点，以保证原先版本不被破坏。\n\n用于解决需要提供以下操作的数据结构（ **对于各个以往的历史版本** ）：\n\n\n1、 插入 $x$\n\n2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）\n\n\n3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）\n\n\n4、查询排名为 $x$ 的数\n\n\n5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）\n\n6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）\n\n**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**\n\n每个版本的编号即为操作的序号（版本$0$即为初始状态，空树）\n对于 $100\\%$ 的数据， $ 1 \\leq n \\leq 5 \\times  10^5 $ , $|x_i| \\leq {10}^9$，$0 \\le v_i < i$，$1\\le \\text{opt} \\le 6$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\nstruct Persistant_Treap\n{\n    struct node\n    {\n        int l, r;\n        int val;\n        int sz;\n        int cnt;\n        int w;\n        node() { l = r = val = sz = cnt = w = 0; };\n        node(int val) : l(0), r(0), val(val), sz(1), cnt(1), w(ran()) {}\n    };\n    int tot = 0;\n    const static int maxn = 5e5 + 9;\n    node tree[maxn << 6];\n    int vers[maxn];\n    int ver = 0;\n    int newnode(int val)\n    {\n        ++tot;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[rt].cnt + tree[tree[rt].l].sz + tree[tree[rt].r].sz;\n        return;\n    }\n    int merge(const int l, const int r)\n    {\n        if (!l || !r)\n            return l | r;\n        int newrt;\n        if (tree[l].w > tree[r].w)\n        {\n            newrt = ++tot;\n            tree[newrt] = tree[l];\n            tree[newrt].r = merge(tree[newrt].r, r);\n        }\n        else\n        {\n            newrt = ++tot;\n            tree[newrt] = tree[r];\n            tree[newrt].l = merge(l, tree[newrt].l);\n        }\n        pushup(newrt);\n        return newrt;\n    }\n    void split_val(int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        int newrt;\n        if (tree[rt].val <= val)\n        {\n            l = ++tot;\n            tree[l] = tree[rt];\n            split_val(tree[rt].r, tree[l].r, r, val);\n            pushup(l);\n        }\n        else\n        {\n            r = ++tot;\n            tree[r] = tree[rt];\n            split_val(tree[rt].l, l, tree[r].l, val);\n            pushup(r);\n        }\n    }\n    inline void insert(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_val(vers[ver], rt1, rt2, val - 1);\n        split_val(rt2, rt2, rt3, val);\n        if (!rt2)\n            rt2 = newnode(val);\n        else\n            tree[rt2].cnt++, tree[rt2].sz++;\n        rt2 = merge(rt2, rt3);\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline void del(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_val(vers[ver], rt1, rt2, val);\n        split_val(rt1, rt1, rt3, val - 1);\n        if (!rt3)\n            return;\n        tree[rt3].cnt--, tree[rt3].sz--;\n        if (!tree[rt3].cnt)\n            rt3 = merge(tree[rt3].l, tree[rt3].r);\n        rt1 = merge(rt1, rt3);\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline int rnk(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n    inline int kth(int v, int k) // 版本访问\n    {\n        vers[++ver] = vers[v];\n        int x = vers[ver];\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int _kth(int rt, int k) // 根访问，private\n    {\n        int x = rt;\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int pre(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val - 1);\n\n        int ans = -(INT_MAX);\n        if (x != 0)\n            ans = _kth(x, tree[x].sz);\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n    inline int suf(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val);\n        int ans = (INT_MAX);\n        if (y != 0)\n            ans = _kth(y, 1);\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n};\nPersistant_Treap tr;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int v, op, x;\n        cin >> v >> op >> x;\n        if (op == 1)\n        {\n            tr.insert(v, x);\n        }\n        else if (op == 2)\n        {\n            tr.del(v, x);\n        }\n        else if (op == 3)\n        {\n            cout << tr.rnk(v, x) << endl;\n        }\n        else if (op == 4)\n        {\n            cout << tr.kth(v, x) << endl;\n        }\n        else if (op == 5)\n        {\n            cout << tr.pre(v, x) << endl;\n        }\n        else\n            cout << tr.suf(v, x) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.3.2 可持久化文艺平衡树\n\n理论上，文艺平衡树可以干了线段树所能干的所有活儿，但是常数$SuperBig$。其存活意义主要在于区间翻转。\n\n维护一个序列，其中需要提供以下操作，要求强制在线（**对于各个以往的历史版本**）：\n\n1. 在第 $p$ 个数后插入数 $x$。\n2. 删除第 $p$ 个数。\n3. 翻转区间 $[l,r]$，例如原序列是 $\\{5,4,3,2,1\\}$，翻转区间 $[2,4]$ 后，结果是 $\\{5,2,3,4,1\\}$。\n4. 查询区间 $[l,r]$ 中所有数的和。\n\n**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 $4$ 即保持原版本无变化），新版本即编号为此次操作的序号。**\n\nemm,相当贴内存$(979MB/1GB)$，爆$\\color{red}MLE$​就看着办吧。\n\n注意，pushdown的时候也要新建立拷贝节点，记住，可持久化数据结构上只要涉及到改必须要新建节点。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\n#define i64 long long\nstruct Persistant_literary_Treap\n{\nprivate:\n    struct node\n    {\n        int l, r;\n        int w;\n        i64 sum;\n        i64 val;\n        bool lazy;\n        int sz;\n        node() { l = r = w = sum = val = sz = lazy = 0; };\n        node(i64 val) : l(0), r(0), w(ran()), sum(val), val(val), sz(1), lazy(0) {}\n    };\n    const static int maxn = 2e5 + 9;\n    node tree[maxn << 7];\n    int vers[maxn], ver = 0;\n    int tot = 0;\n    int newnode(i64 val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushdown(int rt)\n    {\n        if (!rt)\n            return;\n        if (!tree[rt].lazy)\n            return;\n        if (tree[rt].l) // 只要动结点那必须全部备份可持久化\n        {\n            int rl = ++tot;\n            tree[rl] = tree[tree[rt].l];\n            tree[rt].l = rl;\n        }\n        if (tree[rt].r)\n        {\n            int rr = ++tot;\n            tree[rr] = tree[tree[rt].r];\n            tree[rt].r = rr;\n        }\n        swap(tree[rt].l, tree[rt].r);\n        if (tree[rt].l)\n            tree[tree[rt].l].lazy ^= 1;\n        if (tree[rt].r)\n            tree[tree[rt].r].lazy ^= 1;\n        tree[rt].lazy = 0;\n        return;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n        tree[rt].sum = tree[tree[rt].l].sum + tree[tree[rt].r].sum + tree[rt].val;\n        return;\n    }\n    int merge(int l, int r)\n    {\n        if (!l || !r)\n            return l | r;\n        int nowrt = 0;\n        pushdown(l);\n        pushdown(r);\n        if (tree[l].w > tree[r].w)\n        {\n            nowrt = ++tot;\n            tree[nowrt] = tree[l];\n            tree[nowrt].r = merge(tree[nowrt].r, r);\n            pushup(nowrt);\n        }\n        else\n        {\n            nowrt = ++tot;\n            tree[nowrt] = tree[r];\n            tree[nowrt].l = merge(l, tree[nowrt].l);\n            pushup(nowrt);\n        }\n        return nowrt;\n    }\n    void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        pushdown(rt);\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            int newrt = ++tot;\n            tree[newrt] = tree[rt];\n            l = newrt;\n            split_sz(tree[rt].r, tree[newrt].r, r, sz - (tree[tree[newrt].l].sz + 1));\n            pushup(l);\n        }\n        else\n        {\n            int newrt = ++tot;\n            tree[newrt] = tree[rt];\n            r = newrt;\n            split_sz(tree[rt].l, l, tree[newrt].l, sz);\n            pushup(r);\n        }\n        return;\n    }\n\npublic:\n    inline void insert(int v, int k, i64 val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2;\n        split_sz(vers[ver], rt1, rt2, k);\n        rt1 = merge(rt1, newnode(val));\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline void del(int v, int k)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, k);\n        split_sz(rt1, rt1, rt2, k - 1);\n        vers[ver] = merge(rt1, rt3);\n        return;\n    }\n    inline i64 query(int v, int l, int r)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, r);\n        split_sz(rt1, rt1, rt2, l - 1);\n        i64 ans = tree[rt2].sum;\n        rt1 = merge(rt1, rt2);\n        vers[ver] = merge(rt1, rt3);\n        return ans;\n    }\n    inline void reverse(int v, int l, int r)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, r);\n        split_sz(rt1, rt1, rt2, l - 1);\n        tree[rt2].lazy ^= 1;\n        rt1 = merge(rt1, rt2);\n        vers[ver] = merge(rt1, rt3);\n        return;\n    }\n};\nPersistant_literary_Treap tr;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    i64 lastans = 0;\n    while (n--)\n    {\n        i64 v, op, p, x, l, r;\n        cin >> v >> op;\n        if (op == 1)\n        {\n            cin >> p >> x;\n            p ^= lastans;\n            x ^= lastans;\n            tr.insert(v, p, x);\n        }\n        else if (op == 2)\n        {\n            cin >> p;\n            p ^= lastans;\n            tr.del(v, p);\n        }\n        else if (op == 3)\n        {\n            cin >> l >> r;\n            l ^= lastans;\n            r ^= lastans;\n            tr.reverse(v, l, r);\n        }\n        else\n        {\n            cin >> l >> r;\n            l ^= lastans;\n            r ^= lastans;\n            lastans = tr.query(v, l, r);\n            cout << lastans << endl;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 7.树套树\n\n### 7.1 线段树套平衡树\n\n关键词：区间大型平衡树操作。\n\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n\n1. 查询 $k$ 在区间内的排名\n\n2. 查询区间内排名为 $k$ 的值\n\n3. 修改某一位置上的数值\n\n4. 查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，**若不存在输出 `-2147483647`**）\n\n5. 查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，**若不存在输出 `2147483647`**）\n\n$1\\le n,m\\le5\\times 10^4$，序列中的值在任何时刻 $\\in[0,10^8]$。\n\n**（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）**\n\n做法：\n\n每个线段树结点维护一个$Treap$平衡树，区间合并直接平衡树$Merge$​拿下。\n\n1. 查询排名：线段树查询，查询每个子区间内$(k-1)$的排名并求和，复杂度$O(logN)$\n2. 查询排名为$k$的数：这个没办法直接加法求，需要二分+操作1判断，复杂度$O(log^2N)$\n3. 修改：无话可说，复杂度$O(logN)$。\n4. 查询前驱：各区间查询前驱后取$max$，复杂度$O(logN)$。\n5. 查询后继：各区间查询后继后取$min$，复杂度$O(logN)$.\n\n复杂度上界$O(Nlog^3N)$。单纯修改+查询第$K$小树状主席树可以$O(Nlog^2N)$实现。\n\n### 7.2 树状数组+线段树\n\n关键词：主席树强化，差分动态开点线段树\n\n树状数组的差分性质使得主席树可以支持快速修改。\n\n见1.12\n\n<div style=\"page-break-after: always;\"></div>\n\n### *7.3 线段树套线段树\n\n关键词：二维区间修改、区间查询。\n\n见$OI-Wiki$手册，过于偏门。\n\n## 8. 静态树（树上差分；HLD/LLD，重链剖分、长链剖分）\n\n关键词：静态树区间操作，静态树序列化操作。\n\n#### 8.1 树上差分——静态树，静态树节点信息\n\n想操作、查询$u$到$v$节点的区间属性，可以通过树上差分到根操作实现，即结点$u$存储$u$到根的信息，$v$存储$v$到根的信息。\n\n查询的时候直接查询$u+v-lca_{u,v}-fa_{lca_{u,v}}$​即可。\n\n```cpp\n#include <bits/stdc++.h>//树上差分，树上一条链的区间和，from：[JLOI2014] 松鼠的新家\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=3*1e5+10;\nint n,u,v,vis[N],a[N],b[N];\nint fa[N][40],dep[N];\nvector<int>edge[N];\nvoid dfs(int x,int f){//lca预处理\n    dep[x]=dep[f]+1;\n    fa[x][0]=f;\n    for(auto i:edge[x])if(i!=f)dfs(i,x); \n}\nvoid sum(int x,int f){//统计点x的值\n    a[x]=b[x];\n    for(auto i:edge[x]){\n        if(i!=f){\n            sum(i,x);//此时已经统计了所有i的值了\n            a[x]+=a[i];\n        }\n    }\n}\nint lca(int x,int y){//lca\n    if(x==y)return x;\n    if(dep[x]<dep[y])swap(x,y);\n    for(int i=30;i>=0;i--)\n        if(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n    if(x==y)return x;\n    for(int i=30;i>=0;i--)\n        if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n    return fa[x][0];\n}\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>vis[i];\n    for(int i=1;i<=n-1;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int j=1;j<=30;j++)\n        for(int i=1;i<=n;i++)\n            fa[i][j]=fa[fa[i][j-1]][j-1];\n    for(int i=1;i<=n-1;i++){//点差分,一个点的差分数组的值就是这个点的值-所有其亲儿子的值\n    //对vis[i],vis[i+1]这两个点之间加一只需要如下步骤（四步），操作的是差分数组\n        b[vis[i]]++;\n        b[vis[i+1]]++;\n        b[lca(vis[i],vis[i+1])]--;\n        b[fa[lca(vis[i],vis[i+1])][0]]--;\n    }\n    sum(1,0);//遍历整棵树，推出原始权值\n    for(int i=2;i<=n;i++)a[vis[i]]--;//本题例外（因为我们把既作为起点又做为终点的点算了两次，现在把这些点的权值减一即可 ）\n    for(int i=1;i<=n;i++)cout<<a[i]<<endl;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n还有一个树上异或差分：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define lowbit(x) (x&-x)\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int N=1e6+10;\nint n,q,u,v,idx,s,w;\nint tree[N],a[N],dfn[N],dep[N],fa[N][21],siz[N];\nvector<int>edge[N];\n/*要求解决这样一个问题，满足以下两个操作：\n1.u到v的路径上所有值异或上k\n2.输出u到v上所有点的值\n解法：\n树上异或差分，1由异或的性质可以转化为四条链的操作，u->1，v->1，k->1，（k-fa）->1，但是可以简化，利用异或差分数组，一个点的值为这个点异或它的所有儿子节点，这样只需要修改u，v，k，k-fa四个点的值即可\n2单点查询，难度在于如何通过异或差分还原这个点的值，方法就是u异或以u为根的子树的所有点的异或差分数组，利用dfs序，子树内的所有点被维护成了一个区间，这样就变成了区间异或，就可以利用树状数组快速维护，对dfs序建立树状数组即可。\n//涉及知识点：异或、树状数组、dfs序、树上差分、异或前缀和、lca*/\nvoid dfs(int x,int f){\n    dep[x]=dep[f]+1;fa[x][0]=f;a[f]^=a[x],dfn[x]=++idx;\n    siz[x]=1;\n    for(auto i:edge[x]){\n        if(i!=f){\n            dfs(i,x);\n            siz[x]+=siz[i];\n        }\n    }\n}\nvoid add(int x,int k){//点x加上k\n    while(x<=n){\n        tree[x]^=k;//依次修改每个覆盖有x的区间的值\n        x+=lowbit(x);\n    }\n}\nint sum(int x){//处理0到x之间的前缀和\n    int cnt=0;\n    while(x>0){\n        cnt^=tree[x];\n        x-=lowbit(x);\n    }\n    return cnt;\n}\nint lca(int x,int y){\n    if(dep[x]>dep[y]) swap(x,y);//y的深度大，dep大\n    for (int i=20;i>=0;i-- ) \n        if(dep[x]<=dep[y]-(1<<i)) y=fa[y][i];\n    if(x==y) return x;\n    for (int i=20;i>=0;i-- ) \n        if(fa[x][i]!=fa[y][i]) \n            x=fa[x][i],y=fa[y][i];\n    return fa[x][0];\n}\nvoid change(int u,int v,int w){\n    int k=lca(u,v);\n    add(dfn[u],w);\n    add(dfn[v],w);\n    add(dfn[k],w);\n    if (fa[k][0]) add(dfn[fa[k][0]], w);\n}\nint get(int u){\n    return sum(dfn[u]+siz[u]-1)^sum(dfn[u]-1);\n}\nint check2(int u,int v){\n    vector<int>e;int flag=0;\n    if(dep[u]<dep[v])swap(u,v);\n    while(dep[u]>dep[v]){\n        e.push_back(get(u));\n        u=fa[u][0];\n    }\n    if(u==v)e.push_back(get(u));\n    else {\n        while(u!=v){\n            e.push_back(get(u));e.push_back(get(v));\n            u=fa[u][0];v=fa[v][0];\n        }\n        e.push_back(get(u));\n    }\n    sort(e.begin(),e.end());\n    for(int i=2;i<e.size();i++){\n        if(e[i-2]+e[i-1]>e[i])return 1;\n    }\n    return 0;\n}\nint find(int u,int v){\n    int k = lca(u, v);\n    if (dep[u] + dep[v] - 2 * dep[k] + 1 > 46) return 1;\n    else return check2(u,v);\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    for(int i=1;i<=n-1;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int j=1;j<=20;j++)\n        for(int i=1;i<=n;i++)\n            fa[i][j]=fa[fa[i][j-1]][j-1];\n    for(int i=1;i<=n;i++)add(dfn[i],a[i]);\n    for(int i=1;i<=q;i++){\n        cin>>s;\n        if(s==1){\n            cin>>u>>v>>w;\n            change(u,v,w);\n        }\n        else {\n            cin>>u>>v;\n            cout<<find(u,v);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 8.2 重链剖分——静态树，动态树节点信息\n\n一种以链节点数划分轻重以实现树节点编号化，将书上问题转移到区间操作实现。\n\n重链剖分保证每一颗子树中所有节点的编号必定是一段连续的序列$dfn$序号。\n\n重链剖分可以将树上的任意一条路径划分成不超过$logN$条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 $LCA$ 为链的一个端点)。\n\n重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。\n\n重链剖分复杂度是$O(n)$的，两次$dfs$实现，跳链求$lca$的实现是单次询问$O(logN)$​的。对于高节点数而低强度询问相当友好。\n\n这里默认是从$1$开始的\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 3e5 + 9;\nint father[maxn], sizes[maxn], hson[maxn], depth[maxn], top[maxn], ranks[maxn], dfn[maxn], cnt;\nint nxt[maxn << 1LL], head[maxn], to[maxn << 1LL], tot;\nvoid add(int u, int v)\n{\n    nxt[++tot] = head[u];\n    head[u] = tot;\n    to[tot] = v;\n}\nvoid add_edge(int u, int v)\n{\n    add(u, v);\n    add(v, u);\n}\nvoid dfs1(int pos)\n{\n    hson[pos] = -1;\n    sizes[pos] = 1;\n    for (int i = head[pos]; i; i = nxt[i])\n    {\n        if (!depth[to[i]])\n        {\n            depth[to[i]] = depth[pos] + 1;\n            father[to[i]] = pos;\n            dfs1(to[i]);\n            sizes[pos] += sizes[to[i]];\n            if (hson[pos] == -1 || sizes[to[i]] > sizes[hson[pos]])\n                hson[pos] = to[i];\n        }\n    }\n}\nvoid dfs2(int u, int tops)\n{\n    top[u] = tops;\n    dfn[u] = ++cnt;\n    ranks[cnt] = u;\n    if (hson[u] != -1)\n    {\n        dfs2(hson[u], tops);\n        for (int i = head[u]; i; i = nxt[i])\n        {\n            if (to[i] == father[u] || to[i] == hson[u])\n                continue;\n            dfs2(to[i], to[i]);\n        }\n    }\n}\nint n, m, r;\nint a[maxn];\nint lca(int u, int v)\n{\n    while (top[u] != top[v])\n    {\n        if (depth[top[u]] < depth[top[v]])\n            swap(u, v);\n        u = father[top[u]]; // 所在重链首低的向上跳\n    }\n    return depth[u] < depth[v] ? u : v;\n}\nvoid init()\n{\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    depth[r] = 1;\n    dfs1(r);\n    dfs2(r, r);\n    // cout << \"finished build\" << endl;\n    // cout << \"root  is\" << dfn[1] << endl;\n    /*for (int i = 1; i <= n; i++)\n        cout << dfn[i] << \" \";\n    cout << endl;\n    for (int i = 1; i <= n; i++)\n        cout << ranks[i] << \" \";\n    cout << endl;\n    for (int i = 1; i <= n; i++)\n        cout << top[i] << \" \";\n        */\n    return;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 8.3长链剖分——仅深度维度线性优化动态规划\n\n长链剖分的实现方式和重链剖分很像，只不过重儿子被定义为了链长度最长的那一个，sz维护的是所属最长链的长度。\n\n长链剖分跳链的时空复杂度最大是$O(N\\sqrt N)$的，这个道理显而易见。\n\n长链剖分可以做到线性时间的优化树上和深度有关的$dp$。长链剖分后，在维护信息的过程中，先 $O(1)$ 继承重儿子的信息，再暴力合并其余轻儿子的信息。\n\n示例：\n\n给定一棵以 $1$ 为根，$n$ 个节点的树。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。\n\n对于每个点，求一个最小的 $k$，使得 $d(u,k)$ 最大。$1≤n≤10^6$\n\n正常分析的话，设$f_{u,i}$表示在$u$子树中距离$u$距离为$i$的节点数，那么这个方程有：\n$$\nf_{u,i}=\\sum f_{v,i-1}\n$$\n纯暴力转移，深度维度是$O(n)$，总复杂度$O(n^2)$​，无法承受。\n\n考虑树链剖分优化，对于$u$，直接继承其重儿子的$dp$数组，并在数组前头插入一个$1$元素表示$dp_{u,0}=1$，指根节点自己。\n\n然后剩下的轻儿子的暴力向重儿子合并就可以了。时间复杂度$O(2n)$​，线性通过，因为每个子树节点的vector最多存放深度多个元素，总元素数虽多$O(n)$，而不是暴力那样所有的全部开，没有的也开了。\n\n关于直接继承重儿子信息，使用`vector`的`swap`函数显然比写指针更简单易懂。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std; \nconst int N=1e6+5;\nint n,x,y,cnt,hd[N],to[N<<1],nxt[N<<1],len[N],son[N],ans[N];\nvector<int>f[N];    //这里的 vector 是倒序存储的，因为要在继承重儿子的信息后，要将当前节点的 DP 数组最前面插入一个元素，而 push_back 的复杂度优于 pop_front，倒序存储就可以直接使用 push_back \nvoid add(int x,int y){\n    to[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;\n}\nint get(int x,int id){    //由于 vector 是倒序存储的，此处将 vector 正序存储的位置转化为倒序存储的位置 \n    return len[x]-id-1;\n}\nvoid dfs1(int x,int fa){\n    for(int i=hd[x];i;i=nxt[i]){\n        int y=to[i];\n        if(y==fa) continue;\n        dfs1(y,x);\n        if(len[y]>len[son[x]]) son[x]=y;\n    }\n    len[x]=len[son[x]]+1;\n}\nvoid dfs2(int x,int fa){\n    if(son[x]) dfs2(son[x],x),swap(f[x],f[son[x]]),ans[x]=ans[son[x]]+1;    //继承重儿子的信息。这里的继承直接用 swap 而不是复制，swap 在时间和空间上都更优（swap 交换 vector 的时间复杂度为 O(1)）。 \n    f[x].push_back(1);    //push_back 的复杂度优于 pop_front\n    for(int i=hd[x];i;i=nxt[i]){\n        int y=to[i];\n        if(y==fa||y==son[x]) continue;\n        dfs2(y,x);\n        for(int j=1;j<=len[y];j++){\n            f[x][get(x,j)]+=f[y][get(y,j-1)];    //暴力合并轻儿子的信息 \n            if(f[x][get(x,j)]>f[x][get(x,ans[x])]||(f[x][get(x,j)]==f[x][get(x,ans[x])]&&j<ans[x])) ans[x]=j;    //更新答案\n        }\n    }\n    if(f[x][get(x,ans[x])]==1) ans[x]=0;    //f[x][0]=1,f[x][ans[x]]=1，0 显然更优\n}\nsigned main(){\n    scanf(\"%lld\",&n);\n    for(int i=1;i<n;i++){\n        scanf(\"%lld%lld\",&x,&y);\n        add(x,y),add(y,x);\n    }\n    dfs1(1,0),dfs2(1,0);\n    for(int i=1;i<=n;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 9. 动态树 （LCT/Link-Cut Tree，实链剖分）\n\n关键词：动态树，修改树结构后树上区间操作、序列化操作。\n\n***注意，序列上的跳跃同样可以视作一棵树来解决问题***\n\n维护一个 **森林**，支持删除某条边，加入某条边，并保证加边，删边之后仍是森林。我们要维护这个森林的一些信息。\n\n一般的操作有两点连通性，两点路径权值和，连接两点和切断某条边、修改信息等。\n\n核心思想是我要谁我就把谁转到实链上面，其他的都是虚链。\n\n$LCT$的辅助树性质：\n\n1. 辅助树由多棵 $Splay$ 组成，每棵 $Splay$ 维护原树中的一条路径，且中序遍历这棵 $Splay$ 得到的点序列，从前到后对应原树「从上到下」的一条路径。\n2. 原树每个节点与辅助树的 $Splay$ 节点一一对应。\n3. 辅助树的各棵 $Splay$ 之间并不是独立的。每棵 $Splay$ 的根节点的父亲节点本应是空，但在 $LCT$ 中每棵 $Splay$ 的根节点的父亲节点指向原树中 **这条链** 的父亲节点（即链最顶端的点的父亲节点）。这类父亲链接与通常 $Splay$ 的父亲链接区别在于儿子认父亲，而父亲不认儿子，对应原树的一条 **虚边**。因此，每个连通块恰好有一个点的父亲节点为空。\n4. 由于辅助树的以上性质，我们维护任何操作都不需要维护原树，辅助树可以在任何情况下拿出一个唯一的原树，我们只需要维护辅助树即可。\n\n示例：\n\n给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  \n\n操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。\n\n\n- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。\n- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。\n- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。\n- `3 x y` 代表将点 $x$ 上的权值变成 $y$。\n\n保证：\n- $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。\n- 对于操作 $0, 1, 2$，保证 $1 \\leq x, y \\leq n$。\n- 对于操作 $3$，保证 $1 \\leq x \\leq n$，$1 \\leq y \\leq 10^9$。\n\n```cpp\n// LCT，动态树、实链剖分\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int ch[2];\n#define l ch[0]\n#define r ch[1]\n    int val = 0;\n    int sum = 0;\n    // int lazytag = 0;\n    // int sz = 1;\n    int revtag = 0;\n    int fa = 0;\n};\nconst int maxn = 5e5 + 9;\nnode tr[maxn];\nvoid reverse(int x)\n{\n    tr[x].revtag ^= 1;\n    return;\n}\nbool get(int x) // 获取x是父亲节点的哪个儿子\n{\n    return tr[tr[x].fa].r == x;\n}\nbool isroot(int x) // 判断x结点是否作为一棵动态Splay的根\n{\n    return tr[tr[x].fa].l != x && tr[tr[x].fa].r != x;\n}\nvoid pushup(int rt) // 更新结点信息\n{\n    // other pushups;\n    // tr[rt].sz = tr[tr[rt].l].sz + tr[tr[rt].r].sz + 1;\n    tr[rt].sum = tr[tr[rt].l].sum ^ tr[tr[rt].r].sum ^ tr[rt].val;\n    return;\n}\nvoid pushdown(int x) // 树上懒标记，文艺平衡树标记是刚需求\n{\n    if (tr[x].revtag)\n    {\n        swap(tr[x].l, tr[x].r);\n        if (tr[x].l)\n            reverse(tr[x].l);\n        if (tr[x].r)\n            reverse(tr[x].r);\n        tr[x].revtag = 0;\n    }\n}\nvoid update(int x) // 动x之前结算x所在根的所有lazytag\n{\n    if (!isroot(x))\n    {\n        update(tr[x].fa);\n    }\n    pushdown(x);\n    return;\n}\nvoid rotate(int x)\n{\n    int y = tr[x].fa, z = tr[y].fa, k = get(x);\n    if (!isroot(y))\n        tr[z].ch[tr[z].r == y] = x;\n    // 上面这句一定要写在前面，普通的 Splay 是不用的，因为 isRoot  (后面会讲)\n    tr[x].fa = z;\n    tr[y].ch[k] = tr[x].ch[!k];\n    tr[tr[x].ch[!k]].fa = y;\n    tr[x].ch[!k] = y;\n    tr[y].fa = x;\n    pushup(y), pushup(x);\n}\nvoid Splay(int x) // 伸展操作，将结点伸展到根。\n{\n    update(x);\n    for (int fa; fa = tr[x].fa, !isroot(x); rotate(x))\n    {\n        if (!isroot(fa))\n            rotate(get(fa) == get(x) ? fa : x);\n    }\n}\nint access(int x) // 拉直从x到当前动态树根节点的实边路径，返回该路径终点的Splay的根（即路径终点）\n{\n    int p;\n    for (p = 0; x; p = x, x = tr[x].fa)\n    {\n        Splay(x);\n        tr[x].r = p;\n        pushup(x);\n    }\n    return p;\n}\nvoid makeroot(int x) // 换根操作，指定x结点成为原树（非辅助树）的总根\n{\n    access(x);  // 拉出x到当前根的路径，x必然是此时所在Splay中中序遍历的最后一个点\n    Splay(x);   // 旋根，根据LCT-Splay定义，这棵Splay必定没有右儿子\n    reverse(x); // 直接翻转Splay，迫使其成为当前Splay中序遍历第一个访问的点，成为深度最浅的根，实现了换跟\n    return;\n}\nint find(int p) // 找结点p在原森林所属树（非辅助Splay森林树）的树根\n{\n    access(p);\n    Splay(p);\n    pushdown(p);\n    while (tr[p].l)\n        p = tr[p].l, pushdown(p);\n    Splay(p);\n    return p;\n}\nbool link(int x, int y) // 连一条x->y的轻边\n{\n    makeroot(x);\n    if (find(y) == x)\n        return 0;\n    tr[x].fa = y;\n    return 1;\n}\nbool cut(int x, int y)\n{\n    makeroot(x);\n    if (find(y) != x || tr[y].fa != x || tr[y].l)\n        return 0;\n    tr[y].fa = tr[x].r = 0; // x在findroot(y)后被转到了根\n    pushup(x);\n    return 1;\n}\nvoid split(int x, int y) // 动态树中拆出来一条x->y指定路径，保证路径上都是实边,保证y在根。\n{\n    makeroot(x);\n    access(y);\n    Splay(y);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        int v;\n        cin >> v;\n        tr[i].val = v;\n        tr[i].sum = v;\n    }\n    while (m--)\n    {\n        int op, x, y;\n        cin >> op >> x >> y;\n        if (op == 0)\n        {\n            split(x, y);\n            cout << tr[y].sum << endl;\n        }\n        else if (op == 1)\n        {\n            link(x, y);\n        }\n        else if (op == 2)\n        {\n            cut(x, y);\n        }\n        else\n        {\n            Splay(x); // 节点修改转到根再改，不会影响其他信息\n            tr[x].val = y;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 10. 01Trie\n\n关于字典树Trie的内容，详见$Part\\ 2$.\n\n### 10.1 01Trie\n\n01字典树。写法参见可持久化，没啥区别。\n\n`tr[rt].cnt`存储的是从当前节点数位出发还有多少个数字，根节点就是数字的总个数。\n\n### 10.2 可持久化01Trie\n\n维护区间异或最大值或者区间第$K$大值。区间第$K$大值类似于主席树树上二分。\n\n示例：（区间最大值）\n\n给定一个非负整数序列 $\\{a\\}$，初始长度为 $N$。  \n\n有 $M$ 个操作，有以下两种操作类型：  \n\n1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  \n2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ 最大，输出最大值。\n\n- 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Present_Trie\n{\nprivate:\n    struct node\n    {\n        int nxt[2];\n        int cnt = 0;\n    };\n    vector<node> tr;\n    int tot = 0;\n    int n;\n\npublic:\n    void init(int n)\n    {\n        this->n = n;\n        tr.resize(n << 5);\n    }\n    int newroot()\n    {\n        return ++tot;\n    }\n    void insert(int rt1, int rt2, int x)\n    {\n        for (int i = 30; i >= 0; i--)\n        {\n            int bit = (x >> i) & 1;\n            if (bit)\n            {\n                if (!tr[rt2].nxt[1])\n                {\n                    tr[rt2].nxt[1] = ++tot;\n                }\n                tr[rt2].nxt[0] = tr[rt1].nxt[0];\n                rt1 = tr[rt1].nxt[1];\n                rt2 = tr[rt2].nxt[1];\n            }\n            else\n            {\n                if (!tr[rt2].nxt[0])\n                {\n                    tr[rt2].nxt[0] = ++tot;\n                }\n                tr[rt2].nxt[1] = tr[rt1].nxt[1];\n                rt1 = tr[rt1].nxt[0];\n                rt2 = tr[rt2].nxt[0];\n            }\n            tr[rt2].cnt = tr[rt1].cnt + 1;\n        }\n    }\n    int query(int rt1, int rt2, int x)\n    {\n        int ret = 0;\n        for (int i = 30; i >= 0; i--)\n        {\n            int bit = (x >> i) & 1;\n            if (tr[tr[rt2].nxt[bit ^ 1]].cnt - tr[tr[rt1].nxt[bit ^ 1]].cnt > 0)\n            {\n                ret |= (1 << i);\n                rt1 = tr[rt1].nxt[bit ^ 1];\n                rt2 = tr[rt2].nxt[bit ^ 1];\n            }\n            else\n            {\n                rt1 = tr[rt1].nxt[bit];\n                rt2 = tr[rt2].nxt[bit];\n            }\n        }\n        return ret;\n    }\n};\nPresent_Trie pt;\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> root(n + 1);\n    pt.init(1e6 + 9);\n    int calc = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        calc ^= x;\n        root[i] = pt.newroot();\n        pt.insert(root[i - 1], root[i], calc);\n    }\n    while (q--)\n    {\n        char c;\n        int l, r, x;\n        cin >> c;\n        if (c == 'Q')\n        {\n            cin >> l >> r >> x;\n            l--, r--;\n            if (l == 0)\n            {\n                cout << max(x ^ calc, pt.query(root[l], root[r], x ^ calc)) << endl;\n            }\n            else\n            {\n                cout << pt.query(root[l - 1], root[r], x ^ calc) << endl;\n            }\n        }\n        else if (c == 'A')\n        {\n            cin >> x;\n            calc ^= x;\n            root.emplace_back(pt.newroot());\n            n++;\n            pt.insert(root[n - 1], root[n], calc);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 11.单调栈\n\n单调栈，可以维护一个单调的序列，使得每一个元素进栈的时候，所有比这个元素小的栈内元素均会被其消除或者融合，比他大的栈内元素不会与其消除或者融合。最典型的例子就是维护某个数最左侧和最右侧第一个比其大的数。但是单调栈并不局限于此：\n\n给定一个长度为 $m$ 的数组 $b$ 。您可以执行以下任意次操作（可能是零次）：\n\n- 选择两个不同的索引 $i$ 和 $j$ ，其中 $\\bf{1\\le i < j\\le m}$ 和 $b_i$ 为偶数，将 $b_i$ 除以 $2$ ，并将 $b_j$ 乘以 $2$ 。\n\n您的任务是在执行任意数量的此类操作后最大化数组的总和。由于它可能很大，请输出此总和模数 $10^9+7$ 。\n\n由于这道题太简单了，给你一个长度为 $n$ 的数组 $a$ ，你需要对 $a$ 的每个前缀进行求解。\n\n换句话说，表示在执行任意数量的 $f(b)$ 等运算后 $b$ 的最大和，你需要分别输出 $f([a_1])$ 、 $f([a_1,a_2])$ 、 $\\ldots$ 、 $f([a_1,a_2,\\ldots,a_n])$ 模数 $10^9+7$ 。\n\n不难考虑到每个数新加进序列的时候，所有比这个数小的底数（除尽2以后的数）所包含2的个数都要加到新数字上。很像一个线段树区间查，但是这会存在一个问题：\n\n样例： 18 2 7\n\n新加入的7显然查不到9底上的一个2，但是14可以查到。线段树最坏复杂度是$nlog^2n$的。（实际上根据运算特性分析，能够卡满$log^2n$单次询问的情况最多只有$logn$次，所以真实实际复杂度为$nlogn+log^3n\\rightarrow nlogn$的复杂度）\n\n所以，比当前数小的均可以合并，比当前数大的均无法合并，符合单调栈定义：\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    mint tmpsum = 0;\n    vector<i64> a(n + 1);\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    stack<pair<i64, i64>> st;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = 0;\n        while (a[i] % 2 == 0)\n        {\n            k++;\n            a[i] >>= 1;\n        }\n        while (!st.empty() && (k >= 30 || (a[i] << k) > st.top().first))\n        {\n            auto [num, cnt] = st.top();\n            st.pop();\n            tmpsum -= power(mint(2), cnt) * num;\n            tmpsum += num;\n            k += cnt;\n        }\n        st.push({a[i], k});\n        tmpsum += mint(a[i]) * power(mint(2), k);\n        cout << tmpsum << \" \";\n    }\n    cout << endl;\n    return;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 2. 数学\n\n### 0. Modint.h\n\n```cpp\n#ifndef __MODINT_H__\n\n#define __MODINT_H__\n\nusing i64 = long long;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nnamespace Modint\n{\n    template <class T>\n    constexpr T power(T a, i64 b)\n    {\n        T res = 1;\n        for (; b; b /= 2, a *= a)\n        {\n            if (b % 2)\n            {\n                res *= a;\n            }\n        }\n        return res;\n    }\n\n    constexpr i64 mul(i64 a, i64 b, i64 p)\n    {\n        i64 res = a * b - (i64)(1.L * a * b / p) * p;\n        res %= p;\n        if (res < 0)\n        {\n            res += p;\n        }\n        return res;\n    }\n    /*\n     * @brief 模运算（i64），jiangly版本，支持动态模数改变\n     * @param P 模数，仅支持质数。如果选择动态定义模数，P=0，且必须调用setMod函数设置模数。默认为1e18+9\n     */\n    template <i64 P>\n    struct MLong\n    {\n        i64 x;\n        constexpr MLong() : x{} {}\n        constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n\n        static i64 Mod;\n        constexpr static i64 getMod()\n        {\n            if (P > 0)\n            {\n                return P;\n            }\n            else\n            {\n                return Mod;\n            }\n        }\n        constexpr static void setMod(i64 Mod_)\n        {\n            Mod = Mod_;\n        }\n        constexpr i64 norm(i64 x) const\n        {\n            if (x < 0)\n            {\n                x += getMod();\n            }\n            if (x >= getMod())\n            {\n                x -= getMod();\n            }\n            return x;\n        }\n        constexpr i64 val() const\n        {\n            return x;\n        }\n        explicit constexpr operator i64() const\n        {\n            return x;\n        }\n        constexpr MLong operator-() const\n        {\n            MLong res;\n            res.x = norm(getMod() - x);\n            return res;\n        }\n        constexpr MLong inv() const\n        {\n            assert(x != 0);\n            return power(*this, getMod() - 2);\n        }\n        constexpr MLong &operator*=(MLong rhs) &\n        {\n            x = mul(x, rhs.x, getMod());\n            return *this;\n        }\n        constexpr MLong &operator+=(MLong rhs) &\n        {\n            x = norm(x + rhs.x);\n            return *this;\n        }\n        constexpr MLong &operator-=(MLong rhs) &\n        {\n            x = norm(x - rhs.x);\n            return *this;\n        }\n        constexpr MLong &operator/=(MLong rhs) &\n        {\n            return *this *= rhs.inv();\n        }\n        friend constexpr MLong operator*(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res *= rhs;\n            return res;\n        }\n        friend constexpr MLong operator+(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res += rhs;\n            return res;\n        }\n        friend constexpr MLong operator-(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res -= rhs;\n            return res;\n        }\n        friend constexpr MLong operator/(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res /= rhs;\n            return res;\n        }\n        friend constexpr std::istream &operator>>(std::istream &is, MLong &a)\n        {\n            i64 v;\n            is >> v;\n            a = MLong(v);\n            return is;\n        }\n        friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a)\n        {\n            return os << a.val();\n        }\n        friend constexpr bool operator==(MLong lhs, MLong rhs)\n        {\n            return lhs.val() == rhs.val();\n        }\n        friend constexpr bool operator!=(MLong lhs, MLong rhs)\n        {\n            return lhs.val() != rhs.val();\n        }\n    };\n\n    template <>\n    i64 MLong<0LL>::Mod = (i64)(1E18) + 9;\n\n    /*template <i64 V, i64 P>\n    constexpr MLong<P> CInv = MLong<P>(V).inv();*/\n\n    /*\n     * @brief 模运算（int），jiangly版本，支持动态模数改变\n     * @param P 模数，仅支持质数。如果选择动态定义模数，P=0，且必须调用setMod函数设置模数。默认为998244353\n     */\n    template <int P>\n    struct MInt\n    {\n        int x;\n        constexpr MInt() : x{} {}\n        constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n\n        static int Mod;\n        constexpr static int getMod()\n        {\n            if (P > 0)\n            {\n                return P;\n            }\n            else\n            {\n                return Mod;\n            }\n        }\n        constexpr static void setMod(int Mod_)\n        {\n            Mod = Mod_;\n        }\n        constexpr int norm(int x) const\n        {\n            if (x < 0)\n            {\n                x += getMod();\n            }\n            if (x >= getMod())\n            {\n                x -= getMod();\n            }\n            return x;\n        }\n        constexpr int val() const\n        {\n            return x;\n        }\n        explicit constexpr operator int() const\n        {\n            return x;\n        }\n        constexpr MInt operator-() const\n        {\n            MInt res;\n            res.x = norm(getMod() - x);\n            return res;\n        }\n        constexpr MInt inv() const\n        {\n            assert(x != 0);\n            return power(*this, getMod() - 2);\n        }\n        constexpr MInt &operator*=(MInt rhs) &\n        {\n            x = 1LL * x * rhs.x % getMod();\n            return *this;\n        }\n        constexpr MInt &operator+=(MInt rhs) &\n        {\n            x = norm(x + rhs.x);\n            return *this;\n        }\n        constexpr MInt &operator-=(MInt rhs) &\n        {\n            x = norm(x - rhs.x);\n            return *this;\n        }\n        constexpr MInt &operator/=(MInt rhs) &\n        {\n            return *this *= rhs.inv();\n        }\n        friend constexpr MInt operator*(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res *= rhs;\n            return res;\n        }\n        friend constexpr MInt operator+(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res += rhs;\n            return res;\n        }\n        friend constexpr MInt operator-(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res -= rhs;\n            return res;\n        }\n        friend constexpr MInt operator/(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res /= rhs;\n            return res;\n        }\n        friend constexpr std::istream &operator>>(std::istream &is, MInt &a)\n        {\n            i64 v;\n            is >> v;\n            a = MInt(v);\n            return is;\n        }\n        friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a)\n        {\n            return os << a.val();\n        }\n        friend constexpr bool operator==(MInt lhs, MInt rhs)\n        {\n            return lhs.val() == rhs.val();\n        }\n        friend constexpr bool operator!=(MInt lhs, MInt rhs)\n        {\n            return lhs.val() != rhs.val();\n        }\n    };\n\n    template <>\n    int MInt<0>::Mod = 998244353;\n\n    // 逆元\n    template <int V, int P>\n    constexpr MInt<P> CInv = MInt<P>(V).inv();\n    /*\n     * @brief 阶乘类(适配Jiangly模板），支持计算组合数，排列数等操作，复杂度O(n),配套jiangly版本的模运算类\n     * @brief 小数据时需要组合数建议使用组合数表（杨辉三角），大数据时需要组合数建议使用Lucas定理\n     * @param MOD 模数，一般取质数，部分合数情况下可能没有逆元。\n     * @note 支持计算组合数，可以使用C(n,k)计算组合数。\n     * @note 支持计算排列数，可以使用A(n,k)计算排列数。\n     */\n    template <class T>\n    struct Fact\n    {\n        std::vector<T> fact, factinv;\n        const int n;\n        Fact(const int &_n) : n(_n), fact(_n + 1, 1), factinv(_n + 1)\n        {\n            for (int i = 1; i <= n; ++i)\n                fact[i] = fact[i - 1] * i;\n            factinv[n] = fact[n].inv();\n            for (int i = n; i; --i)\n                factinv[i - 1] = factinv[i] * i;\n        }\n        T C(const int &n, const int &k)\n        {\n            if (n < 0 || k < 0 || n < k)\n                return 0;\n            return fact[n] * factinv[k] * factinv[n - k];\n        }\n        T A(const int &n, const int &k)\n        {\n            if (n < 0 || k < 0 || n < k)\n                return 0;\n            return fact[n] * factinv[n - k];\n        }\n    };\n};\n\n#endif //__MODINT_H__\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1. 数论相关\n\n#### 1.1 大质数判定（Miller-Rabin素性测试）\n\n以$O(logN)$复杂度，以较高正确性判定质数。\n\n```cpp\n#define i64 long long\n    i64 mul(i64 a, i64 b, i64 m)\n    {\n        return static_cast<__int128>(a) * b % m;\n    }\n    i64 power(i64 a, i64 b, i64 m)\n    {\n        i64 res = 1 % m;\n        for (; b; b >>= 1, a = mul(a, a, m))\n            if (b & 1)\n                res = mul(res, a, m);\n        return res;\n    }\n    /* @brief Miller-Rabin 素性测试,时间复杂度为 O(log n)\n     * @param n 待测试的数，不大于 1e18\n     * @return true 为素数，false 为合数*/\n    bool isprime(i64 n)\n    {\n        if (n < 2)\n            return false;\n        static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n        int s = __builtin_ctzll(n - 1);\n        i64 d = (n - 1) >> s;\n        for (auto a : A)\n        {\n            if (a == n)\n                return true;\n            i64 x = power(a, d, n);\n            if (x == 1 || x == n - 1)\n                continue;\n            bool ok = false;\n            for (int i = 0; i < s - 1; ++i)\n            {\n                x = mul(x, x, n);\n                if (x == n - 1)\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n        return true;\n    }\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.2 质因数分解\n\n##### 1.2.1  小数字质因数分解\n\n以$O(N\\sqrt N)$复杂度分解质因数。\n\n```cpp\nvector<int> breakdown(int N) {\n  vector<int> result;\n  for (int i = 2; i * i <= N; i++) {\n    if (N % i == 0) {  // 如果 i 能够整除 N，说明 i 为 N 的一个质因子。\n      while (N % i == 0) N /= i;\n      result.push_back(i);\n    }\n  }\n  if (N != 1) {  // 说明再经过操作之后 N 留下了一个素数\n    result.push_back(N);\n  }\n  return result;\n}\n```\n\n##### 1.2.2 大质数质因数分解（Pollar-Rho算法）\n\n以期望复杂度$O(N^{\\frac{1}{4}})$复杂度分解质因数。\n\n```cpp\nnamespace Prime\n{\nusing i64=long long;\n    i64 mul(i64 a, i64 b, i64 m)\n    {\n        return static_cast<__int128>(a) * b % m;\n    }\n    i64 power(i64 a, i64 b, i64 m)\n    {\n        i64 res = 1 % m;\n        for (; b; b >>= 1, a = mul(a, a, m))\n            if (b & 1)\n                res = mul(res, a, m);\n        return res;\n    }\n    /* @brief Miller-Rabin 素性测试,时间复杂度为 O(log n)\n     * @param n 待测试的数，不大于 1e18\n     * @return true 为素数，false 为合数\n     */\n    bool isprime(i64 n)\n    {\n        if (n < 2)\n            return false;\n        static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n        int s = __builtin_ctzll(n - 1);\n        i64 d = (n - 1) >> s;\n        for (auto a : A)\n        {\n            if (a == n)\n                return true;\n            i64 x = power(a, d, n);\n            if (x == 1 || x == n - 1)\n                continue;\n            bool ok = false;\n            for (int i = 0; i < s - 1; ++i)\n            {\n                x = mul(x, x, n);\n                if (x == n - 1)\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n        return true;\n    }\n    /* @brief 素因子分解（Pollard-Rho 算法）,时间复杂度期望为 O(n^(1/4))，最坏为 O(n^(1/2))，本函数复杂度带排序，具体复杂度待定，可估算为亚线性\n     * @param n 待分解的数，不大于 1e18\n     * @return 一个 vector，包含了 n 的所有素因子，按照从小到大的顺序排列，包括重复的\n     */\n    std::vector<i64> factorize(i64 n)\n    {\n        std::vector<i64> p;\n        std::function<void(i64)> f = [&](i64 n)\n        {\n            if (n <= 10000)\n            {\n                for (int i = 2; i * i <= n; ++i)\n                    for (; n % i == 0; n /= i)\n                        p.push_back(i);\n                if (n > 1)\n                    p.push_back(n);\n                return;\n            }\n            if (isprime(n))\n            {\n                p.push_back(n);\n                return;\n            }\n            auto g = [&](i64 x)\n            {\n                return (mul(x, x, n) + 1) % n;\n            };\n            i64 x0 = 2;\n            while (true)\n            {\n                i64 x = x0;\n                i64 y = x0;\n                i64 d = 1;\n                i64 power = 1, lam = 0;\n                i64 v = 1;\n                while (d == 1)\n                {\n                    y = g(y);\n                    ++lam;\n                    v = mul(v, std::abs(x - y), n);\n                    if (lam % 127 == 0)\n                    {\n                        d = std::gcd(v, n);\n                        v = 1;\n                    }\n\n                    if (power == lam)\n                    {\n                        x = y;\n                        power *= 2;\n                        lam = 0;\n                        d = std::gcd(v, n);\n                        v = 1;\n                    }\n                }\n                if (d != n)\n                {\n                    f(d);\n                    f(n / d);\n                    return;\n                }\n                ++x0;\n            }\n        };\n        f(n);\n        std::sort(p.begin(), p.end());\n        return p;\n    }\n    /*\n     * @brief 素因子分解（Pollard-Rho 算法）\n     * @param n 待分解的数，不大于 1e18\n     * @return 一个 vector，包含了 n 的所有素因子，按照从小到大的顺序排列，first 为素因子，second 为指数\n     */\n    std::vector<std::pair<i64, i64>> factorize_pairs(i64 n)\n    {\n        std::vector<i64> p = factorize(n);\n        std::vector<std::pair<i64, i64>> res;\n        for (auto i : p)\n        {\n            if (res.empty() || res.back().first != i)\n                res.emplace_back(i, 1);\n            else\n                res.back().second++;\n        }\n        return res;\n    }\n    void dfs(int p, i64 n, std::vector<std::pair<i64, i64>> &ps, std::vector<i64> &ds)\n    {\n        if (p == ps.size())\n        {\n            if (n > 1)\n            {\n                ds.push_back(n);\n            }\n            return;\n        }\n        for (i64 i = 0; i <= ps[p].second; i++)\n        {\n            dfs(p + 1, n, ps, ds);\n            n *= ps[p].first;\n        }\n        return;\n    }\n    /*\n     * @brief 因数集合(不含1,Pollard-Rho 算法质因数分解)\n     * @param n 待考察的数，不大于 1e18\n     * @return 一个 vector，包含了 n 的因子，按照从小到大的顺序排列。不含1。\n     */\n    std::vector<i64> getd(i64 n)\n    {\n        std::vector<std::pair<i64, i64>> p = factorize_pairs(n);\n        std::vector<i64> d;\n        dfs(0, 1, p, d);\n        std::sort(d.begin(), d.end());\n        return d;\n    }\n\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.3 基于值域处理的快速GCD\n\n你需要解决以下问题：\n\n以$O(1)$的单次询问复杂度、$O(n)$的总时间复杂度回答$\\forall x,y\\in[1,n],gcd(x,y)=?$\n\n操作方法：\n\n将任意$x$分解成三个数的乘积$a\\times b\\times c$，则显然$a,b,c\\le \\sqrt n$.\n\n考虑线筛，若 $x$ 为质数，显然 $(1,1,x)$它的一个分解；\n\n若 $x$ 为合数，设 $p$ 是 $x$ 的最小质因子， $(a_0,b_0,c_0)$ 是 $\\frac{x}{p}$ 的一个分解；\n\n则显然有$(a_0p,b_0,c_0)$排序后是一个从小到大的分解。\n\n若求$gcd(x,y)$，设$x=a\\times b\\times c$. 勒令$p_1=y,r_1=gcd(a,p_1)$​.\n\n勒令$p_2=\\frac{p_1}{r_1}$，$r_2=gcd(b,p_2)$；$p_3=\\frac{p_2}{r_2}$，$r_3=gcd(c,p_3)$.\n\n则有$gcd(x,y)=r_1r_2r_3.$\n\n原理为$gcd(x,y)=rgcd(x/r,y/r)\\quad iff\\quad r|x,r|y$\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e6 + 1;\nconst int maxn = 5001;\nvector<array<int, 3>> v(INF + 10);\nbool vis[INF + 10];\nint prime[INF + 10];\nvoid euler()\n{\n    v[1] = {1, 1, 1};\n    for (int i = 2; i <= INF; i++)\n    {\n        if (!vis[i])\n        {\n            vis[i] = 1;\n            prime[++prime[0]] = i;\n            v[i] = {1, 1, i};\n        }\n        for (int j = 1; j <= prime[0] && i * prime[j] <= INF; j++)\n        {\n            int k = i * prime[j];\n            vis[k] = 1;\n            v[k] = {v[i][0] * prime[j], v[i][1], v[i][2]};\n            sort(v[k].begin(), v[k].end());\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nint gcds[1010][1010];\nvoid init()\n{\n    gcds[0][0] = 0;\n    for (int i = 1; i <= 1000; i++)\n    {\n        gcds[i][0] = gcds[0][i] = i;\n        for (int j = 1; j <= i; j++)\n        {\n            gcds[i][j] = gcds[j][i] = gcds[j][i % j];\n        }\n    }\n}\nint Gcd(int a, int b)\n{\n    int ret = 1;\n    for (int i = 0, r; i < 3; i++)\n    {\n        if (v[a][i] > 1e3)\n        {\n            if (b % v[a][i])\n                r = 1;\n            else\n                r = v[a][i];\n        }\n        else\n            r = gcds[v[a][i]][b % v[a][i]];\n        b /= r;\n        ret = ret * r;\n    }\n    return ret;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.4 扩展欧几里得定理\n\n可求出方程$ax+by=gcd(a,b)$的一组特解。该方程通解为：\n$$\n\\left\\{\n\\begin{aligned}\nx=x^{'}+k\\frac{b}{gcd(a,b)}&\\\\\n\\\\&,k\\in Z\\\\\ny=y^{'}-k\\frac{a}{gcd(a,b)}\\\\\n\\end{aligned}\n\\right.\n$$\n取最小的非负解，`x=(x%s+s)%s`。\n\n```cpp\nvoid exgcd(int a, int b, int &x, int &y)\n{\n    if (b == 0)\n    {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.5 积性函数线性筛（欧拉函数筛）\n\n如果一个积性函数能够满足以下三条性质：\n\n1. $f(p)可O(1)查询$\n2. 若$gcd(n,m)=1$，则$\\varphi(nm)=\\varphi(n)\\varphi(m)$\n3. 若$n\\mid m$,则$\\varphi(nm)可积性转移$（即递推公式只含有乘法）\n\n则均可使用线性筛实现线性求解。\n\n***筛法求欧拉函数：***\n\n```cpp\nint prime[maxn];\nbool vis[maxn];//初始0，标记合数\nint phi[maxn];\nvoid euler(int n)\n{\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i])prime[++prime[0]]=i,phi[i]=i-1;\\\\性质1\n        for(int j=1;j<=prime[0]&&i*prime[j]<=n;j++)\n        {\n            vis[i*prime[j]]=true;\\\\筛去合数\n            if(i%prime[j]==0)\n            {\n                phi[i*prime[j]]=prime[j]*phi[i];\\\\性质3\n                break;\n            }\n            phi[i*prime[j]]=phi[prime[j]]*phi[i];\\\\性质2\n        }\n    }\n}\n```\n\n***因数个数筛：***\n\n```cpp\nstruct pre\n{\n    int n;\n    vector<int> d;\n    vector<int> num;\n    vector<bool> vis;\n    vector<int> prime;\n    void init(int _n)\n    {\n        n = _n;\n        d.resize(n + 1);\n        num.resize(n + 1);\n        vis.resize(n + 1);\n    }\n    void did()\n    {\n        d[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            if (!vis[i])\n            {\n                prime.push_back(i);\n                d[i] = 2;\n                num[i] = 1;\n            }\n            for (int j = 0; j < prime.size() && i * prime[j] <= n; j++)\n            {\n                vis[i * prime[j]] = 1;\n                if (i % prime[j] == 0)\n                {\n                    num[i * prime[j]] = num[i] + 1;\n                    d[i * prime[j]] = d[i] / (num[i * prime[j]]) * (num[i * prime[j]] + 1);\n                    break;\n                }\n                num[i * prime[j]] = 1;\n                d[i * prime[j]] = d[i] * 2;\n            }\n        }\n    }\n    int qs(int x)\n    {\n        return d[x];\n    }\n};\n```\n\n若函数$f(n)$满足$f(1)=1$且$\\forall x,y\\in N^*,gcd(x,y)=1$都有$f(xy)=f(x)f(y)$，则$f(n)$​为积性函数。\n\n特别的，若$\\forall x,y\\in N^*$都有$f(xy)=f(x)f(y)$​​​,则称作完全积性函数。\n\n若$f(x)$和$g(x)$均为积性函数，那么下列函数也称作积性函数：\n$$\n\\begin{align}\n&h(x)=f(x^p)\\\\\n&h(x)=f^p(x)\\\\\n&h(x)=f(x)g(x)\\\\\n&h(x)=\\sum_{d\\mid x}f(d)g(\\frac{x}{d})\\\\\n\\end{align}\n$$\n设质因数分解$x=\\prod_{i=1}^{n}p_i^{k_i}$，则\n\n若$F(x)$为积性函数，则$F(x)=\\prod_{i=1}^{n}f(p_i^k)$\n\n若$F(x)$为完全积性函数，则$F(x)=\\prod_{i=1}^{n}f(p_i^k)=\\prod_{i=1}^{n}f^k(p_i)$​\n\n（因为质数和其自己的$gcd$​并不是1而是其本身）\n\n常见积性函数:\n\n1. 欧拉函数$\\varphi(n)=\\sum_{i=1}^{n}[gcd(i,n)=1]$.\n\n2. 除数函数$\\sigma_k(n)=\\sum_{d\\mid n}d^k,k\\in N.$\n\n   （特别的，$\\sigma_0(n)$又记作$d(n)$，表示除数的个数。$\\sigma_1(n)$又记作$\\sigma(n)$​​，表示因数和）\n\n二者均为非完全积性函数。\n\n3. 莫比乌斯函数\n\n$$\n\\begin{align}\\mu(n)=\\left\\{\n\\begin{aligned}\n&\\quad \\ -1\\qquad \\quad \\ \\ iff\\ \\ n\\ is\\ a\\ prime \\\\\n&\\qquad 0\\qquad \\qquad n^{'}\\;mod\\;p1=0\\\\\n&-\\mu(n^{'})\\qquad \\quad otherwise\n\\end{aligned}\n\\right.\n&,n=p_1\\cdot n^{'}\n\\end{align}\n$$\n\n4. 欧拉函数$\\varphi(n)=\\sum_{i=1}^{n}[gcd(i,n)=1]$\n\n   通解公式\n\n$$\n\\varphi(x)=x\\prod_{i=1}^{n}(1-\\frac{1}{p_i})\\,\\,\\,\\,,\\,\\,\\,x=\\prod_{i=1}^{n}p_i^{k_i}\n$$\n   性质\n1. $\\varphi(p)=p-1$\n2. $\\varphi(p^k)=p^{k-1}\\varphi(p)$\n3. 若$gcd(n,m)=1$，则$\\varphi(nm)=\\varphi(n)\\varphi(m)$\n4. 若$n\\mid m$,则$\\varphi(nm)=n\\varphi(m)$​\n\n仔细观察不难发现2是4的子集关系，故性质1、3、4称作欧拉函数三性质，简称欧拉函数性。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.6 裴蜀定理\n\n$$\n\\begin{aligned}\n&设不全为0的整数a,b，对于任意整数x,y有\\\\\n\\\\\n&\\qquad gcd(a,b)|(ax+by)\\\\\n\\\\\n&且一定存在整数解x_0,y_0使得下列方程成立\\\\\n\\\\\n&\\qquad ax_0+by_0=gcd(a,b)\n\\end{aligned}\n$$\n\n\n\n上述情形可以推广到任意多变量。\n\n#### 1.7 扩展欧拉定理\n\n$$\na^b\\equiv \n\\left \\{\n\\begin{aligned}\n&a^{b\\ mod\\ \\varphi(m)}\\qquad \\qquad gcd(a,m)=1\\\\\n&a^b \\qquad\\qquad\\qquad\\quad\\ gcd(a,m)\\neq1,b<\\varphi(m)\\\\\n&a^{(b\\ mod\\ \\varphi(m))+\\varphi(m)} \\quad \\ gcd(a,m)\\neq1,b\\geq\\varphi(m)\n\\end{aligned}\n\\right.\\quad (mod\\ m)\n$$\n\n\n\n#### 1.8 乘法逆元\n\n线性逆元：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod;\nconst int maxn = 6e6 + 9;\nint inv[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a;\n    cin >> a >> mod;\n    inv[1] = 1;\n    cout << 1 << endl;\n    for (int i = 2; i <= a; i++)\n    {\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n        cout << inv[i] << endl;\n    }\n}\n```\n\n快速幂逆元（费马小定理）：\n$$\n对于任意正整数a，\\exists p满足gcd(a,p)=1,则必然有以下同余式成立:\\\\\na^{p-1} \\equiv1\\ (mod \\; n)\n$$\n\n```cpp\nquickpow(a,mod-2);\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.9 中国剩余定理\n\n给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。\n$$\n\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}\n$$\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^5$，$1 \\le b_i,a_i \\le {10}^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。不保证$b$为质数\n\n**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint quickmul(int a, int b, int mod)\n{\n    while (a < 0)\n        a += mod;\n    while (b < 0)\n        b += mod;\n    if (a < b)\n        swap(a, b);\n    int e = 0;\n    while (b)\n    {\n        if (b & 1)\n            (e += a) %= mod;\n        (a <<= 1) %= mod;\n        b >>= 1;\n    }\n    return e;\n}\nvoid exgcd(int a, int b, int &x, int &y)\n{\n    if (b == 0)\n    {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n}\nconst int maxn = 500001;\nint a[maxn], m[maxn]; // 对m取模余数是a\nint n;\nint ExCRT()\n{\n    int mod = m[1], ans = a[1];\n    for (int i = 2; i <= n; i++)\n    {\n        int b1 = mod, b2 = m[i], c = __gcd(b1, b2), minus = (a[i] - ans % b2 + b2) % b2;\n        if (minus % c != 0)\n            return -1;\n        b1 /= c, b2 /= c, minus /= c;\n        int x, y;\n        exgcd(b1, b2, x, y);\n        x = quickmul(x, minus, b2);\n        ans += x * mod;\n        mod *= b2;\n        ans = (ans % mod + mod) % mod;\n    }\n    return ans;\n}\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> m[i] >> a[i];\n    }\n    cout << ExCRT() << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.10 离散对数\n\n##### 1.10.1 原根\n\n满足$a^n\\equiv 1\\ (mod \\ m),gcd(a,m)=1$的最小正整数$n$存在，称$n$为$a$的阶，记作$\\delta_m(a)$。\n\n给定$m$，若$gcd(g,m)=1$且$\\delta_m(g)=\\varphi(m)$，则称$g$为$m$的一个原根（循环群的生成元）。\n\n详细见$OI-Wiki$\n\n##### 1.10.2 离散对数\n\n定义$a^x\\equiv b\\ (mod\\ m)$，$a$为$m$的一个原根时，记$x=ind_ab$，称作$b$关于$m$的离散对数。\n\n##### 1.10.3 ExBSGS算法\n\n给定 $a,p,b$，求满足 $a^x≡b \\pmod p$ 的最小自然数 $x$ 。如果无解，输出 `No Solution`，否则输出最小自然数解。\n\n对于 $100\\%$ 的数据，$1\\le a,p,b≤10^9$ 或 $a=p=b=0$。$\\sum \\sqrt p\\le 5\\times 10^6$​。\n\n原理：搞到和BSGS算法一致，通过$a \\equiv b \\ (mod\\ c) \\iff a\\times d\\equiv b\\times d\\ (mod\\ c\\times d)$\n\n每次在两边除以 $d=gcd(a,p)$，得到$\\frac{a}{d}\\times a^{x-1}\\equiv\\frac{b}{d}\\ (mod\\ \\frac{p}{d})$\n\n重复执行该语段，直到$gcd(a,p)=1$ 为止。\n\n然后上$BSGS$根号暴力分治算，复杂度$O(\\sqrt {\\varphi(p)})$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int BSGS(int a, int n, int p, int ad = 1) // ad*(a^x)=n(mod p)\n{\n    unordered_map<int, int> mp;\n    int m = ceil(sqrt(p));\n    int s = 1;\n    for (int i = 0; i < m; i++, s = 1ll * s * a % p)\n        mp[1ll * s * n % p] = i;\n    for (int i = 0, tmp = s, s = ad; i <= m; i++, s = 1ll * s * tmp % p)\n        if (mp.find(s) != mp.end())\n            if (1ll * i * m - mp[s] >= 0)\n                return 1ll * i * m - mp[s];\n    return -1;\n}\ninline int exBSGS(int a, int n, int p)\n{\n    a %= p;\n    n %= p;\n    if (n == 1 || p == 1)\n        return 0;\n    int cnt = 0;\n    int d, ad = 1;\n    while ((d = gcd(a, p)) ^ 1)\n    {\n        if (n % d)\n            return -1;\n        cnt++;\n        n /= d;\n        p /= d;\n        ad = (1ll * ad * a / d) % p;\n        if (ad == n)\n            return cnt;\n    }\n    int ans = BSGS(a, n, p, ad);\n    if (ans == -1)\n        return -1;\n    return ans + cnt;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, p, n;\n    while (cin >> a >> p >> n)\n    {\n        if (!a && !p && !n)\n            break;\n        int ans = exBSGS(a, n, p);\n        if (~ans)\n            cout << ans << \"\\n\";\n        else\n            cout << \"No Solution\" << \"\\n\";\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.11 二次剩余（奇素数）\n\n给出 $N,p$，求解方程 \n\n$$\nx^2 \\equiv N \\pmod{p}\n$$\n\n多组数据，**且保证 $p$ 是奇素数。**\n\n输出共 $T$ 行。\n\n对于每一行输出，若有解，则按 $\\bmod ~p$ 后递增的顺序输出在 $\\bmod~ p$ 意义下的全部解；若两解相同，只输出其中一个；若无解，则输出 `Hola!` 。\n\n对于 $100\\%$ 的数据，$1\\leq T\\leq 10^4,0\\le N, p\\leq 10^9+9$​。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nrandom_device rd;\nmt19937 ran(rd());\nstruct num\n{\n    ll x; // 实部\n    ll y; // 虚部(即虚数单位√w的系数)\n};\n\nll t, w, n, p;\n\nnum mul(num a, num b, ll p)\n{ // 复数乘法\n    num res;\n    res.x = ((a.x * b.x % p + a.y * b.y % p * w % p) % p + p) % p; // x = a.x*b.x + a.y*b.y*w\n    res.y = ((a.x * b.y % p + a.y * b.x % p) % p + p) % p;         // y = a.x*b.y + a.y*b.x\n    return res;\n}\nll qpow_r(ll a, ll b, ll p)\n{ // 实数快速幂\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = res * a % p;\n        a = a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\nll qpow_i(num a, ll b, ll p)\n{ // 复数快速幂\n    num res = {1, 0};\n    while (b)\n    {\n        if (b & 1)\n            res = mul(res, a, p);\n        a = mul(a, a, p);\n        b >>= 1;\n    }\n    return res.x % p; // 只用返回实数部分，因为虚数部分没了\n}\nll cipolla(ll n, ll p)\n{\n    n %= p;\n    if (qpow_r(n, (p - 1) / 2, p) == -1 + p)\n        return -1; // 据欧拉准则判定是否有解\n    ll a;\n    while (1)\n    { // 找出一个符合条件的a\n        a = ran() % p;\n        w = (((a * a) % p - n) % p + p) % p; // w = a^2 - n，虚数单位的平方\n        if (qpow_r(w, (p - 1) / 2, p) == -1 + p)\n            break;\n    }\n    num x = {a, 1};\n    return qpow_i(x, (p + 1) / 2, p);\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> p;\n        if (!n)\n        {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        ll ans1 = cipolla(n, p), ans2 = -ans1 + p; // 另一个解就是其相反数\n        if (ans1 == -1)\n            cout << \"Hola!\\n\";\n        else\n        {\n            if (ans1 > ans2)\n                swap(ans1, ans2);\n            if (ans1 == ans2)\n                cout << ans1 << \"\\n\";\n            else\n                cout << ans1 << \" \" << ans2 << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.12 数论分块\n\n以期望复杂度$O(\\sqrt x)$的复杂度求解$F(x)=\\sum_{i=1}^ng(\\lfloor\\frac{x}i\\rfloor)$。\n\n分块理论：如果$\\lfloor\\frac{x}{i}\\rfloor=\\lfloor\\frac{x}{j}\\rfloor$，则有该块的分块区间为$\\large [i,\\lfloor\\frac{x}{\\lfloor\\frac{x}{i}\\rfloor}\\rfloor]$​\n\n原理：$\\lfloor\\frac{x}{ab}\\rfloor=\\lfloor\\frac{\\lfloor\\frac{x}{a}\\rfloor}{b}\\rfloor$\n\n```cpp\nlong long H(int n) {\n  long long res = 0;  // 储存结果\n  int l = 1, r;       // 块左端点与右端点\n  while (l <= n) {\n    r = n / (n / l);  // 计算当前块的右端点\n    // 累加这一块的贡献到结果中。乘上 1LL 防止溢出\n    res += 1LL * (r - l + 1) * (n / l);\n    l = r + 1;  // 左端点移到下一块\n  }\n  return res;\n}\n```\n\n如果是向上取整分块$F(x)=\\sum_{i=1}^ng(\\lceil\\frac{x}i\\rceil)$，则有如果$\\lceil\\frac{x}{i}\\rceil=\\lceil\\frac{x}{j}\\rceil$，则有该块的分块区间为$\\large [i,\\lceil\\frac{x}{\\lceil\\frac{x-1}{i}\\rceil}\\rceil]$。注意特殊处理$i\\ge x$的情况，此时分块右端点分母为$0$.注意右边界的写法。\n\n```cpp\nauto calc = [&](auto self, int x) -> i64\n    {\n        if (mp.count(x))\n            return mp[x];\n        i64 res = 0;\n        int i = 2;\n        while (i <= n)\n        {\n            int invr = (x - 1) / i;\n            int r = n;\n            if (invr != 0)                  // 分块防0\n                r = min(r, (x - 1) / invr); // 注意分块值域不要超过你求和式的上界\n            res = (res + (r - i + 1) * self(self, (x + i - 1) / i) % mod) % mod;\n            i = r + 1;\n        }\n        res = (res * inv) % mod;\n        res = (res + n * inv % mod) % mod;\n        return mp[x] = res;\n    };\n```\n\n\n\n\n\n### 2. 线性代数相关\n\n#### 2.1 矩阵快速幂\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nconst int mod = 1e9 + 7;\nusing mint = MInt<mod>;\nvector<vector<mint>> operator*(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n    vector<vector<mint>> c(a.size(), vector<mint>(a.size(), 0));\n    int n = a.size();\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            for (int k = 0; k < n; k++)\n            {\n                c[i][j] += (a[i][k] * b[k][j]);\n            }\n        }\n    }\n    return c;\n}\nvoid solve()\n{\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<vector<mint>> E(n, vector<mint>(n, 0));\n    vector<vector<mint>> A = E;\n    for (int i = 0; i < n; i++)\n        E[i][i] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> A[i][j];\n        }\n    }\n    while (k)\n    {\n        if (k & 1)\n            E = E * A;\n        A = A * A;\n        k >>= 1;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << E[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    // cin >> t;\n    // while (t--)\n    solve();\n}\n```\n\n#### 2.2 矩阵数列递推\n\n对数列递推式子列矩阵方程就行。最著名的就是feibonacci数列：\n$$\n\\pmatrix{f_n\\\\f_{n-1}} =\\pmatrix{1\\ 1\\\\1 \\ 0}\\pmatrix{f_{ n-1}\\\\f_{n-2}}\n$$\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.3 矩阵求逆/高斯消元(仅可求唯一解)\n\n求矩阵的逆矩阵，无解判定矩阵非满秩矩阵，等价于解线性方程组。使用高斯消元法即可。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\n#define endl '\\n'\nconst int P = 1e9 + 7;\nint power(int a, int b, int mod)\n{\n    int res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = (1ll * res * a) % mod;\n        a = (1ll * a * a) % mod;\n        b >>= 1;\n    }\n    return res % mod;\n}\nstd::vector<int> gauss(std::vector<std::vector<int>> a, std::vector<int> b)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (a[r][i] == 0)\n            ++r;\n        std::swap(a[i], a[r]);\n        std::swap(b[i], b[r]);\n        int inv = power(a[i][i], P - 2, P);\n        for (int j = i; j < n; ++j)\n            a[i][j] = 1ll * a[i][j] * inv % P;\n        b[i] = 1ll * b[i] * inv % P;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            int x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] = (a[j][k] + 1ll * (P - x) * a[i][k]) % P;\n            b[j] = (b[j] + 1ll * (P - x) * b[i]) % P;\n        }\n    }\n    return b;\n}\n/**   高斯消元法（gaussian elimination）【久远】\n *    2020-12-02: https://www.codechef.com/viewsolution/39942900\n **/\nstd::vector<double> gauss(std::vector<std::vector<double>> a, std::vector<double> b, int &rank)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (r < n && a[r][i] == 0)\n            ++r;\n        if (r == n)\n            return b;\n        std::swap(a[i], a[r]);\n        std::swap(b[i], b[r]);\n        double x = a[i][i];\n        rank++;\n        for (int j = i; j < n; ++j)\n            a[i][j] /= x;\n        b[i] /= x;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] -= a[i][k] * x;\n            b[j] -= b[i] * x;\n        }\n    }\n    return b;\n}\nvector<vector<int>> invmatrix(vector<vector<int>> a, vector<vector<int>> b, int &rank)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (r < n && a[r][i] == 0)\n            ++r;\n        if (r == n)\n            break;\n        rank++;\n        swap(a[i], a[r]);\n        swap(b[i], b[r]);\n        int inv = power(a[i][i], P - 2, P);\n        for (int j = i; j < n; ++j)\n            a[i][j] = 1ll * a[i][j] * inv % P;\n        for (int k = 0; k < n; k++)\n            b[i][k] = 1ll * b[i][k] * inv % P;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            int x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] = (a[j][k] + 1ll * (P - x) * a[i][k]) % P;\n            for (int k = 0; k < n; k++)\n                b[j][k] = (b[j][k] + 1ll * (P - x) * b[i][k]) % P;\n        }\n    }\n    return b;\n}\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    vector<vector<int>> E(n, vector<int>(n));\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> a[i][j];\n            if (i == j)\n                E[i][j] = 1;\n        }\n    }\n    vector<vector<int>> A;\n    int rk = 0;\n    A = invmatrix(a, E, rk);\n    if (rk != n)\n    {\n        cout << \"No Solution\" << endl;\n        return;\n    }\n\n    for (auto &i : A)\n    {\n        for (auto &j : i)\n        {\n            cout << j << \" \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    // int t;\n    // cin >> t;\n    // while (t--)\n    solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.4 线性基\n\n不难发现，按位Bitwise Xor运算是一个针对MOD2剩余系向量空间加法运算，故存在代数线性基。\n\n线性空间$<Z_2^n,bitwise\\ Xor,bitwise\\ And>$为域空间。\n\n我们可以利用异或线性基实现：\n\n1. 判断一个数能否表示成某数集子集的异或和（已有集合元素是否能够构造出0）；\n\n2. 求一个数表示成某数集子集异或和的方案数；\n\n3. 求某数集子集的最大/最小/第$k$大/第$k$​小异或和；\n\n   如果说，线性基中异或的最大数（的二进制形式）是一串 **连续的，没有带后续$0$** 的$1$，那相信聪明的你一定会求第$k$大，因为第$k$大其实就是$k$。\n\n   现在相当于告诉你在这一串$1$中夹了很多$0$，问你第$k$大是多少。那么你其实可以不用管中间的$0$，把$k$的二进制形式弄出来，然后把中间省略$0$给插回去就好了。（因为最大值位是$0$的地方一辈子不可能出$1$）\n   解释一下就相当于把线性基异或后出来的最大值里的所有$1$都给挤到最后，然后求出第$k$大，再把你弄走的0给丢回去。\n\n   $eg:$异或后最大值为$101100110_2$，问第$20$大\n\n   挤到后面去后成$11111_2$，第$k$大是$10100_2$，把$0$插回去成为$100100000_2$，第20大便是$100100000_2$\n\n4. 求一个数在某数集子集异或和中的排名。\n\n线性基的独立性决定了一组异或为0的数无论以什么顺序插入最终线性基都不会允许这n个数同时插入线性基中，所以和线性基相关的贪心直接对权值排序后按顺序插入线性基就可以了。\n\n注意，线性基的插入是可重复贡献的，所以支持树上倍增$RMQ$，思想参考树上倍增lca查询和序列区间最大值查询。线性基的极大无关性保证任意一组线性基最多是$logn$​级别的，支持暴力合并。可以借助树上倍增实现树上查询问题。\n\n求$x\\rightarrow y$路径上的最大异或和，只需要四段彩色弧线段所代表的倍增线性基合并即可，这是$O(log^2n)$的单次询问。求$lca$方式的倍增跳是$O(log^3n)$的。\n\n![image-20241030231917971](C:\\Users\\栾津\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241030231917971.png)\n\n```cpp\nstruct LineBase\n{\nprivate:\n    const static int MN = 62;\n    i64 a[MN + 1], tmp[MN + 1];\n    bool flag; // 线性基中是否有重复插入的元素\n\npublic:\n    void insert(i64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                {\n                    a[i] = x;\n                    return;\n                }\n                else\n                    x ^= a[i];\n        flag = true;\n    }\n    bool check(i64 x) // 查看当前线性基中能否表示出来这个数(是否已插入)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                    return false;\n                else\n                    x ^= a[i];\n        return true;\n    }\n    i64 qmax(i64 res = 0)\n    {\n        for (int i = MN; ~i; i--)\n            res = max(res, res ^ a[i]);\n        return res;\n    }\n    i64 qmin()\n    {\n        if (flag) // 线性基有试图插入过相同的数，最小值为0\n            return 0;\n        for (int i = 0; i <= MN; i++)\n            if (a[i])\n                return a[i];\n    }\n    i64 query(i64 k) // 线性基下第k小\n    {\n        i64 res = 0;\n        int cnt = 0;\n        k -= flag; // 线性基有试图插入过相同的数，最小值为0\n        if (!k)\n            return 0;\n        for (int i = 0; i <= MN; i++)\n        {\n            for (int j = i - 1; ~j; j--)\n                if (a[i] & (1ll << j))\n                    a[i] ^= a[j];\n            if (a[i])\n                tmp[cnt++] = a[i];\n        } // 线性基重构\n        if (k >= (1ll << cnt))\n            return -1;\n        for (int i = 0; i < cnt; i++)\n            if (k & (1ll << i))\n                res ^= tmp[i];\n        return res;\n    }\n};\nLineBase lb;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n树上倍增查询路径max\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nusing u64 = unsigned long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nstruct LineBase\n{\nprivate:\n    const static int MN = 60;\n    array<u64, MN + 1> a;\n    bool flag;\n    friend LineBase merge(LineBase a, LineBase b);\n\npublic:\n    LineBase()\n    {\n        a.fill(0);\n    }\n    void ins(u64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                {\n                    a[i] = x;\n                    return;\n                }\n                else\n                    x ^= a[i];\n        flag = true;\n    }\n    bool check(u64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                    return false;\n                else\n                    x ^= a[i];\n        return true;\n    }\n    u64 qmax(u64 res = 0)\n    {\n        for (int i = MN; ~i; i--)\n            res = max(res, res ^ a[i]);\n        return res;\n    }\n    u64 qmin()\n    {\n        if (flag)\n            return 0;\n        for (int i = 0; i <= MN; i++)\n            if (a[i])\n                return a[i];\n    }\n\n    void merge(LineBase b)\n    {\n        for (int i = 0; i < b.MN; i++)\n        {\n            this->ins(b.a[i]);\n        }\n    }\n};\nLineBase merge(LineBase a, LineBase b)\n{\n    LineBase c = a;\n    for (int i = 0; i < b.MN; i++)\n    {\n        c.ins(b.a[i]);\n    }\n    return c;\n}\nstruct node\n{\n    int fa;\n    LineBase lb;\n};\nconst int maxn = 2e4 + 9;\nnode st[maxn][16];\nvector<int> con[maxn];\nvector<int> dep;\nvector<u64> num;\nvoid add_edge(int u, int v)\n{\n    con[u].push_back(v);\n    con[v].push_back(u);\n}\nvoid dfs(int u, int fa)\n{\n    st[u][0].fa = fa;\n    dep[u] = dep[fa] + 1;\n    st[u][0].lb.ins(num[u]);\n    st[u][0].lb.ins(num[fa]);\n    for (int j = 1; j <= 15; j++)\n    {\n        st[u][j].fa = st[st[u][j - 1].fa][j - 1].fa;\n        st[u][j].lb = merge(st[u][j - 1].lb, st[st[u][j - 1].fa][j - 1].lb);\n    }\n    for (auto v : con[u])\n    {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n    }\n    return;\n}\npair<int, LineBase> lca(int u, int v)\n{\n    if (dep[u] < dep[v])\n        swap(u, v);\n    int tmp = dep[u] - dep[v];\n    LineBase ans;\n    ans.ins(num[u]), ans.ins(num[v]);\n    for (int j = 0; j <= 15; j++)\n    {\n        if ((tmp >> j) & 1)\n            ans.merge(st[u][j].lb), u = st[u][j].fa;\n    }\n    if (u == v)\n        return {u, ans};\n    for (int j = 15; j >= 0; j--)\n    {\n        if (st[u][j].fa != st[v][j].fa)\n        {\n            ans.merge(st[u][j].lb);\n            ans.merge(st[v][j].lb);\n            u = st[u][j].fa, v = st[v][j].fa;\n        }\n    }\n    ans.merge(st[u][0].lb);\n    ans.merge(st[v][0].lb);\n    return {st[u][0].fa, ans};\n}\n\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    num.assign(n + 1, 0);\n    dep.assign(n + 1, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> num[i];\n    }\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    dfs(1, 1);\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v).second.qmax() << endl;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.5 二进制矩阵类Matrix.h\n\n这段代码定义了一个名为 `matrix_Z2_base` 的模板类，它用于表示和操作$<Z_2^n,xor,and>$线性空间的矩阵。元素只有0和1，运算在$mod2$数域下。\n\n1. **构造函数**：\n   \n   - `matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false)`：创建一个大小为 n×m 的矩阵，其中 `n` 是行数，`m` 是列数。`init_diagonal` 和 `init_off_diagonal` 参数用于初始化对角线和非对角线元素。如果 `init_diagonal` 为 `true`，则对角线元素被初始化为 1，否则为 0。非对角线元素的初始化由 `init_off_diagonal` 控制。\n   \n2. **访问操作符**：\n   - `std::bitset<SZ> &operator[](int i)`：返回第 `i` 行的引用。\n   - `const std::bitset<SZ> &operator[](int i) const`：返回第 `i` 行的常量引用。\n\n3. **切片操作**：\n   - `matrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr)`：在原地修改矩阵，返回左上角为 `(il, jl)`，右下角为 `(ir, jr)` 的子矩阵。\n   - `matrix_Z2_base slice(int il, int ir, int jl, int jr) const`：返回左上角为 `(il, jl)`，右下角为 `(ir, jr)` 的子矩阵的副本。\n\n4. **行切片和列切片**：\n   - `matrix_Z2_base &inplace_row_slice(int il, int ir)`：在原地修改矩阵，返回行切片子矩阵。\n   - `matrix_Z2_base row_slice(int il, int ir) const`：返回行切片子矩阵的副本。\n   - `matrix_Z2_base &inplace_column_slice(int jl, int jr)`：在原地修改矩阵，返回列切片子矩阵。\n   - `matrix_Z2_base column_slice(int jl, int jr) const`：返回列切片子矩阵的副本。\n\n5. **比较操作符**：\n   - `bool operator==(const matrix_Z2_base &a) const`：比较两个矩阵是否相等。\n   - `bool operator!=(const matrix_Z2_base &a) const`：比较两个矩阵是否不相等。\n\n6. **矩阵加法和减法**：\n   - `matrix_Z2_base &operator+=(const matrix_Z2_base &M)`：原地矩阵加法。\n   - `matrix_Z2_base operator+(const matrix_Z2_base &M) const`：返回两个矩阵相加的结果。\n   - `matrix_Z2_base &operator-=(const matrix_Z2_base &M)`：原地矩阵减法。\n   - `matrix_Z2_base operator-(const matrix_Z2_base &M) const`：返回两个矩阵相减的结果。\n\n7. **矩阵乘法**：\n   - `matrix_Z2_base &operator*=(const matrix_Z2_base &a)`：原地矩阵乘法。\n   - `matrix_Z2_base operator*(const matrix_Z2_base &a) const`：返回两个矩阵相乘的结果。\n\n8. **矩阵乘以常数**：\n   - `matrix_Z2_base &operator*=(bool c)`：将矩阵的每个元素乘以布尔常数 `c`。\n   - `matrix_Z2_base operator*(bool c) const`：返回乘以常数后的矩阵。\n\n9. **矩阵乘方**：\n   - `matrix_Z2_base &inplace_power(T e)`：原地计算矩阵的 `e` 次幂。\n   - `matrix_Z2_base power(T e) const`：返回矩阵的 `e` 次幂。\n\n10. **矩阵转置**：\n    - `matrix_Z2_base &inplace_transpose()`：原地转置矩阵。\n    - `matrix_Z2_base transpose() const`：返回矩阵的转置。\n\n11. **矩阵乘以行向量**：\n    - `std::vector<int> operator*(const std::bitset<SZ> &v) const`：将矩阵乘以行向量 `v`。\n\n12. **行阶梯形式和行列式、秩**：\n    - `tuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1)`：原地计算矩阵的行阶梯形式，并返回行列式和秩。\n    - `tuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const`：返回矩阵的行阶梯形式，并返回行列式和秩。\n\n13. **矩阵逆**：\n    - `optional<matrix_Z2_base> inverse() const`：返回矩阵的逆，如果矩阵不可逆，则返回空。\n\n14. **行列式**：\n    - `bool determinant() const`：返回矩阵的行列式是否为 1。\n\n15. **秩**：\n    - `int rank() const`：返回矩阵的秩。\n\n16. **线性方程组的解**：\n    - `optional<std::bitset<SZ>> find_a_solution() const`：返回矩阵所代表的线性方程组的一个解。\n\n      解多解$n$元$n$式线性方程组示例：\n    \n      ```cpp\n      for (auto s = 0; s < n; ++s)\n      {\n          matrix_Z2 M(n + 1, n + 1);//第n行表示主元都有谁，第n列是方程增广列，表示各线性方程结果。\n          for (auto u = 0; u < n; ++u)\n          {\n              for (auto v = 0; v < n; ++v)\n              {\n                  if (adjm[u] >> v & 1)\n                  {\n                      M[v][u] = 1;//原题是个图论，根据边列的矩阵方程\n                  }\n              }\n              M[n][u] = u == s;//标记主元，表示第s个元素的解必须是1，给出来的多组解必定线性无关\n          }\n          M[n][n] = 1;\n          if (auto resptr = M.find_a_solution())\n          {\n              auto pick = *resptr;\n              for (auto u = 0; u < n; ++u)\n              {\n                  if (pick[u])\n                  {\n                      res[u] |= 1LL << s;\n                  }\n              }\n          }\n          else\n          {\n              cout << \"No\\n\";\n              return 0;\n          }\n      }\n      ```\n    \n      \n    \n17. **输出操作符**：\n    \n    - `friend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a)`：输出矩阵到流。\n    \n18. **矩阵乘以常数（外部）**：\n    - `matrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M)`：返回乘以常数后的矩阵。\n\n19. **行向量乘以矩阵**：\n    - `std::bitset<SZ> operator*(const std::vector<int> &v, const matrix_Z2_base<SZ> &a)`：将行向量 `v` 乘以矩阵 `a`。\n\n```cpp\n#ifndef __MATRIX_H__\n#define __MATRIX_H__\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n *@brief 二进制矩阵类\n *@note 该类支持矩阵的加减乘，求逆，求行列式，求秩，求行阶梯形式，求解线性方程组等操作\n *@tparam SZ 矩阵列向量的位数，即矩阵的列数，用于初始化bitset的位数\n */\ntemplate <size_t SZ>\nstruct matrix_Z2_base\n{\n    int n, m;\n    std::vector<std::bitset<SZ>> data;\n    std::bitset<SZ> &operator[](int i)\n    {\n        assert(0 <= i && i < n);\n        return data[i];\n    }\n    const std::bitset<SZ> &operator[](int i) const\n    {\n        assert(0 <= i && i < n);\n        return data[i];\n    }\n    matrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr)\n    {\n        assert(0 <= il && il <= ir && ir <= n);\n        assert(0 <= jl && jl <= jr && jr <= m);\n        n = ir - il, m = jr - jl;\n        if (il > 0)\n            for (auto i = 0; i < n; ++i)\n                swap(data[i], data[il + i]);\n        data.resize(n);\n        for (auto &row : data)\n            row = row << SZ - jr >> jl;\n        return *this;\n    }\n    /*\n     *@brief 返回一个子矩阵\n     *@param il 左上角行坐标\n     *@param ir 右下角行坐标\n     *@param jl 左上角列坐标\n     *@param jr 右下角列坐标\n     *@return 返回一个子矩阵\n     */\n    matrix_Z2_base slice(int il, int ir, int jl, int jr) const\n    {\n        return matrix_Z2_base(*this).inplace_slice(il, ir, jl, jr);\n    }\n    matrix_Z2_base &inplace_row_slice(int il, int ir)\n    {\n        assert(0 <= il && il <= ir && ir <= n);\n        n = ir - il;\n        if (il > 0)\n            for (auto i = 0; i < n; ++i)\n                swap(data[i], data[il + i]);\n        data.resize(n);\n        return *this;\n    }\n    /*\n     *@brief 返回一个行切片子矩阵\n     *@param il 左上角行坐标\n     *@param ir 右下角行坐标\n     *@return 返回一个行切片子矩阵\n     */\n    matrix_Z2_base row_slice(int il, int ir) const\n    {\n        return matrix_Z2_base(*this).inplace_row_slice(il, ir);\n    }\n    matrix_Z2_base &inplace_column_slice(int jl, int jr)\n    {\n        assert(0 <= jl && jl <= jr && jr <= m);\n        m = jr - jl;\n        for (auto &row : data)\n            row = row << SZ - jr >> jl;\n        return *this;\n    }\n    /*\n     *@brief 返回一个列切片子矩阵\n     *@param jl 左上角列坐标\n     *@param jr 右下角列坐标\n     *@return 返回一个列切片子矩阵\n     */\n    matrix_Z2_base column_slice(int jl, int jr) const\n    {\n        return matrix_Z2_base(*this).inplace_column_slice(jl, jr);\n    }\n    // 矩阵相等\n    bool operator==(const matrix_Z2_base &a) const\n    {\n        assert(n == a.n && m == a.m);\n        return data == a.data;\n    }\n    // 矩阵不等\n    bool operator!=(const matrix_Z2_base &a) const\n    {\n        assert(n == a.n && m == a.m);\n        return data != a.data;\n    }\n    // 矩阵相加\n    matrix_Z2_base &operator+=(const matrix_Z2_base &M)\n    {\n        assert(n == M.n && m == M.m);\n        for (auto i = 0; i < n; ++i)\n            data[i] ^= M[i];\n        return *this;\n    }\n    // 矩阵相加\n    matrix_Z2_base operator+(const matrix_Z2_base &M) const\n    {\n        return matrix_Z2_base(*this) += M;\n    }\n    // 矩阵相减\n    matrix_Z2_base &operator-=(const matrix_Z2_base &M)\n    {\n        assert(n == M.n && m == M.m);\n        for (auto i = 0; i < n; ++i)\n            data[i] ^= M[i];\n        return *this;\n    }\n    // 矩阵相减\n    matrix_Z2_base operator-(const matrix_Z2_base &M) const\n    {\n        return matrix_Z2_base(*this) -= M;\n    }\n    // 矩阵相乘\n    matrix_Z2_base &operator*=(const matrix_Z2_base &a)\n    {\n        assert(m == a.n);\n        int l = a.m;\n        matrix_Z2_base res(n, l);\n        std::vector<std::bitset<SZ>> temp(l);\n        for (auto i = 0; i < l; ++i)\n            for (auto j = 0; j < m; ++j)\n                temp[i][j] = a[j][i];\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < l; ++j)\n                res[i][j] = (data[i] & temp[j]).count() & 1;\n        return *this = res;\n    }\n    // 矩阵相乘\n    matrix_Z2_base operator*(const matrix_Z2_base &a) const\n    {\n        return matrix_Z2_base(*this) *= a;\n    }\n    // 矩阵乘以一个常数\n    matrix_Z2_base &operator*=(bool c)\n    {\n        if (!c)\n            for (auto &v : *this)\n                v.reset();\n        return *this;\n    }\n    // 矩阵乘以一个常数\n    matrix_Z2_base operator*(bool c) const\n    {\n        return matrix_Z2_base(*this) *= c;\n    }\n    // 矩阵乘方\n    template <class T, typename enable_if<is_integral<T>::value>::type * = nullptr>\n    matrix_Z2_base &inplace_power(T e)\n    {\n        assert(n == m);\n        matrix_Z2_base res(n, n, true);\n        for (; e; *this *= *this, e >>= 1)\n            if (e & 1)\n                res *= *this;\n        return *this = res;\n    }\n    // 矩阵乘方\n    template <class T>\n    matrix_Z2_base power(T e) const\n    {\n        return matrix_Z2_base(*this).inplace_power(e);\n    }\n    // 矩阵转置\n    matrix_Z2_base &inplace_transpose()\n    {\n        assert(n == m);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = i + 1; j < n; ++j)\n                swap(data[i][j], data[j][i]);\n        return *this;\n    }\n    // 矩阵转置\n    matrix_Z2_base transpose() const\n    {\n        if (n == m)\n            return matrix_Z2_base(*this).inplace_transpose();\n        matrix_Z2_base res(m, n);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < m; ++j)\n                res[j][i] = data[i][j];\n        return res;\n    }\n    /*\n     *@brief 矩阵乘以一个行向量\n     *@param v 行向量\n     *@return 返回一个行向量\n     *@note 行向量必须在矩阵左乘，时间复杂度O(n * m / w)\n     */\n    std::vector<int> operator*(const std::bitset<SZ> &v) const\n    {\n        std::vector<int> res(n);\n        for (auto i = 0; i < n; ++i)\n            res[i] = (data[i] & v).count() & 1;\n        return res;\n    }\n    // O(n * m * up_to / w)\n    // Returns {REF matrix, determinant, rank}\n\n    /*\n     *@brief 矩阵的行阶梯形式\n     *@param up_to 行阶梯形式的行数，带参数的情况下只计算前up_to=m-1列向量的行阶梯形式，用于解线性方程组\n     *@return 返回一个元组，第一个元素是行阶梯形式的矩阵，第二个元素是行列式，第三个元素是秩\n     *@note 时间复杂度O(n * m * up_to / w),如果要解多解线性方程组，如果想固定第k个自由变量，需要对传入矩阵的a_{n,k}置1,同时增广向量的对应位a_{n,n}也必须置1，然后调用该函数。\n     *@note 实际上等价于新添了一组线性方程，即a_{n,k} * x_k = a_{n,n}。\n     */\n    tuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1)\n    {\n        if (n == 0)\n            return {*this, true, 0};\n        if (!~up_to)\n            up_to = m;\n        bool det = true;\n        int rank = 0;\n        for (auto j = 0; j < up_to; ++j)\n        {\n            int pivot = -1;\n            for (auto i = rank; i < n; ++i)\n                if (data[i][j])\n                {\n                    pivot = i;\n                    break;\n                }\n            if (!~pivot)\n            {\n                det = false;\n                continue;\n            }\n            if (rank != pivot)\n                swap(data[rank], data[pivot]);\n            for (auto i = rank + 1; i < n; ++i)\n                if (data[i][j])\n                    data[i] ^= data[rank];\n            ++rank;\n            if (rank == n)\n                break;\n        }\n        return {*this, det, rank};\n    }\n    // O(n * m * up_to / w)\n    // Returns {REF matrix, determinant, rank}\n    /*\n     *@brief 矩阵的行阶梯形式\n     *@param up_to 行阶梯形式的行数\n     *@return 返回一个元组，第一个元素是行阶梯形式的矩阵，第二个元素是行列式，第三个元素是秩\n     *@note 时间复杂度O(n * m * up_to / w)。解多解线性方程组时，如果想固定第k个自由变量，需要对传入矩阵的a_{n,k}置1,同时增广向量的对应位a_{n,n}也必须置1，然后调用该函数。\n     *@note 实际上等价于新添了一组线性方程，即a_{n,k} * x_k = a_{n,n}。\n     */\n    tuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const\n    {\n        return matrix_Z2_base(*this).inplace_REF(up_to);\n    }\n    // O(n * m * min(n, m) / w)\n    /*\n     *@brief 矩阵的逆\n     *@return 返回一个可选的矩阵，表示矩阵的逆\n     */\n    optional<matrix_Z2_base> inverse() const\n    {\n        assert(n == m);\n        std::vector<std::bitset<SZ>> a(data), res(n);\n        for (auto i = 0; i < n; ++i)\n            res[i].set(i);\n        for (auto j = 0; j < n; ++j)\n        {\n            int pivot = -1;\n            for (auto i = j; i < n; ++i)\n                if (a[i][j])\n                {\n                    pivot = i;\n                    break;\n                }\n            if (!~pivot)\n                return {};\n            swap(a[j], a[pivot]), swap(res[j], res[pivot]);\n            for (auto i = 0; i < n; ++i)\n                if (i != j && a[i][j])\n                    a[i] ^= a[j], res[i] ^= res[j];\n        }\n        swap(*this, res);\n        return true;\n    }\n    /*\n     *@brief 矩阵的行列式\n     *@return 返回一个布尔值，表示矩阵的行列式是否为1\n     */\n    bool determinant() const\n    {\n        assert(n == m);\n        matrix_Z2_base a(data);\n        for (auto i = 0; i < n; ++i)\n        {\n            for (auto j = i + 1; j < n; ++j)\n                if (a[j][i])\n                {\n                    if (a[i][i])\n                        a[j] ^= a[i];\n                    else\n                        swap(a[i], a[j]);\n                }\n            if (!a[i][i])\n                return false;\n        }\n        return true;\n    }\n    // O(n^3 / w)\n    /*\n     *@brief 矩阵的秩\n     *@return 返回一个整数，表示矩阵的秩\n     *@note 时间复杂度O(n^3 / w)\n     */\n    int rank() const\n    {\n        return get<2>(REF());\n    }\n    // Regarding the matrix as a system of linear equations by separating first m-1 columns, find a solution of the linear equation.\n    // O(n * m^2 / w)\n    /*\n     *@brief 矩阵所代表的线性方程组的一个解\n     *@return 返回一个可选的位集，表示矩阵的一个解\n     *@note 时间复杂度O(n * m^2 / w),该矩阵所代表的线性方程组系数矩阵为低m-1位，常数项为第m位，表示n*(m-1)的增广矩阵。\n     *@note 时间复杂度O(n * m * up_to / w),如果要解多解线性方程组，如果想固定第k个自由变量，需要对传入矩阵的a_{n,k}置1,同时增广向量的对应位a_{n,n}也必须置1，然后调用该函数。\n     *@note 实际上等价于新添了一组线性方程，即a_{n,k} * x_k = a_{n,n}。\n     */\n    optional<std::bitset<SZ>> find_a_solution() const\n    {\n        assert(m >= 1);\n        auto [ref, _, rank] = REF(m - 1);\n        for (auto i = rank; i < n; ++i)\n            if (ref[i][m - 1])\n                return {};\n        std::bitset<SZ> res;\n        for (auto i = rank - 1; i >= 0; --i)\n        {\n            int pivot = ref[i]._Find_first();\n            assert(pivot < m - 1);\n            res[pivot] = ref[i][m - 1] ^ (ref[i] & res).count() & 1;\n        }\n        return res;\n    }\n    template <class output_stream>\n    friend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a)\n    {\n        out << \"\\n\";\n        for (auto i = 0; i < a.n; ++i)\n        {\n            for (auto j = 0; j < a.m; ++j)\n                out << bool(a[i][j]);\n            out << \"\\n\";\n        }\n        return out;\n    }\n    /*\n     *@brief 构造函数\n     *@param n 行数\n     *@param m 列数\n     *@param init_diagonal 对角线是否初始化\n     *@param init_off_diagonal 非对角线是否初始化\n     */\n    matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false) : n(n), m(m), data(n)\n    {\n        assert(m <= SZ);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < m; ++j)\n                data[i][j] = i == j ? init_diagonal : init_off_diagonal;\n    }\n    /*\n     *@brief 构造函数\n     *@param n 行数\n     *@param m 列数\n     *@param a 矩阵\n     */\n    matrix_Z2_base(int n, int m, const std::vector<std::bitset<SZ>> &a) : n(n), m(m), data(a) {}\n};\n/*\n *@brief 矩阵乘以一个常数\n *@param c 常数\n *@param M 矩阵\n *@return 返回一个矩阵\n */\ntemplate <size_t SZ>\nmatrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M)\n{\n    if (!c)\n        for (auto &v : M)\n            v.reset();\n    return M;\n}\n// Multiply a row std::vector v on the left\n/*\n *@brief 行向量乘以矩阵\n *@param v 行向量\n *@param a 矩阵\n *@return 返回一个行向量\n */\ntemplate <size_t SZ>\nstd::bitset<SZ> operator*(const std::vector<int> &v, const matrix_Z2_base<SZ> &a)\n{\n    assert(a.n == (int)v.size());\n    std::bitset<SZ> res;\n    for (auto i = 0; i < a.n; ++i)\n        if (v[i])\n            res ^= a[i];\n    return res;\n}\n\n#endif\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3. 多项式相关\n\n关键词：卷积优化。动态规划优化。\n\n#### 3.1 快速傅里叶变换（FTT）/多项式乘法\n\n给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。\n\n请求出 $F(x)$ 和 $G(x)$ 的卷积，从低次方项到高次方项给出系数。\n\n保证输入中的系数大于等于 $0$ 且小于等于 $9$。\n\n对于 $100\\%$ 的数据：$1 \\le n, m \\leq {10}^6$​​。\n\n$FTT$等下列一系列快速变换的本质都是选择出来$2^w=n$个多项式点值，用这组点值向量的运算去替代多项式的运算。\n\n```cpp\n#include <bits/stdc++.h>\n#include <math.h>\nusing namespace std;\nusing d32 = double;\n#define endl '\\n'\nconst d32 PI = 3.14159265358979323846;\nvoid fft(vector<complex<d32>> &a)\n{\n    int n = a.size();\n    if (n == 1)\n        return;\n    vector<complex<d32>> a0(n / 2), a1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        a0[i] = a[i * 2];\n        a1[i] = a[i * 2 + 1];\n    }\n    fft(a0);\n    fft(a1);\n    d32 ang = 2 * PI / n;\n    complex<d32> w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; i < n / 2; i++)\n    {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n / 2] = a0[i] - w * a1[i];\n        w *= wn;\n    }\n}\nvector<d32> mul(vector<d32> a, vector<d32> b)\n{\n    int n = 1;\n    while (n < a.size() + b.size())\n        n *= 2;\n    a.resize(n);\n    b.resize(n);\n    vector<complex<d32>> A(a.begin(), a.end()), B(b.begin(), b.end());\n    fft(A);\n    fft(B);\n    for (int i = 0; i < n; i++)\n        A[i] *= B[i];\n    for (int i = 0; i < n; i++)\n        A[i] = conj(A[i]);//逆变换前求倒数。\n    fft(A);\n    vector<d32> res(n);\n    for (int i = 0; i < n; i++)\n        res[i] = round(A[i].real() / n);\n    return res;\n}\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<d32> a(n + 1), b(m + 1);\n    for (int i = 0; i <= n; i++)\n        cin >> a[i];\n    for (int i = 0; i <= m; i++)\n        cin >> b[i];\n    vector<d32> res = mul(a, b);\n    for (int i = 0; i <= n + m; i++)\n        cout << (long long)res[i] << \" \";\n    cout << endl;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n还有一种写法：\n\n```cpp\nusing d32 = double;\n#define endl '\\n'\nconst d32 PI = 3.14159265358979323846;\nvoid fft(vector<complex<double>> &f, int op)\n{\n    int n = f.size();\n    if (n == 1)\n        return;\n    vector<complex<double>> f0(n / 2), f1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        f0[i] = f[i * 2];\n        f1[i] = f[i * 2 + 1];\n    }\n    fft(f0, op);\n    fft(f1, op);\n    complex<double> cur(1, 0), step(cos(2 * PI / n), sin(2 * PI * op / n));\n    for (int k = 0; k < n / 2; ++k)\n    {\n        complex<double> tmp = cur * f1[k];\n        f[k] = f0[k] + tmp;\n        f[k + n / 2] = f0[k] - tmp;\n        cur *= step;\n    }\n    return;\n}\nvector<d32> mul(vector<d32> &a, vector<d32> &b)\n{\n    int n = 1;\n    while (n < a.size() + b.size())\n        n *= 2;\n    a.resize(n);\n    b.resize(n);\n    vector<complex<d32>> A(a.begin(), a.end()), B(b.begin(), b.end());\n    fft(A, 1);\n    fft(B, 1);\n    for (int i = 0; i < n; i++)\n        A[i] *= B[i];\n    fft(A, -1);\n    vector<d32> res(n);\n    for (int i = 0; i < n; i++)\n        res[i] = round(A[i].real() / n);\n    return res;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.2 快速数论变换（NTT）/多项式乘法\n\n```cpp\nconstexpr int P = 998244353;\n\nint power(int a, int b)\n{\n    int res = 1;\n    for (; b; b /= 2, a = 1LL * a * a % P)\n    {\n        if (b % 2)\n        {\n            res = 1LL * res * a % P;\n        }\n    }\n    return res;\n}\n\nstd::vector<int> rev, roots{0, 1};\n\nvoid dft(std::vector<int> &a)\n{\n    int n = a.size();\n    if (int(rev.size()) != n)\n    {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n        {\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (rev[i] < i)\n        {\n            std::swap(a[i], a[rev[i]]);\n        }\n    }\n    if (roots.size() < n)\n    {\n        int k = __builtin_ctz(roots.size());\n        roots.resize(n);\n        while ((1 << k) < n)\n        {\n            int e = power(31, 1 << (__builtin_ctz(P - 1) - k - 1));\n            for (int i = 1 << (k - 1); i < (1 << k); i++)\n            {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = 1LL * roots[i] * e % P;\n            }\n            k++;\n        }\n    }\n\n    for (int k = 1; k < n; k *= 2)\n    {\n        for (int i = 0; i < n; i += 2 * k)\n        {\n            for (int j = 0; j < k; j++)\n            {\n                int u = a[i + j];\n                int v = 1LL * a[i + j + k] * roots[k + j] % P;\n                a[i + j] = (u + v) % P;\n                a[i + j + k] = (u - v + P) % P;\n            }\n        }\n    }\n}\n\nvoid idft(std::vector<int> &a)\n{\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    int inv = power(n, P - 2);\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = 1LL * a[i] * inv % P;\n    }\n}\n\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b)\n{\n    int n = 1, tot = a.size() + b.size() - 1;\n    while (n < tot)\n    {\n        n *= 2;\n    }\n    if (tot < 128)\n    {\n        std::vector<int> c(a.size() + b.size() - 1);\n        for (int i = 0; i < a.size(); i++)\n        {\n            for (int j = 0; j < b.size(); j++)\n            {\n                c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;\n            }\n        }\n        return c;\n    }\n    a.resize(n);\n    b.resize(n);\n    dft(a);\n    dft(b);\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = 1LL * a[i] * b[i] % P;\n    }\n    idft(a);\n    a.resize(tot);\n    return a;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.3 快速莫比乌斯变换/快速沃尔什变换（FMT/FWT）\n\n给定长度为 $2^n$ 两个序列 $A,B$，设 \n\n$$C_i=\\sum_{j\\oplus k = i}A_j \\times B_k$$\n\n分别当 $\\oplus$ 是 $or, and, xor$ 时求出 $C$​​。称作或、与、异或卷积。**请区分他们与对应乘法的区别。**\n\n卷积原理：$FMT$是子集运算，$FWT$是$x\\circ y=popcount(x\\&y)\\%2$​\n\n$FMT_{and}(A)_i=\\sum_{i\\&j=i}a_j$\n\n$FMT_{or}(A)_i=\\sum_{i|j=i}a_j$\n\n$FMT_{xor}(A)_i=\\sum_{i\\circ j=0}a_j-\\sum_{i\\circ j=1}a_j$\n\n注意，针对异或的快速沃尔什变换是线性变换的，即$FWT(c\\cdot A+B)=c\\cdot FWT(A)+FWT(B)$​\n\n对数组$F(x)=x^0$（即只有$a[0]=1$，其余位置全为$0$）的快速$FWT$后所得序列全为$1$。\n\n对数组$F(x)=x^t$（即只有$a[t]=1$，其余位置全为$0$）的快速$FWT$后所得序列全为$1$或者$-1$（显然）\n\n```cpp\nstd::vector<int> fwt_and(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[j + k] = (1ll * a[j + k] + a[i + j + k]) % mod;\n    return a;\n}\nstd::vector<int> ifwt_and(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[j + k] = (1ll * a[j + k] - a[i + j + k] + mod) % mod;\n    return a;\n}\nstd::vector<int> fwt_or(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[i + j + k] = (1ll * a[j + k] + a[i + j + k]) % mod;\n    return a;\n}\nstd::vector<int> ifwt_or(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[i + j + k] = (1ll * a[i + j + k] - a[j + k] + mod) % mod;\n    return a;\n}\nstd::vector<int> fwt_xor(vector<int> a) // 异或\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (1ll * x + y) % mod;\n                a[i + j + k] = (1ll * x - y + mod) % mod;\n            }\n    return a;\n}\nstd::vector<int> ifwt_xor(vector<int> a)\n{\n    int inv_2 = 499122177;\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (1ll * x + y) * inv_2 % mod;\n                a[i + j + k] = (1ll * x - y + mod) % mod * inv_2 % mod;\n            }\n    return a;\n}\n\nstd::vector<int> fwt_not(std::vector<int> a) // 同或\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[i + j + k] = (1ll * x + y) % mod;\n                a[j + k] = (1ll * x - y + mod) % mod;\n            }\n    return a;\n}\nstd::vector<int> ifwt_not(std::vector<int> a)\n{\n    int inv_2 = 499122177;\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[i + j + k] = (1ll * x + y) * inv_2 % mod;\n                a[j + k] = (1ll * x - y + mod) % mod * inv_2 % mod;\n            }\n    return a;\n}\nstd::vector<int> FWT(std::vector<int> a, std::vector<int> b, vector<int> (*f)(vector<int>), vector<int> (*g)(vector<int>))\n{\n    int n = a.size();\n    assert((n & (n - 1)) == 0); // n是2的幂\n    a = f(a);\n    b = f(b);\n    for (int i = 0; i < n; i++)\n        a[i] = 1ll * a[i] * b[i] % mod;\n    return g(a);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.4 分治NTT（NTT+CQD）\n\n给定序列 $g_{1\\dots n - 1}$，求序列 $f_{0\\dots n - 1}$。\n\n其中 $f_i=\\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。\n\n答案对 $998244353$ 取模。\n\n$2\\leq n\\leq 10^5$，$0\\leq g_i<998244353$​。\n\n利用CDQ分治的思想，先解决左半部分，再解决左半部分对右半部分的贡献。\n\n设当前计算区间为$[l,r]$，此时先$CDQ$已经计算出了$f[l,\\ldots,mid]$，考虑其对$f[mid+1,\\ldots,r]$的贡献。\n\n对于$f_k(k\\ge mid+1)$而言，前半部分所造成的贡献为$\\sum_{i+j=k,i\\le mid}f_ig_{k-i}$\n\n也就是说，需要将$f[l,mid]$和$g(0,r-l)$卷积卷起来，对后半部分进行贡献。\n\n所以算出前半部分后，将$f[l,\\ldots,mid]$搞成一个多项式，卷积$NTT$​计算贡献，加在后面，然后递归后半部分。\n\n复杂度$O(nlog^2n)$\n\n（本例题也可利用生成函数操纵序列，多项式求逆解决，复杂度$O(nlogn)$ ）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nconstexpr int P = 998244353;\n\nint power(int a, int b)\n{\n    int res = 1;\n    for (; b; b /= 2, a = 1LL * a * a % P)\n    {\n        if (b % 2)\n        {\n            res = 1LL * res * a % P;\n        }\n    }\n    return res;\n}\n\nstd::vector<int> rev, roots{0, 1};\n\nvoid dft(std::vector<int> &a)\n{\n   //见NTT\n}\n\nvoid idft(std::vector<int> &a)\n{\n    //见NTT\n}\n\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b)\n{\n   //见NTT\n}\nvector<int> f, g;\nvoid cdq(int l, int r)\n{\n    if (l == r)\n    {\n        if (!l)\n            f[l] = 1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    cdq(l, mid);\n    vector<int> a(mid - l + 1), b(r - l + 1);\n    for (int i = l; i <= mid; i++)\n        a[i - l] = f[i];\n    for (int i = 0; i <= r - l; i++)\n        b[i] = g[i];\n    a = mul(a, b);\n    for (int i = mid + 1; i <= r; i++)\n        f[i] = (f[i] + a[i - l]) % P;\n    cdq(mid + 1, r);\n    return;\n}\nvoid solve()\n{\n    int n;\n    cin >> n;\n    f.resize(n);\n    g.resize(n);\n    for (int i = 1; i < n; i++)\n    {\n        cin >> g[i];\n    }\n    g[0] = 0;\n    cdq(0, n - 1);\n    for (int i = 0; i < n; i++)\n    {\n        cout << f[i] << \" \";\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.5 Poly.h, with NTT&Modint.h\n\n```cpp\n/**   多项式相关（Poly, with. MInt & MLong）\n *    2023-09-20: https://atcoder.jp/contests/arc163/submissions/45737810\n *    2024-07-28: https://codeforces.com/contest/1991/submission/273204889\n **/\n#ifndef __POLYS_H__\n#define __POLYS_H__\n#include <bits/stdc++.h>\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\nusing i64 = long long;\nstd::vector<int> rev;\ntemplate <int P>\nstd::vector<MInt<P>> roots{0, 1};\n\ntemplate <int P>\nconstexpr MInt<P> findPrimitiveRoot()\n{\n    MInt<P> i = 2;\n    int k = __builtin_ctz(P - 1);\n    while (true)\n    {\n        if (power(i, (P - 1) / 2) != 1)\n        {\n            break;\n        }\n        i += 1;\n    }\n    return power(i, (P - 1) >> k);\n}\n\ntemplate <int P>\nconstexpr MInt<P> primitiveRoot = findPrimitiveRoot<P>();\n\ntemplate <>\nconstexpr MInt<998244353> primitiveRoot<998244353>{31};\n\ntemplate <int P>\nconstexpr void dft(std::vector<MInt<P>> &a)\n{\n    int n = a.size();\n\n    if (int(rev.size()) != n)\n    {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n        {\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        if (rev[i] < i)\n        {\n            std::swap(a[i], a[rev[i]]);\n        }\n    }\n    if (roots<P>.size() < n)\n    {\n        int k = __builtin_ctz(roots<P>.size());\n        roots<P>.resize(n);\n        while ((1 << k) < n)\n        {\n            auto e = power(primitiveRoot<P>, 1 << (__builtin_ctz(P - 1) - k - 1));\n            for (int i = 1 << (k - 1); i < (1 << k); i++)\n            {\n                roots<P>[2 * i] = roots<P>[i];\n                roots<P>[2 * i + 1] = roots<P>[i] * e;\n            }\n            k++;\n        }\n    }\n    for (int k = 1; k < n; k *= 2)\n    {\n        for (int i = 0; i < n; i += 2 * k)\n        {\n            for (int j = 0; j < k; j++)\n            {\n                MInt<P> u = a[i + j];\n                MInt<P> v = a[i + j + k] * roots<P>[k + j];\n                a[i + j] = u + v;\n                a[i + j + k] = u - v;\n            }\n        }\n    }\n}\n\ntemplate <int P>\nconstexpr void idft(std::vector<MInt<P>> &a)\n{\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    MInt<P> inv = (1 - P) / n;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] *= inv;\n    }\n}\n\ntemplate <int P = 998244353>\nstruct Poly : public std::vector<MInt<P>>\n{\n    using Value = MInt<P>;\n\n    Poly() : std::vector<Value>() {}\n    explicit constexpr Poly(int n) : std::vector<Value>(n) {}\n\n    explicit constexpr Poly(const std::vector<Value> &a) : std::vector<Value>(a) {}\n    constexpr Poly(const std::initializer_list<Value> &a) : std::vector<Value>(a) {}\n\n    template <class InputIt, class = std::_RequireInputIter<InputIt>>\n    explicit constexpr Poly(InputIt first, InputIt last) : std::vector<Value>(first, last) {}\n    /*\n    @brief 通过函数生成多项式\n    @param n 生成的多项式的长度\n    @param f 生成多项式的函数\n    */\n    template <class F>\n    explicit constexpr Poly(int n, F f) : std::vector<Value>(n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            (*this)[i] = f(i);\n        }\n    }\n    /*\n    @brief 多项式位移\n    @param k 位移的距离，正数表示各项乘以 x^k，负数表示各项除以 x^k\n    @return 位移后的多项式\n    */\n    constexpr Poly shift(int k) const\n    {\n        if (k >= 0)\n        {\n            auto b = *this;\n            b.insert(b.begin(), k, 0);\n            return b;\n        }\n        else if (this->size() <= -k)\n        {\n            return Poly();\n        }\n        else\n        {\n            return Poly(this->begin() + (-k), this->end());\n        }\n    }\n    // 多项式重塑，将多项式的长度调整为 k\n    constexpr Poly trunc(int k) const\n    {\n        Poly f = *this;\n        f.resize(k);\n        return f;\n    }\n    // 多项式加法\n    constexpr friend Poly operator+(const Poly &a, const Poly &b)\n    {\n        Poly res(std::max(a.size(), b.size()));\n        for (int i = 0; i < a.size(); i++)\n        {\n            res[i] += a[i];\n        }\n        for (int i = 0; i < b.size(); i++)\n        {\n            res[i] += b[i];\n        }\n        return res;\n    }\n    // 多项式减法\n    constexpr friend Poly operator-(const Poly &a, const Poly &b)\n    {\n        Poly res(std::max(a.size(), b.size()));\n        for (int i = 0; i < a.size(); i++)\n        {\n            res[i] += a[i];\n        }\n        for (int i = 0; i < b.size(); i++)\n        {\n            res[i] -= b[i];\n        }\n        return res;\n    }\n    // 多项式取负\n    constexpr friend Poly operator-(const Poly &a)\n    {\n        std::vector<Value> res(a.size());\n        for (int i = 0; i < int(res.size()); i++)\n        {\n            res[i] = -a[i];\n        }\n        return Poly(res);\n    }\n    // 多项式乘法，NTT快速数论变换\n    constexpr friend Poly operator*(Poly a, Poly b)\n    {\n        if (a.size() == 0 || b.size() == 0)\n        {\n            return Poly();\n        }\n        if (a.size() < b.size())\n        {\n            std::swap(a, b);\n        }\n        int n = 1, tot = a.size() + b.size() - 1;\n        while (n < tot)\n        {\n            n *= 2;\n        }\n        if (((P - 1) & (n - 1)) != 0 || b.size() < 128)\n        {\n            Poly c(a.size() + b.size() - 1);\n            for (int i = 0; i < a.size(); i++)\n            {\n                for (int j = 0; j < b.size(); j++)\n                {\n                    c[i + j] += a[i] * b[j];\n                }\n            }\n            return c;\n        }\n        a.resize(n);\n        b.resize(n);\n        dft(a);\n        dft(b);\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] *= b[i];\n        }\n        idft(a);\n        a.resize(tot);\n        return a;\n    }\n    constexpr friend Poly operator*(Value a, Poly b)\n    {\n        for (int i = 0; i < int(b.size()); i++)\n        {\n            b[i] *= a;\n        }\n        return b;\n    }\n    constexpr friend Poly operator*(Poly a, Value b)\n    {\n        for (int i = 0; i < int(a.size()); i++)\n        {\n            a[i] *= b;\n        }\n        return a;\n    }\n    constexpr friend Poly operator/(Poly a, Value b)\n    {\n        for (int i = 0; i < int(a.size()); i++)\n        {\n            a[i] /= b;\n        }\n        return a;\n    }\n    constexpr Poly &operator+=(Poly b)\n    {\n        return (*this) = (*this) + b;\n    }\n    constexpr Poly &operator-=(Poly b)\n    {\n        return (*this) = (*this) - b;\n    }\n    constexpr Poly &operator*=(Poly b)\n    {\n        return (*this) = (*this) * b;\n    }\n    constexpr Poly &operator*=(Value b)\n    {\n        return (*this) = (*this) * b;\n    }\n    constexpr Poly &operator/=(Value b)\n    {\n        return (*this) = (*this) / b;\n    }\n    // 多项式求导\n    constexpr Poly deriv() const\n    {\n        if (this->empty())\n        {\n            return Poly();\n        }\n        Poly res(this->size() - 1);\n        for (int i = 0; i < this->size() - 1; ++i)\n        {\n            res[i] = (i + 1) * (*this)[i + 1];\n        }\n        return res;\n    }\n    // 多项式积分\n    constexpr Poly integr() const\n    {\n        Poly res(this->size() + 1);\n        for (int i = 0; i < this->size(); ++i)\n        {\n            res[i + 1] = (*this)[i] / (i + 1);\n        }\n        return res;\n    }\n    // 多项式求逆，中间m为模多项式长度，即 mod x^m\n    constexpr Poly inv(int m) const\n    {\n        Poly x{(*this)[0].inv()};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x * (Poly{2} - trunc(k) * x)).trunc(k);\n        }\n        return x.trunc(m);\n    }\n    // 多项式求lnx\n    constexpr Poly log(int m) const\n    {\n        return (deriv() * inv(m)).integr().trunc(m);\n    }\n    // 多项式求e^x\n    constexpr Poly exp(int m) const\n    {\n        Poly x{1};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x * (Poly{1} - x.log(k) + trunc(k))).trunc(k);\n        }\n        return x.trunc(m);\n    }\n    // 多项式快速幂\n    constexpr Poly pow(int k, int m) const\n    {\n        int i = 0;\n        while (i < this->size() && (*this)[i] == 0)\n        {\n            i++;\n        }\n        if (i == this->size() || 1LL * i * k >= m)\n        {\n            return Poly(m);\n        }\n        Value v = (*this)[i];\n        auto f = shift(-i) * v.inv();\n        return (f.log(m - i * k) * k).exp(m - i * k).shift(i * k) * power(v, k);\n    }\n    // 多项式开根\n    constexpr Poly sqrt(int m) const\n    {\n        Poly x{1};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x + (trunc(k) * x.inv(k)).trunc(k)) * CInv<2, P>;\n        }\n        return x.trunc(m);\n    }\n    // 多项式转置乘法，计算F(x)*G(1/x)的结果，抹掉负次方项\n    constexpr Poly mulT(Poly b) const\n    {\n        if (b.size() == 0)\n        {\n            return Poly();\n        }\n        int n = b.size();\n        std::reverse(b.begin(), b.end());\n        return ((*this) * b).shift(-(n - 1));\n    }\n    // 多项式多点求值\n    constexpr std::vector<Value> eval(std::vector<Value> x) const\n    {\n        if (this->size() == 0)\n        {\n            return std::vector<Value>(x.size(), 0);\n        }\n        const int n = std::max(x.size(), this->size());\n        std::vector<Poly> q(4 * n);\n        std::vector<Value> ans(x.size());\n        x.resize(n);\n        std::function<void(int, int, int)> build = [&](int p, int l, int r)\n        {\n            if (r - l == 1)\n            {\n                q[p] = Poly{1, -x[l]};\n            }\n            else\n            {\n                int m = (l + r) / 2;\n                build(2 * p, l, m);\n                build(2 * p + 1, m, r);\n                q[p] = q[2 * p] * q[2 * p + 1];\n            }\n        };\n        build(1, 0, n);\n        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num)\n        {\n            if (r - l == 1)\n            {\n                if (l < int(ans.size()))\n                {\n                    ans[l] = num[0];\n                }\n            }\n            else\n            {\n                int m = (l + r) / 2;\n                work(2 * p, l, m, num.mulT(q[2 * p + 1]).trunc(m - l));\n                work(2 * p + 1, m, r, num.mulT(q[2 * p]).trunc(r - m));\n            }\n        };\n        work(1, 0, n, mulT(q[1].inv(n)));\n        return ans;\n    }\n};\n\ntemplate <int P = 998244353>\nPoly<P> berlekampMassey(const Poly<P> &s)\n{\n    Poly<P> c;\n    Poly<P> oldC;\n    int f = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        auto delta = s[i];\n        for (int j = 1; j <= c.size(); j++)\n        {\n            delta -= c[j - 1] * s[i - j];\n        }\n        if (delta == 0)\n        {\n            continue;\n        }\n        if (f == -1)\n        {\n            c.resize(i + 1);\n            f = i;\n        }\n        else\n        {\n            auto d = oldC;\n            d *= -1;\n            d.insert(d.begin(), 1);\n            MInt<P> df1 = 0;\n            for (int j = 1; j <= d.size(); j++)\n            {\n                df1 += d[j - 1] * s[f + 1 - j];\n            }\n            assert(df1 != 0);\n            auto coef = delta / df1;\n            d *= coef;\n            Poly<P> zeros(i - f - 1);\n            zeros.insert(zeros.end(), d.begin(), d.end());\n            d = zeros;\n            auto temp = c;\n            c += d;\n            if (i - temp.size() > f - oldC.size())\n            {\n                oldC = temp;\n                f = i;\n            }\n        }\n    }\n    c *= -1;\n    c.insert(c.begin(), 1);\n    return c;\n}\n\ntemplate <int P = 998244353>\nMInt<P> linearRecurrence(Poly<P> p, Poly<P> q, i64 n)\n{\n    int m = q.size() - 1;\n    while (n > 0)\n    {\n        auto newq = q;\n        for (int i = 1; i <= m; i += 2)\n        {\n            newq[i] *= -1;\n        }\n        auto newp = p * newq;\n        newq = q * newq;\n        for (int i = 0; i < m; i++)\n        {\n            p[i] = newp[i * 2 + n % 2];\n        }\n        for (int i = 0; i <= m; i++)\n        {\n            q[i] = newq[i * 2];\n        }\n        n /= 2;\n    }\n    return p[0] / q[0];\n}\n\nstruct Comb\n{\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n\n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb()\n    {\n        init(n);\n    }\n\n    void init(int m)\n    {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n)\n            return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n\n        for (int i = n + 1; i <= m; i++)\n        {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--)\n        {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n\n    Z fac(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m)\n    {\n        if (n < m || m < 0)\n            return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nPoly<P> get(int n, int m)\n{\n    if (m == 0)\n    {\n        return Poly(n + 1);\n    }\n    if (m % 2 == 1)\n    {\n        auto f = get(n, m - 1);\n        Z p = 1;\n        for (int i = 0; i <= n; i++)\n        {\n            f[n - i] += comb.binom(n, i) * p;\n            p *= m;\n        }\n        return f;\n    }\n    auto f = get(n, m / 2);\n    auto fm = f;\n    for (int i = 0; i <= n; i++)\n    {\n        fm[i] *= comb.fac(i);\n    }\n    Poly pw(n + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        pw[i] = pw[i - 1] * (m / 2);\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        pw[i] *= comb.invfac(i);\n    }\n    fm = fm.mulT(pw);\n    for (int i = 0; i <= n; i++)\n    {\n        fm[i] *= comb.invfac(i);\n    }\n    return f + fm;\n}\n#endif\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.6 多项式求逆\n\n给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \\equiv 1 \\pmod{x^n}$。系数对 $998244353$ 取模。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$ 0 \\leq a_i \\leq 10^9$​。\n\n工作原理：\n\n我们不妨假设，$n=2^k$,$k\\in N$。\n\n若$n=1$，则$A(x)×B(x)≡a_0×b_0≡1(mod\\  x^1)$,其中$a_0$，$b_0$表示多项式$A$和多项式$B$的常数项。\n\n若需要求出$b_0$，直接用费马小定理求出$a_0$的乘法逆元即可。\n\n当$n>1$时：\n\n我们假设在模$x^{\\frac{n}{2}}$的意义下$A(x)$的逆元$B^′(x)$我们已经求得。\n\n依据定义，则有\n\n$A(x)B^′(x)≡1(mod\\  x^{\\frac{n}{2}})$ (1)\n\n对(1)式进行移项得\n\n$A(x)B^′(x)−1≡0(mod\\ x^{\\frac{n}{2}})$ (2)\n\n然后对(2)式等号两边平方，得\n\n$A^2(x)B^{′2}(x)−2A(x)B^′(x)+1≡0(mod\\  x^n)$ (3)\n\n将常数项移动到等式右侧，得\n\n$A^2(x)B^{′2}(x)−2A(x)B^′(x)≡−1(mod\\  x^n)$ (4)\n\n将等式两边去相反数，得\n\n$2A(x)B^′(x)−A^2(x)B^{′2}(x)≡1(mod\\  x^n)$ (5)\n\n下面考虑回我们需要求的多项式$B(x)$，依据定义，其满足\n\n$A(x)B(x)≡1(mod\\ x^n)$ (6)\n\n将(5)−(6)并移项，得\n\n$A(x)B(x)≡2A(x)B^′(x)−A^2(x)B^{′2}(x)(mod\\  x^n)$ (7)\n\n等式两边约去$A(x)$，得\n\n$B(x)≡2B′(x)−A(x)B^{′2}(x)(mod\\  x^n)$ (8)\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &i : a)\n        cin >> i;\n    Poly<P> A(a);\n    Poly<P> invA = A.inv(n);\n    for (auto &i : invA)\n    {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.7 多项式除法\n\n***严格注意：多项式除法不可以拿来做高精度除法！因为多项式除法做了取余数的操作！相当于扣了项的系数！***\n\n给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：\n\n - $Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$\n - $F(x) = Q(x)  G(x) + R(x)$\n\n所有的运算在模 $998244353$ 意义下进行。   \n\n如果 $R(x)$ 不足 $m-1$ 次，多余的项系数补 $0$。\n\n对于所有数据，$1 \\le m < n \\le 10^5$，给出的系数均属于 $[0, 998244353) \\cap \\mathbb{Z}$。\n\n$N$次多项式$A(x)$的系数$vector$进行一次$reverse$后表示的是$A(\\frac{1}{x})x^N$的系数。\n\n故求多项式除法$A(x)=B(x)C(x)+D(x)$时，考虑$x^NA(\\frac{1}{x})=x^MB(\\frac{1}{x})x^{N-M}C(\\frac{1}{x})+D(\\frac{1}{x})$\n\n多项式对$x^{N-M+1}$求模，$D(x)$消失，有$x^{N-M}C(\\frac{1}{x})\\equiv \\frac{A^{'}(x)}{B^{'}(x)}$\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<Z> a(n + 1), b(k + 1);\n    for (auto &i : a)\n        cin >> i;\n    for (auto &i : b)\n        cin >> i;\n    Poly<P> A(a), B(b);\n    reverse(A.begin(), A.end());\n    reverse(B.begin(), B.end());\n    A.resize(n - k + 1);\n    B.resize(n - k + 1);\n    Poly<P> C = A * (B.inv(n - k + 1));\n    C.resize(n - k + 1);\n    reverse(C.begin(), C.end());\n    for (auto &i : C)\n        cout << i << \" \";\n    cout << endl;\n    Poly<P> D = Poly<P>(a) - Poly<P>(b) * C;\n    D.resize(k);\n    for (auto &i : D)\n        cout << i << \" \";\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.8 多项式对数\n\n求个导再积分就行。\n\n给定多项式$A(x)$，求$B(x)$使得$B(x)\\equiv lnA(x)\\ (mod\\ x^n)$，保证$a_0=1$\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &x : a)\n        cin >> x;\n    Poly<P> p(a);\n    auto b = p.log(n);\n    for (auto x : b)\n        cout << x << ' ';\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.9 多项式自然指数\n\n给定多项式$A(x)$，求$B(x)$使得$B(x)\\equiv e^{A(x)}\\ (mod\\ x^n)$，保证$a_0=0$​\n\n函数求导，牛顿迭代法。\n\n先从牛顿迭代讲起。 \n\n已知多项式函数$G(z)$，求多项式函数$F(x)$满足 $$G(F(x))\\equiv0 \\pmod{x^n}$$ \n\n考虑用迭代求解，假设我们已经求得$F_0(x)$满足 $$G(F_0(x))\\equiv0\\pmod{x^{\\left\\lceil\\frac{n}{2}\\right\\rceil}}$$ \n\n将函数$G$在$z=F_0(x)$处进行泰勒展开 $$G(F(x))=\\sum_{i=1}^{\\infty}\\frac{G^i(F_0(x))}{i!}(F(x)-F_0(x))^i$$ ,其中$G^i$为$G$的$i$阶导函数. \n\n取前两项 $$G(F(x))\\equiv G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))\\pmod{x^n}$$ \n\n考虑到$G(F(x))\\equiv 0\\pmod{x^n}$ $$F(x)\\equiv F_0(x)-\\frac{G(F_0(x))}{G'(F_0(x))}\\pmod{x^n}$$ \n\n边界条件即$f[0]=e^{a_0}$，向上迭代即可. \n\n回到本题，考虑到 $$B(x)\\equiv e^{A(x)}\\pmod{x^n}$$ \n\n即 $$\\ln B(x)-A(x)\\equiv0\\pmod{x^n}$$ \n\n于是令 $$G(B(x))\\equiv\\ln B(x)-A(x)\\pmod{x^n}$$ \n\n由于$A(x)$为常数， $$G'(B(x))=B^{-1}(x)$$ ，套牛顿迭代 $$B(x)\\equiv B_0(x)(1-\\ln B_0(x)+A(x))\\pmod{x^n}$$\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &x : a)\n        cin >> x;\n    Poly<P> p(a);\n    auto b = p.exp(n);\n    for (auto x : b)\n        cout << x << ' ';\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.10 多项式多点求值\n\n原理不会，抄就行。\n\n给定一个 $n$ 次多项式 $f(x)$ ，现在请你对于 $i \\in [1,m]$ ，求出 $f(a_i)$ 。***注意是$n$次，意味着有$n+1$项***。\n\n$n,m \\in [1,64000]$，$a_i,[x^i]f(x) \\in [0,998244352]$ 。\n\n$[x^i]f(x)$ 表示 $f(x)$ 的 $i$​ 次项系数。\n\n```cpp\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    Poly<P> f(n + 1);\n    for (auto &v : f)\n    {\n        cin >> v;\n    }\n    vector<Z> x(m);\n    for (auto &v : x)\n    {\n        cin >> v;\n    }\n    auto fx = f.eval(x);\n    for (auto v : fx)\n    {\n        cout << v << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.11 多项式快速插值/拉格朗日快速插值\n\n以下默认$mid=\\lfloor\\frac{l+r}{2}\\rfloor$\n\n由拉格朗日差值公式$\\large F(x)=\\sum_{i=1}^n y_i\\prod_{j\\neq i}\\frac{x-x_j}{x_i-x_j}$化简得到\n$$\n\\large F(x)=\\sum_{i=1}^n \\frac{y_i}{\\prod_{j\\neq i}(x_i-x_j)}\\prod_{j\\neq i}(x-x_j)\n$$\n设$\\large \\delta(x)=\\prod_{i=1}^n(x-x_i)$，则显然有洛必达法则下，$\\large \\prod_{j\\neq i}(x_i-x_j)=\\lim_{x\\to x_i}\\frac{\\delta(x)}{x-x_i}=\\delta'(x_i)$\n\n对$\\delta(x)$分治$NTT$（类似快速幂那种就行了），求导后多点求值得到$\\delta'(x_i)$.\n\n接下来继续正宗分治$NTT$即可，设$G_{l,r}(x)=\\prod_{i=l}^r(x-x_i)$，$H_{l,r}$为$(x_l,y_l),\\cdots,(x_r,y_r)$插出来的多项式，即$\\sum_{i=l}^r \\frac{y_i}{\\delta'(x_i)}\\prod_{j\\neq i,l\\le j\\le r}(x-x_j)$，则有\n$$\nG_{l,r}=G_{l,mid}\\ \\cdot\\ G_{mid+1,r}\\\\\nH_{l,r}=H_{l,mid}\\ \\cdot G_{mid+1,r}\\ +\\ H_{mid+1,r}\\ \\cdot\\ G_{l,mid}\n$$\n\n\n分治$NTT$即可。复杂度$O(nlog^2n)$\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.12 二维卷积\n\n$$\n\\large s_{i,j}=\\sum_{x_1\\circ x_2=i,y_1*y_2=j}a_{x_1,y_1}\\times b_{x_2,y_2}\n$$\n\n分5步：\n\n1.对$a$和$b$的每一行做普通$DFT$或对应$FWT$\n\n2.对$a$和$b$的每一列做普通$DFT/FWT$\n\n3.新建矩阵$s$，$s_{i,j}=a_{i,j}b_{i,j}$\n\n4.对$s$的每一**列**做普通$IDFT/IFWT$(别忘了做完之后乘上每列长度的逆元)\n\n5.对$s$的每一**行**做普通$IDFT/IFWT$(别忘了做完之后乘上每行长度的逆元)\n\n然后$s$就是要求的结果了。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.13 普通生成函数操作\n\n普通生成函数操作组合数学计数问题。\n\n举一个例子：\n\n一个长度为$n$的数列，从中取出$s$个数，要求异或结果为$k$的方案数。\n\n操纵生成函数：\n$$\nF(x,y)=\\prod_{i=1}^n(1+x^{a_i}y)\n$$\n这里$x$为异或卷积，$y$为正卷积。\n\n则答案为$[x^{k}y^s]F(x,y)$，即对应项系数。一般不会有二维的情况，二维显然无法确定单位根，一般是需要暴力卷积的。本生成函数原题$ABC367G$中$y$是一个长度不超过$100$​的循环卷积，问题只在快速沃尔什变换上。\n\n考虑对$1+x^{a_i}y$进行快速沃尔什点值变换，记变换后的点值序列为$FWT(x^{a_i})=\\{g_{a_i}^{w}\\}$，则由于将$y$于此维度视作常数，由于沃尔什变换线性性有$FWT(1+x^{a_i}y)=\\{1+g_{a_i}^{w}y\\}$​.\n\n由于沃尔什变换特性，幂次函数$x^n$的沃尔什变换序列只有$1$和$-1$两种情况，所以沃尔什序列对应位置点值相乘后有$FWT(F(x,y))_w=[y^0]\\prod_{i=1}^n(1+y)^{c_w}(1-y)^{n-c_w}$，其中$c_w$为$FWT(x_{a_i})_w$为$1$的$i$的数量。关于$c_w$显然有$c_w+(n-c_w)\\times(-1)=\\sum_{i=1}^nh_{a_i}^w$，等式右边可以由$\\sum_{i=1}^nx^{a_i}$快速沃尔什变换得到（$FWT$线性性）\n\n由于$y$​维度很小，暴力卷积卷出来，最后快速沃尔什逆变换后就是结果多项式，直接锁结果就行了。\n\n```cpp\nvector<int> f, a, b, finalans;\nvector<vector<int>> presum, presum2;\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    f.assign(1 << 20, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        f[x]++;\n    }\n    a = fwt_xor(f);\n    for (int i = 0; i < (1 << 20); i++)\n    {\n        a[i] = ((n + a[i]) % mod * (499122177)) % mod;\n    }\n    // 暴力预处理循环卷积(1+y)^a 以及(1-y)^a\n    presum.assign(n + 1, vector<int>(m + 1)), presum2 = presum;\n    presum[0][0] = presum2[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            presum[i][j] = (presum[i][j] + presum[i - 1][j]) % mod;                              //(1+y)\n            presum[i][(j + 1) % m] = (presum[i][(j + 1) % m] + presum[i - 1][j]) % mod;          //(1+y)\n            presum2[i][j] = (presum2[i][j] + presum2[i - 1][j]) % mod;                           //(1-y)\n            presum2[i][(j + 1) % m] = (presum2[i][(j + 1) % m] - presum2[i - 1][j] + mod) % mod; //(1-y)\n        }\n    }\n    finalans.assign(1 << 20, 0);\n    for (int i = 0; i < (1 << 20); i++) // 快速沃尔什变换第i位的值\n    {                                   //(1+y)^(a[i])*(1-y)^(n-a[i])\n                                        // 求y^0，即y^m项\n        for (int j = 0; j < m; j++)\n        {\n            finalans[i] = (finalans[i] + (presum[a[i]][j] * presum2[n - a[i]][(m - j) % m] % mod)) % mod;\n        }\n    }\n    b = ifwt_xor(finalans);\n    i64 ans = 0;\n    for (int i = 0; i < (1 << 20); i++)\n    {\n        ans = (ans + b[i] * power(i, k) % mod) % mod;\n    }\n    cout << ans << endl;\n}\n```\n\n其他见$OI-Wiki$\n\n#### 3.14 指数生成函数操作\n\n操纵排列数学计数问题。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 4. 计算几何相关\n\n#### 4.1 平面几何（with Complex)\n\n```cpp\n/**   平面几何（with. complex）\n *    2023-09-04: https://qoj.ac/submission/164445\n**/\nusing Point = std::complex<long double>;\n\n#define x real\n#define y imag\n\nlong double dot(const Point &a, const Point &b) {\n    return (std::conj(a) * b).x();\n}\n\nlong double cross(const Point &a, const Point &b) {\n    return (std::conj(a) * b).y();\n}\n\nlong double length(const Point &a) {\n    return std::sqrt(dot(a, a));\n}\n\nlong double dist(const Point &a, const Point &b) {\n    return length(a - b);\n}\n\nlong double get(const Point &a, const Point &b, const Point &c, const Point &d) {\n    auto e = a + (b - a) * cross(c - a, d - a) / cross(b - a, d - c);\n    return dist(d, e);\n}\n```\n\n#### 4.2 二维凸包+旋转卡壳（凸包直径）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// #define DEBUG 1\n#define i64 long long\n#define d32 double\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e6 + 9;\nstruct node\n{\n    i64 x, y;\n    bool operator<(const node &a) const\n    {\n        return x == a.x ? y < a.y : x < a.x;\n    }\n    bool operator==(const node &a) const\n    {\n        return x == a.x && y == a.y;\n    }\n    node operator-(const node &a) const\n    {\n        return {x - a.x, y - a.y};\n    }\n    i64 operator*(const node &a) const\n    {\n        return x * a.y - y * a.x;\n    }\n    i64 operator^(const node &a) const\n    {\n        return x * a.x + y * a.y;\n    }\n    node operator+(const node &a) const\n    {\n        return {x + a.x, y + a.y};\n    }\n    friend d32 dis(node a, node b)\n    {\n        return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    friend i64 dis2(node a, node b)\n    {\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n};\nint stk[N], tp = 0;\nbool used[N];\n\n//返回的vector0位空出，最后一位为第一个点\nvector<node> get_convex(node p[], int n)\n{\n    // stk[] 是整型，存的是下标\n    // p[] 存储向量或点\n    // h[] 存储凸包上的点\n    // used[] 标记是否在凸包上\n    // tp 栈顶指针\n    tp = 0; // 初始化栈\n            // 标记是否在凸包上\n    for (int i = 1; i <= n; i++)\n    {\n        used[i] = 0;\n    }\n    std::sort(p + 1, p + 1 + n); // 对点进行排序\n    stk[++tp] = 1;\n    // 栈内添加第一个元素，且不更新 used，使得 1 在最后封闭凸包时也对单调栈更新\n    for (int i = 2; i <= n; ++i)\n    {\n        while (tp >= 2 // 下一行 * 操作符被重载为叉积\n               && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n            used[stk[tp--]] = 0;\n        used[i] = 1; // used 表示在凸壳上\n        stk[++tp] = i;\n    }\n    int tmp = tp; // tmp 表示下凸壳大小\n    for (int i = n - 1; i > 0; --i)\n        if (!used[i])\n        {\n            // ↓求上凸壳时不影响下凸壳\n            while (tp > tmp && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n                used[stk[tp--]] = 0;\n            used[i] = 1;\n            stk[++tp] = i;\n        }\n    vector<node> h;\n    h.push_back({-INF, -INF});    // 从 1 开始存储凸包上的点\n    for (int i = 1; i <= tp; ++i) // 复制到新数组中去\n        h.push_back(p[stk[i]]);\n    int ans = tp - 1;\n    return h;\n}\nbool is[N];\n// 求凸包直径，返回直径的平方\ni64 get_longest(vector<node> sta)\n{\n#ifdef DEBUG\n    cout << \"-------------------DEBUG-------------------\" << endl;\n    cout << \"points in convex hull:\" << endl;\n    for (auto i : sta)\n    {\n        cout << i.x << \" \" << i.y << endl;\n    }\n    cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n    i64 mx = 0;               // 求凸包直径\n    int top = sta.size() - 1; // 将凸包上的节点编号存在栈里，第一个和最后一个节点编号相同\n    int j = 3;\n    if (top < 4)\n    {\n        mx = dis2(sta[1], sta[2]);\n        return mx;\n    }\n    for (int i = 1; i < top; i++)\n    {\n        while ((sta[i + 1] - sta[i]) * (sta[j] - sta[i + 1]) <= (sta[i + 1] - sta[i]) * (sta[j % top + 1] - sta[i + 1]))\n        {\n#ifdef DEBUG\n            cout << \"-------------------DEBUG-------------------\" << endl;\n            cout << \"i=\" << i << \" j=\" << j << endl;\n            cout << \"sta[i]=\" << sta[i].x << \" \" << sta[i].y << endl;\n            cout << \"sta[i+1]=\" << sta[i + 1].x << \" \" << sta[i + 1].y << endl;\n            cout << \"sta[j]=\" << sta[j].x << \" \" << sta[j].y << endl;\n            cout << \"sta[j%top+1]=\" << sta[j % top + 1].x << \" \" << sta[j % top + 1].y << endl;\n            cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n            j = j % top + 1;\n        }\n#ifdef DEBUG\n        cout << \"-------------------DEBUG-------------------\" << endl;\n        cout << \"mx=\" << mx << endl;\n        cout << \"dis2(sta[\" << i << \"],sta[\" << j << \"])=\" << dis2(sta[i], sta[j]) << endl;\n        cout << \"dis2(sta[\" << i + 1 << \"],sta[\" << j << \"])=\" << dis2(sta[i + 1], sta[j]) << endl;\n        cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n        mx = max(mx, max(dis2(sta[i], sta[j]), dis2(sta[i + 1], sta[j])));\n    }\n    return mx;\n}\nnode a[N + 1], b[N + 1];\nvoid solve()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i].x >> a[i].y;\n    }\n    vector<node> h = get_convex(a, n);\n    int cnt = h.size() - 2;\n    d32 C = 0;\n    for (int i = 1; i <= cnt; i++)\n    {\n        C += dis(h[i], h[i + 1]);\n    }\n\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> b[i].x >> b[i].y;\n    }\n    h.clear();\n    h = get_convex(b, n);\n    d32 D = sqrtl(get_longest(h));\n    // cout << C << endl;\n    cout << fixed << setprecision(10) << C + 2 * M_PI * D << endl;\n    return;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5. 组合数学相关\n\n#### 5.1 组合数杨辉三角+线性递推逆元\n\n```cpp\n#include<iostream>\n\nusing namespace std;\nint n,m;\nint f[1005][1005];\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n    {\n        f[i][i]=1;\n        f[i][0]=1;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            f[i][j]=f[i-1][j]+f[i-1][j-1];\n    cout<<f[n][m];\n    return 0;\n}\n\n```\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod;\nconst int maxn = 6e6 + 9;\nint inv[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a;\n    cin >> a >> mod;\n    inv[1] = 1;\n    cout << 1 << endl;\n    for (int i = 2; i <= a; i++)\n    {\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n        cout << inv[i] << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 5.2 卢卡斯定理/扩展卢卡斯定理\n\n$$\nC_n^{m}\\ mod\\ p=C_{\\lfloor \\frac{n}{p}\\rfloor}^{\\lfloor \\frac{m}{p}\\rfloor}\\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p}\\ mod \\ p\n$$\n\n强制要求$p$为质数。复杂度$O(p+Tlogn)$\n\n```cpp\nlong long C(long long n,long long m,long long mod)\n{\n    if(m>n&&n==0)return 0;\n    if(m==0)return 1;\n    return ((frac[n]*invq[m]%mod)*invq[n-m])%mod;\n}\n//阶乘的值和逆元预处理是线性的递推\nlong long Lucas(long long n, long long m, long long p)\n{\n    if (m == 0)\n        return 1;\n    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;\n}\n```\n\n对于扩展卢卡斯定理，不再要求$p$必须是质数，原理见$OI-Wiki$。注意，单次询问$O(plogp)$复杂度，基本不可能支持大量次数询问。模板也是仅支持查询一次的。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <climits>\n#include <cmath>\nusing namespace std;\nnamespace ExLucas\n{\n    const int N = 1e6;\n    typedef long long ll;\n    ll n, m, p;\n    inline ll power(ll a, ll b, const ll p = LLONG_MAX)\n    {\n        ll ans = 1;\n        while (b)\n        {\n            if (b & 1)\n                ans = ans * a % p;\n            a = a * a % p;\n            b >>= 1;\n        }\n        return ans;\n    }\n    ll fac(const ll n, const ll p, const ll pk)\n    {\n        if (!n)\n            return 1;\n        ll ans = 1;\n        for (int i = 1; i < pk; i++)\n            if (i % p)\n                ans = ans * i % pk;\n        ans = power(ans, n / pk, pk);\n        for (int i = 1; i <= n % pk; i++)\n            if (i % p)\n                ans = ans * i % pk;\n        return ans * fac(n / p, p, pk) % pk;\n    }\n    ll exgcd(const ll a, const ll b, ll &x, ll &y)\n    {\n        if (!b)\n        {\n            x = 1, y = 0;\n            return a;\n        }\n        ll xx, yy, g = exgcd(b, a % b, xx, yy);\n        x = yy;\n        y = xx - a / b * yy;\n        return g;\n    }\n    ll inv(const ll a, const ll p)\n    {\n        ll x, y;\n        exgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n    ll C(const ll n, const ll m, const ll p, const ll pk)\n    {\n        if (n < m)\n            return 0;\n        ll f1 = fac(n, p, pk), f2 = fac(m, p, pk), f3 = fac(n - m, p, pk), cnt = 0;\n        for (ll i = n; i; i /= p)\n            cnt += i / p;\n        for (ll i = m; i; i /= p)\n            cnt -= i / p;\n        for (ll i = n - m; i; i /= p)\n            cnt -= i / p;\n        return f1 * inv(f2, pk) % pk * inv(f3, pk) % pk * power(p, cnt, pk) % pk;\n    }\n    ll a[N], c[N];\n    int cnt;\n    inline ll CRT()\n    {\n        ll M = 1, ans = 0;\n        for (int i = 0; i < cnt; i++)\n            M *= c[i];\n        for (int i = 0; i < cnt; i++)\n            ans = (ans + a[i] * (M / c[i]) % M * inv(M / c[i], c[i]) % M) % M;\n        return ans;\n    }\n    ll exlucas(const ll n, const ll m, ll p)\n    {\n        ll tmp = sqrt(p);\n        for (int i = 2; p > 1 && i <= tmp; i++)\n        {\n            ll tmp = 1;\n            while (p % i == 0)\n                p /= i, tmp *= i;\n            if (tmp > 1)\n                a[cnt] = C(n, m, i, tmp), c[cnt++] = tmp;\n        }\n        if (p > 1)\n            a[cnt] = C(n, m, p, p), c[cnt++] = p;\n        return CRT();\n    }\n    int work()\n    {\n        ios::sync_with_stdio(false);\n        cin >> n >> m >> p;\n        cout << exlucas(n, m, p);\n        return 0;\n    }\n}\nint main()\n{\n    return zyt::work();\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 5.3 $Catlan$数与$Fibonacci$数列\n\n$H_n=\\frac{2n!}{n+1},n\\ge 2$，维护一种绝对大于等于的关系，比如固定入栈顺序，有多少种出栈顺序（保证栈内元素数量一定大于等于总出栈元素数量）​\n\n数列皮亚诺周期不超过$6k$，$k$​为模数。强行解周期可以考虑矩阵原根计算，因为矩阵$mod$$p$最小周期是皮亚诺周期，所以根号开$\\sqrt {6k+1}$.\n\n```cpp\n#include <bits/stdc++.h>\n#define umap unordered_map\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstring S;\nll MOD;\n\nconst int L = 2;\nconst ull BASE = 13331;\nstruct Matrix {\n    ll M[L+1][L+1];\n    ll *operator[](int p) {\n        return M[p];\n    }\n    void clear() {\n        memset(M, 0, sizeof M);\n    }\n    void reset() {\n        clear();\n        for (int i = 1; i <= L; i++)\n            M[i][i] = 1;\n    }\n    Matrix friend operator*(Matrix A, Matrix B) {\n        Matrix C; C.clear();\n        for (int i = 1; i <= L; i++)\n            for (int k = 1; k <= L; k++)\n                for (int j = 1; j <= L; j++)\n                    (C[i][j] += A[i][k] * B[k][j] % MOD) %= MOD;\n        return C;\n    }\n    ull hs() { // hash\n        ull ret = 0;\n        for (int i = 1; i <= L; i++)\n            for (int j = 1; j <= L; j++)\n                ret = ret * BASE + M[i][j];\n        return ret;\n    }\n\n};\nMatrix qpow(Matrix A, ll b) {\n    Matrix Ret; Ret.reset();\n    while (b) {\n        if (b & 1)\n            Ret = Ret * A;\n        A = A * A;\n        b >>= 1;\n    }\n    return Ret;\n}\n\nll BSGS(Matrix A, Matrix B) {\n    umap<ull, ll> mp;\n    ll t = sqrt(MOD * 6) + 1;\n    Matrix Cur; Cur.reset();\n    for (ll i = 1; i <= t; i++) {\n        mp[(Cur * B).hs()] = i-1;\n        Cur = A * Cur;\n    }\n    Matrix Cur2 = Cur;\n    for (ll i = 1; i <= t; i++) {\n        if (mp.find(Cur2.hs()) != mp.end())\n            return i * t - mp[Cur2.hs()];\n        Cur2 = Cur * Cur2;\n    }\n    return -1;\n}\n\nMatrix A, I;\nvoid init() {\n    A[1][1] = 1; A[1][2] = 1;\n    A[2][1] = 1; A[2][2] = 0;\n\n    I[1][1] = 1; I[1][2] = 0;\n    I[2][1] = 0; I[2][2] = 1;\n}\n\nll fib(ll n) {\n    if (n == 0)\n        return 0;\n    return qpow(A, n-1)[1][1];\n}\n\nint main() { ios::sync_with_stdio(0); cin.tie(0);\n    cin >> S >> MOD;\n    if (MOD == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    init();\n    ll pi = BSGS(A, I);\n    ll n = 0;\n    for (auto c : S)\n        n = (n * 10 + (c - '0')) % pi;\n    cout << fib(n) << endl;\n    return 0;\n}\n```\n\n\n\n查$OI-Wiki$​\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6. 位运算相关技巧杂谈\n\n1. 异或是特殊的矩阵加法，在$<Z_2^n,xor,and>$下。\n2. 连续从$1$到$n$的异或和是有规律的，对于模$4$剩余下有余$1$得$1$，余$2$得$n+1$，余$3$得$0$，余$0$得$n$​.\n3. 区间异或和可表示两个前缀异或的异或和。\n4. 带递归形式的$f(x)=f(\\frac{x}{3})$等之类的关注位运算进制表示规律。\n5. $a+b=2(a\\&b)+(a\\oplus b)$\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 3. 杂项技巧\n\n### 3.1 普通莫队\n\n假设$n=m$,那么对于序列上的区间询问问题,如果从$[l,r]$的答案能够$O(1)$扩展到$[l-1,r],[l+1,r],[l,r+1],[l,r-1]$（即与$[l,r]$相邻的区间）的答案,那么可以在$O(n\\sqrt n)$​的复杂度内求出所有询问的答案。\n\n莫队需要相当牛逼的卡常，基本上禁用一切$mapSTL$，实在必要需要手搓哈希表。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nint block; // 莫队分块大小\nstruct node\n{\n    int l, r, id;\n    bool operator<(const node &x) const\n    {\n        if (l / block != x.l / block)\n            return l < x.l;\n        // 注意下面两行不能写小于（大于）等于，否则会出错（详见下面的小细节）\n        if ((l / block) & 1)\n            return r < x.r;\n        return r > x.r;\n    }\n};\nint sum = 0;\nconst int maxn = 2e5 + 9;\nconst int inf = 1e6 + 9;\nint mp[inf];\nint a[maxn];\nvoid add(int pos)\n{\n    if (mp[a[pos]])\n        sum--;\n    else\n        sum++;\n    mp[a[pos]] ^= 1;\n}\nvoid del(int pos)\n{\n    if (mp[a[pos]])\n        sum--;\n    else\n        sum++;\n    mp[a[pos]] ^= 1;\n}\nint n;\nvoid solve()\n{\n    sum = 0;\n    int n, q;\n    cin >> n >> q;\n    block = sqrt(n);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        mp[a[i]] = 0;\n    }\n    vector<node> qs;\n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        qs.push_back({l, r, i});\n    }\n    vector<int> ans(q);\n    sort(qs.begin(), qs.end());\n    int l = 1, r = 0;\n    for (int i = 0; i < q; i++)//莫队算法灵魂\n    {\n        while (l > qs[i].l)\n            add(--l);\n        while (r < qs[i].r)\n            add(++r);\n        while (l < qs[i].l)\n            del(l++);\n        while (r > qs[i].r)\n            del(r--);\n        ans[qs[i].id] = sum;\n    }\n    for (int i = 0; i < q; i++)\n    {\n        if (ans[i])\n        {\n            cout << \"NO\" << endl;\n        }\n        else\n            cout << \"YES\" << endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.2 带修改莫队\n\n普通莫队算法不支持修改，需要带修改的莫队。带修改莫队唯一的区别就是加上了一个时间戳维度，变成了多维莫队。\n\n然后跳时间戳就行了，改少了就多改，改多了就改回去。\n\n注意，带修改莫队常数较大，分块$n^{\\frac{2}{3}}$，时间复杂度$O(n^{\\frac{5}{3}})$，不要带奇偶排序​\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nint block;\nstruct qnode\n{\n    int l, r, id, t;\n    bool operator<(const qnode &x) const\n    {\n        if (l / block != x.l / block)\n            return l < x.l;\n        if (r / block != x.r / block)\n            return r < x.r;\n        return t < x.t;\n    };\n};\nvector<array<int, 2>> upd(1);\nvector<int> mp(1e7);\nint sum = 0;\nvoid add(int x)\n{\n    mp[x]++;\n    if (mp[x] == 1)\n        sum++;\n}\nvoid del(int x)\n{\n    mp[x]--;\n    if (mp[x] == 0)\n        sum--;\n}\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    block = pow(n, 2.0 / 3);\n    vector<qnode> query;\n    for (int i = 0, cnt = 0; i < q; i++)\n    {\n        char op;\n        cin >> op;\n        if (op == 'Q')\n        {\n            int l, r;\n            cin >> l >> r;\n            query.emplace_back((qnode){l - 1, r - 1, cnt, upd.size() - 1});\n            cnt++;\n        }\n        else\n        {\n            int x, y;\n            cin >> x >> y;\n            upd.push_back({x - 1, y});\n        }\n    }\n    vector<int> ans(query.size());\n    sort(query.begin(), query.end());\n    int l = 0, r = -1, t = 0;\n    stack<array<int, 2>> stk;\n    for (auto &i : query)\n    {\n        while (l > i.l)\n            add(a[--l]);\n        while (r < i.r)\n            add(a[++r]);\n        while (l < i.l)\n            del(a[l++]);\n        while (r > i.r)\n            del(a[r--]);\n        while (t < i.t)\n        {\n            t++;\n            if (l <= upd[t][0] && upd[t][0] <= r)\n            {\n                del(a[upd[t][0]]);\n                add(upd[t][1]);\n            }\n            stk.push({upd[t][0], a[upd[t][0]]});\n            a[upd[t][0]] = upd[t][1];\n        }\n        while (t > i.t)\n        {\n            if (l <= upd[t][0] && upd[t][0] <= r)\n            {\n                del(a[upd[t][0]]);\n                add(stk.top()[1]);\n            }\n            a[upd[t][0]] = stk.top()[1];\n            stk.pop();\n            t--;\n        }\n        ans[i.id] = sum;\n    }\n    for (auto i : ans)\n        cout << i << endl;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.3 树上莫队\n\n给定一个$n$个节点的树，每个节点表示一个整数，问$u$到$v$的路径上有多少个不同的整数。\n\n转成欧拉序区间问题。\n\n具体做法：设每个点的编号$a$首次出现的位置$first[a]$，最后出现的位置为$last[a]$，那么对于路径$x→y$，设$first[x]\\le first[y]$（不满足则`swap`，这个操作的意义在于，如果$x$、$y$在一条链上，则$x$一定是$y$的祖先或等于$y$），如果$lca(x,y)=x$，则直接把$[first[x],first[y]]$的区间扯过来用，反之使用$[last[x],first[y]]$区间，但这个区间内不包含$x$和$y$的最近公共祖先，查询的时候加上即可。\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 4. 图论\n\n## 1. 最短路\n\n最短路，图上问题，分层图最短路，最短路形式优化$dp$​.\n\n最短路具有类似$dp$的最优子结构性质，判定一条边$(u,v)$属于最短路$i\\to j$的一条边，当且仅当$dis_{i,u}+w+dis_{v,j}=dis_{i,j}$\n\n### 1.1 Dijkstra\n\n稀疏图堆优化，复杂度$O((n+m)logn)$，只能处理完全正边权图。如果有负边权需要参考费用流中对偶$Dijkstra$，使用势能函数进行评估。\n\n```cpp\n//mlogn\n#include<bits/stdc++.h>//处理完全正权有向图，可以有环\n//将结点分为两类，不断松弛，但注意确定一个节点后我们便不再进行更新这个节点了（所以这是dij的短视性），所以无法处理负权，因为负权可能会更新我们已加入的节点。\nusing namespace std;\nconst int N=1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,s,u,v,sum;\nstruct node{\n    int to,val;\n};\nvector<vector<node> >edge;\nint dis[N],vis[N];\nvoid dijkstra(){\n    memset(dis,inf,sizeof(dis));//初始化\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;//小根堆启动\n    q.push({0,s});//距离在前，点在后，因为pair默认先排前面的\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second]){\n            if(dis[j.to]>dis[k.second]+j.val){\n                dis[j.to]=min(dis[j.to],dis[k.second]+j.val);\n                q.push({dis[j.to],j.to});\n            }\n        } \n        //对所有相邻顶点进行松弛，dis是到源点的距离\n    }\n}\nint main(){\n    cin>>n>>m>>s;\n    edge.resize(n+1);\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        edge[u].push_back({v,sum});\n    }\n    dijkstra();\n    for(int i=1;i<=n;i++){\n        if(!vis[i])cout<<(1<<31)-1<<\" \";//说明不相连\n        else cout<<dis[i]<<\" \";\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.2  Floyed\n\n以$O(n^3)$的方式暴力预处理所有的最短路，本质是连通矩阵的传递闭包。适合数据范围极小的大量的最短路询问操作。曾经在$Atcoder$​出现过。\n\n暴力枚举顺序千万别反了。\n\n```cpp\ncin>>n>>m>>s;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(i!=j)a[i][j]=inf;//初始化\n            else a[i][j]=0;\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        a[u][v]=min(a[u][v],sum);//应付重边\n    }\n    for(int k=1;k<=n;k++)//先枚举每个中间点，来更新i，j，必须先这么做\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);//核心过程：借助每个中间点进行松弛操作\n    for(int i=1;i<=n;i++){\n        if(a[s][i]==inf)cout<<(1<<31)-1<<\" \";//说明不相连\n        else cout<<a[s][i]<<\" \";\n}\n```\n\n### 1.3  SPFA/Bellman-Ford\n\n关于$SPFA$——他死了。\n\n极端条件下会被菊花图卡成$O(nm)$的算法。可以用于普适性的带负边权的图，可以检测负环。\n\n```cpp\nbool spfa()\n{\n    memset(dis, inf, sizeof(dis)); // 初始化\n    memset(cnt, 0, sizeof(cnt));   // 负环计数器\n    dis[s] = 0;\n    vis[s] = 1; // 注意 vis数组代表在不在队列中，在这里点是可以重复入队的\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0; // 取出队列中的元素，故vis为0\n        for (auto i : edge[u])\n        {\n            if (dis[i.to] > dis[u] + i.val)\n            {\n                cnt[i.to]++;\n                if (cnt[i.to] > n)\n                    return 0;\n                dis[i.to] = dis[u] + i.val;\n                if (vis[i.to] == 0)\n                {\n                    vis[i.to] = 1;\n                    q.push(i.to);\n                }\n            }\n        }\n    }\n    return 1;\n}\n```\n\n判断负环方式：当一个点被松弛了超过$n$次，意味着其中一定有经过它的负环。\n<div style=\"page-break-after: always;\"></div>\n\n### 1.4 差分约束\n\n$x_r-x_l\\le c\\iff addEdge(l,r,c)$，$x_r-x_l\\ge c\\iff addEdge(r,l,-c)$\n\n跑最短路求可行解即可，使用$Spfa$跑最短路。有负环则无解。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<vector<array<int, 2>>> con;\nvoid addedge(int x, int y, int z)\n{\n    con[x].push_back({y, z});\n}\nvector<int> dist, vis, tot;\nint n, m;\nbool spfa(vector<int> &dist, int st)\n{\n    dist.assign(n + 1, LONG_LONG_MIN / 2);\n    vis.assign(n + 1, 0);\n    tot.assign(n + 1, 0);\n    queue<int> q;\n    dist[0] = 0;\n    vis[0] = 1;\n    q.push(0);\n    while (!q.empty())\n    { // 判负环，看上面的\n        int cur = q.front();\n        q.pop();\n        vis[cur] = 0;\n        for (auto [v, w] : con[cur])\n            if (dist[cur] + w > dist[v])\n            {\n                dist[v] = dist[cur] + w;\n                if (!vis[v])\n                {\n                    vis[v] = 1;\n                    q.push(v);\n                    tot[v]++;\n                    if (tot[v] >= n)\n                    {\n                        return 0;\n                    }\n                }\n            }\n    }\n    return 1;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> m;\n    con.assign(n + 1, vector<array<int, 2>>());\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        addedge(u, v, w);\n        addedge(v, u, -w);\n    }\n    for (int i = 1; i <= n; i++)\n        addedge(0, i, 0);\n    spfa(dist, 0);\n    for (int i = 1; i <= n; i++)\n        cout << dist[i] << ' ';\n    cout << '\\n';\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.5 分层图最短路\n\n对于特定的一些限制条件，可以通过拆分分层图，用不同图层表示不同的状态。\n\n#### 示例1：$k$次机会不消耗花费通过某条边的最短路\n\n```cpp\n#include<bits/stdc++.h>//解决问题：我们有k次机会0代价的通过某条路下的最短路\n//分层图：当我们使用一次机会时，相当于我们进入下一张图\nusing namespace std;\nconst int N=2*1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> P;\nint n,m,k,s,t,u,v,sum;\nvector<P>edge[N];\nint dis[N],vis[N];\nvoid dijkstra(){//常规不必再说\n    memset(dis,inf,sizeof(dis));\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;\n    q.push({0,s});\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second])dis[j.first]=min(dis[j.first],dis[k.second]+j.second),q.push({dis[j.first],j.first});\n    }\n}\nint main(){\n    cin>>n>>m>>k>>s>>t;\n    s++;t++;\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        u++;v++;\n        edge[u].push_back({v,sum});//原始层\n        edge[v].push_back({u,sum});\n        for(int j=1;j<=k;j++){//一共有k+1层，某个点在每个层s，s+n,s+2n,...,s+kn\n            edge[u+j*n].push_back({v+j*n,sum});//每个层都是一样的\n            edge[v+j*n].push_back({u+j*n,sum});\n            edge[v+(j-1)*n].push_back({u+j*n,0});//使用特权：即换层\n            edge[u+(j-1)*n].push_back({v+j*n,0});\n        }\n    }\n    for(int i=1;i<=k;i++)edge[t+(i-1)*n].push_back({t+i*n,0});//把终点从上到小连起来，这样即使没有用完n次机会我们也是从t+nk中读答案\n    dijkstra();//正常跑最短路\n    printf(\"%d\",dis[t+k*n]);\n}\n\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 示例2：地铁换乘问题\n\n```cpp\n//坐地铁问题：一共m条线路，n个地铁站，有换乘等问题，那就建m+1*n个点，在5e5左右，因为每层图之间的边权不同所以要把站点拆开成m个，再建立虚层连接不同层代表模拟换乘的过程\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N = 510000,INF = 0x3f3f3f3f;  //注意数据范围\ntypedef pair<int,int> P;\nint n,m,s,t;\nstruct node{\n    int to,val;\n};\nvector<node>edge[N];\nint dis[N],vis[N];\nvoid add(int u,int v,int w) //加边函数\n{\n    //cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    edge[u].push_back({v,w});\n}\n\nvoid dijkstra(int s){\n    memset(dis,INF,sizeof(dis));//初始化\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;//小根堆启动\n    q.push({0,s});//距离在前，点在后，因为pair默认先排前面的\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second]){\n            if(dis[j.to]>dis[k.second]+j.val){\n                //if(j.to==8)cout<<k.second<<\" \"<<dis[k.second]<<endl;\n                dis[j.to]=min(dis[j.to],dis[k.second]+j.val);\n                q.push({dis[j.to],j.to});\n            }\n        } \n    }\n}\nint main()\n{\n    int price,ad,num,pre,cur;\n    cin >> n >> m >> s >> t;\n    for(int i = 1;i <= m;i++)\n    {\n        cin >> price >> ad >> num;\n        for(int j = 0;j <num;j++)\n        {\n            cin >> cur;\n            if(j){\n                add((i-1)*n+pre,(i-1)*n+cur,ad);    \n                add((i-1)*n+cur,(i-1)*n+pre,ad);\n            }\n            add((i-1)*n+cur,n*m+cur,0);\n            add(n*m+cur,(i-1)*n+cur,price); \n            pre = cur;  \n        }\n    }\n    dijkstra(n*m+s);    \n    if(dis[n*m+t] == INF)   \n        cout << -1 << endl;\n    else\n        cout << dis[n*m+t] << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 示例3：一些相类似的移动方式集合到一起（2023澳门区域赛）\n\n题意概括：\n\n有一个$n$个节点的环，编号$0\\to n-1$. 你初始在$i$号节点。给一个长度为$n$的数组$a$。你每一次可以进行以下操作：\n\n1. 从$i$立即传送：$i\\to (a_i+i)\\pmod{n}$\n2. 修改当前$a_i$：$a_i\\to a_i+1$\n\n给定一个$x$，询问最少经过多少次操作能够从$0$到达$x$.\n\n这里要看你怎么看待这个修改。在$i$对$a_i$加$1$等价于直接跳到$a_i+i$后又花费一次机会向后走。因为你永远不可能走回头路，就是第二次经过$i$这个点，所以这个抽象是合理的。而我们又不可能直接在原图上把所有的点全部直接串起来。\n\n所以开一个分层图，额外新建立一个有向环模拟后跳跃这个操作，然后一次操作$1$就从原图的$i$向环上的$i+a_i$连边。环上的点向原图的自己连一条代价为0的单向有向边。\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2. 网络流\n\n解决网络流模型问题。\n\n### 2.1 MaxFlow.h\n\nJiangly最新最大流模板，点编号从0开始。费用流同理。\n\n```cpp\ntemplate <class T>\nstruct MaxFlow\n{\n    struct _Edge\n    {\n        int to;\n        T cap;\n        _Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n\n    int n;\n    std::vector<_Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n\n    MaxFlow() {}\n    MaxFlow(int n)\n    {\n        init(n);\n    }\n\n    void init(int n)\n    {\n        this->n = n;\n        e.clear();\n        g.assign(n, {});\n        cur.resize(n);\n        h.resize(n);\n    }\n\n    bool bfs(int s, int t)\n    {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty())\n        {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u])\n            {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1)\n                {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                    {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n\n    T dfs(int u, int t, T f)\n    {\n        if (u == t)\n        {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i)\n        {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1)\n            {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0)\n                {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c)\n    {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T flow(int s, int t)\n    {\n        T ans = 0;\n        while (bfs(s, t))\n        {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n\n    std::vector<bool> minCut()\n    {\n        std::vector<bool> c(n);\n        for (int i = 0; i < n; i++)\n        {\n            c[i] = (h[i] != -1);\n        }\n        return c;\n    }\n\n    struct Edge\n    {\n        int from;\n        int to;\n        T cap;\n        T flow;\n    };\n    std::vector<Edge> edges()\n    {\n        std::vector<Edge> a;\n        for (int i = 0; i < e.size(); i += 2)\n        {\n            Edge x;\n            x.from = e[i + 1].to;\n            x.to = e[i].to;\n            x.cap = e[i].cap + e[i + 1].cap;\n            x.flow = e[i + 1].cap;\n            a.push_back(x);\n        }\n        return a;\n    }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 MinCostFlow.h\n\n支持负数费用，不支持负数流量。\n\n```cpp\n/*\n *@brief 费用流（Jiangly）\n *@note 时间复杂度O(F(n+m)log(n+m)),F(n+m)表示流量和，n表示点数，m表示边数\n *@note 空间复杂度O(n+m)\n *@tparam Cap 流量数据类型\n *@tparam Cost 费用数据类型\n *@note  复杂度估算可同最大流，点数不超过2000，最坏上界估算O(n^3)到O(n^4)，基本不会TLE\n */\ntemplate <class T>\nstruct MinCostFlow\n{\n    struct _Edge\n    {\n        int to;\n        T cap;\n        T cost;\n        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}\n    };\n    int n;\n    std::vector<_Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<T> h, dis;\n    std::vector<int> pre;\n    bool dijkstra(int s, int t)\n    {\n        dis.assign(n, std::numeric_limits<T>::max());\n        pre.assign(n, -1);\n        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> que;\n        dis[s] = 0;\n        que.emplace(0, s);\n        while (!que.empty())\n        {\n            T d = que.top().first;\n            int u = que.top().second;\n            que.pop();\n            if (dis[u] != d)\n            {\n                continue;\n            }\n            for (int i : g[u])\n            {\n                int v = e[i].to;\n                T cap = e[i].cap;\n                T cost = e[i].cost;\n                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost)\n                {\n                    dis[v] = d + h[u] - h[v] + cost;\n                    pre[v] = i;\n                    que.emplace(dis[v], v);\n                }\n            }\n        }\n        return dis[t] != std::numeric_limits<T>::max();\n    }\n    MinCostFlow() {}\n    MinCostFlow(int n_)\n    {\n        init(n_);\n    }\n    void init(int n_)\n    {\n        n = n_;\n        e.clear();\n        g.assign(n, {});\n    }\n    void addEdge(int u, int v, T cap, T cost)\n    {\n        g[u].push_back(e.size());\n        e.emplace_back(v, cap, cost);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0, -cost);\n    }\n    std::pair<T, T> flow(int s, int t)\n    {\n        T flow = 0;\n        T cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t))\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                h[i] += dis[i];\n            }\n            T aug = std::numeric_limits<int>::max();\n            for (int i = t; i != s; i = e[pre[i] ^ 1].to)\n            {\n                aug = std::min(aug, e[pre[i]].cap);\n            }\n            for (int i = t; i != s; i = e[pre[i] ^ 1].to)\n            {\n                e[pre[i]].cap -= aug;\n                e[pre[i] ^ 1].cap += aug;\n            }\n            flow += aug;\n            cost += aug * h[t];\n        }\n        return std::make_pair(flow, cost);\n    }\n    struct Edge\n    {\n        int from;\n        int to;\n        T cap;\n        T cost;\n        T flow;\n    };\n    std::vector<Edge> edges()\n    {\n        std::vector<Edge> a;\n        for (int i = 0; i < e.size(); i += 2)\n        {\n            Edge x;\n            x.from = e[i + 1].to;\n            x.to = e[i].to;\n            x.cap = e[i].cap + e[i + 1].cap;\n            x.cost = e[i].cost;\n            x.flow = e[i + 1].cap;\n            a.push_back(x);\n        }\n        return a;\n    }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.3 Dinic (朱)\n\n```cpp\n// 理论上界为n2m，处理1e4-1e5的数据\n// 三个优化：多路增广，当前弧，炸点\n// 少做几次bfs，一次dfs进行多次增广\n// 建图时不用考虑点的变化，过程中没有用到点数这个信息，只需把边建出来就能跑\n// 多测的时候记得清空e[0]\n// 检查这条边是不是满流：是的话这条边的len变成0（没有剩余流量）\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], cur[N];\nbool bfs() // bfs分层\n{\n    memset(dep, -1, sizeof dep);\n    queue<int> q;\n    q.push(S);\n    dep[S] = 0;\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i = i + 1)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1 && e[t][i].len) // 如果这个点没有被定义层次，且还有剩余流量\n            {\n                dep[ed] = dep[t] + 1;\n                q.push(ed);\n            }\n        }\n    }\n    memset(cur, 0, sizeof(cur));\n    if (dep[T] == -1)\n        return 0;\n    else\n        return 1;\n}\nint dfs(int st, int limit) // limit最大可增加的流量\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // 定义当前节点的流量,多路增广优化，找满当前能找的limit流量上界\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // 当前弧优化，如果一个点有很多出边，有些出边可能无法再推流了，我们就记录第一条可以推流的边\n    {\n        cur[st] = i; // 当前弧优化\n        int ed = e[st][i].ed;\n        if (dep[ed] == dep[st] + 1 && e[st][i].len) // 这条边能推且，深度为更深一层（为了找最短的增广路）\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // 是为了限制后面点的流量不能大于limit-nowflow\n            if (t)                                               // 走下去能推流\n            {\n                e[st][i].len -= t;           // 减去相应的\n                e[ed][e[st][i].id].len += t; // 反边+相应的\n                nowflow += t;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    }\n    if (!nowflow)\n        dep[st] = -1; // 如果这个点不能延申，那就删掉这个点（炸点优化）\n    return nowflow;   // 会返回本次bfs（）后所有增广路能加的最多流量\n}\nint dinic()\n{\n    int r = 0;\n    while (bfs())\n        r += dfs(S, INF);\n    return r;\n}\nvoid add(int u, int v, int w)\n{ // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // 建边\n    e[v].push_back((edge){u, 0, sti});\n}\nsigned main()\n{\n    cin >> n >> m >> S >> T;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        add(u, v, w);\n    }\n    cout << dinic();\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.4 ISAP (朱)\n\n```cpp\n// 理论上界为n2m，处理1e4-1e5的数据\n// 只做一次bfs\n// 建图时注意n的改变，运行过程中有跟点数相关\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], gap[N], cur[N];\nvoid bfs() // bfs分层\n{\n    memset(dep, -1, sizeof dep);\n    memset(gap, 0, sizeof(gap));\n    queue<int> q;\n    q.push(T);\n    dep[T] = 0; // T为层数为0的点\n    gap[0] = 1; // 层数为0的点有一个\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i++)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1) // 如果这个点没有被定义层次就考虑（在这里不在乎这条边的流量是否为0！只负责分层)\n            {\n                dep[ed] = dep[t] + 1;\n                gap[dep[ed]]++;\n                q.push(ed);\n            }\n        }\n    }\n    return;\n}\nint dfs(int st, int limit) // limit最大可增加的流量\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // 定义当前节点的流量,多路增广优化，找满当前能找的limit流量上界\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // 当前弧优化，如果一个点有很多出边，有些出边可能无法再推流了，我们就记录第一条可以推流的边\n    {\n        cur[st] = i; // 当前弧优化\n        int ed = e[st][i].ed;\n        if (dep[ed] + 1 == dep[st] && e[st][i].len) // 这条边能推且，深度为更深一层（为了找最短的增广路）\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // 是为了限制后面点的流量不能大于limit-nowflow\n            if (t)                                               // 走下去能推流\n            {\n                e[st][i].len -= t;           // 减去相应的\n                e[ed][e[st][i].id].len += t; // 反边+相应的\n                nowflow += t;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    } // 到这说明这个点还有剩余流量，层数就+1\n    --gap[dep[st]];\n    if (gap[dep[st]] == 0)\n        dep[S] = n + 1; // 出现断层，无法到达t了，直接结束\n    dep[st]++;          // 层++\n    gap[dep[st]]++;\n    return nowflow; // 会返回本次bfs（）后所有增广路能加的最多流量\n}\nint ISAP()\n{\n    int flow = 0;\n    bfs();\n    while (dep[S] < n)\n    {\n        memset(cur, 0, sizeof(cur)); // 每一次开始dfs前都要注意cur数组的清空！与dinic不同，因为这里只需要一次bfs\n        flow += dfs(S, INF);         // 初始流量为无穷大\n    }\n    return flow;\n}\nvoid add(int u, int v, int w)\n{ // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // 建边\n    e[v].push_back((edge){u, 0, sti});\n}\nsigned main()\n{\n    cin >> n >> m >> S >> T;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        int sti = e[u].size();\n        int edi = e[v].size();\n        e[u].push_back((edge){v, w, edi}); // 建边\n        e[v].push_back((edge){u, 0, sti});\n    }\n    cout << ISAP();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.5 预流推进（AmiyaCast）\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define pii make_pair\nconst ll inf = 1145141919810;\nusing namespace std;\nint n, m, s, t;\nstruct Dinic\n{\n    int tp, s, t, n, m;\n    struct Edge\n    {\n        int u, v;\n        ll cap;\n    };\n    vector<ll> dis;\n    vector<int> cur, que;\n    vector<vector<int>> v;\n    vector<Edge> e, _e;\n    Dinic(int _n, int _s, int _t)\n    {\n        n = _n, s = _s, t = _t;\n        dis.resize(_n + 1), cur.resize(_n + 1), que.resize(_n + 1),\n            v.resize(n + 1);\n    }\n    void add(int x, int y, ll w) { _e.push_back({x, y, w}); }\n    void Add(int x, int y, int flw)\n    {\n        e.push_back(Edge{x, y, flw}), e.push_back(Edge{y, x, 0});\n        v[x].push_back(e.size() - 2);\n    }\n    int bfs()\n    {\n        dis.assign(n + 1, inf);\n        int l = 1, r = 1;\n        que[1] = s, dis[s] = 0;\n        while (l <= r)\n        {\n            int p = que[l++], to;\n            for (int i : v[p])\n                if (e[i].cap && dis[to = e[i].v] >= inf)\n                    dis[to] = dis[p] + 1, que[++r] = to;\n        }\n        return dis[t] < inf;\n    }\n    int dfs(int p, ll a)\n    {\n        if (p == t || !a)\n            return a;\n        int sf = 0, flw;\n        for (int &i = cur[p], to; i < (int)v[p].size(); ++i)\n        {\n            Edge &E = e[v[p][i]];\n            if (dis[to = E.v] == dis[p] + 1 && (flw = dfs(to, min(a,\n                                                                  E.cap))))\n            {\n                E.cap -= flw;\n                e[v[p][i] ^ 1].cap += flw;\n                a -= flw;\n                sf += flw;\n                if (!a)\n                    break;\n            }\n        }\n        return sf;\n    }\n    ll dinic(int tp = 1)\n    {\n        this->tp = tp;\n        int flw = 0;\n        while (bfs())\n            cur.assign(n + 1, 0), flw += dfs(s, inf);\n        return flw;\n    }\n    ll get_ans()\n    {\n        ll ans = 0;\n        m = _e.size();\n        sort(_e.begin(), _e.end(), [](Edge a, Edge b)\n             { return a.cap >\n                      b.cap; });\n        for (int rp = 0; rp <= 1; ++rp)\n            for (int p = 1 << 30, i = 0; p; p /=\n                                            2)\n            {\n                for (; i < m && _e[i].cap >= p; ++i)\n                    if (rp)\n                        v[_e[i].v].push_back(i * 2 + 1);\n                    else\n                        Add(_e[i].u, _e[i].v, _e[i].cap);\n                ans += dinic(rp);\n            }\n        return ans;\n    }\n};\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m >> s >> t;\n    Dinic d(n, s, t);\n    for (int i = 0; i < m; i++)\n    {\n        int x, y;\n        ll w;\n        cin >> x >> y >> w;\n        d.add(x, y, w);\n    }\n    cout << d.get_ans() << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.6 最小费用最大流（朱）\n\n```cpp\n//理论上界为n2m，处理1e4-1e5的数据\n//每条边流过去多了一个成本\n//bfs换成了spfa跑最短路即可,0号点得空出来\n//最大费用最大流：建边时把c反着建，照样跑板子，最后答案也反过来就行，类似最长路\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n    int cost;\n};\nvector <edge> e[N];\nint n, m, S, T;\nint dep[N], dis[N], vis[N],ans ,res;\nbool spfa(){\n    memset(dis,0x3f,sizeof(dis));//初始化\n    memset(vis,0,sizeof(vis));\n    dis[T]=0;\n    vis[T]=1;//vis数组代表在不在队列中\n    deque<int>q;q.push_back(T);\n    while(!q.empty()){\n        int u=q.front();q.pop_front();\n        vis[u]=0;//取出队列中的元素，故vis为0\n        for (int i = 0; i < e[u].size(); i++){\n            int ed = e[u][i].ed;\n            if (e[ed][e[u][i].id].len && dis[ed]>dis[u]-e[u][i].cost){//取反向边是因为我们要保证正流，但是SPFA是倒着跑的，所以说我们要求e[u][i]的对应反向边是正的，\n                dis[ed]=dis[u]-e[u][i].cost;\n                if (!vis[ed]){\n                    vis[ed]=true;\n                    if (q.empty() || dis[ed]>=dis[q.front()])q.push_back(ed);//一个lis优化spfa的\n                        else q.push_front(ed);\n                }\n            }\n        }\n    }\n    return dis[S]<dis[0];\n}\nint dfs(int st, int limit){\n    vis[st]=1;\n    if (st == T||limit==0)\n        return limit;\n    int nowflow=0;//定义当前节点的流量\n    for (int i = 0; i < e[st].size(); i = i + 1){\n        int ed = e[st][i].ed;\n        if (dis[ed] == dis[st] - e[st][i].cost && e[st][i].len&&!vis[ed])//这条边能推且，深度为更深一层，且没走过\n        {\n            int t = dfs(ed, min(e[st][i].len, limit-nowflow));//是为了限制后面点的流量不能大于limit-nowflow\n            if (t)//走下去能推流\n            {\n                res+=t*e[st][i].cost;//统计答案，经过这一条边\n                e[st][i].len -= t;\n                e[ed][e[st][i].id].len += t;\n                nowflow+=t;\n                if(nowflow==limit)return nowflow;\n            }\n\n        }\n    }\n    if(!nowflow)dep[st]=-1;//如果这个点不能延申，那就删掉这个点（炸点优化）\n    return nowflow;//会返回本次bfs（）后所有增广路能加的最多流量\n}\nvoid dinic(){\n    while(spfa()){\n        vis[T]=1;\n        while(vis[T]){//如果dfs完已经走不到t了那说明这一轮结束\n            memset(vis,0,sizeof vis);\n            ans+=dfs(S,INF);\n        }\n    }\n}\nvoid add(int u,int v,int w,int c){\n    //cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi, c});//建边\n    e[v].push_back((edge){u, 0, sti, -c});\n}\nsigned main(){\n    cin>>n>>m>>S>>T;\n    for (int i = 1; i <= m; i++){\n        int u,v,w,c;\n        cin >> u >> v >> w >> c;\n        int sti = e[u].size();\n        int edi = e[v].size();\n        e[u].push_back((edge){v, w, edi, c});//建边\n        e[v].push_back((edge){u, 0, sti, -c});\n    }\n    dinic();\n    cout<<ans<<\" \"<<res;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.7 网络流结论\n\n#### 2.7.1 二分图博弈\n\n二分图博弈，给出一张二分图和起始点 H，A 和 B轮流操作，每次只能选与上个被选择的点（第一回合则是点 H）相邻的点，且不能选择已选择过的点，无法选点的人输掉。\n\n具体来说，就是所有的状态可以被分为两类，每次操作必定是从一个状态到另一类状态，不能操作的人输\n\n做法，如果二分图的所有最大匹配都经过H，那么先手必胜，否则必败\n\n建图后判断H是不是必须点即可（跑两次，第一次不带H点，跑一次，再带上H点，看看能不能有新增流量，若有则是必须点，先手必胜，否则必败）\n\n```cpp\nvoid solve(){\n    cin>>m>>n>>s;\n    for (int i = 0; i < N; i++)e[i].clear();\n    memset(sp,0,sizeof(sp));\n    int M=a[m];S=M+1;T=M+2;\n    for (int i = 1; i <= n; i++) {\n        int x ;cin>>x; sp[x] = 1;//禁止访问的状态\n    }\n    for(int i = 0; i < M; i++) {//每个状态\n        if(sp[i]) continue;\n        if(odd[i] == odd[s]) {\n            calc(i);//i的后继状态连边\n            if (i != s) add(S, i, 1);//起点先不连\n        }\n        else {\n            add(i, T, 1);   \n        }\n    }\n    dinic();//如何判断这个点是不是最大匹配的必须点？先不加这个点跑一次，再加上跑一次，看能不能有新流即可\n    add(S, s, 1);\n    if(dinic())\n        cout<<\"Alice\"<<endl;\n    else \n        cout<<\"Bob\"<<endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.2 最小路径覆盖与偏序集合Dilworth定理\n\n##### 2.7.2.1 最小路径覆盖\n\n最小路径覆盖问题是指用最少的**不相交**路径，使得路径覆盖整个有向图的所有点。\n\n本质是二分图的最大匹配。\n\n目标是覆盖所有的点，这些路径不要求非得共用起点和终点。初始考虑每个点都被一条自环唯一覆盖，那么一条边连通两个点就意味着这条边同时覆盖了这两个点，同时因为不相交路径的属性确保了如果点$A$连向了点$B$，那么一定不会再有点$A$连向任何一个点。确保一个点只连接一条出边，就是二分图的最大匹配问题。建图跑最大匹配后找出最大可化简数量，结果就是$n-$最大流。\n\n**示例1：（模板题)**\n\n给定有向图 $G=(V,E)$ 。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个定点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个定点开始，长度也是任意的，特别地，可以为 $0$。$G$ 的最小路径覆盖是 $G$ 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图）$G$ 的最小路径覆盖。\n\n**输入格式**\n\n第一行有两个正整数 $n$ 和 $m$。$n$ 是给定 DAG（有向无环图）$G$ 的顶点数，$m$ 是 $G$ 的边数。接下来的 $m$ 行，每行有两个正整数 $i$ 和 $j$ 表示一条有向边 $(i,j)$。\n\n**输出格式**\n\n从第一行开始，每行输出一条路径。文件的最后一行是最少路径数。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 150$，$1\\leq m\\leq 6000$​​。\n\n记录路径在dfs中维护一个nxt数组表示这个点的下一个。\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], cur[N], p[N], net[N], d[N];\nbool bfs() // bfs分层\n{\n    memset(dep, -1, sizeof dep);\n    queue<int> q;\n    q.push(S);\n    dep[S] = 0;\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i = i + 1)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1 && e[t][i].len) // 如果这个点没有被定义层次，且还有剩余流量\n            {\n                dep[ed] = dep[t] + 1;\n                q.push(ed);\n            }\n        }\n    }\n    memset(cur, 0, sizeof(cur));\n    if (dep[T] == -1)\n        return 0;\n    else\n        return 1;\n}\nint dfs(int st, int limit) // limit最大可增加的流量\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // 定义当前节点的流量,多路增广优化，找满当前能找的limit流量上界\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // 当前弧优化，如果一个点有很多出边，有些出边可能无法再推流了，我们就记录第一条可以推流的边\n    {\n        cur[st] = i; // 当前弧优化\n        int ed = e[st][i].ed;\n        if (dep[ed] == dep[st] + 1 && e[st][i].len) // 这条边能推且，深度为更深一层（为了找最短的增广路）\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // 是为了限制后面点的流量不能大于limit-nowflow\n            if (t)                                               // 走下去能推流\n            {\n                e[st][i].len -= t;           // 减去相应的\n                e[ed][e[st][i].id].len += t; // 反边+相应的\n                nowflow += t;\n                if (t)\n                    net[st] = ed - n;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    }\n    if (!nowflow)\n        dep[st] = -1; // 如果这个点不能延申，那就删掉这个点（炸点优化）\n    return nowflow;   // 会返回本次bfs（）后所有增广路能加的最多流量\n}\nint dinic()\n{\n    int r = 0;\n    while (bfs())\n        r += dfs(S, INF);\n    return r;\n}\nvoid add(int u, int v, int w)\n{\n    // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // 建边\n    e[v].push_back((edge){u, 0, sti});\n}\nvoid print(int x)\n{\n    printf(\"%d \", x);\n    if (net[x] > 0)\n        print(net[x]);\n}\nsigned main()\n{\n    cin >> n >> m;\n    S = 0;\n    T = 2 * n + 1;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add(u, v + n, 1);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        add(S, i, 1);\n        add(i + n, T, 1);\n    }\n    int maxflow = dinic();\n    for (int i = 1; i <= n; i++)\n        if (net[i])\n            d[net[i]]++;\n    for (int i = 1; i <= n; i++)\n        if (!d[i])\n            print(i), cout << endl;\n    cout << n - maxflow;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n##### 2.7.2.2 Dilworth定理\n\n根据$Dilworth$定理，偏序集合的**最长链长度**等于其**最小的反链覆盖**。\n\n**链**：一条链是一些**点的集合**，点集中任意两个点$u$和$v$，满足$u$能到达$v$或是$v$能到达$u$（存在偏序关系），则称该点集为一条链。\n\n**反链**：一条反链是一些**点的集合**，点集中任意两个点$u$和$v$，满足$u$不能到达$v$并且$v$不能到达$u$​，则称该点集为一条反链。\n\n**最小链覆盖**是指在有向图中用**可以相交**的若干条路径覆盖整个图且路径数最少。\n\n**求出有向图的传递闭包之后即可按照示例一不相交路径求解，二分图最大匹配即可。**\n\n如果有向图是一个**完备**的**偏序集合哈斯图**（即其传递闭包等于自身），则**最小链覆盖等价于最小路径覆盖**。此时，$Dilworth$定理可重新表述为**最大链长度等于最小的反链划分**。\n\n**示例1：ABC237Ex Hakata**\n\n我们有一个由小写英文字母组成的字符串 $S$ 。Bob 每天都在思考回文。他决定从 $S$ 中选择一些回文子串并告诉 Anna。\n\n如果 Bob 告诉的回文之一是另一个回文的子串，Anna 会生气。Bob 可以选择最多多少个回文而不会让 Anna 生气？\n\n$N\\le 300$\n\n显然，包含是一个偏序关系。我们要求解的是**最长的互相不包含的回文串序列长度**，实际上就是**最长的反链长度**。\n\n$Dilworth$定理转**最小的反链覆盖**。由于我们能够建立出完备的偏序哈斯图（实际上都可以），又转**最小反链划分**，即**最小路径覆盖**。\n\n求二分图最大匹配，参考示例1，作差即可。\n\n```cpp\nvoid solve()\n{\n    string s;\n    cin >> s;\n    vector<string> pali;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 1; i + j <= s.size(); j++)\n        {\n            string t = s.substr(i, j);\n            string r = t;\n            reverse(r.begin(), r.end());\n            if (t == r)\n            {\n                pali.push_back(t);\n            }\n        }\n    }\n    sort(pali.begin(), pali.end());\n    pali.erase(unique(pali.begin(), pali.end()), pali.end());\n    int sz = pali.size();\n    MaxFlow<int> mf(2 * sz + 10);\n    const int S = 2 * sz, T = 2 * sz + 1;\n    for (int i = 0; i < sz; i++)\n    {\n        mf.addEdge(S, i, 1);\n        mf.addEdge(sz + i, T, 1);\n    }\n    for (int i = 0; i < sz; i++)\n    {\n        for (int j = 0; j < sz; j++)\n        {\n            if (i == j)\n                continue;\n            if (pali[i].find(pali[j]) != string::npos)\n            {\n                mf.addEdge(i, sz + j, 1);\n            }\n        }\n    }\n    cout << sz - mf.flow(S, T) << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.3 最大流最小割定理\n\n最大流=最小割。\n\n割集好比是一个恐怖分子 把你家和自来水厂之间的水管网络砍断了一些 然后自来水厂无论怎么放水 水都只能从水管断口哗哗流走了 你家就停水了 割的大小应该是恐怖分子应该关心的事 毕竟细管子好割一些 而最小割花的力气最小\n\n网络的最大流等于最小割 \n\n具体的证明分三部分 \n\n1. 任意一个流都小于等于任意一个割。\n\n这个很好理解，自来水公司随便给你家通点水构成一个流，恐怖分子随便砍几刀，砍出一个割，由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量，每一根被砍的水管的水本来都要到你家的，现在流到外面，加起来得到的流量还是等于原来的流。管子的容量加起来就是割，所以流小于等于割。由于上面的流和割都是任意构造的，所以任意一个流小于任意一个割。\n\n2. 构造出一个流等于一个割。\n\n当达到最大流时，根据增广路定理，残留网络中$s$到$t$已经没有通路了，否则还能继续增广。我们把$s$能到的的点集设为$S$，不能到的点集为$T$，构造出一个割集$C[S,T]$，$S$到$T$的边必然满流，否则就能继续增广，这些满流边的流量和就是当前的流即最大流。把这些满流边作为割，就构造出了一个和最大流相等的割。\n\n3. 最大流等于最小割。\n\n\n设相等的流和割分别为$F_m$和$C_m$，则因为任意一个流小于等于任意一个割，任意$F≤Fm=Cm≤$任意$C$ 。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.4 最大权闭合子图\n\n最大权闭合子图：给定一个有向图, 顶点带权值. 你可以选中一些顶点, 要求当选中一个点 $u$ 的时候, 若存在边 $u\\rightarrow v$ 则 $v$​ 也必须选中. 最大化选中的点的总权值.\n\n建模：负点权点向重点连边，源点向正点权点连边，图中原先的点连无穷大边，跑最小割即可，最终结果就是所有正点权之和$-$最小割。\n\n示例：**CFedu171 Best Subsequence**\n\n给定一个整数数组 $$a$$ ，大小为 $n$ 。\n\n我们将数组的值定义为其大小减去数组所有元素按位或中的设置位数。\n\n例如，对于数组 $[1, 0, 1, 2]$ ，按位或为 $3$ (包含 $2$ 个设置位)，数组的值为 $$4-2=2$$ 。\n\n您的任务是计算给定数组的某个子序列的最大可能值。\n\n显然是最大权闭合子图问题，或者可以理解为二者选其一问题。该点要被选择，这些位置都要被扣1.\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<i64> a(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    MaxFlow<i64> f;\n    int sz = n + 60 + 2;\n    f.init(sz);\n    const int s = n + 60, t = n + 60 + 1;\n    for (int i = 0; i < n; i++)\n    {\n        f.addEdge(s, i, 1);\n        for (int j = 59; j >= 0; j--)\n        {\n            if ((a[i] >> j) & 1)\n            {\n                f.addEdge(i, n + j, 1);\n            }\n        }\n    }\n    for (int j = 59; j >= 0; j--)\n    {\n        f.addEdge(n + j, t, 1);\n    }\n    i64 ans = f.flow(s, t);\n    cout << n - ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.5  二者选其一问题\n\n将若干元素$e_1,e_2,…,e_n$划分到两个集合$A,B$中。对于元素$e_i$,它被划分到$A$或$B$中分别能获得一个$a_{e_i}$或$b_{e_i}$的分值。除此之外,还给出若干个组合$C_i\\in E$,当组合中的元素被同时划分到$A$或$B$时,可以获得额外的分值$a'$或$b'$。求最大的分值。\n\n基本模型是设立两个超级源点，每个物品分别连，最大收益就是收益总和-最小割\n\n对于同属于一遍的额外组合，则新建节点，超级源点（以$A$示例）向该新节点流额外收益$a'$，为保证后续节点必定在$A$部，该新节点向该组合的中间点连无穷大边，迫使最小割如果保留了$a'$边，就必须隔断所有和$B$的边，以达成正确性。\n\n<img src=\"https://pic4.zhimg.com/v2-3f06c22d87598fc1b5c1774376d303c3_r.jpg\" alt=\"img\" style=\"zoom:25%;\" />\n\n示例：**2024杭电多校（5）猫咪们狂欢**\n\n猫咪们生活在树上。\n\n具体来说，有 $n$ 只猫咪和两棵大小为$n$的树。猫咪编号为 $1∼n$ ，每棵树上的节点编号也为 $1∼n$（编号各不相同） 。\n\n今晚，每只猫咪要分别选择一棵树，并待在与其编号相同的节点。\n\n在这 $n$ 只猫咪之中，有 $k$ 只猫咪是狂欢猫。狂欢猫晚上不会睡觉，而是会选择开party。其他猫咪则会选择睡觉。\n\n每条树边都有一个狂欢值，如果这条边连接的两个节点在晚上都有狂欢猫待着，这个狂欢值就会被累加到总狂欢值上。\n\n最大化今晚的总狂欢值，并输出这个值。\n\n\n\n显然是二者选其一问题，每只猫咪有选择左还是选择右的问题，有最多$n-1$组组合会有额外收益。狂欢猫只有$k$只，涉及到的狂欢猫才形成组队节点。\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<int> cat(k + 1);\n    map<int, int> mp;\n    for (int i = 1; i <= k; i++)\n    {\n        cin >> cat[i];\n        mp[cat[i]] = 1;\n    }\n    const int s = 0, t = n + 1;\n    MaxFlow<i64> flow(4 * n + 10);\n    int virp = n + 2;\n    i64 ans = 0;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        if (mp[u] && mp[v])\n        {\n            flow.addEdge(s, virp, w);\n            flow.addEdge(virp, u, INT_MAX / 2);\n            flow.addEdge(virp, v, INT_MAX / 2);\n            ans += w;\n            virp++;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        if (mp[u] && mp[v])\n        {\n            flow.addEdge(virp, t, w);\n            flow.addEdge(u, virp, INT_MAX / 2);\n            flow.addEdge(v, virp, INT_MAX / 2);\n            ans += w;\n            virp++;\n        }\n    }\n    cout << ans - flow.flow(s, t) << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.6 二分图最大边权匹配\n\n二分图的最大权匹配是指二分图中边权和最大的匹配。数据保证有解。\n\n考虑费用流。\n\n与 **二分图最大匹配**类似，二分图的最大权匹配也可以转化为网络流问题来求解。\n\n首先，在图中新增一个源点和一个汇点。\n\n从源点向二分图的每个左部点连一条流量为 $1$ ，费用为 $0$ 的边，从二分图的每个右部点向汇点连一条流量为 $1$ ，费用为 $0$ 的边。\n\n接下来对于二分图中每一条连接左部点 $u$ 和右部点 $v$ ，边权为 $w$ 的边，则连一条从 $u$ 到 $v$，流量为 $1$ ，费用为 $w$ 的边。\n\n另外，考虑到***最大权匹配下***，***匹配边的数量不一定与最大匹配的匹配边数量相等（不一定最大流）***，因此对于每个左部点，还需向汇点连一条流量为$1$ ，费用为 $0$ 的边。\n\n求这个网络的 **最大费用最大流**即可得到答案。此时，该网络的最大流量一定为左部点的数量，而最大流量下的最大费用即对应一个最大权匹配方案。最大费用最大流可以直接负费用的最小费，Jiangly模板支持。\n\n#### 2.7.7 二分图最小边权点覆盖\n\n二分图的最小边权点覆盖指找到一个边权和最小的顶点覆盖。数据保证有解。\n\n考虑最小覆盖的一种构造方式：\n\n选择一个匹配边集合$E_1$，所有不属于$E_1$包含的点集$V_1$的点选择一条与自己相邻的点中边权最小的那一个点，添加对应边（**允许重边**）。可以证明最优解一定可以被这种构造方式构造，且是否是最优解一定取决于$E_1$的选择。\n\n设点$u$为端点的边的最小边权为$wm_u$，则有一个非常简单的化简：\n$$\nCost=\\sum_{e\\in E_1}c(e)+\\sum_{v\\in V\\backslash V_1}wm_v=\\sum_{v\\in V}wm_v+\\sum_{e\\in E_1}(c(e_{u,v})-wm_u-wm_v)\n$$\n最小化第二项成本即可。构建以下网络流二分图跑最小费用流：\n\n- 从 $S$ 向每个 $X_i$ 添加一条边，容量为 $1$ ，成本为 $0$\n- 对于每个 $(X_i,Y_j)$ ，从 $X_i$ 向 $Y_j$ 添加一条边，容量为 $1$ ，成本为 $(c(e_{X_i,Y_i})-wm_{X_i}-wm_{Y_i})$\n- 从每个 $Y_i$ 向 $T$ 添加一条边，容量为 $1$ ，成本为 $0$.\n- 另外，考虑到***最小费匹配下***，***匹配边的数量不一定与最大匹配的匹配边数量相等（不一定最大流，这个带有负成本的更为明显）***，因此对于每个左部点，还需向汇点连一条流量为 $1$ ，费用为 $0$ 的边。\n\n直接跑$MincostFlow.h$就行，Jiangly模板支持负数费用。\n\n示例1：**ABC231H - Minimum Coloring**\n\n我们有一个网格，有 $H$ 行和 $W$ 列。令 $(i,j)$ 表示从顶部算起第 $i$ 行和从左侧算起第 $j$ 列的方格。\n\n在这个网格上，有 $N$ 个白色棋子，编号为 $1$ 至 $N$ 。棋子 $i$ 位于 $(A_i,B_i)$ 上。\n\n您可以支付 $C_i$ 的费用来将棋子 $i$ 改为黑色棋子。\n\n找出在每一行和每一列中至少有一个黑色棋子所需的最小总费用。\n\n裸的板子。\n\n```cpp\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    const int s = n + m, t = n + m + 1;\n    MinCostFlow<i64> mcf(n + m + 10);\n    vector<int> a(n + m + 10, INT_MAX / 2);\n    vector<array<int, 3>> e(k);\n    for (int i = 0; i < k; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--;\n        v--;\n        e[i] = {u, v, w};\n        a[u] = min(a[u], w);\n        a[n + v] = min(a[n + v], w);\n    }\n    i64 ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        mcf.addEdge(s, i, 1, 0);\n        mcf.addEdge(i, t, 1, 0);\n        ans += a[i];\n    }\n    for (int j = 0; j < m; j++)\n    {\n        mcf.addEdge(n + j, t, 1, 0);\n        ans += a[n + j];\n    }\n    for (int i = 0; i < k; i++)\n    {\n        auto [u, v, w] = e[i];\n        mcf.addEdge(u, n + v, 1, w - a[u] - a[n + v]);\n    }\n    auto [flow, cost] = mcf.flow(s, t);\n    cout << ans + cost << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.8 剩余物品互不相同问题\n\n操作后剩余互不相同，可以通过列举出所有剩余物品种类之后每个只向超级汇点连一条容量为$1$的边，以确保每种物品只会出现一次。\n\n剩余数量限制为$x$​的时候同理，限制容量大小即可。\n\n**示例1：（2024成都站K)**\n\n您有一个神奇的集合，最初包含 $n$ 个不同的整数。您发现这些数字可以通过除以它们的因数来产生能量。在每个步骤中，您可以从集合中选择任何大于 $1$ 的数字，将其删除，然后插入它的一个因数。您插入的因数不得等于原始数字。此外，由于神奇集合的不稳定性，您的操作必须确保集合中的数字保持不同。\n\n每个操作都会产生一个能量单位，您的目标是通过执行尽可能多的操作来最大化产生的总能量。给定集合中的初始数字，确定可以产生的最大能量，即可执行的最大操作数。\n\n显然每个数都会尽可能的按步数分解，最大的操作数一定取决于随后剩余的因数组合问题。规约到二分图最大权匹配即可。\n\n分解因数，超级源点向初始数连一条容量为$1$、费用为$0$的边；初始数字向对应因数连容量为$1$、对应消耗次数的费用$w$；对应因数向超级终点连容量为$1$、费用为$0$的边。跑最大费用流即可。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.9 其他记录\n\n1.小M的作物(最小割) 巧妙将问题转化为最小割\n\n2.奶牛的电信Telecowmunication 最小割边转化为最小割点，方法是拆点把一个点拆成两个点，用1的边长连起来，两个不同点之间的连线用INF连起来，这样的最小割就只能割1的点，相当于割点了 \n\n3.教辅的组成 也是拆点，我们限制一个点通过的流量，就是把这个点拆成两个点，中间连一条我们要限制的流量的大小的边\n\n4.狼捉兔子 可以直接网络流 也可以最小割转平面图最短路（平面图最小割=对偶图的最短路）\n\n5.方格取数问题，有条件的最值。二分图点权最大独立集\n\n把方格根据i+j的奇偶性分为两类点，发现保留一个点的代价是取走周围的另一类的点，转化为最小割。\n\nS连白点，容量为点权，黑点连T同理，同时一个点向周围四个点连边，边权为inf，这样跑出来的最小割，舍弃一个点为断开他与一个源点的连接，意思就是不要这个点，保留下来的点就是最大的，sum-dinic()即可\n\n套路：方格中的点看看能不能分为两类，即分为一个二分图，同类的点是可以共存的，然后不能共存的一定是两类之间，中间连inf边跑最大流，答案就是总和减去最小割。\n\n<div style=\"page-break-after: always;\"></div>\n\n## 3. 生成树\n\n#### 3.1 两种最小生成树\n\n##### 3.1.1 Prim\n\n```cpp\nvoid prim(){\n    memset(dis,0x3f3f3f3f,sizeof(dis));\n    priority_queue<node>q;//所以这里其实是小根堆，存的是边（每次抉择时待选的边）\n    node t;t.to=1,t.val=0;dis[1]=0;\n    q.push(t);//（最开始选择起点）\n    while(q.size()!=0){\n        node now=q.top();q.pop();\n        if(vis[now.to]==1)continue;\n        vis[now.to]=1;\n        ans+=now.val;\n        for(auto i:edge[now.to]){\n            if(!vis[i.to]&&dis[i.to]>i.val){\n                //有更新的边，都是可能要被选的边，加入队列中，这里的判断只有边权，因为dis是到当前集合的距离\n                dis[i.to]=i.val;\n                q.push(i);\n            }\n        }\n    }\n}\n```\n\n##### 3.1.2 Kruskal\n\n```cpp\ncin>>n>>m;\n    for(int i=1;i<=n;i++)fa[i]=i;//并查集维护是否在生成树里\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        a[i].x=u,a[i].y=v,a[i].val=sum;\n    }\n    sort(a+1,a+1+m);\n    for(int i=1;i<=m;i++){\n        if(fa[find(a[i].x)]==fa[find(a[i].y)])continue;//已经加入了那就不要了\n        else{\n            unions(a[i].x,a[i].y);//加边\n            k++;\n            ans+=a[i].val;\n        }\n        if(k==n-1)break;\n    }\n    if(k<n-1)cout<<\"orz\";\nelse cout<<ans;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *3.2 Kruskal重构树\n\nKruskal 重构树就是基于 Kruskal 的最小生成树算法在无向图中得出的树所构造而成的树。\n\n**性质**\n\n- 是一棵二叉树。\n- 如果是按最小生成树建立的话是一个大根堆。\n- **强大性质**：原图中两个点间所有路径上的边最大权值的最小值 == 最小生成树上两点简单路径的边最大权值 == $Kruskal$ 重构树上两点 $LCA$ 的点权。\n\n利用这个性质，我们可以找到到点 $x$ 的简单路径上的边最大权值的最小值$≤ val$的所有点 $y$。可以发现都在 $Kruskal$ 重构树上的某一棵子树内，且恰好为该子树的所有叶节点。\n\n**具体细节**\n\n我们在 $Kruskal$ 重构树上找到 $x$ 到根的路径上权值 $≤val$ 的最浅的节点,这就是那棵子树的根节点。这个到时候类似求$LCA$由高到低倍增跳就行了，一般这种情况下还有树上线段树合并或者书上主席树之类的。\n\n- 如果题目要求最小权值最大值，可以建最大生成树的重构树从而达到一样的效果。\n\n```cpp\nvoid Ex_Kruskal()\n{\n    int cnt=n;\n    sort(e+1,e+m+1,cmp);//对边排序\n    for (int i=1;i<2*n;++i) f[i]=i;//预处理并查集\n    for (int i=1;i<=m;++i)\n    {\n        int u=get(e[i].x),v=get(e[i].y);\n        if (u!=v)\n        {\n            ++cnt;//新点\n            f[u]=f[v]=cnt;//初始化\n            val[cnt]=e[i].z;//新点权为这个边权\n            add(cnt,u);add(cnt,v);//连边\n            if (cnt==2*n-1) break;//一共2*n-1个点，建好退出\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 4.  二分图最大匹配/二分图最小点覆盖\n\n匈牙利算法，或者网络流。\n\n匈牙利算法,判断二分图：并查集/dfs（即染色法/并查集）\n\n二分图是什么？节点由两个集合组成，且两个集合内部没有边的图。这张图上的所有边的两个端点，都分属不同的部分，无向图\n\n最大匹配：要求选出一些边，使得这些边没有公共顶点，且边的数量最大。\n\n二分图中，最小点覆盖 = 最大匹配  最小点覆盖：指的是在一个图中：一个点覆盖与之连接的边，求用最少的点可以覆盖图。\n\n二分图中，最大独立集 = $n- $最小点覆盖 \n\n最大独立集：一个点集，里面的点两两不相邻 \n\n算法步骤：如果后来的和以前的发生矛盾，则以前的被绿优先退让。\n\n如果以前的退让之后没有cp可处，则以前的拒绝退让，新来的去寻找下一个匹配。\n\n如果新来的谁也匹配不上了，那就这么单着吧。\n\n```cpp\n//O(nm),但是Dinic可以sqrt(n)*m\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2*1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> P;\nint n,m,e,u,v,ans;\nvector<int>edge[505];\nint vis[505],match[505];//match：为右部点建立的数组，存的是与它匹配的左部点\nbool check(int x){\n    for(auto i:edge[x]){//枚举每一个右部点\n        if(!vis[i]){//没访问过\n            vis[i]=1;\n            if(!match[i]||check(match[i])){//可以直接匹配or原先的i可以换人\n                match[i]=x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    cin>>n>>m>>e;\n    for(int i=1;i<=e;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n    }\n    for(int i=1;i<=n;i++){\n        memset(vis,0,sizeof(vis));//对于每一个u的研究，对另一外一半只能访问一次，故每次都要清空\n        if(check(i))ans++;\n    }\n    cout<<ans;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 5.树上问题\n\n### 5.1  树上LCA\n\n关于倍增法以及欧拉序$ST$表在线做法参见数据结构部分。这里只给出离线$Tarjan$算法，实现$O(n+m)$​复杂度。\n\n```cpp\n#include<bits/stdc++.h>//Tarjan离线算法\nusing namespace std;\nconst int N=5*1e5+2;\ntypedef long long ll;\nstruct point{\n    int x,i;\n};\nvector<vector<int> >edge;\nvector<vector<point> >q;\nint dep[N],fa[N],vis[N],ans[N];\nint find(int x){//路径压缩\n    if(fa[x]!=x){\n        fa[x]=find(fa[x]);\n    }\n    return fa[x];\n}\nvoid unions(int x,int y){//x合并到y上\n    fa[find(x)]=fa[find(y)];\n}\nvoid dfs(int x,int f){/***1.**以s为根节点，从根节点开始。\n**2.**遍历该点u所有子节点v，并标记这些子节点v已被访问过。\n**3.**若是v还有子节点，返回2，否则下一步。\n**4.**合并v到u上。\n**5.**寻找与当前点u有询问关系的点v。\n**6.**若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。*/\n    vis[x]=1;\n    for(auto i:edge[x]){\n        if(i!=f){\n            dfs(i,x);\n            unions(i,x);\n        }\n    }\n    for(auto t:q[x]){\n        if(vis[t.x])ans[t.i]=find(t.x);\n    }\n}\nint main(){\n    int n,m,s;int x,y;\n    cin>>n>>m>>s;\n    edge.resize(n+1);\n    q.resize(n+1);\n    for(int i=1;i<=n;i++)fa[i]=i;\n    for(int i=1;i<n;i++){\n        cin>>x>>y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    for(int i=1;i<=m;i++){\n        cin>>x>>y;\n        q[x].push_back({y,i});//另一个相关点和组数\n        q[y].push_back({x,i});\n    }\n    dfs(s,0);\n    for(int i=1;i<=m;i++)cout<<ans[i]<<endl;\n    return 0;\n}\n\n/*一个熊孩子Link从一棵有根树的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。\n岩浆会不断的注入，直到注满整个树…\n如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。\n岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。\n机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置*/\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.2 树链剖分\n\n参见数据结构部分静态树章节，对于长链、重链都有。\n\n这里贴出重链剖分头文件$HLD.h$。这个是从$0$开始的。\n\n```cpp\n/*\n     *@brief 重链剖分(jiangly)版本\n     *@brief 时间复杂度O(n)\n     *@brief 空间复杂度O(n)\n     */\n    struct HLD\n    {\n        int n;\n        std::vector<int> siz, top, dep, parent, dfn, enddfn, rk;\n        std::vector<std::vector<int>> adj;\n        int cur;\n        HLD() {}\n        HLD(int n)\n        {\n            init(n);\n        }\n        void init(int n)\n        {\n            this->n = n;\n            siz.resize(n);\n            top.resize(n);\n            dep.resize(n);\n            parent.resize(n);\n            dfn.resize(n);\n            enddfn.resize(n);\n            rk.resize(n);\n            cur = 0;\n            adj.assign(n, {});\n        }\n        void add_edges(int u, int v)\n        {\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        /*\n         * @brief 重链剖分（jiangly），只能剖一次，不支持动态树，节点编号和树剖编号都是从0开始。\n         * @param root 根节点\n         * @note 重链剖分前需要先调用init函数,调用重链剖分后，邻接表vector中存储的是重链剖分后的树，没有指向父节点的边\n         * @note 重链剖分后，dfn数组中存储的是节点的dfs序，rk数组中存储的是dfs序对应的节点，enddfn数组中存储的是节点所对应子树的dfs序的结束位置的后一个（左闭右开）。\n         */\n        void work(int root = 0)\n        {\n            top[root] = root;\n            dep[root] = 0;\n            parent[root] = -1;\n            dfs1(root);\n            dfs2(root);\n        }\n        void dfs1(int u)\n        {\n            if (parent[u] != -1)\n            {\n                adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));\n            }\n            siz[u] = 1;\n            for (auto &v : adj[u])\n            {\n                parent[v] = u;\n                dep[v] = dep[u] + 1;\n                dfs1(v);\n                siz[u] += siz[v];\n                if (siz[v] > siz[adj[u][0]])\n                {\n                    std::swap(v, adj[u][0]);\n                }\n            }\n        }\n        void dfs2(int u)\n        {\n            dfn[u] = cur++;\n            rk[dfn[u]] = u;\n            for (auto v : adj[u])\n            {\n                top[v] = v == adj[u][0] ? top[u] : v;\n                dfs2(v);\n            }\n            enddfn[u] = cur;\n        }\n        /*\n         * @brief 返回u到v的最近公共祖先\n         * @param u 起点\n         * @param v 终点\n         * @return 返回u到v的最近公共祖先节点\n         */\n        int lca(int u, int v)\n        {\n            while (top[u] != top[v])\n            {\n                if (dep[top[u]] > dep[top[v]])\n                {\n                    u = parent[top[u]];\n                }\n                else\n                {\n                    v = parent[top[v]];\n                }\n            }\n            return dep[u] < dep[v] ? u : v;\n        }\n        /*\n         * @brief 返回u到v的距离\n         * @param u 起点\n         * @param v 终点\n         * @return 返回u到v的距离\n         */\n        int dist(int u, int v)\n        {\n            return dep[u] + dep[v] - 2 * dep[lca(u, v)];\n        }\n        /*\n         * @brief 跳跃\n         * @param u 起点\n         * @param k 跳跃距离\n         * @return 返回跳跃后的节点\n         */\n        int jump(int u, int k)\n        {\n            if (dep[u] < k)\n            {\n                return -1;\n            }\n\n            int d = dep[u] - k;\n\n            while (dep[top[u]] > d)\n            {\n                u = parent[top[u]];\n            }\n\n            return rk[dfn[u] - dep[u] + d];\n        }\n        /*\n         * @brief 判断u是否是v的祖先\n         * @param u 起点\n         * @param v 终点\n         * @return 返回u是否是v的祖先\n         */\n        bool isAncester(int u, int v)\n        {\n            return dfn[u] <= dfn[v] && dfn[v] < enddfn[u];\n        }\n        /*\n        int rootedParent(int u, int v)\n        {\n            std::swap(u, v);\n            if (u == v)\n            {\n                return u;\n            }\n            if (!isAncester(u, v))\n            {\n                return parent[u];\n            }\n            auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y)\n                                       { return dfn[x] < dfn[y]; }) -\n                      1;\n            return *it;\n        }\n        int rootedSize(int u, int v)\n        {\n            if (u == v)\n            {\n                return n;\n            }\n            if (!isAncester(v, u))\n            {\n                return siz[v];\n            }\n            return n - siz[rootedParent(u, v)];\n        }\n\n        int rootedLca(int a, int b, int c)\n        {\n            return lca(a, b) ^ lca(b, c) ^ lca(c, a);\n        }*/\n    };\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.3 树的直径\n\n树形$dp$，求出每个点的最长路和次长路。\n\n```cpp\nvoid dfs(int u,int fa){\n    int sum1=0,sum2=0;\n    f[u]=1;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            dfs(i,u);\n            if(f[i]>sum1)sum2=sum1,sum1=f[i];\n            else if(f[i]>sum2)sum2=f[i];\n        }\n    }\n    if(f[u]+sum1+sum2>ans)ans=f[u]+sum1+sum2;\n    f[u]+=sum1;\n}\n```\n\n### 5.4 树的重心\n\n无根树的重心点定义为树种的点$u$，使得$u$相邻的所有子树的子树大小均不大于树大小的一半。显然一棵树最多只有两个重心（当树节点为奇数时），且两个重心必定相邻。根据这个可以进行一定的二分（2024南京站G）\n\n**性质1**\n\n某个点是树的**重心**等价于它最大子树大小**不大于**整棵树大小的**一半**。\n\n**性质2**\n\n树**至多有两个**重心。如果树有两个重心，那么它们**相邻**。此时树一定有**偶数**个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。\n\n**性质3**\n\n树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。\n\n**性质4**\n\n往树上增加或减少一个叶子，如果原节点数是奇数，那么重心可能增加一个，原重心仍是重心；如果原节点数是偶数，重心可能减少一个，另一个重心仍是重心\n\n**性质5**\n\n把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。\n\n```cpp\nint n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小\nvector<int> ctr; // 重心\nvoid dfs(int p, int fa = 0) // 找重心\n{\n    sz[p] = 1, mss[p] = 0;\n    for (auto [to, w] : edges[p])\n        if (to != fa)\n        {\n            dfs(to, p);\n            mss[p] = max(mss[p], sz[to]);\n            sz[p] += sz[to];\n        }\n    mss[p] = max(mss[p], n - sz[p]);\n    if (mss[p] <= n / 2) ctr.push_back(p);\n}\n```\n\n### 5.5 树上差分\n\n见数据结构静态树部分。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.6 树上启发式合并\n\n树上启发式合并是一种暴力的$Trick$，通过小子树信息向大子树合并，实现和并查集按秩合并一样的亚线性复杂度。估算按照$nlogn$​算就行，也是一种乱搞做法。\n\n示例1: **2024杭电多校1 树**\n\n给一棵根为 $1$ 的有根树，点 $i$ 具有一个权值 $A_i$ 。\n\n定义一个点对的值 $f(u,v)=max(A_u,A_v)×|A_u−A_v|$ 。\n\n你需要对于每个节点 $i$ ，计算 $ans_i=∑_{u∈subtree(i),v∈subtree(i)}f(u,v) $，其中 $subtree(i)$ 表示 $i$ 的子树。\n\n请你输出 $⊕(ans_i\\ mod\\ 2^{64})$ ，其中 ⊕ 表示 $XOR$​​.\n\n显然硬按着结点不好想。\n\n考虑两个子树合并，$ans_i$的信息是一定要继承$ans_{u},u\\in son(i)$的。考虑不同属于两个子树的点如何处理。\n\n权值树合并，权值树区间合并的时候，一定是左部分的区间点权小于右部分的区间点权。所以两部分合并的时候右半区间的每一个点会额外产生\n$$\n\\large\\sum -sum_{lsons}\\times val_{r_i}+cnt_{lson}\\times val_{r_i}^2\n$$\n线段树结点维护区间$sum$、区间数个数、区间$sum^2$即可。然后$nlogn$​线段树树上启发式合并即可。\n\n<div style=\"page-break-after: always;\"></div>\n\n示例2：**2024杭电多校3 旅行**\n\n有一棵$n$ 个结点的无根树，每个结点都有对应的类型 $c_i$ 和权重 $w_i$ ，你需要在这棵树上规划若干次旅行。\n\n对于一次旅行，你将从一个树上的一个结点出发，沿着树上的边进行旅行，最终到达另一个和起点类型相同的结点。\n\n你会进行很多次旅行，但你希望对于每个结点，在所有旅行路线中最多只会经过一次。\n\n一次旅行的价值是起始点和终止点的权重和，你需要规划旅行的方案使得旅行的总权重和最大。\n\n$\\sum n\\le 2e5,c_i\\le n,w_i \\le 1e6$​\n\n和子树有关，考虑子树合并。\n\n一个子树内最优解为$dp_u$，那么其和另一个子树$dp_v$进行合并更新。那么有两种更新方式：\n\n$\\large dp_u=max(dp_u+dp_v,\\{f_{u,c}+f_{v,c}\\})$\n\n其中$f_{u,c}$表示$u$子树上传一个颜色为$c$的路径接口所能提供的最大权值和。显然$dp_u$是不提供上传路径的。\n\n对$f_{u,c}$​的更新有下列式子，出于启发式合并，如果$v$上传路径穿过$u$，则不能使用$dp_u$\n\n$f_{u,c}=max(f_{u,c}+dp_v,f_{v,c}+\\sum_{t\\in son(u)} dp_t)$​\n\n启发式线段树合并即可。\n\n```cpp\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\n#define int long long\nstruct node\n{\n    int l, r;\n    i64 f;\n    i64 lz = 0;\n};\nconst int maxn = 3e5 + 9;\nnode tree[maxn << 5];\nint tot = 0;\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0, 0};\n    return tot;\n}\nvoid pushup(int rt)\n{\n    tree[rt].f = max(tree[tree[rt].l].f, tree[tree[rt].r].f);\n    return;\n}\nvoid pushd(int rt)\n{\n    if (tree[rt].lz)\n    {\n        if (tree[rt].l)\n        {\n            tree[tree[rt].l].f += tree[rt].lz;\n            tree[tree[rt].l].lz += tree[rt].lz;\n        }\n        if (tree[rt].r)\n        {\n            tree[tree[rt].r].f += tree[rt].lz;\n            tree[tree[rt].r].lz += tree[rt].lz;\n        }\n        tree[rt].lz = 0;\n    }\n    return;\n}\nvoid upd(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n        rt = newnode();\n    if (cl == cr)\n    {\n        tree[rt].f = val;\n        return;\n    }\n    pushd(rt);\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        upd(tree[rt].l, pos, val, cl, mid);\n    else\n        upd(tree[rt].r, pos, val, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nvector<i64> dp, dpson, w, c;\nint n;\nvector<vector<int>> con;\nvector<int> root;\nvoid merges(int &rt1, int &rt2, int cl, int cr, i64 &ans, i64 dpv, i64 dpson)\n{\n    if (!rt1 || !rt2)\n    {\n        if (rt1)\n        {\n            tree[rt1].f += dpv;\n            tree[rt1].lz += dpv;\n        }\n        else\n        {\n            tree[rt2].f += dpson;\n            tree[rt2].lz += dpson;\n        }\n        rt1 |= rt2;\n        return;\n    }\n    if (cl == cr)\n    {\n        ans = max(ans, tree[rt1].f + tree[rt2].f);\n        tree[rt1].f = max(tree[rt1].f + dpv, tree[rt2].f + dpson);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    pushd(rt1), pushd(rt2);\n    merges(tree[rt1].l, tree[rt2].l, cl, mid, ans, dpv, dpson);\n    merges(tree[rt1].r, tree[rt2].r, mid + 1, cr, ans, dpv, dpson);\n    pushup(rt1);\n    return;\n}\nvoid dfs(int u, int f)\n{\n    upd(root[u], c[u], w[u], 1, n);\n    dp[u] = 0, dpson[u] = 0;\n    for (auto &v : con[u])\n    {\n        if (v == f)\n            continue;\n        dfs(v, u);\n        i64 tmp = 0;\n        merges(root[u], root[v], 1, n, tmp, dp[v], dpson[u]);\n        dp[u] = max(dp[u] + dp[v], tmp);\n        dpson[u] += dp[v];\n    }\n}\nvoid solve()\n{\n    tot = 0;\n    cin >> n;\n    dp.assign(n + 1, 0);\n    dpson.assign(n + 1, 0);\n    w.assign(n + 1, 0);\n    c.assign(n + 1, 0);\n    root.assign(n + 1, 0);\n    for (int i = 1; i <= n; i++)\n        cin >> c[i];\n    for (int i = 1; i <= n; i++)\n        cin >> w[i];\n    con.assign(n + 1, vector<int>());\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        con[u].push_back(v);\n        con[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout << dp[1] << endl;\n}\n\nsigned main()\n{\n    // freopen(\"1002.in\", \"r\", stdin);\n    // freopen(\"1.out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n示例3：（未知来源，朱的例题）\n\n```cpp\n//处理子树相关的问题，不支持修改，nlogn的复杂度，离线算法\n#include<bits/stdc++.h>\n#define LL long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint N, col[MAXN], son[MAXN], siz[MAXN], cnt[MAXN], Mx, Son;\nLL sum = 0, ans[MAXN];\nvector<int> v[MAXN];\nvoid dfs(int x, int fa) {\n    siz[x] = 1;\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa) continue;\n        dfs(to, x);\n        siz[x] += siz[to];\n        if(siz[to] > siz[son[x]]) son[x] = to;//轻重链剖分\n    }\n}\nvoid add(int x, int fa,int c) {//暴力计算x的子树颜色和，不考虑重边，\n    cnt[col[x]] +=c;//这里可能会因题目而异\n    if(cnt[col[x]] > Mx) Mx = cnt[col[x]], sum = col[x];\n    else if(cnt[col[x]] == Mx) sum += (LL)col[x];\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa || to == Son) continue;\n        add(to, x,c);\n    }\n}\nvoid dfs2(int x, int fa, int opt) {//处理当前节点的答案\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa) continue;\n        if(to != son[x]) dfs2(to, x, 0);//简单的往轻边走算轻边的答案，opt = 0表示递归完成后消除对该点的影响\n    }\n    if(son[x]) dfs2(son[x], x, 1), Son = son[x];//统计重儿子的贡献，不消除影响\n    //这时候的sum和Mx都是只考虑重儿子计算出来的\n    add(x, fa,1); Son = 0;\n    //暴力统计所有轻儿子的贡献，会递归所有轻儿子，除了当前节点的重儿子，而不是son[x]，因为轻儿子的重儿子是需要计算的，这里只是不需要计算x的重儿子\n    ans[x] = sum;//更新答案\n    if(!opt) add(x,fa,-1), sum = 0, Mx = 0;//如果需要删除贡献的话就删掉\n}\nint main() {\n    N = read();\n    for(int i = 1; i <= N; i++) col[i] = read();\n    for(int i = 1; i <= N - 1; i++) {\n        int x = read(), y = read();\n        v[x].push_back(y); v[y].push_back(x);\n    }\n    dfs(1, 0);\n    dfs2(1, 0, 1);\n    for(int i = 1; i <= N; i++) printf(\"%I64d \", ans[i]);\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 6.图的连通性\n\n### 6.1 无向图连通性\n\n无向图的连通性主要关于点双联通分量和边双联通分量，用于操作缩点以及缩边，从而把无向图中的环删掉。\n\n#### 6.1.1 割点\n\n对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。\n\n```cpp\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=2e4+1e3;\nint n,m,ans;\nvector<int> g[N];\nbool cut[N];\nint dfn[N],low[N],cnt;\nvoid tarjan(int u,int root){\n    dfn[u]=low[u]=++cnt;\n    int child=0;\n    for(auto v:g[u]){\n        if(!dfn[v]){\n            tarjan(v,root),low[u]=min(low[u],low[v]);\n            if(low[v]>=dfn[u]&&u!=root) cut[u]=true;//如果儿子的low值大于等于dfn，则代表其为儿子与其他非子树点相连的唯一途径\n            if(u==root) child++;\n        }\n        else low[u]=min(low[u],dfn[v]);//注意这里是dfn[v]\n    //因为割点判定法则是小于等于号，所以在求割点时，不必考虑父节点和重边的问题，从x出发能访问到的所有点的时间戳都可以用来更新 lowx\n    }\n    if(child>=2&&u==root)cut[u]=true;//对根的处理,大于两个子树\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        g[u].pb(v);g[v].pb(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(!dfn[i]) tarjan(i,i);\n    for(int i=1;i<=n;i++)\n        if(cut[i]) ans++;\n    cout<<ans<<endl;\n    for(int i=1;i<=n;i++)\n        if(cut[i]) cout<<i<<\" \";\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.2 割边\n\n对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。严谨来说，就是：假设有连通图 $G=(V,E)$​，$e$​是其中一条边（即 $e\\in E$​)，如果$G-e$​ 是不连通的，则边 $e$​是图$G$​的一条割边（桥)。\n\n```cpp\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=200;\nint n,m,sum;\nint a[200][200];\nbool cut[N];\nint dfn[N],low[N],cnt,fa[N];\nstruct Edge {\n    int x,y;\n} edge[5001];\nbool cmp(struct Edge a,struct Edge b) {\n    if(a.x==b.x)return a.y<b.y;\n    return a.x<b.x;\n}\nvoid tarjan(int u){\n    dfn[u]=low[u]=++cnt;\n    for(int v=1; v<=n; v++) {\n        if(!a[u][v])continue;\n        if(!dfn[v]){\n            fa[v]=u,tarjan(v),low[u]=min(low[u],low[v]);\n            if(low[v]>dfn[u]) edge[++sum].x=u, edge[sum].y=v;//儿子回不到父亲以上的位置\n        }\n        else if(v!=fa[u])low[u]=min(low[u],dfn[v]);//注意这里不能是fa[u],不然上面的if那里一定取不了大于号！\n        //low的意思这里是不经过父亲能回到的最早的点\n    }\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        a[u][v]=a[v][u]=1;\n    }\n    for(int i=1; i<=n; i++) \n        if(!dfn[i])tarjan(i);//tarjan\n    sort(edge+1,edge+sum+1,cmp);\n    for(int i=1;i<=sum; i++) {\n        cout<<min(edge[i].x,edge[i].y)<<' '<<max(edge[i].x,edge[i].y)<<endl;//输出\n    }\n    return 0;\n}\n\n```\n\n封装风格：\n\n```cpp\nmap<array<int, 3>, int> mp;\n    vector<int> dfn(n), low(n), fa(n);\n    int cnt = 0;\n    function<void(int)> tarjan = [&](int u)\n    {\n        dfn[u] = low[u] = ++cnt;\n        for (auto [v, w] : newcon[u])\n        {\n            if (!dfn[v])\n            {\n                fa[v] = u, tarjan(v), low[u] = min(low[u], low[v]);\n                if (low[v] > dfn[u])\n                    mp[{u, v, w}] = mp[{v, u, w}] = 1; // 割边\n            }\n            else if (v != fa[u])\n                low[u] = min(low[u], dfn[v]);\n        }\n    };\n    for (int i = 0; i < n; i++)\n        if (!dfn[i])\n            tarjan(i);\n```\n\n\n\n\n\n#### 6.1.3 点双\n\n若一个无向图中的去掉任意一个点都不会改变此图的连通性，即不存在割点，则称作点双连通图。一个无向图中的每一个极大点双连通子图称作此无向图的点双连通分量。\n\n对于两个点$u,v$，如果删除除他们自己外哪一个点都不能使其不联通，则称两点之间双联通。点双联通不具有传递性。\n\n```cpp\n/*点双连通：若对于一个无向图，其任意一个节点对于这个图本身而言都不是割点，则称其点双连通。也就是说，删除任意点及其相关边后，整个图仍然属于一个连通分量。\n\n点双连通分量：无向图中，极大的点双连通子图。与连通分量类似，抽离出一些点及它们之间的边，使得抽离出的图是一个点双连通图，在这个前提下，使得抽离出的图越大越好。*/\n\n/*桥（割边）不属于任何 e-DCC（边双连通分量），但是割点可能属于多个 v-DCC*/\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int N = 1000010, M = 5000010;\nint dfn[N], low[N], stack[N],cut[N];\nint n, m, tot = 1, num, root, top, sum, cnt;\nvector<int> dcc[N * 2];//dcc[i] 存储编号为 i 的 v-DCC 中的所有节点\nvector<int> edge[N];\nvoid tarjan(int u,int root) {\n    //不用特别根节点是不是割点，它一定属于它儿子的点双中，无论是不是割点\n    dfn[u] = low[u] = ++cnt;\n    stack[++top] = u;\n    if (u == root && edge[u].size() == 0) { //孤立点直接处理\n        dcc[++sum].push_back(u);\n        return;\n    }\n    for (auto v:edge[u]) {\n        if (!dfn[v]) {\n            tarjan(v,root);low[u] = min(low[u], low[v]);\n            if (low[v] >= dfn[u]) {//u为割点，把栈里u前的都要出去\n                sum++;\n                int z;\n                do {//弹栈\n                    z = stack[top--];\n                    dcc[sum].push_back(z);\n                } while (z != v);//把v弹走后目前栈顶为u(u为割点)，u不能弹走因为它属于多个点双（至少2）\n                dcc[sum].push_back(u);//单独加入u\n            }\n        } \n        else low[u] = min(low[u], dfn[v]);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        if(u!=v)edge[u].push_back(v),edge[v].push_back(u);//判自环\n    }\n    for (int i=1;i<=n;i++)\n        if (!dfn[i])tarjan(i,i);\n    //for (int i=1;i<=n;i++)cout<<low[i]<<endl;\n    cout<<sum<<endl;\n    for (int i=1;i<=sum;i++) { \n        cout<<dcc[i].size();\n        for (auto j:dcc[i])\n            cout << ' ' << j;\n        cout<<endl;\n    }\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.4 边双\n\n若一个无向图中的去掉任意一条边都不会改变此图的连通性，即不存在割桥，则称作边双连通图。一个无向图中的每一个极大边双连通子图称作此无向图的边双连通分量。\n\n在一张连通的无向图中，对于两个点$u$和$v$，如果无论删去哪条边（只能删去一条）都不能使它们不连通，我们就说$u$和$v$ **边双连通**。边双联通具有传递性\n\n```cpp\n//边双连通分量，很显然，边双连通分量中没有割边，所以只需要去掉所有桥边剩下的就是边双，跑dfs即可\n//注意这里可能有重边，所以我们存图的时候额外存一下每边的数量（map），找桥的时候正常找，如果非桥边有多个不影响，桥边有多个就说明额外连起来了两个v-ecc，所以我们找到桥边就数量-1，dfs的时候正常dfs，如果桥边还有那就走，没有的话就说明是一个v-ecc\n//用于无向图的缩点\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=5e5+10;\nint n,m,sum;\nint dfn[N],low[N],cnt,fa[N],vis[N];\nunordered_map<int,int>mp[N];\nvector<int>edge[N],ans[N];//ans即是bcc\nvoid tarjan(int u){\n    dfn[u]=low[u]=++cnt;\n    for(auto v:edge[u]) {\n        if(!dfn[v]){\n            fa[v]=u,tarjan(v),low[u]=min(low[u],low[v]);\n            if(low[v]>dfn[u]) mp[u][v]--,mp[v][u]--;//儿子回不到父亲以上的位置\n        }\n        else if(v!=fa[u])low[u]=min(low[u],dfn[v]);//注意这里不能是fa[u],不然上面的if那里一定取不了大于号！\n        //low的意思这里是不经过父亲能回到的最早的点\n    }\n}\nvoid dfs(int u,int k){\n    ans[k].emplace_back(u);\n    vis[u]=1;\n    for(auto v:edge[u]){\n        if(!vis[v]&&mp[u][v]){\n            dfs(v,k);\n        }\n    }\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        if(u==v)continue;\n        if(mp[u].find(v)==mp[u].end()||mp[v].find(u)==mp[v].end()){\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n            mp[u][v]=1;\n            mp[v][u]=1;\n        }\n        else  mp[u][v]++,mp[v][u]++;\n    }\n    for(int i=1; i<=n; i++) \n        if(!dfn[i])tarjan(i);//tarjan\n    for(int i=1; i<=n; i++) {\n        if(!vis[i]){\n            sum++;\n            dfs(i,sum);\n        }\n    }\n    cout<<sum<<endl;\n    for(int i=1;i<=sum;i++){\n        cout<<ans[i].size()<<\" \";\n        for(auto j:ans[i])cout<<j<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *6.1.5 圆方树\n\n```cpp\n//点双的关键性质:对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双。\n//即同一个点双中的两不同点 u,v 之间一定存在一条简单路径经过给定的在同一个点双内的另一点 w。所以看到简单路径的时候，可以考虑圆方树\n//圆方树：点双当作一个点，这个点和所有点连边形成的树，这样不同点双会靠割点联系起来形成一棵树\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int N = 100005;\nint n,m, cnt;\nint dfn[N], low[N], dfc;\nint stk[N], tp;\nvector<int> G[N], T[N * 2];//相关数组开两倍！！！\nvoid tarjan(int u) {\n    low[u] = dfn[u] = ++dfc; //dfs序\n    stk[++tp] = u; \n    for (auto v : G[u]) { // 遍历 u 的相邻节点\n        if (!dfn[v]) { \n            tarjan(v); low[u] = min(low[u], low[v]); \n            if (low[v] == dfn[u]) { // 找到一个以 u 为根的点双连通分量\n                ++cnt; // 增加方点个数\n                for (int x = 0; x != v; --tp) {// 将点双中除了 u 的点退栈，并在圆方树中连边\n                    x = stk[tp];\n                    T[cnt].push_back(x);\n                    T[x].push_back(cnt);\n                }\n                T[cnt].push_back(u);\n                T[u].push_back(cnt);\n            }\n        }\n        else low[u] = min(low[u], dfn[v]); // 已访问的和 dfn 取 min\n    }\n}\nsigned main() {\n    cin>>n>>m;\n    cnt = n; \n    for (int i = 1; i <= m; ++i) {\n        int u, v;cin>>u>>v;\n        G[u].push_back(v); \n        G[v].push_back(u);\n    }\n    // 处理非连通图\n    for (int u = 1; u <= n; ++u)\n        if (!dfn[u]) tarjan(u), --tp;\n        // 注意到退出 Tarjan 时栈中还有一个元素即根，将其退栈\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.2 有向图连通性\n\n#### 6.2.1 强连通分量\n\n强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。\n\n强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图\n\n```cpp\n#include <bits/stdc++.h> //O(n+m)\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\nconst int M = 1e6 + 10;\nint n, m, u, v, cnt, sum;\nint dfn[N], low[N], vis[N], belong[N], flag[N]; // belong的含义是这个点是否属于一个强连通分量，low[x] x能通过有向边能回溯到的最早时间段\nvector<int> edge[N];\nvector<int> q[N];\nstack<int> s;\nvoid tarjan(int x)\n{ // tarjan算法，处理x所在的连通块的强连通分量\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (!belong[i])\n            low[x] = min(dfn[i], low[x]);\n        // 如果这个点不属于任何一个强连通分量，说明在栈中，即需要考虑更新low值\n        // 不在栈里说明不可能存在于一个强连通分量(访问过了又不在栈里，说明已经是一个强连通分量出去了)\n    }\n    if (low[x] == dfn[x])\n    { // 回溯时把（x到栈顶的点）全归为一个强连通分量\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0; // 退栈\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> u >> v;\n        edge[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        if (!dfn[i])\n            tarjan(i);\n    cout << sum << endl;\n    for (int i = 1; i <= n; i++)\n    {\n        if (!flag[i])\n        {\n            sort(q[belong[i]].begin(), q[belong[i]].end());\n            for (auto j : q[belong[i]])\n            {\n                flag[j] = 1;\n                cout << j << \" \";\n            }\n            cout << endl;\n        }\n    }\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.2.2 缩点\n\n缩点的本质就是一个环可以等效处理成一个点时，我们把旧图的每一个强连通分量当作一个点建立一个新图，并把一个环的信息全部统计到一个新点上。\n\n给定一个 $n$个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。\n\n允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。\n\n```cpp\n#include <bits/stdc++.h> //缩点的本质就是一个环可以等效处理成一个点时，我们把旧图的每一个强连通分量当作一个点建立一个新图，并把一个环的信息全部统计到一个新点上\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\nconst int M = 1e6 + 10;\nint n, m, u, v, cnt, sum, k;\nint dfn[N], low[N], vis[N], belong[N], a[N], b[N], in[N], c[N], f[N];\nvector<int> edge[N];\nvector<int> out[N];\nvector<int> inn[N];\nvector<int> q[N];\nstack<int> s;\nvoid topo()\n{\n    queue<int> q;\n    for (int i = 1; i <= sum; i++)\n        if (!in[i])\n            q.push(i);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        c[++k] = u;\n        for (auto j : out[u])\n        {\n            in[j]--;\n            if (!in[j])\n                q.push(j);\n        }\n    }\n}\nvoid tarjan(int x)\n{ // tarjan算法\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (vis[i])\n            low[x] = min(low[i], low[x]);\n    }\n    if (low[x] == dfn[x])\n    {\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0;\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> u >> v;\n        edge[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        if (!dfn[i])\n            tarjan(i);\n    // 现在有sum个强连通分量，接下来将每个强连通分量的信息统计到一个点上\n    for (int i = 1; i <= sum; i++)\n    {\n        for (auto j : q[i])\n        {\n            b[i] += a[j];\n        }\n    }\n    // b数组储存了每个强连通分量的权值和，统计完毕后建立新图\n    // 建图时注意考虑，两个强连通分量之间可能会有多重边！！搜索时注意vis数组\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto j : edge[i])\n        {\n            if (belong[i] == belong[j])\n                continue;\n            out[belong[i]].push_back(belong[j]);\n            inn[belong[j]].push_back(belong[i]);\n            in[belong[j]]++;\n        }\n    }\n    topo();\n    // 拓扑排序来决定dp转移顺序，因为一个点的最优解是从它的所有来边转移过来的，拓扑排序决定了在处理当前点时，它的来边已经全部处理好了\n    for (int i = 1; i <= k; i++)\n    {\n        int u = c[i];\n        f[u] = b[u];\n        for (auto j : inn[u])\n        { // 直接转移就可以\n            f[u] = max(f[u], f[j] + b[u]);\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= k; i++)\n        ans = max(ans, f[i]);\n    cout << ans;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *6.2.3 2-SAT适定性问题\n\n有 $n$ 个布尔变量 $x_1$$\\sim$$x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。\n\n2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。\n\n**输入格式**\n\n第一行两个整数 $n$ 和 $m$，意义如题面所述。\n\n接下来 $m$ 行每行 $4$ 个整数 $i$, $a$, $j$, $b$，表示 「$x_i$ 为 $a$ 或 $x_j$ 为 $b$」($a, b\\in \\{0,1\\}$)\n\n**输出格式**\n\n如无解，输出 `IMPOSSIBLE`；否则输出 `POSSIBLE`。\n\n下一行 $n$ 个整数 $x_1\\sim x_n$（$x_i\\in\\{0,1\\}$），表示构造出的解。\n\n$1\\leq n, m\\leq 10^6$ \n\n```cpp\n/*实际的问题里往往是给出一个更细致的情景，而且题干信息中\n会有二选一的标志，此时可以考虑往2-sat模型上考虑。考虑过程，即\n去寻找题目中的限制，把二选一等信息，转化为一个蕴含关系，即\na ⇒ b 这样的式子*/\n// 其中一个不成立则另一个一定成立\n#include <bits/stdc++.h> //O(n+m)\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 2e6 + 10;\nconst int M = 2e6 + 10;\nint n, m, u, v, cnt, sum;\nint dfn[N], low[N], vis[N], belong[N], flag[N]; // belong的含义是这个点是否属于一个强连通分量，low[x] x能通过有向边能回溯到的最早时间段\nvector<int> edge[N];\nvector<int> q[N];\nstack<int> s;\nvoid tarjan(int x)\n{ // tarjan算法，处理x所在的连通块的强连通分量\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (!belong[i])\n            low[x] = min(dfn[i], low[x]);\n        // 如果这个点不属于任何一个强连通分量，说明在栈中，即需要考虑更新low值\n        // 不在栈里说明不可能存在于一个强连通分量(访问过了又不在栈里，说明已经是一个强连通分量出去了)\n    }\n    if (low[x] == dfn[x])\n    { // 回溯时把（x到栈顶的点）全归为一个强连通分量\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0; // 退栈\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nvoid add(int a, int b)\n{\n    edge[a].push_back(b);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int a, b, x, y;\n        cin >> a >> x; // 第a个数为x或第b个数为y\n        cin >> b >> y;\n        if (x == 0 && y == 0) //\"如果第a个数为0或第b个数为0\"至少满足其一\n        {\n            add(a + n, b); // a=1则b=0\n            add(b + n, a); // b=1则a=0\n        }\n        if (x == 0 && y == 1) //\"如果第a个数为0或第b个数为1\"至少满足其一\n        {\n            add(a + n, b + n); // a=1则b=1\n            add(b, a);         // b=0则a=0\n        }\n        if (x == 1 && y == 0) //\"如果第a个数为1或第b个数为0\"至少满足其一\n        {\n            add(a, b);         // a=0则b=0\n            add(b + n, a + n); // b=1则a=1\n        }\n        if (x == 1 && y == 1) //\"如果第a个数为1或第b个数为1\"至少满足其一\n        {\n            add(a, b + n); // a=0则b=1\n            add(b, a + n); // b=0则a=1\n        }\n    }\n    for (int i = 1; i <= 2 * n; i++)\n        if (!dfn[i])\n            tarjan(i); // 两倍\n    for (int i = 1; i <= n; i++)\n    {\n        if (belong[i] == belong[i + n]) // 同一变量的两种取值在同一强联通分量里,说明无解\n        {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    cout << \"POSSIBLE\" << endl; // 否则就是有解\n    for (int i = 1; i <= n; i++)\n    {\n        if (belong[i] > belong[i + n])\n            cout << 1 << \" \"; // 两种取值中选择拓扑序较大的那个值，而强联通分量编号越小 -> 拓扑序越大 -> 越优\n        else\n            cout << 0 << \" \";\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## *7. 基环树\n\n基环树，只有一个环的树，边数为$n$.\n\n```cpp\n//1. 暴力删边\n//每次断开环上的一条边跑一遍答案，然后取最大值  适用于:数据较小，且环不会影响答案的题目\n//eg：旅行，每次的旅行一定是走n-1条边，直接暴力枚举删掉某一条边，跑一次答案 ，n^2过\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=2e5+10;\nint n,m,x[N],y[N],ans[N],cnt,tx,ty,sum[N],vis[N];\nvector<int>edge[N];\nvoid dfs(int u,int fa){\n    ans[++cnt]=u;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            dfs(i,u);\n        }\n    }\n}\nvoid dfs2(int u,int fa){\n    vis[u]=1;\n    sum[++cnt]=u;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            if((i==tx&&u==ty)||(i==ty&&u==tx)||vis[i])continue;\n            dfs2(i,u);\n        }\n    }\n}\nbool check(){\n    for(int i=1;i<=n;i++){\n        if(sum[i]==ans[i])continue;\n        else if(sum[i]>ans[i])return 0;\n        else return 1;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>m;\n    for(int u,v,i=1;i<=m;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n        x[i]=u;y[i]=v;\n    }\n    for(int i=1;i<=n;i++)\n        sort(edge[i].begin(),edge[i].end());\n    if(m==n-1){\n        dfs(1,0);\n        for(int i=1;i<=n;i++)\n            cout<<ans[i]<<\" \";\n        return 0;\n    }\n    for(int i=1;i<=m;i++){\n        memset(vis,0,sizeof(vis));\n        tx=x[i],ty=y[i];cnt=0;\n        dfs2(1,0);\n        if(cnt<n)continue;\n        if(ans[1]==0)\n            for(int j=1;j<=n;j++)ans[j]=sum[j];\n        else if(check())\n            for(int j=1;j<=n;j++)ans[j]=sum[j];\n    }\n    for(int i=1;i<=n;i++)\n        cout<<ans[i]<<\" \";\n    return 0;\n}\n//2. 断边跑两次\n//骑士，每个人有个讨厌的人，那么就是n个点n条边，形成了基环树，注意到环上的某一条边，意味着u和v不能同时选，我们计算两种情况，选u和选v\n//等价于强制隔开这两个人各自选一次\n//正确性：每个人只有一个讨厌的人，那么最终情况一定是，要么有他，要么有他讨厌的人，不可能都没有，所以跑两次是正确的\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define N 1000010\nconst int inf=0x3f3f3f3f;\nusing namespace std;\nint w[N],d[N],n,vis[N],flag,f[N][2],ans;\nvector<int>edge[N];\nvoid dp(int u){\n    vis[u]=1;\n    f[u][0]=0;f[u][1]=w[u];\n    for(auto i:edge[u]){\n        if(i!=flag){//不能dp回根\n            dp(i);\n            f[u][0]+=max(f[i][0],f[i][1]);\n            f[u][1]+=f[i][0];\n        }\n    }\n}\nvoid dfs(int u){\n    vis[u]=1;\n    if(vis[d[u]])flag=u;\n    else dfs(d[u]);\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n;\n    for(int u,v,i=1;i<=n;i++){\n        cin>>w[i]>>d[i];\n        edge[d[i]].push_back(i);//存的是仇恨他的人有哪些\n    }\n    for(int i=1;i<=n;i++){\n        if(vis[i])continue;\n        dfs(i);\n        //现在已经找到了一个环上的一条边:flag 和 d[flag]\n        //我们强制其中一个点不选\n        dp(flag);\n        int ans1=f[flag][0];//不选flag\n        flag=d[flag];\n        dp(flag);\n        int ans2=f[flag][0];//不选d[flag]\n        ans+=max(ans1,ans2);\n    }\n    cout<<ans<<endl;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n\n\n# Part 5. 字符串\n\n***强制规定：所有与字符串相关的数组下标或者函数接口如果未特殊说明，都是从$0$开始。***\n\n## 1.字符串哈希（双哈希）\n\n```cpp\ntemplate <int m1, int mod1, int m2, int mod2>\nstruct Stringhashs\n{\n    int n;\n    vector<i64> h1, h2, mi1, mi2;\n    string s;\n    void init(int n)\n    {\n        this->n = n;\n        h1.resize(n + 10);  // h1[i]表示前i个字符的哈希值，注意哈希数组是从1开始的\n        h2.resize(n + 10);  // h2[i]表示前i个字符的哈希值\n        mi1.resize(n + 10); // mi1[i]表示m1^i,哈希模数\n        mi2.resize(n + 10); // mi2[i]表示m2^i,哈希模数\n        mi1[0] = mi2[0] = 1;\n        s.clear();\n        for (int i = 1; i <= n; i++)\n        {\n            mi1[i] = (i64)mi1[i - 1] * m1 % mod1;\n            mi2[i] = (i64)mi2[i - 1] * m2 % mod2;\n            h1[i] = ((i64)h1[i - 1] * m1 + s[i - 1]) % mod1;\n            h2[i] = ((i64)h2[i - 1] * m2 + s[i - 1]) % mod2;\n        }\n    }\n    void insert(string s)\n    {\n        assert(s.size() <= n);\n        this->s = s;\n        for (int i = 0; i < s.size(); i++)\n        {\n            h1[i + 1] = ((i64)h1[i] * m1 % mod1 + s[i]) % mod1;\n            h2[i + 1] = ((i64)h2[i] * m2 % mod2 + s[i]) % mod2;\n        }\n    }\n    array<int, 2> queryfullhash(string s)\n    {\n        int h1 = 0, h2 = 0;\n        for (int i = 0; i < s.size(); i++)\n        {\n            h1 = ((i64)h1 * m1 % mod1 + s[i]) % mod1;\n            h2 = ((i64)h2 * m2 % mod2 + s[i]) % mod2;\n        }\n        return {h1, h2};\n    }\n    array<int, 2> query(int l, int r)\n    {\n        assert(n);\n        assert(l >= 0 && r < n && l <= r);\n        l++, r++;\n        int h1 = ((this->h1[r] - (i64)this->h1[l - 1] * mi1[r - l + 1] % mod1) % mod1 + mod1) % mod1;\n        int h2 = ((this->h2[r] - (i64)this->h2[l - 1] * mi2[r - l + 1] % mod2) % mod2 + mod2) % mod2;\n        return {h1, h2};\n    }\n};\nconst int mod1 = 1e9 + 7, mod2 = 998244353;\nusing hashs = Stringhashs<131, mod1, 13331, mod2>;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.KMP字符串匹配\n\n适配：文本串固定$T$，多个主串$S$，询问$T$在$S$中出现的次数。时间复杂度$O(|T|+\\sum |S|)$\n\n### 2.1 前缀函数与nxt数组\n\n前缀函数定义：$\\pi[i]$表示$s.substr(0,i+1)$中公共前后缀的长度。即有$s[0,\\cdots,\\pi[i]-1]=s[i-\\pi[i]+1,\\cdots,i]$。\n\n规定长度为$1$的字符串前缀函数为$0$。\n\n```cpp\nvector<int> prefix_function(string s) {\n  int n = (int)s.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\n```\n\n基于此维护的$KMP\\ nxt$数组就是方便寻找失配之后下一个配对的位置：\n\n```cpp\nnxt[0] = 0;\n        for (int i = 1, j = 0; i < T.size(); i++)\n        {\n            while (j && T[i] != T[j])\n                j = nxt[j - 1];\n            if (T[i] == T[j])\n                j++;\n            nxt[i] = j;\n        }\n```\n\n\n\n### 2.2 KMP字符串模式匹配算法\n\n$KMP$算法的精髓在于当前匹配失配之后模式串$T$的指针跳到哪里开始重新匹配的问题。因为已匹配部分保证了两段相同，那么只需要跳到公共前后缀的前缀后一位继续匹配就行了。前缀函数是对模式串$T$求解的。\n\n$KMP$匹配思想不只局限于字符串匹配，与匹配有关的$dp$题也会利用到$nxt$数组的思想来优化$dp$。\n\n```cpp\nstruct KMP\n{\n    string T;\n    vector<int> nxt;\n    KMP(string T) : T(T)\n    {\n        nxt.resize(T.size());\n        nxt[0] = 0;\n        for (int i = 1, j = 0; i < T.size(); i++)\n        {\n            while (j && T[i] != T[j])\n                j = nxt[j - 1];\n            if (T[i] == T[j])\n                j++;\n            nxt[i] = j;\n        }\n    }\n    vector<int> match(string S)\n    {\n        vector<int> res;\n        for (int i = 0, j = 0; i < S.size(); i++)\n        {\n            while (j && S[i] != T[j])\n                j = nxt[j - 1];\n            if (S[i] == T[j])\n                j++;\n            if (j == T.size())\n            {\n                res.push_back(i - j + 1);\n                j = nxt[j - 1];\n            }\n        }\n        return res;\n    }\n};\n```\n\n示例1:**2024湖南省赛 经文**\n\n题目大意：有一个长度为$n\\le 1000$的空串和长度为$t\\le 100$的模式串$T$，询问有多少用小写英文字母填充空串的方案数，使得$T$于其中不相交的出现精准$k$次。\n\n设$dp_{i,j,l}$表示前$i$个字符已经匹配了$j$个完整文本串，现在正在匹配$l$位置的方案数。枚举$26$个小写字母，初始匹配指针$pre=l$\n\n如果$s[pre]==char$，则直接有$dp[i][j][pre+1]+=dp[i][j][l]$，满一个则$j$进位。\n\n如果该字符导致了$fail$匹配，则类似$KMP$跳转$pre=nxt[pre-1]$，继续下一个位置的匹配，直到$pre=0$。如果$pre=0$都未能匹配，则说明下一个位置只能从头开始。\n\n```cpp\nbool flag = 0;\nfor (int pre = l; 1; pre = nxt[pre - 1])\n{\n    if (s[pre] == 'a' + m)\n    {\n        if (pre == sz - 1)\n        {\n            if (j + 1 <= k)\n            {\n                dp[i + 1][j + 1][0] += dp[i][j][l];\n                dp[i + 1][j + 1][0] %= mod;\n            }\n        }\n        else\n        {\n            dp[i + 1][j][pre + 1] += dp[i][j][l];\n            dp[i + 1][j][pre + 1] %= mod;\n        }\n        flag = 1;\n        break;\n    }\n    if (!pre)\n        break;\n}\n```\n\n完整代码：\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int sz = s.size();\n    vector<int> nxt(sz);\n    nxt[0] = 0;\n    for (int i = 1, j = 0; i < sz; i++)\n    {\n        while (j && s[i] != s[j])\n            j = nxt[j - 1];\n        if (s[i] == s[j])\n            j++;\n        nxt[i] = j;\n    }\n    vector<vector<vector<i64>>> dp(n + 1, vector<vector<i64>>(k + 1, vector<i64>(sz + 1)));\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; i++)              // 前i个字符\n        for (int j = 0; j <= k; j++)         // 已经匹配了j个\n            for (int l = 0; l < sz; l++)     // 正在匹配第l个\n                for (int m = 0; m < 26; m++) // 枚举字符\n                {\n                    bool flag = 0;\n                    for (int pre = l; 1; pre = nxt[pre - 1])\n                    {\n                        if (s[pre] == 'a' + m)\n                        {\n                            if (pre == sz - 1)\n                            {\n                                if (j + 1 <= k)\n                                {\n                                    dp[i + 1][j + 1][0] += dp[i][j][l];\n                                    dp[i + 1][j + 1][0] %= mod;\n                                }\n                            }\n                            else\n                            {\n                                dp[i + 1][j][pre + 1] += dp[i][j][l];\n                                dp[i + 1][j][pre + 1] %= mod;\n                            }\n                            flag = 1;\n                            break;\n                        }\n                        if (!pre)\n                            break;\n                    }\n                    if (!flag)\n                    {\n                        dp[i + 1][j][0] += dp[i][j][l];\n                        dp[i + 1][j][0] %= mod;\n                    }\n                }\n\n    i64 ans = 0;\n    for (int i = 0; i < sz; i++)\n    {\n        ans += dp[n][k][i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3. 字典树Trie\n\n写法见数据结构部分$01$Trie,没有本质区别。\n\n### 4. Manacher马拉车算法\n\n一种非常优秀的以线性时间复杂度求解字符串中最长回文子串的算法。\n\n```cpp\nint manacher(string t)\n{\n    string s;\n    int tot = 0;\n    s.push_back('$');\n    for (int i = 0; i < t.size(); i++)\n    {\n        s.push_back('#');\n        s.push_back(t[i]);\n    }\n    s.push_back('#');\n    int ans = 0;\n    vector<int> d(s.size() + 10);\n    d[0] = 1; // d[i]代表i为中心的最大半径-1,也表示原回文串长度\n    for (int i = 1, l = 0, r = 0; i < s.size(); ++i)\n    {\n        if (i <= r)\n            d[i] = min(d[l + r - i], r - i + 1);\n        while (s[i + d[i]] == s[i - d[i]])\n            d[i]++;\n        if (d[i] + i - 1 > r)\n            r = d[i] + i - 1, l = i - d[i] + 1;\n        ans = max(ans, d[i]);\n    }\n    return ans - 1;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5. AC自动机\n\n与$KMP$互补，本质依旧是$KMP$，实现的是多模式串$T_1\\to T_n$匹配唯一主串$S$​.复杂度$O(2\\sum|T_i|+|S|)$\n\n字典树上构建$Fail$指针的思路与$nxt$数组极其相似。考虑本模板中如果有$s[i]\\neq s[j]$，则$j=nxt[j-1]$含义为$i$匹配失败后所跳跃的位置。**第$i$个失配了，肯定要跳跃$i-1$的下一个适配点，也就是$nxt[j-1]$**\n\n考虑字典树中，如果结点$u$失配，意味着结点$u$的所有儿子都不适配下一个字符，但是结点$u$的父亲是适配上一个字符的，所以我们要去跳转下一个对应上一个字符的结点，这个就是$u$结点父亲所指向的$Fail$​结点。\n\n```cpp\nint Fail = trie[u].fail;\nfor (int i = 0; i < 26; i++)\n{\n    int v = trie[u].son[i];\n    if (!v)\n    {\n        trie[u].son[i] = trie[Fail].son[i];\n        continue;\n    }\n    trie[v].fail = trie[Fail].son[i];\n    in[trie[v].fail]++;\n    q.push(v);\n}\n```\n\n下面是模板，每重新一次新主串$S$都要重新跳一遍$Fail$指针。\n\n版本1：（只求有多少个文本串$T$于主串$S$中出现过）\n\n```cpp\n// 构建字典图实现自动跳转，构建失配指针实现多模式匹配。\n// 本题AC自动机解决求有多少个不同的模式串在文本串里出现过，且两个模式串不同当且仅当他们编号不同；\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct AC\n{\n    const static int N = 1 * 1e6 + 4;\n    int t[N][30], idx, q; // t[i][j]:表示一个节点，父节点的编号为I,自己的字符是j，idx是节点总数\n    int cnt[N];           // 记录以这个点为结尾有几个单词\n    int fail[N];          // 失配指针，从i跳到j就说明，word(j)是i的最长后缀！！\n    int getnum(char ch)\n    { // 字符转为数字\n        if (ch >= 'a' && ch <= 'z')\n            return ch - 'a' + 1;\n    }\n    void insert(string s)\n    {                              // 插入\n        int p = 0, len = s.size(); // 从0节点开始\n        for (int i = 0; i < len; i++)\n        {\n            int c = getnum(s[i]);\n            if (!t[p][c])\n                t[p][c] = ++idx; // 创建节点\n            p = t[p][c];         // 把父节点更改为上个节点\n        }\n        cnt[p]++; // 以该点为结尾的单词数量，因为不保证模式串一致\n    }\n    void build()\n    {\n        queue<int> q;\n        memset(fail, 0, sizeof(fail));\n        for (int i = 1; i <= 26; i++)\n            if (t[0][i])\n                q.push(t[0][i]);\n        // 根节点的首字符入队\n        // 不直接将0入队是为了避免指向自己\n        while (!q.empty())\n        {\n            int k = q.front();\n            q.pop(); // 当前结点\n            for (int i = 1; i <= 26; i++)\n            {\n                if (t[k][i])\n                {                                  // 如果子节点存在\n                    fail[t[k][i]] = t[fail[k]][i]; // 构建当前的fail指针\n                    // 原理，上一层的fail已经求出，例如上一层为her，自己是s，r的fail指向了er，若r有这个子节点s，由于er是her的最长后缀，那么ers必然是hers的最长后缀。\n                    // 另外结合else的代码 ，原本按道理如果没有s这个节点应不断跳fail，但这里为什么不用呢？因为如果跳完fail的话能换到一条链，则else的代码能够帮助一步跳过去所以可以一步，如果不能，则赋值为0，同样也是根节点，完美\n                    q.push(t[k][i]); // 入队\n                }\n                else\n                    t[k][i] = t[fail[k]][i];\n                // 匹配到空字符，则索引到父节点fail指针对应的字符，以供后续指针的构建\n                // 类似并差集的路径压缩，把不存在的tr[k][i]全部指向tr[fail[k]][i]\n                // 这句话在后面匹配主串的时候也能帮助跳转\n            }\n        }\n    }\n    int queryy(string S)\n    {\n        int len = S.size(), p = 0, ans = 0;\n        for (int i = 0; i < len; i++)\n        {\n            p = t[p][getnum(S[i])];\n            for (int j = p; j && ~cnt[j]; j = fail[j])\n                ans += cnt[j], cnt[j] = -1; // 答案加上结尾，cnt[j]=-1就是以后别在统计这里相关的了，防止重复\n            // 这个点开始跳fail数组，求得与之相关的后缀的单词有没有\n            // 分析j&&~cnt[j]:只有=-1时取反才是0，所以结束条件为跳到根节点（j=0）或者到达了求过的点\n            // 因为本题要求有多少个模式串出现过，所以不能重复贡献\n        }\n        return ans;\n    }\n};\nAC ac;\nint main()\n{\n    int n;\n    cin >> n;\n    string s;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> s;\n        ac.insert(s);\n    }\n    ac.build();\n    cin >> s;\n    cout << ac.queryy(s) << endl;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n版本2：返回每一个$T_i$​的出现次数\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nstruct AC\n{\n    const static int maxn = 2e5 + 9;\n    int n, cnt = 1, vis[maxn], ans, in[maxn << 5], Map[maxn];\n    struct Trie\n    {\n        int son[26], fail, flag, ans;\n        void clear() { memset(son, 0, sizeof(son)), fail = flag = ans = 0; }\n    } trie[maxn << 5];\n    queue<int> q;\n    void init(int _n)\n    {\n        for (int i = 0; i <= cnt; i++)\n            trie[i].clear();\n        for (int i = 1; i <= n; i++)\n            vis[i] = 0;\n        cnt = 1;\n        n = _n;\n    }\n    void insert(string t, int num)\n    {\n        int u = 1, len = t.size();\n        for (int i = 0; i < len; i++)\n        {\n            int v = t[i] - 'a';\n            if (!trie[u].son[v])\n                trie[u].son[v] = ++cnt;\n            u = trie[u].son[v];\n        }\n        if (!trie[u].flag)\n            trie[u].flag = num;\n        Map[num] = trie[u].flag;\n    }\n    void getFail()\n    {\n        for (int i = 0; i < 26; i++)\n            trie[0].son[i] = 1;\n        q.push(1);\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            int Fail = trie[u].fail;\n            for (int i = 0; i < 26; i++)\n            {\n                int v = trie[u].son[i];\n                if (!v)\n                {\n                    trie[u].son[i] = trie[Fail].son[i];\n                    continue;\n                }\n                trie[v].fail = trie[Fail].son[i];\n                in[trie[v].fail]++;\n                q.push(v);\n            }\n        }\n    }\n    void topu()\n    {\n        for (int i = 1; i <= cnt; i++)\n            if (in[i] == 0)\n                q.push(i);\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            vis[trie[u].flag] = trie[u].ans;\n            int v = trie[u].fail;\n            in[v]--;\n            trie[v].ans += trie[u].ans;\n            if (in[v] == 0)\n                q.push(v);\n        }\n    }\n    void query(string s)\n    {\n        int u = 1, len = s.size();\n        for (int i = 0; i < len; i++)\n            u = trie[u].son[s[i] - 'a'], trie[u].ans++;\n    }\n    vector<int> querys(string s)\n    {\n        vector<int> res;\n        query(s);\n        topu();\n        for (int i = 1; i <= n; i++)\n            res.push_back(vis[Map[i]]);\n        return res;\n    }\n};\nAC ac;\nint main()\n{\n    int n;\n    cin >> n;\n    ac.init(n);\n    for (int i = 1; i <= n; i++)\n    {\n        string t;\n        cin >> t;\n        ac.insert(t, i);\n    }\n    ac.getFail();\n    string s;\n    cin >> s;\n    auto res = ac.querys(s);\n    for (auto i : res)\n        cout << i << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6. 后缀数组SA\n\n***Warning: 此处SA数组的字符串下标定义是从1开始的！***\n\n后缀数组$sa[i]$表示的是字典序排名第$i$小的后缀是原来字符串中哪一个后缀。\n\n排名数组$rk[i]$表示原来字符串的后缀中第$i$个后缀是多少字典序。\n\n第$i$个后缀的定义：$s[i\\cdots n]$\n\n$O(nlogn)$求法：\n\n```cpp\nstruct SufArray\n{\n    const static int maxn = 1e6 + 9;\n    // rk[i] i 的排名  sa[i] 第i名\n    // 字符串的序号  +k 就是往后走k个\n    int rk[maxn + 10], sa[maxn + 10], n, lstrk[maxn + 10], lstsa[maxn], w,\n        m = 127, cnt[maxn], h[maxn], f[maxn][20];\n    string s;\n\n#define siz n * sizeof(int)\n    void init(string _s)\n    {\n        s = _s;\n        m = 127;\n        n = s.length();\n        memset(cnt, 0, sizeof cnt);\n        memset(sa, 0, sizeof sa);\n        memset(rk, 0, sizeof rk);\n        memset(h, 0, sizeof h);\n        for (int i = 1; i <= n; ++i)\n            ++cnt[rk[i] = s[i - 1]];\n        for (int i = 1; i <= m; ++i)\n            cnt[i] += cnt[i - 1];\n        for (int i = n; i >= 1; --i)\n            sa[cnt[rk[i]]--] = i;\n        memcpy(lstrk + 1, rk + 1, siz);\n        for (int p = 0, i = 1; i <= n; ++i)\n            if (lstrk[sa[i]] == lstrk[sa[i - 1]])\n                rk[sa[i]] = p;\n            else\n                rk[sa[i]] = ++p;\n        for (w = 1; w < n; w <<= 1, m = n)\n        {\n            for (int p = 0, i = n; i >= n - w + 1; --i)\n                lstsa[++p] = i;\n            for (int p = w, i = 1; i <= n; ++i)\n                if (sa[i] > w)\n                    lstsa[++p] = sa[i] - w;\n            memset(cnt, 0, sizeof cnt);\n            for (int i = 1; i <= n; ++i)\n                ++cnt[rk[lstsa[i]]];\n            for (int i = 1; i <= m; ++i)\n                cnt[i] += cnt[i - 1];\n            for (int i = n; i >= 1; --i)\n                sa[cnt[rk[lstsa[i]]]--] = lstsa[i];\n            memcpy(lstrk + 1, rk + 1, siz);\n            for (int p = 0, i = 1; i <= n; ++i)\n                if (lstrk[sa[i]] == lstrk[sa[i - 1]] && lstrk[sa[i] + w] == lstrk[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n        }\n        for (int i = 1, k = 0; i <= n; ++i)\n        {\n            if (rk[i] == 0)\n                continue;\n            if (k)\n                --k;\n            while (s[i + k - 1] == s[sa[rk[i] - 1] + k - 1])\n                ++k;\n            h[rk[i]] = k;\n        }\n\n        memset(f, 0x3f, sizeof f);\n        for (int i = 1; i <= n; ++i)\n            f[i][0] = h[i];\n        for (int j = 1; (1 << j) <= n; ++j)\n            for (int i = 1; i <= n - (1 << j) + 1; ++i)\n                f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n    }\n    int lcp(int x, int y)\n    { // 后缀x和后缀y的最长公共前缀\n        if (x == y)\n            return n - y + 1;\n        x = rk[x], y = rk[y];\n        if (x >= y)\n            swap(x, y);\n        int k = log2(y - (x + 1) + 1);\n        return min(f[x + 1][k], f[y - (1 << k) + 1][k]);\n    }\n} SA;\nvoid solve()\n{\n    string s;\n    cin >> s;\n    SA.init(s);\n    for (int i = 1; i <= SA.n; i++)\n        cout << SA.sa[i] << ' ';\n    cout << endl;\n    // for (int i = 1; i <= SA.n; i++)\n    //     cout << SA.h[i] << ' ';\n    // cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 7. SA数组(线性SA-IS)\n\n**Warning：此处SA数组以及height数组是从0开始的**\n\n```cpp\nstruct SA\n{\n    int n;\n    vector<int> sa, rk;\n    vector<i64> h;\n    SA(string s)\n    {\n        n = s.size();\n        s.push_back(0);\n        sa.resize(n);\n        h.resize(n - 1);\n        rk.resize(n);\n        iota(sa.begin(), sa.end(), 0);\n        sort(sa.begin(), sa.end(), [&](int a, int b)\n             { return s[a] < s[b]; });\n        rk[sa[0]] = 0;\n        for (int i = 1; i < n; ++i)\n        {\n            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);\n        }\n        int k = 1;\n        vector<int> tmp, cnt(n);\n        tmp.reserve(n);\n        while (rk[sa[n - 1]] < n - 1)\n        {\n            tmp.clear();\n            for (int i = 0; i < k; ++i)\n            {\n                tmp.push_back(n - k + i);\n            }\n            for (auto i : sa)\n            {\n                if (i >= k)\n                {\n                    tmp.push_back(i - k);\n                }\n            }\n            fill(cnt.begin(), cnt.end(), 0);\n            for (int i = 0; i < n; ++i)\n            {\n                ++cnt[rk[i]];\n            }\n            for (int i = 1; i < n; ++i)\n            {\n                cnt[i] += cnt[i - 1];\n            }\n            for (int i = n - 1; i >= 0; --i)\n            {\n                sa[--cnt[rk[tmp[i]]]] = tmp[i];\n            }\n            swap(rk, tmp);\n            rk[sa[0]] = 0;\n            for (int i = 1; i < n; ++i)\n            {\n                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);\n            }\n            k *= 2;\n        }\n        for (int i = 0, j = 0; i < n; ++i)\n        {\n            if (rk[i] == 0)\n            {\n                j = 0;\n                continue;\n            }\n            for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j];)\n                ++j;\n            h[rk[i] - 1] = j;\n        }\n    }\n};\n\nvoid solve()\n{\n    string s;\n    cin >> s;\n    SA sa(s);\n    for (int i = 0; i < s.size(); i++)\n        cout << sa.sa[i] + 1 << \" \";\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 8. 后缀自动机SAM\n\n$SAM$自动机是一种压缩子串信息的自动机，可以在线性时间内解决以下问题：\n\n- 在另一个字符串中搜索一个字符串的所有出现位置。\n- 计算给定的字符串中有多少个不同的子串。\n\n```cpp\nstruct SAM {\n    //root是1\n    int size, last, len[N << 1], fa[N << 1], tr[N << 1][31];\n    int nxt[N << 1], head[N << 1], to[N << 1], ecnt = 1;\n    int cnt[N << 1], first_pos[N << 1], is_clone[N << 1];\n\n#define sfor(x, i) for(int i = 0; i <= 30; ++i) if(tr[x][i])\n    SAM() {\n        size = last = ecnt = 1;\n    }\n    int extend(int x) {\n        int cur = ++ size,u;\n        cnt[cur] = 1, first_pos[cur] = len[cur] = len[last] + 1;\n        for(u = last; u && !tr[u][x]; u = fa[u]) tr[u][x] = cur;\n        if(!u) fa[cur] = 1;\n        else {\n            int v = tr[u][x];\n            if(len[v] == len[u] + 1) fa[cur] = v;\n            else {\n                int clone = ++ size;\n                len[clone] = len[u] + 1, fa[clone] = fa[v], first_pos[clone] = first_pos[v], is_clone[clone] = 1;\n                memcpy(tr[clone], tr[v], sizeof(tr[v]));//时间复杂度在这个地方\n                for(; u && tr[u][x] == v; u = fa[u]) tr[u][x] = clone;\n                fa[cur] = fa[v] = clone;\n            }\n        }\n        return last = cur;\n    }\n    //cnt数组表示endpos的大小，默认是真实大小\n    //d数组表示下面可以走多少路径，默认和endpos集合大小有关\n    //每个结点的endpos集合起始就是终点结点的endpos的集合\n//=========================================建树=========================================\n    void add(int x, int y) {\n        nxt[++ecnt] = head[x], to[ecnt] = y, head[x] = ecnt;\n    }\n    void build_tree() {\n        for(int i = 2; i <= size; ++i) add(fa[i], i);\n    }\n\n//===========================================求occ=========================================\n    int pos[N << 1], f[N << 1][20];//pos代表s[1...r]对应的结点\n    //调用的时候pos[r] = extend(s[r] - 'a' + 1);\n    //调用时先建树 并求得cnt\n    void get_f(int x = 1){//遍历后缀链接树\n        f[x][0] = fa[x];\n        for(int i = 1; i <= 19; ++i) f[x][i] = f[f[x][i - 1]][i - 1];\n        for(int i = head[x]; i; i = nxt[i]) if(fa[x] != to[i]) {\n            get_f(to[i]);\n        }\n    }\n    int node(int l, int r){\n        int now = pos[r];\n        for(int i = 19; i >= 0; --i) if(len[f[now][i]] >= r-l+1) now = f[now][i];\n        return now;//找到l...r所在的结点\n    }\n    int occ(int l, int r){\n        return cnt[node(l, r)];\n    }\n//==========================================求结点的cnt=======================================\n    void Get_cnt(int x) {\n        for(int i = head[x]; i; i = nxt[i]) Get_cnt(to[i]), cnt[x] += cnt[to[i]];\n    }\n    //调用时先建树\n    void get_cnt(int type = 1) {\n        if(type == 0) for(int i = 1; i <= size; ++i) cnt[i] = 1;    //不同位置的子串算作一个 强制每个子串只出现一次\n        else Get_cnt(1);\n    }\n    vector<int> endpos(int x) {\n        queue<int> q;\n        vector<int> ep;\n        q.push(x);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            if(!is_clone[now])  //是终点结点\n                ep.push_back(first_pos[now]);\n            for(int i = head[now]; i; i = nxt[i])\n                q.push(to[i]);\n        }\n        return ep;\n    }\n    //遍历后缀树：用图那一套 从1开始 //遍历后缀自动机：从1开始用tr转移\n    ll d[N], ans[N];//d记录了从x开始往下有几条路径 ans记录了从x开始，往下所有路径上不同子串的总长度。\n    void get_d(int x = 1) {\n        if(d[x]) return ;\n        d[x] = cnt[x];\n        sfor(x, i) get_d(tr[x][i]), d[x] += d[tr[x][i]];\n    }\n    void debug() {\n        puts(\"--------Debug_SAM--------\");\n        for(int i = 1; i <= size; ++i)\n            cout << \"i = \" << i << \", endpos_size = \" << cnt[i] << \", fa = \" << fa[i] << \", len = \" << len[i] << \", d = \" << d[i] << endl;\n        for(int i = 1; i <= size; ++i) {\n            cout << \"i = \" << i << \" can trans to \" << endl;\n            sfor(i, j)  cout << tr[i][j] << \" by \" << char(j + 'a' - 1) << endl;\n        }\n        puts(\"--------End_Debug--------\");\n    }\n} sam;\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 6. 动态规划\n\n## 1. sosdp（高维前缀和dp)\n\n对于所有的$i$,$0≤i≤2^n−1$,求解$∑_{j⊂i}a_j$。\n\n以$O(n2^n)$的复杂度管理子集前缀和$dp$​。\n\n子集：$i$对应是$0$的位置，$j$必须对应为$0$\n\n```cpp\nfor(int j = 0; j < n; j++) \n    for(int i = 0; i < 1 << n; i++)\n        if(i >> j & 1) f[i] += f[i ^ (1 << j)];\n\n```\n\n超集：$i$对应是$1$的位置，$j$必须对应$1$\n\n```cpp\nfor(int j = 0; j < n; j++) \n    for(int i = 0; i < 1 << n; i++)\n        if(!(i >> j & 1)) f[i] += f[i ^ (1 << j)];\n\n```\n\n示例1：（2024湖南省赛）\n\n给出一个长度为$n$的正整数串 。现在可以把两个没有重叠的连续子串前后拼接起来，但是要求拼接之后的数串中每个正整数不能出现超过$1$次。请问能拼接出来的符合要求的数字串的最大长度是多少。保证$a_i\\le18$.\n\n数据范围一眼状压$dp$，考虑维护出现不超过一次。显然两个串的$mask$位的交集为$0$，考虑串$A$的$mask$位$K$，则显然串$B$的$mask$必定有$mask_B\\subset(2^{18}\\oplus mask_A)$\n\n串长度不超过$18$，暴力枚举所有合法串初始化$dp$数组，然后跑$sosdp$维护子集$max$，最后暴力检查一圈就行了。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int B = (1 << 18) - 1;\nint mp[2 * B];\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], a[i]--;\n    int i = 1, j = 1;\n    int bit = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        bit = 0;\n        for (int j = 0; j < 18 && j + i <= n; j++)\n        {\n            if ((bit >> a[i + j]) & 1)\n            {\n                break;\n            }\n            bit ^= (1 << a[i + j]);\n            mp[bit] = max(mp[bit], j + 1);\n        }\n    }\n    int ans = 0;\n    for (int j = 0; j < 18; j++)\n    {\n        for (int i = 0; i <= B; i++)\n        {\n            if (i >> j & 1)\n                mp[i] = max(mp[i], mp[i ^ (1 << j)]);\n        }\n    }\n    for (int i = 0; i <= B; i++)\n    {\n        ans = max(ans, mp[i] + mp[B ^ i]);\n    }\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.线性dp\n\n### 2.1 LIS ($O(nlogn)$​)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint a[N], dp[N], dp2[N];\nint main()\n{\n    int n, ans = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        dp[i] = 1;\n    }\n    // O(nlogn)做法\n    int maxx = 0;\n    memset(dp2, inf, sizeof(dp2));\n    for (int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(dp2, dp2 + n, a[i]) - dp2;\n        if (j + 1 > maxx)\n            maxx = j + 1;\n        dp2[j] = a[i];\n    }\n    cout << maxx << endl;\n}\n```\n\n单调栈优化：\n\n```cpp\nint arr[maxn], sta[maxn];\nsigned main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> arr[i];\n    int len = 1;\n    sta[len] = arr[1];\n    for (int i = 2; i <= n; i++)\n    {\n        if (arr[i] > sta[len])\n        {\n            sta[++len] = arr[i];\n        }\n        else\n        {\n            int tem = lower_bound(sta + 1, sta + 1 + len, arr[i]) - sta;\n            sta[tem] = arr[i];\n        }\n    }\n    cout << len << endl;\n    // system(\"pause\");\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 背包\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 2;\n// 物品容积与权重\nint c[N], w[N], dp[N];\nint main()\n{\n    // 01背包\n    // 物品数目与背包体积\n    int n, v;\n    for (int i = 1; i <= n; i++)        // 枚举所有物品\n        for (int j = v; j >= c[i]; j--) // 枚举背包体积\n            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);\n    // 分组背包\n    // t[k][i]表示第k组的第i件物品的编号是多少\n    int ts, m, cnt[N], t[N][N];\n    for (int k = 1; k <= ts; k++)                                        // 循环每一组\n        for (int i = m; i >= 0; i--)                                     // 循环背包容量\n            for (int j = 1; j <= cnt[k]; j++)                            // 循环该组的每一个物品\n                if (i >= w[t[k][j]])                                     // 背包容量充足\n                    dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]); // 像0 - 1背包一样状态转移\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.3 整数划分\n\n```cpp\nll dp[maxn][maxn];\nll f[maxn][maxn], g[maxn][maxn];\nint n, k;\nvoid div1()\n{\n    // dp[i][j] 代表将i划分为不大于j的划分数(允许重复数字)\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (j == 1)\n                dp[i][j] = 1;\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        }\n    }\n}\nvoid div2()\n{\n    // dp[i][j] 代表将i划分为不大于j的划分数(没有重复数字)\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (j == 1)\n            {\n                if (i == 1)\n                    dp[i][j] = 1;\n                else\n                    dp[i][j] = 0; // 初始化不同即可, 转移方程依旧相同.\n            }\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1];\n        }\n    }\n}\nvoid div3()\n{\n    // dp[i][j]为将i恰好划分为j个整数的划分数\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i == j)\n                dp[i][j] = 1;\n            else if (i < j)\n                dp[i][j] = 0;\n            else\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];\n        }\n    }\n}\nvoid div4()\n{\n    // 设f[i][j]为将i恰好划分为j个奇数之和的划分数\n    //  g[i][j]为将i恰好划分为j个偶数之和的划分数。\n    f[0][0] = g[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i < j)\n                f[i][j] = g[i][j] = 0;\n            else\n            {\n                f[i][j] = f[i - 1][j - 1] + g[i - j][j];\n                g[i][j] = f[i - j][j];\n            }\n        }\n    }\n}\nvoid div5()\n{\n    // dp[i][j] 代表i划分为不多于j个正整数的划分数\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i == 1 || j == 1)\n                dp[i][j] = 1;\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.4 数位dp\n\n```cpp\nint a[maxn], f[maxn][maxn][2];\n// f[len][state],状压的state记录状态\nint dfs(int pos, int pre, bool limit, bool lead0, int cnt) {\n    if (!pos)\n        return 1;  // 看情况return 1还是cnt\n    auto& now = f[pos][pre][limit];\n    if (!lead0 && ~now)\n        return now;\n    int up = limit ? a[pos] : 9;\n    int res = 0;\n    for (int i = 0; i <= up; i++) {\n        if (!lead0 && abs(i - pre) < 2)\n            continue;  // 保证枚举的要合法\n        res += dfs(pos - 1, i, limit && i == up, lead0 && i == 0, cnt);\n    }\n    if (!lead0)\n        now = res;\n    return res;\n}\nint solve(int x) {\n    int len = 0;\n    while (x > 0) {\n        a[++len] = x % 10;\n        x /= 10;\n    }\n    return dfs(len, 0, true, true, 0);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.5 四边形不等式优化dp\n\n```cpp\nint m[maxn][maxn],dp[maxn][maxn],sum[maxn],arr[maxn];\n//m是区间分割点\nsigned main(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>arr[i];\n        sum[i]=sum[i-1]+arr[i];\n        m[i][i]=i;\n    }\n    for(int len=2;len<=n;len++){//枚举区间长度，也是对角线条数\n        for(int i=1,j=len;j<=n;i++,j++){\n            dp[i][j]=inf;\n            for(int k=m[i][j-1];k<=m[i+1][j];k++){\n                if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]<dp[i][j]){\n                    dp[i][j]=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1];\n                    m[i][j]=k;\n                }\n            }\n        }\n    }\n    cout<<dp[1][n]<<endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.6 状态压缩dp\n\n```cpp\nusing namespace std;\nconst int maxn = 1 << 16;\ndb f[17][1 << 17]; // 当前到第i个奶酪，并且已经经过的状态为j\ndb d[17][17];\ndb x[17] = {0}, y[17] = {0};\ndb dis(int i, int j)\n{\n    return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n}\nint main()\n{\n    int n = read();\n    memset(f, 127, sizeof(f));\n    db ans = f[0][0];\n    for (int i = 1; i <= n; i++)\n        cin >> x[i] >> y[i];\n    for (int i = 0; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            d[i][j] = d[j][i] = dis(i, j); // 初始化任意两个奶酪之间的距离\n    for (int i = 1; i <= n; i++)\n        f[i][1 << (i - 1)] = d[0][i];\n    for (int j = 0; j < (1 << n); j++)\n    { // 枚举当前已经走过的状态\n        for (int i = 1; i <= n; i++)\n        {\t\t\t\t\t\t\t\t   // 枚举当前已经到第i个奶酪\n            if ((j & (1 << (i - 1))) == 0) // 本应已经到了i个奶酪，但是还没走过i不合题意\n                continue;\n            for (int k = 1; k <= n; k++)\n            { // 枚举上一个走到的奶酪\n                if (i == k)\n                    continue;\t\t\t\t   // 重复了跳过\n                if ((j & (1 << (k - 1))) == 0) // 目前走过的j没走过k\n                    continue;\n                f[i][j] = min(f[i][j], f[k][j - (1 << (i - 1))] + d[i][k]);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        ans = min(ans, f[i][(1 << n) - 1]);\n    cout << fixed << setprecision(2) << ans << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.7 最短路优化dp\n\n最短路$dp$后效性问题会被最短路优化掉。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\n#define int long long\nconst int maxn = 2e5 + 9;\nvector<pair<int, int>> connects[maxn];\nint a[maxn];\nvoid add_edge(int u, int v, int w)\n{\n    connects[u].push_back({v, w});\n    connects[v].push_back({u, w});\n    return;\n}\nvector<int> dist, dist1;\nvoid Dijkstra_queue0()\n{\n    using pi = pair<int, int>;\n    vector<bool> vis(n + 1, 0);\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    for (int i = 1; i <= n; i++)\n    {\n        q.push({dist[i], i});\n    }\n    while (!q.empty())\n    {\n        auto [dis, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto [v, w] : connects[u])\n        {\n            if (vis[v])\n                continue;\n            if (dist[v] > dist[u] + w)\n            {\n                dist[v] = dist[u] + w;\n                q.push({dist[v], v});\n            }\n        }\n    }\n    return;\n}\nvoid Dijkstra_queue1()\n{\n    using pi = pair<int, int>;\n    vector<bool> vis(n + 1, 0);\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    for (int i = 1; i <= n; i++)\n    {\n        q.push({dist1[i], i});\n    }\n    while (!q.empty())\n    {\n        auto [dis, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto [v, w] : connects[u])\n        {\n            int now = min(dist[u], dist1[u] + w);\n            if (now < dist1[v])\n            {\n                dist1[v] = now;\n                q.push({dist1[v], v});\n            }\n        }\n    }\n    return;\n}\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        add_edge(u, v, w);\n    }\n    dist.resize(n + 10), dist1.resize(n + 10);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        dist[i] = dist1[i] = a[i];\n    }\n    Dijkstra_queue0();\n    Dijkstra_queue1();\n    cout << *max_element(dist1.begin() + 1, dist1.end()) << endl;\n}\n```\n\n","tags":["ACM","ICPC","算法模版"]},{"title":"我的21岁","url":"/2024/11/29/我的21岁/","content":"恍恍惚惚已经来到这个世界上20个年头，这段时期里有高光也有低谷，无论怎样，一切都已随风而去。对于过去，唯有感恩。正如涛涛的祝福一样，希望自己在今后心态和能力都要提升，更加成熟一点。新的一岁，要做到**言必信，行必果**。涛涛的祝福语还有一句”无事绊心弦，随缘皆所念”。好奇为什么不是“所愿皆所念”，可是发现“随缘”比“所愿”更好......真正在意你的人，又怎么会让你伤心呢，“送给自己一朵小红花，开在我新长的枝桠”，拥抱未来，珍惜爱我的人。\n\n<center>\n\n<img src=\"https://s2.loli.net/2024/11/29/Fh43SXJnB8y1Y5C.jpg\" width=\"100%\" />\n\nFigure 1\n</center>\n\n和室友聚餐庆祝一下。\n\n<center>\n\n<img src=\"https://s2.loli.net/2024/11/29/mn7x5To8t9VAEwY.jpg\" width=\"100%\" />\n\nFigure 2\n</center>","tags":["生日"]},{"title":"Mini App","url":"/2024/10/30/Mini App/","content":"## 作业要求\n**作业说明：**\n个人作业。不限主题，不限功能，做出一款Mini App\n\n**具体要求：**\n1.功能要求：可使用任意界面框架完成至少一个的功能点\n2.技术要求：需要使用到网络、存储等技术点中至少一条\n3.性能要求：不卡顿、无明显资源泄露\n\n**提交要求：**\n1.产品报告：不限于ppt/word/pdf格式，内容需至少包括 ①产品功能介绍；②程序概要设计；③软件架构图；④技术亮点及其实现原理（非必选）\n2.源代码：要求提交到GitHub/gitee repo仓库，将仓库地址粘贴到txt提交即可\n3.演示录屏：mkv, mp4, avi, rm, rmvb格式优先\n4.提交时间：11月30日晚12点前\n\n**提交格式：**\n请将以上三个内容合并到一个文件夹并压缩，命名：学校+姓名+Android/iOS+App名称\n上传至：\n腾讯客户端菁英班课程大作业提交\n\n**样例参考：**\n例1：《表情图库》\n1.功能要求：使用网格/列表，展示表情图库\n2.技术要求：使用 DB 存储图片文件信息，使用文件存储表情图片\n3.性能要求：快速打开超过1000张图片的图库，显示图片流畅滑动不卡顿，内存资源不泄露\n\n例2：《微信文本/图片聊天》\n1.功能要求：仿照微信做一个可以文本/图片聊天的界面\n2.技术要求：能够进行两人以上的聊天，能够发送文本/图片\n3.性能要求：聊天列表上下滑动不卡顿，没有资源泄露\n\n注：以上仅为样例参考，同学们可以任意选择自己想做的 Mini App。\n\n## 《表情图库》Web开发流程\n### 技术架构\n我们将使用以下技术：\n- **HTML**：负责网页结构。\n- **CSS**：负责页面布局和样式。\n- **JavaScript**：控制页面逻辑，操作 IndexedDB 数据库。\n- **IndexedDB**：用于存储图片的文件信息（包括路径、标题和分类）。\n图片文件存储在文件系统（`assets` 文件夹）中，数据库只存储图片的元数据。\n### 开发环境准备\n1.工具：\n- 下载并安装 [`VS Code`](https://code.visualstudio.com/) 作为代码编辑器。\n- 安装浏览器插件 `Live Server`，用于运行本地网页。\n2.文件夹结构： 创建一个名为 表情图库 的文件夹，内部文件组织如下：\n### 项目实现流程\n\n### 运行项目\n","tags":["Mini App","腾讯"]},{"title":"《软件工程》复习","url":"/2024/10/30/《软件工程》复习/","content":"## 1.2 软件及其特点\n### 软件的组成\n程序、数据和相关文档 \n### 软件的生命周期\n需求分析、软件设计、编码实现、软件测试、部署运行、使用维护。\n### 软件的分类\n**应用软件**\n**系统软件**\n**支撑软件**\n### 开源软件的优势\n#### **开源软件的好处**\n源代码可自由传播\n激发创作者的热情\n免费使用降低成本\n#### **开源软件的优势**\n**采购和开发的成本更低**：开源软件通常是免费的，即使要付费，其费用也非常低廉\n**软件质量更高、更安全**：核心代码都在公众的视野之中，代码问题（如缺陷、安全漏洞等）很容易被人发现\n**软件研制和交付的更快**：基于开源软件的项目开发可以更为快速地给用户交付软件产品\n**软件功能更为强大**：大量的软件开发者不仅参与软件开发，贡献他们的代码，而且还参与软件的创新，提出和构思软件需求，不断完善软件功能\n### 软件质量要素\n正确性、可靠性、健壮性、有效性、安全性、可维护性、可移植性、可重用性、可理解性、可信性、持续性、可用性、互操作性。\n\n## 2 软件工程概述\n### 软件危机的表现\n开发成本高\n进度难以控制\n质量难以保证\n软件维护困难\n失败风险很大\n\n### 软件工程的要素\n![alt text](image.png)\n### 软件工程的原则\n抽象和建模、模块化、软件重用、信息隐藏、关注点分离、分而治之、双向追踪原则、工具辅助。\n\n## 3.1 软件过程模型\n### 典型软件过程模型\n**瀑布模型、增量模型、迭代模型、原型模型、螺旋模型**、基于构件的过程模型、UP模型。\n\n## 3.2 敏捷软件开发方法\n### 敏捷开发的概念和观点\n\n### 敏捷准则\n\n### 敏捷开发代表方法\n\n## 4 软件需求分析基础\n### 利益相关方\n\n### 软件需求的类别\n\n### 面向对象的需求分析方法\n\n## 5 获取软件需求\n### 获取软件需求的方法\n### 用例图\n\n## 6 分析软件需求\n### 顺序图\n### 类图\n### 状态图\n### 分析软件需求过程\n### 软件需求文档\n\n## 7 软件设计基础\n### 软件设计的质量要求\n### 软件设计原则\n\n## 8 软件体系结构设计\n### 常用软件体系结构风格\n\n## 10 软件详细设计\n### 详细设计过程\n### 活动图\n### 用例设计\n### 类设计\n### 数据设计\n\n## 13 软件测试\n### 软件测试过程\n### 软件测试原则\n### 软件测试技术\n\n## 15 软件维护和演化\n### 软件维护的形式\n### 软件维护技术","tags":["复习","软件工程"]},{"title":"Hackathon决赛","url":"/2024/10/26/Hackathon决赛/","content":"本次所选工程题目对于我们来说难度还是太大了。所以决定先去观光一下华为欧洲小镇吧~\n<center>\n<img src=\"https://s2.loli.net/2024/10/26/dDNqeRghP17isKX.jpg\" width=\"100%\" />\n\nFigure 1\n</center>\n\n意料之外获得“安慰奖”。\n<center>\n<img src=\"https://s2.loli.net/2024/10/29/xtLy9h3d5SHAeuZ.jpg\" width=\"100%\" />\n\nFigure 2\n</center>\n\n返程飞机上的体验感还不错。\n<center>\n<img src=\"https://s2.loli.net/2024/10/29/UOLH8Fyaf7lPsI6.jpg\" width=\"100%\" />\n\nFigure 3\n</center>","tags":["Hackathon","华为","比赛","体验"]},{"title":"C/C++ 读取EXCEL数据","url":"/2024/10/25/读取EXCEL数据/","content":"- 打开Excel文件，点击文件-另存为\n- 在保存类型这里设置保存为csv格式\n- 选择好想保存的目录后，点击保存\n- 回到工作界面后，会弹出窗口，选择确定就可以了\n\n**按行读取。**\n```C++\n#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    ifstream file(\"01.csv\"); // 打开CSV文件\n    if (!file.is_open()) {\n        cout << \"无法打开文件！\" << endl;\n        return 1;\n    }\n\n    string line;\n    while (getline(file, line)) { // 逐行读取文件\n        cout << line << endl; // 打印每一行内容\n    }\n\n    file.close(); // 关闭文件\n    return 0;\n}\n```","tags":["c++"]},{"title":"基于VirtualBox虚拟机安装Ubuntu教程","url":"/2024/10/17/基于VirtualBox虚拟机安装Ubuntu教程/","content":"## 一. 下载安装VirtualBox\n\n1. [官网下载VirtualBox安装程序](https://www.virtualbox.org/wiki/Downloads)，我的版本（released July 28 2021）：VirtualBox 6.1.26 for Windows hosts x86/amd64\n\n2. 下载好了安装VirtualBox，一路`Next`就可以了,这个比较简单。\n\n3. 运行VirtulBox程序, 如下图：\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/wV8GSWjOA7szHuf.png\" width=\"80%\" />\n</center>\n\n4. 配置VirtualBox。按 `CTRL+G`打开全局设定，根据需要可以设定虚拟脑位置和界面语言：\n\\\n修改`默认虚拟脑位置`比如`D:\\VirtualBox VMs`可以让自己更方便的查找，备份安装好的虚拟机。\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/c6gMmE9kOTUKePa.png\" width=\"80%\" />\n</center>\n\n&emsp;&emsp;&emsp;如果界面是英文，可以改成中文：\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Ui6OyNV37F9pfZ8.png\" width=\"80%\" />\n</center>\n   \n5. 安装VirtualBox Extension Pack（新手可以不做）\n\\\n[下载](https://download.virtualbox.org/virtualbox/6.1.4/Oracle_VM_VirtualBox_Extension_Pack-6.1.4.vbox-extpack), 双击安装，支持USB 2.0 和USB 3.0 设备, VirtualBox RDP, 磁盘加密，虚拟机快照等功能。\n\n## 二、安装Ubuntu\n\n### 创建虚拟机\n\n1. 运行VirtulBox程序，点击“新建”按钮，新建一个虚拟机。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/BUaJM38DxXOEISC.png\" width=\"80%\" />\n</center>\n\n2. 虚拟机名称可以随意输入，示例：`zhy`。操作系统选择Linux，版本选择ubuntu(64-bit)。点击“下一步”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Ov6DCRIuglzAwrP.png\" width=\"80%\" />\n</center>\n\n3. 设定虚拟机的内存，此内存即为虚拟机所占用的系统内存，可随意修改，建议不要超过系统内存的1/2。\\\n   首先了解自己的笔记本电脑系统内存大小，“我的电脑”->“属性”。样机为16G。\\\n   为了方便以后编程学习使用，这里将虚拟内存设为4G。点击“下一步”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/PI3uBHkc1NQ4DhJ.png\" width=\"80%\" />\n</center>\n\n4. 为虚拟机创建一块虚拟硬盘。选择“现在创建虚拟硬盘”，并单击“创建”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/uxgviweoWYF7AmR.png\" width=\"80%\" />\n</center>\n   如果你安装有问题，可以在`默认虚拟脑位置`比如`D:\\VirtualBox VMs`处拷贝别人安装好的XXX.vdi文件，在此选择“使用已有的虚拟硬盘文件”，然后选中拷贝过来的vdi文件就可以了，下面的安装就不用做了。\n\n**在此强烈建议把教程走完，出错了也会有不一样的收获**\n\n5. 选择虚拟硬盘文件类型。选择默认的VDI（VirtualBox磁盘映像），并单击“下一步”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/aXFf74RUsb5B1DW.png\" width=\"80%\" />\n</center>\n\n6. 选择“动态扩展”，并单击“下一步”。\\\n   因为分配给虚拟机的内存空间较大，使用时逐渐占用磁盘空间，闲置时自动缩减比较合理，所以选择动态扩展类型。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/6Todt8VHPwBabZX.png\" width=\"80%\" />\n</center>\n\n7. 输入虚拟硬盘文件的名称，并选择保存位置。\\\n   选择虚拟硬盘大小时一定先确定保存所在位置磁盘的可用大小。可用空间为500G，虚拟硬盘大小设置为10G。单击“创建”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Y1TEbI2jc4Fkis9.png\" width=\"80%\" />\n</center>\n\n8. 虚拟机创建完成。也就是说Ubuntu所需的硬件资源准备好了，相当于买了一个没有安装操作系统的电脑主机。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/6mFDeJh9cHsoCbQ.png\" width=\"80%\" />\n</center>\n\n### 安装Ubuntu 系统软件\n\n&emsp;在虚拟机上安装Ubuntu和在真实机器上安装没有大的差别。\n\n&emsp;**官网下载（不推荐）**\n&emsp;可以直接访问[Ubuntu官网](https://cn.ubuntu.com/)进行下载，但由于服务器在国外，下载速度会非常非常慢，推荐使用国内的一些镜像站下载。\n&emsp;**镜像下载**\n&emsp;个人推荐[清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/)。\n1. 进入之后搜索Ubuntu，选择“ubuntu-releases”。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/8DxnGiw1QrjhVR9.png\" width=\"80%\" />\n</center>\n\n2. 根据个人体验，强烈推荐选择20.04版本（截至发文时间）。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/EmOAqMUvDk6JH2N.png\" width=\"80%\" />\n</center>\n\n3. 选择“ubuntu-20.04.6-desktop-amd64.iso”进行下载\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/YkesCc46KwqvIub.png\" width=\"80%\" />\n</center>\n\n4. 双击启动创建好的虚拟机\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/DJfizcujNO7oSRe.png\" width=\"80%\" />\n</center>\n弹出下图对话框，选择启动盘。单击右侧文件夹小图标。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/QpPLAmoDwtslZEN.png\" width=\"80%\" />\n</center>\n\n选择虚拟光盘文件ubuntu-20.04.6.-desktop-amd64.iso，单击“启动”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/Co1ONqVjIac7DnK.png\" width=\"80%\" />\n</center>\n\n5. 进入安装界面。 选择“中文简体”，选择“安装Ubuntu”\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/fN83Bec7irMAdWo.png\" width=\"80%\" />\n</center>\n\n6. 选择“继续”。 网络状况不好可以不选择“安装Ubuntu时下载更新”\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/QcKatrVeqIpmw7J.png\" width=\"80%\" />\n</center>\n\n7. 选择“清除整个磁盘并安装Ubuntu”单击“现在安装”\n\\\n弹出警告框，选择“继续”。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/doFsbU7IuhjYy9L.png\" width=\"80%\" />\n</center>\n\n8. 安装过程中时区，用鼠标单击地图中的“中国”，就会选择“上海”，单击“继续”，语言选“汉语”。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/vF5qPY2yWjN8dOp.png\" width=\"80%\" />\n</center>\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/vw3OeZxm2Mt1HRS.png\" width=\"80%\" />\n</center>\n\n9. 输入个人信息：用户名，口令等。单击“继续”，安装过程可能需要几十分钟，请耐心等待。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/C4OJgIzNfKsvy2d.png\" width=\"80%\" />\n</center>\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/LviOMRdTNaprWj9.png\" width=\"80%\" />\n</center>\n\n10. 安装完毕，重启一下Ubuntu。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/X4JRekfNnozGrHQ.png\" width=\"80%\" />\n</center>\n\n## 安装VirtualBox虚拟机增强功能\n\n注意：以下需要输入命令代码时请注意之间的空格！以及文件名相互对应！\n\n1. 进入虚拟机Ubuntu系统，安装VirtualBox增强功能，这可以极大的提高虚拟机效率。首先点击VBox菜单栏的“设备”项，选择最下面的“安装增强功能”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/X4JRekfNnozGrHQ.png\" width=\"80%\" />\n</center>\n\n3. 这时可以看到桌面多出一个光盘图标，如果没有，则重试本步。\n\n4. 按`CTRL+ALT+T`打开“终端”。输入以下命令（**注意空格！注意路径、文件名相互对应。**）\n\n输入命令时要根据自己的情况修改，文件名用`Tab`补全，减少录入错误。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/X4JRekfNnozGrHQ.png\" width=\"80%\" />\n</center>\n\n等待几分钟就安装好了！\n\n### 分配共享数据空间(易出错，新手可以不做)\n\n为了方便虚拟机和宿主机之间的数据传输，我们可以为虚拟机设置一个和主机共享的“数据空间”。VBox为我们提供了这个功能。\n\n1. 在VBox主界面左侧选择刚刚创建好的虚拟机，点击上方的“设置”按钮，进入虚拟机配置界面。点击左侧“共享文件夹”按钮，在新窗口中任意选择一个本地文件夹作为共享文件夹。示例选择文件夹位置为C:\\rocshare，不要勾选“只读分配”。单击“确定”，并关闭设置窗口。\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030093638484-754721120.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030094135281-471357754.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030093648984-2094658791.png>)\n\n2. 启动Ubuntu，打开终端窗口。（注意空格！）\\\n   一个要点是：命令，文件名要通过`Tab`补全，这样就会减少录入错误。\n\n* 输入命令“sudo mkdir /mnt/shared”。回车后键入密码。\n* 继续输入命令“sudo mount –t vboxsf rocshare /mnt/shared\" //注意rocshare /mnt/shared 要跟据自己的情况修改\n* 输入命令“sudo gedit /etc/fstab”\n\n3. 在弹出的文本末尾添加一行下面的内容：\n\n* “rocshare /mnt/shared vboxsf rw,gid=100,uid=1000,auto 0 0”\n\n4. 现在打开/mnt/shared文件夹，就可以看到主机对应共享文件夹rocshare中的内容了。这就是宿主机和虚拟机之间的桥梁。\n\n比如我们在Ubuntu中用touch命令新建一个testtest的文件，到宿主机的c://rocshare中就能看到这个文件。\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030095516359-1565360436.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030095524640-2011954975.png>)\n\n5. 至此，虚拟机安装配置完成。\n\n## 配置Ubuntu\n\nUbuntu的使用可以参考[别出心裁的Linux命令学习法](http://www.cnblogs.com/rocedu/p/4902411.html).\n\n1. 通过`sudo apt-get update;sudo apt-get upgrade` 更新一下系统。\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030110713000-318570997.png>)\n\n2. 安装软件。Ubuntu中安装软件比较简单，使用`sudo apt-get install XXX`就可以安装XXX软件，比如我们常用的Vim,就可以用`sudo apt-get install Vim`来安装。\n\n![install vim](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030110919031-429532360.png>)\n\n注意：Ubuntu中使用到某个没有安装的软件时，会有贴心的提示，如上图。\n\n我们可以通过`apt-cache search XXXX`来查找软件库中有没有我们想要安装的软件。比如我们想看看有没有常用的调试工具cgdb,就可以使用`apt-cache search cgdb`来查找：\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030112106046-695358617.png>)\n\n找到后就可以通过`sudo apt-get install cgdb`来安装了。\n\n我们可以一次安装多个软件，比如`sudo apt-get install git ddd`就会安装分布式版本控制工具git和图形化调试工具ddd：\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030112525687-2083766394.png>)\n\n这提醒我们可以写个脚本简化软件的安装，你可以源源不断的把自己用的软件添加到这个脚本中，方便日后自己安装新系统：\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030113309812-1973136131.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030113321468-101934690.png>)\n\n我的安装脚本供大家能参考：\n\n```bash\n#!/bin/sh\n\n# update system\n\nsudo apt-get update\nsudo apt-get grade \nsudo apt-get autoremove\n\n# utilities\nsudo apt-get install krusader unace unrar zip unzip p7zip-full p7zip-rar sharutils rar uudeview mpack  arj cabextract file-roller\nsudo apt-get install apvlv biff bsdgames byobu calcurse curl dia dia2code dtach dump fbset filezilla  freemind gimp  htop iotop jhead ksnapshot multitail moreutils pandoc planner powertop putty python-pip retext rpm screen sniffit socat stardict tmux tpp tree  vlc vnc4server xvnc4viewer wireshark xchm xpdf tweak\n\n# cheat \nsudo pip install docopt pygments\ngit clone https://github.com/chrisallenlane/cheat.git\ncd cheat\nsudo python setup.py install  \n\n#vi \ncd ~/.vim/bundle\nwget http://www.vim.org/scripts/download_script.php?src_id=9679\n\n#java\nsudo apt-get install eclipse  eclipse-wtp eclipse-emf eclipse-gef netbeans  gaphor umbrello umlet\n\n#programming\nsudo apt-get install ascii automake bison bison-doc bluefish  cgdb clang cmake codeblocks codeblocks-dbg codeblocks-dev cscope cvs dia ddd doxygen doxygen-doc doxygen-gui dstat eclipse eclipse-cdt eclipse-cdt-qt  eclipse-cdt-valgrind eclipse-eclox eclipse-egit  eclipse-egit-mylyn eclipse-mylyn  exuberant-ctags flex fossil fp-compiler fp-ide  g++ gcc gdb  git gitk git-gui git-doc git-cvs git-svn git-sh gnustep groovy ifstat indent jedit jython  libncurses5-dev ncurses-doc libasound2-dev libasound2-doc manpages-posix manpages-posix-dev  nasm python-django python-django-doc qtcreator splint sqlite3 libsqlite3-dev sqlitebrowser sqliteman swig2.0 sysstat tcl8.5 tcl8.5-doc tk8.5 tk8.5-doc txt2tags python-pip qtcreator ruby1.9.3  qt4-qmake qtcreator jruby subversion tidy valgrind vim scala \n\n#security\nsudo apt-get install lib32z1 libc6-dev-i386     //64->32\nsudo apt-get install lib32readline-gplv2-dev\n```\n\n## 安装过程中遇到的问题\n### 界面显示不全\n      我们可以通过设置分辨率，所以未安装好之前我们可以通过终端修改分辨率来解决。\n1. `Ctrl+Alt+t`打开终端面板\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/V7dy4rNz5FXgsLC.png\" width=\"80%\" />\n</center>\n\n2. 输入`xrandr`然后回车，查看支持的所有分辨率。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/egZc47lbwQ1KmvE.png\" width=\"80%\" />\n</center>\n\n3. 选择其中一个比较大的分辨率，比如输入：`xrandr -s 1920x1080`，然后回车。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/dav6WrY2VbGHUu7.png\" width=\"80%\" />\n</center>\n\n4. 就可以解决问题了。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/Mn7kD9vlrHS4Z6E.png\" width=\"80%\" />\n</center>\n\n### 安装增强功能时【未能加载虚拟光盘】\n1. 进入系统在侧边找到如图加载的虚拟光驱，右击，点击弹出，然后就可正常安装增强功能了。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/tfUlRFo97yDsOjI.png\" width=\"80%\" />\n</center>\n\n\n1. 终端依次输入。\n```BASH\nsudo apt-get update\nsudo apt-get install build-essential gcc make perl dkms\nreboot\n```","tags":["教程","VirtualBox","Ubuntu"]},{"title":"MiniMIPS32","url":"/2024/10/12/MiniMIPS32/","content":"## 指令集仿真器 -- TEMU\n### 实验简介\n采用高级语言（C/C++、Java或Python等）设计面向32位MIPS或LoongArch指令集子集的指令集仿真器 -- TEMU，用于实现对程序执行过程的模拟和调试。该指令集仿真器可模拟常见指令，支持单步执行、断点、显示寄存器信息、显示特定存储单元信息等功能，为后续的处理器设计实验提供仿真测试工具。","tags":["MiniMIPS32"]},{"title":"数值计算方法","url":"/2024/10/08/数值计算方法/","content":"## 插值法\n**实现范德蒙德多项式插值、拉格朗日插值、牛顿插值、分段线性、分段三次 Hermite 插值，并完成各方法之间的对比。**\n<font color=red>输入</font>：插值区间 $[a, b]$，参数 $c, d, e, f$ 作为标准函数 $f(x) = c \\cdot \\sin dx + e \\cdot \\cos fx$ 的值，参数 $n+1$ 作为采样点的个数，参数 $m$ 作为实验点的个数。\n<font color=red>要求</font>：在区间 $[a, b]$ 上均匀采集个采集点，利用这 $n+1$ 个采集点，分别使用范德蒙德多项式插值、拉格朗日插值、牛顿插值、分段线性、分段三次 Hermite 插值进行插值，求出 $L(x)$，之后再选取 $m$ 个点作为实验点，计算在这 $m$ 个实验点上插值函数 $L(x)$ 与目标函数 $f(x)$ 的平均误差。同时对比各插值方法之间的精度差异。\n<font color=red>输出</font>：对比函数曲线，平均误差。\n```Python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 范德蒙德多项式插值\ndef vandermonde_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    c = []\n    for i in range(n):\n        coeff = []\n        for j in range(n):\n            coeff.append(x[i]**j)\n        coefficients.append(coeff)\n        c.append(y[i])\n    A = np.array(coefficients)\n    inv_A = np.linalg.inv(A)\n    a = inv_A.dot(c)\n    sum = 0\n    for i in range(n):\n        sum += a[i] * x_values ** i\n    return sum\n\n# 拉格朗日插值\ndef lagrange_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n):\n        p = y[i]\n        for j in range(n):\n            if j != i:\n                p *= (x_values - x[j]) / (x[i] - x[j])\n        result += p\n    return result\n\n# 牛顿插值\ndef newton_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    for i in range(n-1, 0, -1):\n        divided_diff = (y[i] - y[i-1]) / (x[i] - x[i-1])\n        coefficients.append(divided_diff)\n        for j in range(n-i-1, 0, -1):\n            divided_diff = (-divided_diff + coefficients[j-1]) / (x[n-j] - x[i-1])\n            coefficients[j-1] = divided_diff\n    coefficients.append(y[0])\n    result = coefficients[0]\n    for i in range(n-2, -1, -1):\n        result = result * (x_values - x[i]) + coefficients[n-1-i]\n    return result\n\n# 分段线性插值\ndef piecewise_linear_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        mask = (x[i] <= x_values) & (x_values < x[i+1])\n        slope = (y[i+1] - y[i]) / (x[i+1] - x[i])\n        result += ((y[i] + slope * (x_values - x[i]))*mask)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# 分段三次Hermite插值\ndef piecewise_cubic_hermite_interpolation(x, y, yy, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        if ((x[i] <= x_values) & (x_values < x[i+1])):\n            ai = (1+2*(x_values-x[i])/(x[i+1]-x[i]))*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            bi = (x_values - x[i])*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            ai1 = (1+2*(x_values-x[i+1])/(x[i]-x[i+1]))*((x_values-x[i])/(x[i+1]-x[i]))**2\n            bi1 = (x_values - x[i+1])*((x_values-x[i])/(x[i+1]-x[i]))**2\n            result += (y[i] * ai +yy[i] * bi +y[i+1] * ai1 +yy[i+1] * bi1)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# 目标函数\ndef target_function(c,d,e,f,x):\n    return [(c*np.sin(d*val)+e*np.cos(f*val)) for val in x] \n\n# 目标函数导函数\ndef derivative_function(c,d,e,f,x):\n    return [(c*d*np.cos(d*val)-e*f*np.sin(f*val)) for val in x]\n\n# 计算平均误差\ndef compute_average_error(f, g, x_values):\n    return sum([abs(f[i] - g[i]) for i in range(len(x_values))]) / len(x_values)\n\n# 设置插值区间和参数\na = float(input())\nb = float(input())\nc = float(input())\nd = float(input())\ne = float(input())\nf = float(input())\nnum_samples = int(input())\nnum_experiments = int(input())\nx_values = [a + (b - a) * i / (num_samples - 1) for i in range(num_samples)]\nys = target_function(c,d,e,f,x_values)\nyy = derivative_function(c,d,e,f,x_values)\n\n# 计算实验点\nexperiment_points = [a + (b - a) * i / (num_experiments - 1) for i in range(num_experiments)]\n\n# 计算各插值方法的插值结果和平均误差\nvandermonde_interpolated = [vandermonde_interpolation(x_values, ys, val) for val in experiment_points]\nvandermonde_error = compute_average_error(target_function(c,d,e,f,experiment_points), vandermonde_interpolated, experiment_points)\n\nlagrange_interpolated = [lagrange_interpolation(x_values, ys, val) for val in experiment_points]\nlagrange_error = compute_average_error(target_function(c,d,e,f,experiment_points), lagrange_interpolated, experiment_points)\n\nnewton_interpolated = [newton_interpolation(x_values, ys, val) for val in experiment_points]\nnewton_error = compute_average_error(target_function(c,d,e,f,experiment_points), newton_interpolated, experiment_points)\n\npiecewise_linear_interpolated = [piecewise_linear_interpolation(x_values, ys, val) for val in experiment_points]\npiecewise_linear_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_linear_interpolated, experiment_points)\n\npiecewise_cubic_hermite_interpolated = [piecewise_cubic_hermite_interpolation(x_values, ys, yy, val) for val in experiment_points]\npiecewise_cubic_hermite_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_cubic_hermite_interpolated, experiment_points)\n\nfig = plt.figure(num = 1,dpi = 120)\nax = plt.subplot(1,1,1)\n # 坐标轴\nax = plt.gca()  # get current axis 获得坐标轴对象\nax.spines['right'].set_color('none')  # 将右边 边沿线颜色设置为空 其实就相当于抹掉这条边\nax.spines['top'].set_color('none')\nax.xaxis.set_ticks_position('bottom')\nax.yaxis.set_ticks_position('left')\n# 设置中心的为（0，0）的坐标轴\nax.spines['bottom'].set_position(('data', 0))  # 指定 data 设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上\nax.spines['left'].set_position(('data', 0))\n\nx=list(np.arange(a,b,0.01))#此处可调整自变量取值范围，以便选择合适的观察尺度\ny=[]\ny1=[]\ny2=[]\ny3=[]\ny4=[]\ny5=[]\nfor i in range(len(x)):\n    y = target_function(c,d,e,f,x)\n    y1.append(vandermonde_interpolation(x_values, ys, x[i]))\n    y2.append(lagrange_interpolation(x_values, ys, x[i]))\n    y3.append(newton_interpolation(x_values, ys, x[i]))\n    y4.append(piecewise_linear_interpolation(x_values, ys, x[i]))\n    y5.append(piecewise_cubic_hermite_interpolation(x_values, ys, yy, x[i]))\n    \n\nax.plot(x,y,label = \"Target Function\",color =\"blueviolet\")\nax.plot(x_values,ys, marker = \"*\",linestyle = \"\", color = \"blueviolet\")\nax.plot(x,y1,label = \"vandermonde interpolation\\n average error=%f\"%vandermonde_error,color =\"red\")\nax.plot(experiment_points, vandermonde_interpolated, marker = \"o\",linestyle = \"\", color = \"red\")\nax.plot(x,y2,label = \"lagrange interpolation\\n average error=%f\"%lagrange_error,color =\"yellow\")\nax.plot(experiment_points, lagrange_interpolated, marker = \"o\",linestyle = \"\", color = \"yellow\")\nax.plot(x,y3,label = \"newton interpolation\\n average error=%f\"%newton_error,color =\"green\")\nax.plot(experiment_points, newton_interpolated, marker = \"o\",linestyle = \"\", color = \"green\")\nax.plot(x,y4,label = \"piecewise linear interpolation\\n average error=%f\"%piecewise_linear_error,color =\"blue\")\nax.plot(experiment_points, piecewise_linear_interpolated, marker = \"o\",linestyle = \"\", color = \"blue\")\nax.plot(x,y5,label = \"piecewise cubic hermite interpolation\\n average error=%f\"%piecewise_cubic_hermite_error,color =\"purple\")\nax.plot(experiment_points, piecewise_cubic_hermite_interpolated, marker = \"o\",linestyle = \"\", color = \"purple\")\n#ax.set_xlim(0,2)\n#plt.draw()\nplt.legend()\nplt.show()\n```\n\n## 函数逼近\n**实现最佳平方逼近与最小二乘拟合，并完成两种方法之间的对比。**\n<font color=red>输入</font>：函数区间 $[a, b]$，参数 $c$ 作为标准函数$f(x)=\\frac{1}{1+cx^2}$的值，参数 $k$ 作为所构造的逼近多项式的次数 $(k=1,2,3)$ 。参数 $n+1$ 作为采样点的个数，参数 $m$ 作为实验点的个数。\n<font color=red>要求</font>：要求选用勒让德正交多项式作最佳平方逼近；在区间 $[a, b]$ 上均匀采集 $n$ 个采集点，利用这 $n+1$ 个采集点，计算采集点上的函数值，构造最小二乘拟合多项式函数。之后再选取 $m$ 个点作为实验点，计算在这 $m$ 个实验点上所构造的逼近函数与给定的目标函数 $f(x)$ 的平均误差。同时对比两种逼近方法之间的精度差异。\n<font color=red>输出</font>：对比函数曲线，平均误差。\n```Python\nfrom sympy import *\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.rcParams['font.sans-serif']=['SimHei']\nplt.rcParams['axes.unicode_minus'] = False\ndef qpow(a,n):\n    ans=1\n    while n!=0:\n        if n&1:\n            ans*=a\n        a*=a\n        n>>=1\n    return ans\ndef F(x):\n    res = 1/(1+c*x*x)\n    return res\ndef cntpf():\n    t = symbols('t')\n    # (b-a)*t/2+(b+a)/2\n    fp[0] = integrate(1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2)),(t, -1, 1)).evalf()\n    fp[1] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (t),(t, -1, 1)).evalf()\n    fp[2] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (3 * t * t / 2 - 1 / 2),(t, -1, 1)).evalf()\n    fp[3] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (5 * t * t * t / 2 - 3 * t / 2),(t, -1, 1)).evalf()\ndef bsa(inp):\n    res=0\n    inp =(2 * inp -a - b) / (b - a)\n    for i in range(0,k):\n        res+=(2*i+1)*fp[i]*qpow(inp,i)/2\n    return res\ndef setup():\n    for i in range(0,100):\n        vispa[i]=0\n        vispb[i]=0\ndef initx():\n    d=(b-a)/n\n    x[0]=a\n    for i in range(1,n):\n        x[i]=x[i-1]+d\ndef compa(i):\n    if vispa[i]==1:\n        return  pa[i]\n    up=0\n    down=0\n    for j in range(0,n):\n        up+=comP(i-1,x[j])*comP(i-1,x[j])*x[j]\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispa[i] = 1\n    pa[i] = res\n    return res\ndef compb(i):\n    if vispb[i]==1:\n        return pb[i]\n    up = 0\n    down = 0\n    for j in range(0, n):\n        up += comP(i, x[j]) * comP(i, x[j])\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispb[i] = 1\n    pb[i] = res\n    return res\ndef comP(i,inp):\n    res=0\n    if i==0:\n        res=1\n    elif i==1:\n        res = (inp -compa(1))*comP(0, inp)\n    else:\n        res = (inp -compa(i))*comP(i - 1, inp)-compb(i - 1) * comP(i - 2, inp)\n\n    return res\ndef lsf(inp):\n    initx()\n    res=0\n    for i in range(0,k):\n        up=0\n        down=0\n        for j in range(0,n):\n            up += F(x[j]) * comP(i, x[j])\n            down += comP(i, x[j]) * comP(i, x[j])\n        res += comP(i, inp)*up / down\n    return res\ndef bsaerror(inp):\n    return abs(bsa(inp)-F(inp))\ndef lsferror(inp):\n    return abs(lsf(inp)-F(inp))\n\n#全局变量\nx=[None]*200\nfp=[None]*50\nvispa=[0]*100\nvispb=[0]*100\npa=[None]*200\npb=[None]*200\n\n#主函数段\na, b, c = map(int, input(\"输入a,b,c: \").split())\nn , k = map(int, input(\"输入n,k: \").split())\nm=input(\"请输入测试组数：\")\ntst = input(\"请输入测试用例：\").split()\n\nsetup() #初始化fp数组\ncntpf() #初始化fp数组\n\nbsax=range(int(a),int(b))\nbsay=[]\nbsae=0\nfor i in bsax:\n    bsay.append(bsa(i))\n    \nlsfx=range(int(a),int(b))\nlsfy=[]\nlsfe=0\nfor i in lsfx:\n    lsfy.append(lsf(i))\n    \nnx=range(int(a),int(b))\nny=[]\nfor i in nx:\n    ny.append(F(i))\n    \nfor i in tst:\n    bsae+=bsaerror(float(i))\n    lsfe+=lsferror(float(i))\nbsae/=float(m)\nlsfe/=float(m)\nprint('最佳平方逼近的平均误差为%f'%bsae)\nprint('最小二乘拟合的平均误差为%f'%lsfe)\nplt.plot(bsax, bsay, label='最佳平方逼近', color='red')\nplt.plot(lsfx, lsfy, label='最小二乘拟合', color='blue')\nplt.plot(nx, ny, label='原函数', color='orange')\nplt.legend()\nplt.title('函数逼近对比函数')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n```\n\n## 数值积分\n**实现复化梯形公式和龙贝格算法计算积分，并完成两种方法之间的精度对比。**\n<font color=red>输入</font>：函数区间 $[a, b]$，被积函数为 $f(x) =\\sqrt{x}lnx$，参数 $h$ 作为步长。参数 $ε$ 作为要求满足的精度条件。\n<font color=red>要求</font>：取不同的步长 $h$，要求用复化梯形公式和龙贝格算法分别计算积分值计算当精度达到 $ε$ 时，所需要等分积分区间的次数（假设每次都是二等分）及 $h$ 的大小。当达到精度要求时，对比两种方法需要划分次数及步长 $h$ 的大小。\n<font color=red>输出</font>：数值积分计算结果，划分次数，步长 $h$ 的大小。\n```Python\nimport math\n#初始化变量\nvis = [[0 for i in range(1000)] for j in range(1000)]\nT = [[0 for i in range(1000)] for j in range(1000)]\n\ndef f(x):\n    res=math.sqrt(x)*math.log(x,math.e)\n    return res\n\ndef F(x):\n    x3=x*x*x\n    res=2*math.log(x,math.e)*math.sqrt(x3)/3-4*math.sqrt(x3)/9\n    return res\n\n#使用牛顿莱布尼茨公式直接积分\ndef Fitg(a,b):\n    res=F(b)-F(a)\n    return  res\n\n#使用复合梯形求积公式直接积分\ndef ctqf(n):\n    h=(b-a)/n\n    res=0\n    for k in range(n):\n        res+=f(a+k*h)+f(a+(k+1)*h)\n    res=res*h/2\n    return res\n\n#计算T的值\ndef cntT(m,k):\n    if(vis[m][k]==1):\n        return T[m][k]\n    else:\n        vis[m][k] == 1\n        if(m==0 and k==0):\n            T[m][k]=(b-a)*(f(a)+f(b))/2\n        elif(m==0):\n            n=1<<(k-1)\n            h=(b-a)/n\n            sm=0\n            for i in range(n):\n                sm+=f(a+(2*i+1)*h/2)\n            sm=sm*h/2\n            T[m][k]=cntT(m,k-1)/2+sm\n        else:\n            fourm=math.pow(4,m)\n            T[m][k]=fourm*cntT(m-1,k+1)/(fourm-1)-cntT(m-1,k)/(fourm-1)\n    return T[m][k]\n\n#使用龙贝格积分求积\ndef Romberg(m):\n    return cntT(m,0)\n\na,b =map(float,input(\"请输入积分区间a,b: \").split())\ne=float(input(\"请输入精度条件e: \"))\n\nfor k in range(1000):\n    n=1<<k\n    eps=abs(ctqf(n)-Fitg(a,b))\n    if(eps<e):\n        h=(b-a)/n\n        print('复合梯形求积公式的计算结果为：%f'%(ctqf(n)))\n        print('划分次数为：%d'%(k))\n        print('步长为：%f' % (h))\n        break\n\nfor k in range(1,1000):\n    n=1<<k\n    eps=abs(Romberg(k)-Romberg(k-1))\n    if(eps<e):\n        h=(b-a)/n\n        print('龙贝格求积公式的计算结果为：%f'%(Romberg(k)))\n        print('划分次数为：%d'%(k))\n        print('步长为：%f' % (h))\n        break\n```\n\n## 线性方程组的直接解法\n**1. 编写列主元消元法的通用程序。**\n<font color=red>输入</font>：矩阵 $A$ 和向量 $b$。\n<font color=red>输出</font>：消元后的增广矩阵及方程 $Ax=b$ 的根值 $x^*$。\n<font color=red>要求1</font>：选取进行测试，打印出上述程序的输出。\n<font color=red>要求2</font>：随机生成 $n$ 阶（$n$>=20，具体值自定）方阵 $A$，$n*1$ 维非零向量 $b$，求解 $x$。\n\n**2. 编写使用LU分解法求解线性方程组的通用程序。**\n<font color=red>输入</font>：矩阵 $A$ 和向量 $b$。\n<font color=red>输出</font>：对矩阵 $A$ 进行 $LU$ 分解后的 $L$ 和 $U$，以及方程组的根值 $x^*$。  \n<font color=red>要求1</font>：选取进行测试，打印输出结果。\n<font color=red>要求2</font>：随机生成 $n$ 阶（$n$>=20，具体值自定）方阵 $A$，$n*1$ 维非零向量 $b$，求解 $x$。\n```C++\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include <random>\n\nusing namespace std;\nint n;\nconst int maxn=200;\ndouble inA[maxn][maxn];\ndouble A[maxn][maxn];\ndouble L[maxn][maxn];\ndouble U[maxn][maxn];\ndouble ans[maxn];\ndouble ansy[maxn];\nvoid Pivot();//列主元消元法\nvoid copyA();//将输入矩阵复制给A\nvoid printA();//打印矩阵A\nvoid printb();//打印向量b\nvoid exc(int i,int j);//交换行\nvoid Minus(int i,int j,double mult);//第j行减第i行\nvoid printans();//打印答案\nvoid LU();//LU分解法\nvoid iscorrect();//回代判断答案是否正确\ndouble gerandom(double a,double b);//生成a到bdouble类型的随机数\nint main(){\n    int T;\n     cout<<\"please input T :\";\n     cin>>T;\n     while (T--)\n     {\n         cout << \"please input n :\";\n         cin >> n;\n         cout << \"enter 1 if you want to use your own input or 2 if you want your input to be random\"<<endl;\n         int cho;\n         cin>>cho;\n         if (cho == 1)\n         {\n             cout << \"please input matrix A :\" << endl;\n             for (int i = 1; i <= n; i++)\n             {\n                 for (int j = 1; j <= n; j++)\n                 {\n                     cin >> inA[i][j];\n                 }\n             }\n             cout << \"please input vector b :\" << endl;\n             for (int i = 1; i <= n; i++)\n             {\n                 cin >> inA[i][n + 1];\n             }\n         }\n         else{\n            double a,b;\n            cout << \"please input the range of the random number :\" << endl;\n            cin>>a>>b;\n            for (int i = 1; i <= n; i++)\n             {\n                 for (int j = 1; j <= n; j++)\n                 {\n                    inA[i][j]=gerandom(a,b);\n                 }\n             }\n             for (int i = 1; i <= n; i++)\n             {\n                inA[i][n + 1]=gerandom(a,b);\n             }\n         }\n         cout << \"enter 1-Pivot or 2-LU:\" << endl;\n         cin>>cho;\n         if(cho==1){\n            Pivot();\n         }\n         else{\n            LU();\n         }\n         printans();\n         iscorrect();\n     }\n    return 0;\n}\nvoid printA(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cout<<inA[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n}\nvoid copyA(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n+1;j++){\n            A[i][j]=inA[i][j];\n        }\n    }\n}\nvoid exc(int i,int j){\n    for(int k=1;k<=n+1;k++){\n        swap(A[i][k],A[j][k]);\n    }\n}\nvoid Minus(int i,int j,double mult){\n    for(int k=1;k<=n+1;k++){\n        A[j][k]-=A[i][k]*mult;\n    }\n}\nvoid printans(){\n    for(int i=1;i<=n;i++){\n        cout<<ans[i]<<\" \";\n    }\n    cout<<endl;\n}\nvoid Pivot(){\n    copyA();\n    for(int t=1;t<=n-1;t++){\n        double nman=0;\n        int maxi=0;\n        for(int i=t;i<=n;i++){\n            double tp=abs(A[i][t]);\n            if(tp>=nman){\n                maxi=i;\n                nman=tp;\n            }\n        }\n        exc(t,maxi);\n        for(int i=t+1;i<=n;i++){\n            double multi=A[i][t]/A[t][t];\n            Minus(t,i,multi);\n        }\n    }\n    for(int t=n;t>=1;t--){\n        double right=A[t][n+1];\n        for(int j=n;j>t;j--){\n            right-=A[t][j]*ans[j];\n        }\n        ans[t]=right/A[t][t];\n    }\n}\nvoid iscorrect(){\n    int tag=1;\n    for(int i=1;i<=n;i++){\n        double myans=0;\n        for(int j=1;j<=n;j++){\n            myans+=inA[i][j]*ans[j];\n        }\n        if(abs(myans-inA[i][n+1])>=1e-4){\n            tag=0;\n        }\n    }\n    if(tag){\n        cout<<\"answer is correct!\"<<endl;\n    }\n    else{\n        cout<<\"answer is wrong!\"<<endl;\n    }\n}\nvoid LU(){\n    copyA();\n    for(int i=1;i<=n;i++){\n        U[1][i]=A[1][i];\n        L[i][i]=1;\n    }\n    for(int i=2;i<=n;i++){\n        L[i][1]=A[i][1]/U[1][1];\n    }\n    for(int r=2;r<=n;r++){\n        for(int i=r;i<=n;i++){\n            double tplu=0;\n            for(int k=1;k<=r-1;k++){\n                tplu+=L[r][k]*U[k][i];\n            }\n            U[r][i]=A[r][i]-tplu;\n        }\n        if(r!=n){\n            for(int i=r+1;i<=n;i++){\n                double tplu=0;\n                for(int k=1;k<=r-1;k++){\n                    tplu+=L[i][k]*U[k][r];\n                }\n                L[i][r]=(A[i][r]-tplu)/U[r][r];\n            }\n        }\n    }\n    ansy[1]=A[1][n+1];\n    for(int i=2;i<=n;i++){\n        double tply=0;\n        for(int k=1;k<=i-1;k++){\n            tply+=L[i][k]*ansy[k];\n        }\n        ansy[i]=A[i][n+1]-tply;\n    }\n    ans[n]=ansy[n]/U[n][n];\n    for(int i=n-1;i>=1;i--){\n        double tpux=0;\n        for(int k=i+1;k<=n;k++){\n            tpux+=U[i][k]*ans[k];\n        }\n        ans[i]=(ansy[i]-tpux)/U[i][i];\n    }\n}\ndouble gerandom(double a,double b){\n    static random_device rd;\n    static mt19937 gen(rd());\n    uniform_real_distribution<double> dis(a, b);\n    return dis(gen);\n}\n```\n\n## 线性方程组的迭代解法\n**1. 编写高斯-塞德尔迭代和SOR迭代的通用程序。**\n<font color=red>输入</font>：矩阵A和向量b，迭代初值x0，迭代最大步数K，误差控制。对于超松弛迭代，还需输入松弛因子。\n<font color=red>输出</font>：迭代步数及方程 $Ax=b$ 的根值 $x^*$。\n<font color=red>要求</font>：\n(1)选取进行测试，取初值x<sup>(0)</sup>=0，误差控制=10<sup>-8</sup>，打印出两种迭代方法的输出。\n(2)取松弛因子 $=\\frac{i}{50}$，$i$=1,2,...99,打印迭代步数，并给出一个最佳值。\n```C++\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int maxn = 1000;\ndouble a[maxn][maxn];\ndouble b[maxn];\ndouble xk[maxn];\ndouble xk1[maxn];\nint n;\nint K;\ndouble w;\ndouble eps;\ndouble mf;\ndouble nstep;\nvoid setxk0();//初始化xk0\nvoid movk();//将xk1赋值给xk\ndouble cntloss();//计算detx\nvoid SOR(double w);//超松弛迭代法\nvoid printx();//打印x\nvoid iscorrect();//回代验证答案是否正确\nint main(){\n    cout<<\"input max step K : \";\n    cin>>K;\n    cout<<\"input eps  : \";\n    cin>>eps;\n    cout<<\"input the size of A  : \";\n    cin>>n;\n    cout<<\"matrix A :\"<<endl;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>a[i][j];\n        }\n    }\n    cout<<\"vector b :\"<<endl;\n    for(int i=1;i<=n;i++){\n        cin>>b[i];\n    }\n    cout<<\"enter 1 if you want to test one w\"<<endl;\n    cout<<\"or 2 if you want to find the best w\"<<endl;\n    cout<<\"enter : \";\n    cin>>mf;\n    if(mf==1){\n        cout<<\"input Relaxation factor w  : \";\n        cin>>w;\n        SOR(w);\n        printx();\n        iscorrect();\n    }\n    else{\n        int bst=K+1;\n        double bsw=0;\n        for(int i=1;i<=99;i++){\n            double ii = (double)i;\n            double nw=ii/(double)50;\n            cout<<\"now i is \"<<i<<endl;\n            SOR(nw);\n            if(nstep<bst){\n                bst = nstep;\n                bsw=nw;\n            }\n        }\n        cout<<\"the best w is \"<<bsw<<endl;\n    }\n    \n    return 0;\n}\nvoid setxk0(){\n    for(int i=1;i<=n;i++){\n        xk[i]=0;\n    }\n}\nvoid movk(){\n    for(int i=1;i<=n;i++){\n        xk[i]=xk1[i];\n    }\n}\ndouble cntloss(){\n    double res = 0;\n    for(int i=1;i<=n;i++){\n        double tp = abs(xk1[i]-xk[i]);\n        if(tp>res){\n            res = tp;\n        }\n    }\n    return res;\n}\nvoid printx(){\n    for(int i=1;i<=n;i++){\n        cout<<xk1[i]<<\" \";\n    }\n    cout<<endl;\n}\nvoid iscorrect(){\n    int flag = 1;\n    for(int i=1;i<=n;i++){\n        double s=0;\n        for(int j=1;j<=n;j++){\n            s+=a[i][j]*xk1[j];\n        }\n        if(abs(s-b[i])>1e-3){\n            flag=0;\n        }\n    }\n    if(flag){\n        cout<<\"answer is correct!\"<<endl;\n    }\n    else{\n        cout<<\"answer is wrong!\"<<endl;\n    }\n}\nvoid SOR(double w){\n    setxk0();\n    for(int step=1;step<=K;step++){\n        for(int i=1;i<=n;i++){\n            double s1 = 0;\n            double s2 = 0;\n            for(int j=1;j<=i-1;j++){\n                s1+=a[i][j]*xk1[j];\n            }\n            for(int j=i;j<=n;j++){\n                s2+=a[i][j]*xk[j];\n            }\n            xk1[i]=xk[i]+w*(b[i]-s1-s2)/a[i][i];\n        }\n        if(cntloss()<eps){\n            if(mf==2){\n                nstep = step;\n                cout<<\"the step is \"<<step<<endl;\n            }\n            break;\n        }\n        else{\n            movk();\n        }\n    }\n}\n```\n\n## 非线性方程（组）的数值解法\n**1. 编写不动点迭代、斯特芬森加速迭代和牛顿迭代的通用程序。**\n<font color=red>要求</font>：\n(1)设计一种不动点迭代格式，求解函数 $f(x)=x^2-3x+2-e^x$ 和 $g(x)=x^3+2x^2+10x-20$ 的根，要求该迭代格式收敛。然后再使用斯特芬森加速迭代，计算到 |x<sub>k</sub>-x<sub>k-1</sub>|<10<sup>-8</sup> 为止。\n(2)用牛顿迭代，同样计算到 |x<sub>k</sub>-x<sub>k-1</sub>|<10<sup>-8</sup> 。输出迭代初值、迭代次数及各次迭代值，比较方法优劣。\n```Python\n\n```\n**2. 本章计算实习题3。**\n```Python\n\n```","tags":["数值计算方法","实验记录","Python"]},{"title":"图论算法做题总结","url":"/2024/10/07/图论算法做题总结/"},{"title":"单调栈做题总结","url":"/2024/10/06/单调栈做题总结/","content":"# 基础\n## 每日温度\n```C++\n/***** 找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n=temperatures.size();\n        vector<int> ans(n);\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&temperatures[s.top()]<temperatures[i]){ //栈中维护下标写法\n                ans[s.top()]=i-s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        return ans;\n    }\n};\n```\n## 商品折扣后的最终价格\n```C++\n/***** 找后面第一个小于等于 *****/\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n=prices.size();\n        vector<int> ans(n);\n \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&prices[s.top()]>=prices[i]){\n                ans[s.top()]=prices[s.top()]-prices[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n        \n        while(!s.empty()){\n            ans[s.top()]=prices[s.top()];\n            s.pop();\n        }\n        return ans;\n    }\n};\n```\n## 下一个更大元素 I\n```C++\n/***** 找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        unordered_map<int,int> hashmap;\n        \n        //处理nums2\n        stack<int> s;\n        for(int i=0;i<nums2.size();i++){\n            while(!s.empty()&&nums2[s.top()]<nums2[i]){\n                int temp=nums2[s.top()];\n                hashmap[temp]=nums2[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        for(int i=0;i<nums1.size();i++){\n            int temp=nums1[i];\n            if(hashmap[temp]) ans[i]=hashmap[temp];\n            else ans[i]=-1;\n        }\n        return ans;\n    }\n};\n```\n## 下一个更大元素 II\n```C++\n/***** 循环找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> ans(n,-1);\n \n        stack<int> s;\n        for(int i=0;i<2*n-1;i++){\n            while(!s.empty()&&nums[s.top()]<nums[i%n]){\n                ans[s.top()]=nums[i%n];\n                s.pop();\n            }\n            s.push(i%n);\n        }\n        \n        return ans;\n    }\n};\n```\n## 最大宽度坡\n```C++\n/*单调递减栈*/\nclass Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        stack<int> s;\n        int n = nums.size();\n        for (int i = 0;i < n;i++) {\n            if (s.empty() || nums[s.top()] > nums[i]) {//要把第一个数据push\n                s.push(i);\n            }\n        }\n        int ans = 0;\n        for (int i = n - 1;i >= 0;i--) {\n            while (!s.empty() && nums[s.top()]<=nums[i]) {\n                ans = max(ans,i - s.top());\n                s.pop();\n            }\n        }\n        return ans;\n    }\n};\n```\n## 车队\n```C++\n/***** 排序+单调栈 *****/\n/***** 根据位置由小到大排序，位置大的左侧（位置小）的时间不应更小等->（严格）单调递减栈 *****/\nclass Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        map<int,int> ps; //自动排序\n        for(int i=0;i<position.size();i++){\n            ps[position[i]]=speed[i];\n        }\n\n        stack<double> s;\n        for(auto& [pos,spd]:ps){\n            double time=double(target-pos)/spd;\n            while(!s.empty()&&s.top()<=time){\n                s.pop();\n            }\n            s.push(time);\n        }\n        return s.size();\n    }\n};\n```\n# 矩形面积（完结）\n## 柱状图中最大的矩形\n```C++\n/***** 单调栈的其中一种写法---处理栈中元素 *****/\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> left(n,-1), right(n,n); //左边第一个小的位置、右边第一个小的位置\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){ //处理右边\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tright[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n \n        s = stack<int> (); //清空栈\n        for(int i=n-1;i>=0;i--){ //处理左边\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tleft[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);\n        }\n        return ans;\n    }\n};\n```\n## 好子数组的最大分数\n```C++\n/***** 单调栈的另一种写法---处理当前元素 *****/\nclass Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> left(n,-1),right(n,n); //左边第一小的编号、右边第一小的编号\n \n        stack<int> s;\n        for(int i=0;i<n;i++){ //处理左边\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) left[i]=s.top();\n            s.push(i);\n        }\n \n        s=stack<int> ();\n        for(int i=n-1;i>=0;i--){ //处理右边\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) right[i]=s.top();\n            s.push(i);\n        }\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            int h=nums[i],l=left[i],r=right[i];\n            if(l<k&&r>k){ //多了一个区间判断\n                ans=max(ans,h*(r-l-1));\n            }\n        }\n        return ans;\n    }   \n};\n```\n## 最大矩形\n```C++\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int n=matrix.size(); //行数\n        int m=matrix[0].size(); //列数\n        vector<vector<int>> left(n,vector<int>(m,0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(matrix[i][j]=='1'){\n                    left[i][j]=(j==0?1:left[i][j-1]+1); //往左能够延申的最大长度\n                }\n            }\n        }\n        int ret=0;\n \n        //对于每一列，使用基于柱状图求最大矩形的方法\n        for(int j=0;j<m;j++){\n            vector<int> up(n,0),down(n,0);\n \n            stack<int> s;\n            for(int i=0;i<n;i++){ \n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                up[i]=s.empty()?-1:s.top(); //上边第一个小于的编号\n                s.push(i);\n            }\n            s=stack<int>();//清空栈\n            for(int i=n-1;i>=0;i--){\n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                down[i]=s.empty()?n:s.top(); //下边第一个小于的编号\n                s.push(i);\n            }\n            \n            for(int i=0;i<n;i++){\n                int width=down[i]-up[i]-1;\n                int area=width*left[i][j];\n                ret=max(ret,area);\n            }\n        }\n \n        return ret;\n    }\n};\n```\n## 统计全 1 子矩形\n```C++\nclass Solution {\npublic:\n    int numSubmat(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<int> height(m);\n \n        /*单调栈求左右更小值(同时处理)*/\n        auto calc=[&]()->int{\n            vector<int> left(m,-1),right(m,m);\n \n            stack<int> s;\n            for(int i=0;i<m;i++){\n                while(!s.empty()&&height[s.top()]>height[i]){\n                    right[s.top()]=i;\n                    s.pop();\n                }\n                if(!s.empty()){\n                    left[i]=s.top();\n                }\n                s.push(i);\n            }\n \n            int ans=0;\n            /* 计算结果时, 乘法原理 * 矩阵高度 */\n            for(int i=0;i<m;i++){\n                ans+=(right[i]-i)*(i-left[i])*height[i];\n            }\n            return ans;\n        };\n \n        int ans=0;\n        for(int i=0;i<n;i++){ /* 遍历每一行的高度, 更新改行的高度值使用单调栈计算左侧更小值和右侧更小值,再计算每个小矩阵出现的次数*/\n            for(int j=0;j<m;j++){\n                if(mat[i][j]==0){\n                    height[j]=0;\n                }\n                else{\n                    height[j]++;\n                }\n            }\n            ans+=calc();\n        }\n        return ans;\n    }\n};\n```\n## 接雨水\n```C++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans=0;\n        int n=height.size();\n\n        stack<int> s;\n        for (int i=0;i<n;i++) {\n            while (!s.empty() && height[s.top()]<height[i]) {\n                int top = s.top();\n                s.pop();\n                if (s.empty()) {\n                    break;\n                }\n                int left = s.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            s.push(i);\n        }\n        \n        return ans;\n    }\n};\n/***** 不能单纯找左边第一个大、右边第一个大 *****/\n/*这种情况会多算\n*   *\n** **\n** **\n*****\n*/\n```\n# 最小字典序\n## 移掉 K 位数字\n","tags":["编程","单调栈","c++"]},{"title":"动态规划做题总结","url":"/2024/10/02/动态规划做题总结/","content":"# 入门 DP\n## 爬楼梯\n### 爬楼梯\n```C\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> f(n+1);     \n        f[0]=1,f[1]=1;\n        for(int i=2;i<=n;i++){\n            f[i]=f[i-1]+f[i-2];\n        }\n        return f[n];\n    }\n};\n/*由于这里的 f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)*/\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; i++) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n```\n### 使用最小花费爬楼梯\n```C\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n + 1);\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[n];\n    }\n};\n```\n### 组合总和 Ⅳ\n```C\n/*本质是爬楼梯，相当于每次往上爬 nums[i] 步*/\nclass Solution {\npublic:\n    long long combinationSum4(vector<int>& nums, int target) {\n        vector<long long> dp(target + 1);\n        dp[0] = 1; //只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。\n        for (int i = 1; i <= target; i++) {\n            for (int& num : nums) {\n                if (num <= i&& dp[i - num] < INT_MAX - dp[i]) {\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n        return dp[target];\n    }\n};\n/*另一种写法*/\nclass Solution {\npublic:\n    int combinationSum4(vector<int> &nums, int target) {\n        // 使用 unsigned 可以让溢出不报错\n        // 对于溢出的数据，不会影响答案的正确性（题目保证）\n        vector<unsigned> f(target + 1);\n        f[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int x : nums) {\n                if (x <= i) {\n                    f[i] += f[i - x];\n                }\n            }\n        }\n        return f[target];\n    }\n};\n```\n### 统计构造好字符串的方案数\n```C\nclass Solution {\npublic:\n    int countGoodStrings(int low, int high, int zero, int one) {\n        const int MOD = 1'000'000'007;\n        int ans = 0;\n        vector<int> f(high + 1); // f[i] 表示构造长为 i 的字符串的方案数\n        f[0] = 1; // 构造空串的方案数为 1\n        for (int i = 1; i <= high; i++) {\n            if (i >= zero) f[i] = f[i - zero];\n            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;\n            if (i >= low)  ans = (ans + f[i]) % MOD;\n        }\n        return ans;\n    }\n};\n```\n### 统计打字方案数\n```C\nclass Solution {\npublic:\n    int countTexts(string pressedKeys) {\n        int m = 1000000007;\n        vector<long long> dp3 = {1, 1, 2, 4};   // 连续按多次 3 个字母按键对应的方案数\n        vector<long long> dp4 = {1, 1, 2, 4};   // 连续按多次 4 个字母按键对应的方案数\n        int n = pressedKeys.size();\n        for (int i = 4; i < n + 1; ++i) {\n            dp3.push_back((dp3[i-1] + dp3[i-2] + dp3[i-3]) % m);\n            dp4.push_back((dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % m);\n        }\n        long long res = 1;   // 总方案数\n        int cnt = 1;   // 当前字符连续出现的次数\n        for (int i = 1; i < n; ++i) {\n            if (pressedKeys[i] == pressedKeys[i-1]) {\n                ++cnt;\n            } else {\n                // 对按键对应字符数量讨论并更新总方案数\n                if (pressedKeys[i-1] == '7' || pressedKeys[i-1] == '9') {\n                    res *= dp4[cnt];\n                } else {\n                    res *= dp3[cnt];\n                }\n                res %= m;\n                cnt = 1;\n            }\n        }\n        // 更新最后一段连续字符子串对应的方案数\n        if (pressedKeys[n-1] == '7' || pressedKeys[n-1] == '9') {\n            res *= dp4[cnt];\n        } else {\n            res *= dp3[cnt];\n        }\n        res %= m;\n        return res;\n    }\n};\n```\n## 打家劫舍\n### 打家劫舍\n```C\n/*题意转化为：从序列中选择子序列使得它们的和最大，数不能有相邻*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        vector<int> dp(n,0); //用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n        }  \n        return dp[n-1];\n    }\n};\n/*上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\n};\n```\n### 删除并获得点数\n```C\nclass Solution {\nprivate:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxval=0;\n        for(int val:nums){\n            maxval=max(maxval,val);\n        }\n        vector<int>sum(maxval+1,0);\n        for(int val:nums){\n            sum[val]+=val;\n        }\n        return rob(sum);\n    }\n};\n```\n### 统计放置房子的方式数\n```C\n/*单独考虑一侧的房子，定义 f[i] 表示前 i 个地块的放置方案数，其中第 i 个地块可以放房子，也可以不放房子。*/\nconst int mod=1e9+7;\nclass Solution {\npublic:\n    int countHousePlacements(int n) {\n        vector<long long> f(n+1,0);\n        f[0]=1;\n        f[1]=2;\n        for(int i=2;i<=n;i++){\n            f[i]=(f[i-1]+f[i-2])%mod;\n        }\n        return f[n]*f[n]%mod;\n    }\n};\n```\n### 打家劫舍 II\n```C\n/*第一间房屋和最后一间房屋不同时偷窃*/\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        int first = nums[start], second = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n\n    int rob(vector<int>& nums) {\n        int length = nums.size();\n        if (length == 1) {\n            return nums[0];\n        } \n        else if (length == 2) {\n            return max(nums[0], nums[1]);\n        }\n        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n};\n```\n### 施咒的最大总伤害\n## 最大子数组和\n>*定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是f[i]=a[i]，和 i 左边拼起来就是f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)。这个做法也叫做 Kadane 算法。*\n### 最大子数组和\n```C\n/*模板题*/\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n        }\n        return ranges::max(dp);\n    }\n};\n```\n### 找到最大开销的子字符串\n```C\n/*一点转化+模板题*/\nclass Solution {\npublic:\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\n        vector<int> m(26+1);\n        iota(m.begin(),m.end(),0);\n        for(int i=0;i<chars.size();i++){\n            m[chars[i]-'a'+1]=vals[i];\n        }\n \n        vector<int> dp(s.size());\n        dp[0]=m[s[0]-'a'+1];\n        int ans=max(0,dp[0]);\n        for(int i=1;i<s.size();i++){\n            dp[i]=max(dp[i-1],0)+m[s[i]-'a'+1];\n            ans=max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n```\n### 任意子数组和的绝对值的最大值\n```C\n/*题目转化为max(最大子数组和，-最小子数组和，0)*/\nclass Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        int ans1=dp[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n            ans1=max(ans1,dp[i]);\n        }\n \n        vector<int> dp1(nums.size());\n        dp1[0]=nums[0];\n        int ans2=dp1[0];\n        for(int i=1;i<nums.size();i++){\n            dp1[i]=min(dp1[i-1],0)+nums[i];\n            ans2=min(ans2,dp1[i]);\n        }\n        int ans=max(0,ans1);\n        ans=max(ans,-ans2);\n        return ans;\n    }\n};\n```\n### K 次串联后最大子数组之和\n```C\n/*\n考虑两种情况：\n\n1.如果k=1，那就是正常DP。\n\n2.k>1时也考虑两种情况：数组所有元素和大于0，数组所有元素和小于等于0。\n首先计算两个相接的DP也就是k=2的情况，如果数组元素和大于0，那可以看成再第一段结尾第二段开头插入k-2个正数，如果数组所有元素和为负，那k=2的情况就是最大的情况。\n*/\nclass Solution {\npublic:\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        const int mod=1e9+7;\n        int n=arr.size();\n        long long sum=0,presum=0,result=0;\n        for(int i=0;i<n*(k>1?2:1);i++){\n            long long num=arr[i%n];\n            presum=max(presum,0ll)+num;\n            result=max(result,presum);\n            if(i<n) sum+=num;\n        }\n        if(sum>0&&k>1){\n            result=(result+sum*(k-2)%mod)%mod;\n        }\n        return result;\n    }\n};\n/*\n1.sum>0、k=2时，最大子数组和如果没有跨过两个数组，那岂不是不能在中间插入k-2个sum吗？\n反证法，反设sum>0时，如果最大子数组和没有跨过两个数组。从L到R的子数组的和最大（0<=L<=R<n-1），考虑R向右n个数(R+1到R+n)，这n个数一定是和arr的数是一样的（循环了），那么这n个数的和是sum，大于0。所以从L到R+n的子数组的和要更大，而这个子数组跨过了两个数组，与反设矛盾。所以这样做是对的。\n2.sum<=0时，为什么可以化归到k=2的情况？\n还是反证法，假设最大子数组的长度>2n，那一定包括一个完整的arr数组，那么因为sum<=0，所以拿掉这一部分，把前后拼接在一起（这样做显然是合法的），这样做结果只会更优，如此操作下去，就可以划归到k=2的情况了。\n*/\n```\n### 环形子数组的最大和\n```C\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> qianmax(n); //前缀最大值\n        int presum=nums[0];\n        qianmax[0]=nums[0];\n\n        int pre=nums[0];\n        int ans=pre;\n\n        for(int i=1;i<n;i++){\n            pre=max(pre,0)+nums[i];\n            ans=max(ans,pre);\n\n            presum+=nums[i];\n            qianmax[i]=max(qianmax[i-1],presum);\n        }\n\n        int housum=0;\n        for(int i=n-1;i>0;i--){ //枚举后缀和\n            housum+=nums[i];\n            ans=max(ans,housum+qianmax[i-1]);\n        }\n        return ans;\n    }\n};\n```\n### 拼接数组的最大分数\n```C\n/*转换成最大子数组和*/\nclass Solution {\n    int solve(vector<int> &nums1, vector<int> &nums2) {\n        int sum = 0, maxSum = 0;\n        for (int i = 0, s = 0; i < nums1.size(); i++) {\n            sum += nums1[i];\n            s = max(s,0)+(nums2[i] - nums1[i]);\n            maxSum = max(maxSum, s);\n        }\n        return sum + maxSum;\n    }\n\npublic:\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2) {\n        return max(solve(nums1, nums2), solve(nums2, nums1));\n    }\n};\n```\n### (扩展）乘积最大子数组\n```C\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector <long> maxF(nums.begin(),nums.end()), minF(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            maxF[i] = max(maxF[i - 1] * nums[i], max((long)nums[i], minF[i - 1] * nums[i]));\n            minF[i] = min(minF[i - 1] * nums[i], min((long)nums[i], maxF[i - 1] * nums[i]));\n            if(minF[i]<INT_MIN) {\n                minF[i]=nums[i];\n            }\n        }\n        return *max_element(maxF.begin(), maxF.end());\n    }\n};\n/*优化空间*/\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        long maxF = nums[0], minF = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            long mx = maxF, mn = minF;\n            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));\n            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));\n            if(minF<INT_MIN) {\n                minF=nums[i];\n            }\n            ans = max(maxF, ans);\n        }\n        return ans;\n    }\n};\n```\n# 网格图 DP\n## 基础\n### 珠宝的最高价值\n```C\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(n,vector<int>(m));\n        f[0][0]=frame[0][0];\n        for(int i=1;i<n;i++){ //处理第一列\n            f[i][0]=f[i-1][0]+frame[i][0];\n        }\n        for(int j=1;j<m;j++){ //处理第一行\n            f[0][j]=f[0][j-1]+frame[0][j];\n        }\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                f[i][j]=max(f[i-1][j],f[i][j-1])+frame[i][j];\n            }\n        }\n        return f[n-1][m-1];\n    }\n};\n \n/*注意到状态转移方程中，f(i,j) 只会从 f(i−1,j) 和 f(i,j−1) 转移而来，而与 f(i−2,⋯) 以及更早的状态无关，因此我们同一时刻只需要存储最后两行的状态，即使用两个长度为 n 的一位数组代替 n×m 的二维数组 f，交替地进行状态转移，减少空间复杂度。*/\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(2,vector<int>(m));\n        for(int i=0;i<n;i++){\n            int pos=i%2;\n            for(int j=0;j<m;j++){\n                f[pos][j]=0;\n                if(i>0) f[pos][j]=max(f[pos][j],f[1-pos][j]);\n                if(j>0) f[pos][j]=max(f[pos][j],f[pos][j-1]);\n                f[pos][j]+=frame[i][j];\n            }\n        }\n        return f[(n-1)%2][m-1];\n    }\n};\n```\n### 不同路径\n```C\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++) f[i][0]=1;\n        for(int j=0;j<n;j++) f[0][j]=1;\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n/*此外，由于 f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。*/\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> f(n,1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                f[j]+=f[j-1];\n            }\n        }\n        return f[n - 1];\n    }\n};\n```\n### 不同路径 II\n```C\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++){ //处理第一列\n            if(obstacleGrid[i][0]==1){ //有障碍 \n                f[i][0]=0; \n                break; //后面都到达不了\n            }\n            else f[i][0]=1;\n        }\n        for(int j=0;j<n;j++){  //处理第一行\n            if(obstacleGrid[0][j]==1){ //有障碍\n                f[0][j]=0; \n                break; //后面都到达不了\n            }\n            else f[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(obstacleGrid[i][j]==1) f[i][j]=0;\n                else f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n```\n### 最小路径和\n```C\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m));\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<n;i++) dp[i][0]=dp[i-1][0]+grid[i][0];\n        for(int j=1;j<m;j++) dp[0][j]=dp[0][j-1]+grid[0][j];\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};\n```\n### 三角形最小路径和\n```C\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            dp[i][0]=dp[i-1][0]+triangle[i][0]; //第一列只能从上面转移\n            for(int j=1;j<i;j++){\n                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n            }\n            dp[i][i]=dp[i-1][i-1]+triangle[i][i];//最后一列只能从左上转移\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n/*可以发现，dp[i][j] 只与 dp[i−1][..] 有关，而与 dp[i−2][..] 及之前的状态无关，因此我们不必存储这些无关的状态。具体地，我们使用两个长度为 n 的一维数组进行转移，将 i 根据奇偶性映射到其中一个一维数组，那么 i−1 就映射到了另一个一维数组。这样我们使用这两个一维数组，交替地进行状态转移。*/\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            dp[cur][0]=dp[pre][0]+triangle[i][0]; //第一列只能从上面转移\n            for(int j=1;j<i;j++){\n                dp[cur][j]=min(dp[pre][j-1],dp[pre][j])+triangle[i][j];\n            }\n            dp[cur][i]=dp[pre][i-1]+triangle[i][i];//最后一列只能从左上转移\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n### 下降路径最小和\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        copy(matrix[0].begin(),matrix[0].end(),dp[0].begin());\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++){\n                int minn=dp[i-1][j]; //都能从正上方转移\n                if(j>0){ //可以从左上方转移\n                    minn=min(minn,dp[i-1][j-1]);\n                }\n                if(j<n-1){ //可以从右上方转移\n                    minn=min(minn,dp[i-1][j+1]);\n                }\n                dp[i][j]=minn+matrix[i][j];\n            }\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n```\n### 矩阵中移动的最大次数\n```C\nclass Solution {\npublic:\n    int maxMoves(vector<vector<int>>& grid) {\n        int ans=0; bool flag=1;\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m)); //dp[i][j]==1表示(i,j)位置可到达\n        for(int i=0;i<n;i++) dp[i][0]=1; \n        for(int j=1;j<m;j++){\n            if(!flag) return ans;\n            flag=0;\n            for(int i=0;i<n;i++){\n                if(grid[i][j-1]<grid[i][j]&&dp[i][j-1]){\n                    dp[i][j]=1;\n                }\n                if(i>0){\n                    if(grid[i-1][j-1]<grid[i][j]&&dp[i-1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(i<n-1){\n                    if(grid[i+1][j-1]<grid[i][j]&&dp[i+1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(dp[i][j]){\n                    flag=1;\n                    ans=j;\n                }\n            }\n        }\n        //ans+=1;\n        return ans;\n    }\n};\n```\n### 网格中的最小路径代价\n```C\nclass Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0]=grid[0];\n        for(int i=1;i<m;i++){\n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            for(int j=0;j<n;j++){ //当前行每一列\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<n;k++){ //上一行每一列\n                    dp[cur][j]=min(dp[cur][j],dp[pre][k]+moveCost[grid[i-1][k]][j]+grid[i][j]);\n                }\n            }\n        }\n        return *min_element(dp[(m-1)%2].begin(),dp[(m-1)%2].end());\n    }\n};\n```\n### 下降路径最小和 II\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(m));\n        dp[0]=grid[0];\n        for(int i=1;i<n;i++){ \n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            for(int j=0;j<m;j++){ //当前行每一列\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<m;k++){ //上一行每一列\n                    if(j!=k){\n                        dp[cur][j]=min(dp[cur][j],dp[pre][k]+grid[i][j]);\n                    }\n                }\n            }\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n## 进阶\n### 矩阵的最大非负积\n```C\nclass Solution {\npublic:\n    int maxProductPath(vector<vector<int>>& grid) {\n        const int mod=1e9+7;\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<long long>> maxgt(m,vector<long long>(n));\n        vector<vector<long long>> minlt(m,vector<long long>(n));\n        maxgt[0][0]=minlt[0][0]=grid[0][0];\n        for(int j=1;j<n;j++){ //处理第一行\n            maxgt[0][j]=minlt[0][j]=maxgt[0][j-1]*grid[0][j];\n        }\n        for(int i=1;i<m;i++){ //处理第一列\n            maxgt[i][0]=minlt[i][0]=maxgt[i-1][0]*grid[i][0];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(grid[i][j]>=0){\n                    maxgt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                    minlt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                }\n                else{\n                    maxgt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                    minlt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                }\n            }\n        }\n        if(maxgt[m-1][n-1]<0) return -1;\n        else{\n            return maxgt[m-1][n-1]%mod;\n        }\n    }\n};\n```\n### 最大得分的路径数目\n```C\nusing PII = pair<int, int>;\n\nclass Solution {\nprivate:\n    static constexpr int mod = (int)1e9 + 7;\n\npublic:\n    void update(vector<vector<PII>>& dp, int n, int x, int y, int u, int v) {\n        if (u >= n || v >= n || dp[u][v].first == -1) {\n            return;\n        }\n        if (dp[u][v].first > dp[x][y].first) {\n            dp[x][y] = dp[u][v];\n        }\n        else if (dp[u][v].first == dp[x][y].first) {\n            dp[x][y].second += dp[u][v].second;\n            if (dp[x][y].second >= mod) {\n                dp[x][y].second -= mod;\n            }\n        }\n    }\n\n    vector<int> pathsWithMaxScore(vector<string>& board) {\n        int n = board.size();\n        vector<vector<PII>> dp(n, vector<PII>(n, {-1, 0}));\n        dp[n - 1][n - 1] = {0, 1};\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (!(i == n - 1 && j == n - 1) && board[i][j] != 'X') {\n                    update(dp, n, i, j, i + 1, j);\n                    update(dp, n, i, j, i, j + 1);\n                    update(dp, n, i, j, i + 1, j + 1);\n                    if (dp[i][j].first != -1) {\n                        dp[i][j].first += (board[i][j] == 'E' ? 0 : board[i][j] - '0');\n                    }\n                }\n            }\n        }\n        return dp[0][0].first == -1 ? vector<int>{0, 0} : vector<int>{dp[0][0].first, dp[0][0].second};\n    }\n};\n```\n### 矩阵中和能被 K 整除的路径\n```C\n/*把路径和模 k 的结果当成一个扩展维度*/\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>> &grid, int k) {\n        const int mod = 1e9 + 7;\n        int m = grid.size(), n = grid[0].size(), f[m + 1][n + 1][k];\n        memset(f, 0, sizeof(f)); // f[i][j][v] 表示从左上走到 (i,j)，且路径和模 k 的结果为 v 时的路径数\n        f[0][1][0] = 1;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                for (int v = 0; v < k; ++v)\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\n        return f[m][n][0];\n    }\n};\n/*代码实现时，为了避免判断是否越界，可以把下标都加一。此时可以设初始值 f[0][1][0]=1（或者 f[1][0][0]=1）简化一点点代码。*/\n```\n### 地下城游戏\n```C\n\n```\n# 背包\n## 0-1 背包\n>*每个物品只能选一次*\n### 和为目标值的最长子序列的长度\n```C\n\n```\n## 完全背包\n## 多重背包\n## 分组背包\n# 经典线性 DP\n## 最长公共子序列（LCS）\n>*一般定义f[i][j]表示对(s[:i],t[:j])的求解结果。*\n### 最长公共子序列\n```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.size(),n=text2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1)); \n        for(int i=1;i<=m;i++){\n            char c1=text1[i-1];\n            for(int j=1;j<=n;j++){\n                char c2=text2[j-1];\n                if(c1==c2){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                else{\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n### 两个字符串的删除操作\n```C++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; i++) {\n            char c1 = word1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = word2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        int lcs = dp[m][n];\n        return m - lcs + n - lcs;\n    }\n};\n```\n### 两个字符串的最小ASCII删除和\n```C++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int m = s1.size();\n        int n = s2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; ++i) {\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\n        }\n        for (int j = 1; j <= n; ++j) {\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\n        }\n        for (int i = 1; i <= m; i++) {\n            char c1 = s1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = s2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n```\n### 编辑距离\n```C++\n\n```\n## 最长递增子序列（LIS）\n","tags":["动态规划","编程"]},{"title":"软件工程综合实践","url":"/2024/10/01/软件工程综合实践/","content":"## 故事场景\n>你们是几名到某软件开发公司（以下简称T软）实习的学生。上班第一天，老板告诉你们，公司现在有个紧急项目，要求三周后上线，但是……上周末，这个项目唯一的程序员，小东，因不满公司的薪水待遇过低而离职了，现在留下了一个半成品的烂摊子，重担落在了你们几个毫无开发经验的实习生身上……\n## JDBC 项目\n**主要目标：解决“使用 JDBC 封装数据层，并实现增删改查”的问题。**\n## 前端项目\n**主要目标：解决“使用 HTML5+CSS3+JavaScript 开发企业级前端静态页面”的问题。**\n## JavaWeb 项目\n**主要目标：解决“使用 Vue（前端）+Servlet（服务端）开发基于前后端分离架构应用程序”的问题。**\n## SpringBoot 项目\n**主要目标：解决“使用 Vue（前端）+SpringBoot（服务端）开发基于前后端分离架构应用程序”的问题。**\n## SpringCloud 项目\n**主要目标：解决“使用 Vue（前端）+SpringCloud（服务端）开发基于微服务的互联网应用程序”的问题。**","tags":["软件工程","实践","开发"]},{"title":"计算机网络实践记录","url":"/2024/09/28/计算机网络实践记录/","content":"---\n- 天津大学 2024 计算机网络 TCP 课程实践\n- Lab Member：海棠未雨，梨花先雪\n- 最终成绩 +∞ 分捏 😋\n---\n# 文件结构说明\n```markdown\ntju_tcp ----------------- 项目根目录 \n├─ build ---------------- 存放所有编译的中间文件\n│  ├─ kernel.o\n│  ├─ tju_packet.o  \n│  └─ tju_tcp.o\n├─ inc ------------------ 存放所有头文件\n│  ├─ global.h ---------- 定义一些全局都会用到的变量和结构\n│  ├─ kernel.h ---------- 模拟一部分linux内核行为 比如如何发送数据到下一层 根据五元组查找socket等\n│  ├─ tju_packet.h ------ 定义TCP所用到的数据包格式 提供各种数据包的操作(创建 获得字段等)\n│  └─ tju_tcp.h --------- 需要实现的TCP的各种结构和功能的定义\n├─ src ------------------ 存放所有源代码文件\n│  ├─ client.c ---------- 客户端主函数实现\n│  ├─ server.c ---------- 服务端主函数实现\n│  ├─ kernel.c ---------- 虚拟内核实现\n│  ├─ tju_packet.c ------ 可靠层包封装实现\n│  └─ tju_tcp.c --------- 可靠层实现\n├─ Makefile ------------- 生成脚本\n├─ README.md ------------ 文件说明\n└─ bin\n   ├─ client\n   └─ server\n```\n---\n# 系统环境信息\n```SHELL\nneofetch\n--------------\nOS: Ubuntu 20.04.2 LTS x86_64\nHost: Oracle Corporation VirtualBox\nKernel: 5.4.0-80-generic\nUptime: 3 mins\nPackages: 676 (dpkg), 4 (snap)\nShell: bash 5.0.17\nResolution: 800x600\nTerminal: /dev/pts/0\nCPU: 11th Gen Intel i7-11800H (2) @ 2.304GHz\nGPU: VirtualBox Graphics Adapter\nMemory: 294MiB / 981MiB\n```\n---\n# 具体实验记录\n## 连接管理\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/t2LOxSBZgRkiblj.png\" width=\"60%\" />\n</center>\n\n### 三次握手建立连接\n**1. tju_connect( )**\n`tju_connect( )`函数是三次握手的开端。在该函数中，客户端的sock绑定好本地的ip和port后向服务器端发送SYN包，同时把当前的状态变化为SYN_SENT。成功建立连接后将sock放入ESTABLISHED的hash表中。\n```C\nint tju_connect(tju_tcp_t* sock, tju_sock_addr target_addr){\n    sock->established_remote_addr = target_addr;\n\n    tju_sock_addr local_addr;\n    local_addr.ip = inet_network(CLIENT_IP);\n    local_addr.port = 5678; // 连接方进行connect连接的时候 内核中是随机分配一个可用的端口\n    sock->established_local_addr = local_addr;\n\n    // 这里也不能直接建立连接 需要经过三次握手\n    // 实际在linux中 connect调用后 会进入一个while循环\n    // 循环跳出的条件是socket的状态变为ESTABLISHED 表面看上去就是 正在连接中 阻塞\n    // 而状态的改变在别的地方进行 在我们这就是tju_handle_packet\n    uint32_t seq = 0;  // 序列号\n    uint32_t ack = 0;  // 确认号\n    uint8_t flag=SYN_FLAG_MASK; //flag标记为：连接状态进行到哪一步\n    char *SYN = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n    sendToLayer3(SYN, DEFAULT_HEADER_LEN); //客户端向服务器端发送同步报文--第一次握手\n    change_sock_state(sock, SYN_SENT);\n    // printf(\"client发送SYN\\n\");\n    \n    Timeout_retransmission(sock, ESTABLISHED, SYN, DEFAULT_HEADER_LEN); //阻塞等待，直到sock被建立\n    int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n    established_socks[hashval] = sock;\n    return 0;\n}\n```\n**2. Timeout_retransmission( )**\n```C\nvoid Timeout_retransmission(tju_tcp_t* sock, int exp_state, char* pkt, int pktlen) { //超时重传发包函数\n    //printf(\"bg1\\n\");\n    long timeout = 100000L;\n    struct timeval start_time, end_time;\n    gettimeofday(&start_time, NULL);\n    while (sock->state != exp_state){\n        gettimeofday(&end_time, NULL);\n        long Time = 1000000L * (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_usec - start_time.tv_usec);\n        if (Time >= timeout) { //超时重传\n            gettimeofday(&start_time, NULL);\n            sendToLayer3(pkt, pktlen);\n        }\n    }\n    //printf(\"ed1\\n\");\n}\n```\n**3. change_sock_state( )**\n```C\nvoid change_sock_state(tju_tcp_t* sock, int state) {  //添加：sock状态改变\n    while (pthread_mutex_lock(&(sock->state_lock)) != 0) ; //改变sock状态前先加锁\n    sock->state = state;  \n    pthread_mutex_unlock(&(sock->state_lock)); //解锁\n}\n```\n**4. tju_accept()**\n`tju_accept( )`函数中添加了一个阻塞，使得只有当全连接hash表中存在这一个sock，服务器端才算连接完成，才能把新的sock加入到ESTABLISHED的hash表中。\n```C\ntju_tcp_t *tju_accept(tju_tcp_t *listen_sock){\n    while (listen_sock->received_len < DEFAULT_HEADER_LEN);\n    char *header = malloc(DEFAULT_HEADER_LEN);\n    memcpy(header, listen_sock->received_buf, DEFAULT_HEADER_LEN);\n    memset(listen_sock->received_buf, 0, DEFAULT_HEADER_LEN);\n    listen_sock->received_buf = NULL;\n    listen_sock->received_len = listen_sock->received_len - DEFAULT_HEADER_LEN;\n\n    tju_tcp_t* new_conn = (tju_tcp_t*)malloc(sizeof(tju_tcp_t));\n    pthread_mutex_init(&(new_conn->state_lock), NULL);\n    memcpy(new_conn, listen_sock, sizeof(tju_tcp_t));\n\n    tju_sock_addr local_addr, remote_addr;\n    /*\n     这里涉及到TCP连接的建立\n     正常来说应该是收到客户端发来的SYN报文\n     从中拿到对端的IP和PORT\n     换句话说 下面的处理流程其实不应该放在这里 应该在tju_handle_packet中\n    */\n    remote_addr.ip = inet_network(CLIENT_IP);  //具体的IP地址\n    remote_addr.port = 5678;  //端口\n\n    local_addr.ip = listen_sock->bind_addr.ip;  //具体的IP地址\n    local_addr.port = listen_sock->bind_addr.port;  //端口\n\n    new_conn->established_local_addr = local_addr;\n    new_conn->established_remote_addr = remote_addr;\n\n    while (listen_sock->state != ESTABLISHED) ;\n    change_sock_state(new_conn, ESTABLISHED);\n\n    // 将新的conn放到内核建立连接的socket哈希表中\n    int hashval = cal_hash(local_addr.ip, local_addr.port, remote_addr.ip, remote_addr.port);\n    established_socks[hashval] = new_conn;\n    return new_conn;\n}\n```\n**5. tju_handle_packet( )**\n`tju_handle_packet( )`函数中需要解决对各种报文的解析。`onTCPPocket( )`函数如果从established_hash或listen_hash中找到了对应的socket，就会调用 `tju_handle_packet( )`函数对收到的数据包进行处理。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    if (sock->state == LISTEN && get_flags(pkt) == SYN_FLAG_MASK){ //第二次握手\n        while (pthread_mutex_lock(&(sock->recv_lock)) != 0);\n        if (sock->received_buf == NULL) sock->received_buf = malloc(DEFAULT_HEADER_LEN);\n        else sock->received_buf = realloc(sock->received_buf, sock->received_len + DEFAULT_HEADER_LEN);\n        memcpy(sock->received_buf + sock->received_len, pkt, DEFAULT_HEADER_LEN);\n        sock->received_len += DEFAULT_HEADER_LEN;\n        pthread_mutex_unlock(&(sock->recv_lock));\n\n        tju_sock_addr remote;\n        remote.ip = inet_network(CLIENT_IP);\n        remote.port = get_src(pkt);\n\n        sock->established_local_addr = sock->bind_addr;\n        sock->established_remote_addr = remote;\n\n        int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, remote.ip, remote.port);\n        half_connection[hashval] = sock;  //收到SYN报文后放进LISTEN的半连接队列中\n        established_socks[hashval] = sock; //还会将该新建的socket放到ehash中\n\n        uint32_t seq = 0;  \n        uint32_t ack = get_seq(pkt) + 1; //确认号是SYN报文序列号+1\n        uint8_t flag = SYN_FLAG_MASK | ACK_FLAG_MASK; //状态记为SYN+ACK，这里采用位运算|\n        char *SYNACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(SYNACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, SYN_RECV);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == (ACK_FLAG_MASK | SYN_FLAG_MASK)){ //第三次握手\n        //printf(\"client收到SYCACK, 准备发送ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == SYN_FLAG_MASK){ //第三次握手（奇怪）\n        // //printf(\"client收到SYCACK, 准备发送ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == (SYN_FLAG_MASK | ACK_FLAG_MASK)){  //三次握手第三个包的重传\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == SYN_RECV && get_flags(pkt) == ACK_FLAG_MASK){\n        // //printf(\"server收到ACK\\n\");\n        sock->window.wnd_recv->expect_seq = get_seq(pkt) + get_plen(pkt) - DEFAULT_HEADER_LEN;\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        com_connection[hash] = sock;\n        half_connection[hash] = NULL;\n        change_sock_state(sock, ESTABLISHED);\n        if (get_plen(pkt) > DEFAULT_HEADER_LEN) { //ACK包携带信息\n            pkt2buffer(sock, pkt);\n        }\n    }\n```\n**6. pkt2buffer( )**\n```C\nvoid pkt2buffer(tju_tcp_t* sock, char* pkt) {\n    //printf(\"bg6\\n\");\n    uint32_t data_len = get_plen(pkt) - DEFAULT_HEADER_LEN;\n\n    while (pthread_mutex_lock(&(sock->recv_lock)) != 0); // 加锁\n    if (sock->received_buf == NULL){\n        sock->received_buf = malloc(data_len);\n    }\n    else{\n        sock->received_buf = realloc(sock->received_buf, sock->received_len + data_len);\n    }\n    memcpy(sock->received_buf + sock->received_len, pkt + DEFAULT_HEADER_LEN, data_len);    \n    sock->received_len += data_len;\n    pthread_mutex_unlock(&(sock->recv_lock)); // 解锁\n    //printf(\"ed6\\n\");\n}\n```\n### 四次挥手关闭连接\n**1. tju_close ( )**\n四次挥手有两种情况，分别为先后关闭和同时关闭，两种方式首先都需要调用`tju_close( )`函数，因此，在`tju_close( )`函数中，需要构造一个 FIN+ACK 报文，seq和ack都是当前报文窗口的下一个数值，并把自身状态变为 FIN-WAIT1。\n```C\nint tju_close (tju_tcp_t* sock){\n    uint16_t flag = FIN_FLAG_MASK | ACK_FLAG_MASK;\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_send->nextseq;\n    char* FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n    sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n    change_sock_state(sock, FIN_WAIT_1);\n    sock->window.wnd_send->nextseq++;\n\n    while (sock->state != CLOSED) ;\n    //printf(\"连接完全关闭\\n\");\n    return 0;\n}\n```\n**2. tju_handle_packet( )**\n接下来分为两种情况，但处理过程均在`tju_handle_packet( )`中完成，`tju_handle_packet( )`作为对收到的包进行响应的函数。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    ``````\n    ``````\n    ``````\n    else if (sock->state == ESTABLISHED && get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK)){ // server收到第一次挥手，并进行第二次挥手和第三次挥手\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第二次挥手报文\\n\");\n        change_sock_state(sock, CLOSE_WAIT);\n        \n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        seq = sock->window.wnd_send->nextseq;\n        ack = get_seq(pkt) + 1;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第三次挥手报文\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == ESTABLISHED && get_flags(pkt) == FIN_FLAG_MASK){ // server收到第一次挥手，并进行第二次挥手和第三次挥手\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, CLOSE_WAIT);\n        //printf(\"发送第二次挥手报文\\n\");\n\n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第三次挥手报文\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == FIN_WAIT_1 && get_flags(pkt) == ACK_FLAG_MASK){ // client收到第二次挥手\n        change_sock_state(sock, FIN_WAIT_2);\n        //printf(\"收到第二次挥手报文\\n\");\n    } \n    else if (sock->state == FIN_WAIT_2 && (get_flags(pkt) == (ACK_FLAG_MASK | FIN_FLAG_MASK))){ // client收到第三次挥手进行第四次挥手并关闭连接\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint32_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN,flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"收到第三次挥手报文, 并发出第四次挥手\\n\");\n        change_sock_state(sock, TIME_WAIT);\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,    sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        //这里要等待2MSL\n        change_sock_state(sock, CLOSED);\n        established_socks[hash] = NULL;\n        //printf(\"关闭连接\\n\");\n    } \n    else if (sock->state == LAST_ACK && (get_flags(pkt) == ACK_FLAG_MASK)){ // server收到第四次挥手并关闭连接\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"关闭连接\\n\");\n    }\n    else if (sock->state == FIN_WAIT_1 && (get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK))){ // 同时关闭收到第一次挥手\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK,DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n        // //printf(\"同时关闭发出ACK\\n\");\n    } \n    else if(sock->state == FIN_WAIT_1 && get_flags(pkt) == FIN_FLAG_MASK){ // 同时关闭收到第一次挥手\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == CLOSING && get_flags(pkt) == ACK_FLAG_MASK){ // 同时关闭时收到第三次挥手\n        change_sock_state(sock, TIME_WAIT);\n        //等待2MSL\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"同时关闭彻底关闭\\n\");\n    }\n}\n```\n## 可靠数据传输\n### 发送缓冲区管理\n**1. `global.h` 中宏定义 TCP 发送窗口大小。**\n```C\n#define TCP_SENDWN_SIZE 1000 \n```\n**2. `tju_packet.h` 中为发送缓冲区创建1000个报文长度的循环队列，方便数据包超时重传。**\n```C\n// TCP 报文的结构定义\ntypedef struct {\n\ttju_header_t header;\n\tstruct timeval sent_time;\n\tchar* data;\n} tju_packet_t;\ntju_packet_t* pktlist[TCP_SENDWN_SIZE];\n```\n**3. tju_send( )**\n上层调用 `tju_send( )` 时，我们在 `tju_send( )`函数内创建发送线程并把发送数据存入缓冲区中。\n&emsp;这里我们先了解一下创建线程 `pthread_create( )`函数。\n>int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg);\n>- tidp：事先创建好的pthread_t类型的参数。成功时tidp指向的内存单元被设置为新创建线程的线程ID。\n>- attr：用于定制各种不同的线程属性。APUE的12.3节讨论了线程属性。通常直接设为NULL。\n>- start_rtn：新创建线程从此函数开始运行。无参数是arg设为NULL即可。\n>- arg：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。\n>- 返回值为 0（表示线程成功创建）。\n```C\nint send_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    // 这里当然不能直接简单地调用sendToLayer\n    if(!send_thread_flag){\n        send_thread_flag = 1;\n        pthread_t sendthreadid;\n        int ret = pthread_create(&sendthreadid, NULL, send_pkt, (void *)sock);\n    }\n\n    while (pthread_mutex_lock(&(sock->send_lock)) != 0) ;\n    memcpy(sock->sending_buf + sock->index, (char*)buffer, len);\n    sock->sending_len += len;\n    sock->index += len;\n    pthread_mutex_unlock(&(sock->send_lock));\n\n    return 0;\n}\n```\n**4. send_pkt( )**\n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    //printf(\"bg4\\n\");\n    //struct timeval start_time, now_time;\n    //gettimeofday(&start_time, NULL);\n    //long deltatime = 0; //时间差\n    while (1){ //不断检查和发送数据包\n        if (sock->window.wnd_send->nextseq < sock->index){ //检查发送窗口：检查当前发送序列号是否小于索引，确保有数据需要发送。\n            //gettimeofday(&now_time, NULL);\n            //deltatime = now_time.tv_sec - start_time.tv_sec;\n\n            while (pthread_mutex_lock(&(sock->send_lock)) != 0);\n            int unlen = sock->sending_len - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base); //计算当前未发送的数据长度。 \n            int len = min(unlen, MAX_DLEN); //确定本次发送的长度，取未发送长度和最大数据长度中的最小值。 \n            pthread_mutex_unlock(&(sock->send_lock));\n            int leftlen = sock->window.wnd_send->rwnd - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base);\n            len =len>leftlen?leftlen:len;            \n\n            if (sock->window.wnd_send->nextseq - sock->window.wnd_send->base + len <= sock->window.wnd_send->rwnd) { //检查窗口大小：检查当前已发送的长度加上本次发送长度是否在接收窗口范围内。 \n                uint32_t seq = sock->window.wnd_send->nextseq;\n                uint32_t ack = seq + len; //不理解 \n                uint8_t flag = ACK_FLAG_MASK;\n                uint16_t pkt_len = len + DEFAULT_HEADER_LEN;\n                char *data = (char *)malloc(MAX_DLEN);\n                memcpy(data, sock->sending_buf + sock->window.wnd_send->nextseq, len);\n                tju_packet_t *datapacket = create_packet(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n\n                sendToLayer3(ACK, pkt_len);\n                \n                sock->window.wnd_send->nextseq += len;\n                pktlist[sock->packetr] = datapacket;\n                gettimeofday(&pktlist[sock->packetr]->sent_time, NULL);\n                sock->packetr = (sock->packetr + 1) % TCP_SENDWN_SIZE;\n                if (len == (int)(sock->window.wnd_send->nextseq - sock->window.wnd_send->base)){\n                    gettimeofday(&(sock->window.wnd_send->send_time), NULL);\n                    \n                    while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n                    sock->window.wnd_send->ack_cnt = 0;\n                    pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n                }\n            }\n        }\n    }\n    printf(\"ed4\\n\");\n}\n```\n### 失序报文数组的管理\n**1. tju_handle_packet( )**\n`tju_handle_packet( )`中添加建立连接后收到数据包的处理。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    `````` 建立连接 ``````\n    ````````````````````\n    ````````````````````\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == ACK_FLAG_MASK){ //收到数据包\n        char hostname[8];\n        gethostname(hostname, 8);\n        if (strcmp(hostname, \"server\") == 0){\n            serverrdt(sock, pkt);\n        } \n        else{\n            clientrdt(sock, pkt);\n        } \n    }\n    `````` 关闭连接 ``````\n    ````````````````````\n    ````````````````````\n}\n```\n**2. `tju_tcp_t` 结构体中创建空间用来存储失序报文并记录失序报文的个数。**\n```C\n// TJU_TCP 结构体 保存TJU_TCP用到的各种数据\ntypedef struct {\n\tchar unorder[100][MAX_LEN]; //失序报文数组\n\tint unolen; //失序报文个数\n} tju_tcp_t;\n```\n**3. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){ // 服务器端处理数据包\n    if (get_seq(pkt) < (sock->window.wnd_recv->expect_seq)){ //函数发送一个 ACK 响应已确认接收\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if(get_seq(pkt) > (sock->window.wnd_recv->expect_seq)){ //数据包乱序，函数将包暂存，并发送 ACK，同时更新接收窗口\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n\n        if((sock->unolen) > MAX_PKT_IN_WINDOW)  return;\n        memcpy(sock->unorder[sock->unolen], pkt, get_plen(pkt));\n        sock->unolen++;\n    }\n    else{ //刚刚好\n        sock->window.wnd_send->nextseq=get_ack(pkt);\n        sock->window.wnd_recv->expect_seq+=get_plen(pkt)-DEFAULT_HEADER_LEN;\n        pkt2buffer(sock,pkt);\n        if(sock->unolen == 0){\n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag,TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n        else{\n            int len = sock->unolen;\n\n            for(int i = 0; i < len; i++){\n                for(int j = i + 1; j < len; j++){\n                    if(get_seq(sock->unorder[i])>get_seq(sock->unorder[j])){\n                        my_swap(&sock->unorder[i], &sock->unorder[j]);\n                    }\n                }\n            }\n            int index = 0;\n            for(; index < len; index++){\n                if(get_seq(sock->unorder[index]) == sock->window.wnd_recv->expect_seq){\n                    sock->window.wnd_send->nextseq = get_ack(sock->unorder[index]);\n                    sock->window.wnd_recv->expect_seq += get_plen(sock->unorder[index]) - DEFAULT_HEADER_LEN;\n                    pkt2buffer(sock, sock->unorder[index]);\n                }\n                else if(get_seq(sock->unorder[index]) < (sock->window.wnd_recv->expect_seq)) continue;\n                else break;\n            }\n            for (int i = index; i < len; i++){\n                memcpy(sock->unorder[i - index], sock->unorder[i], sizeof(sock->unorder[i]));\n            }\n            sock->unolen -= index;\n           \n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n    }\n}\n```\n**4. my_swap( )**\n```C\nvoid my_swap(char** a, char** b){\n    char* tem = (char*)malloc(MAX_LEN);\n    memcpy(tem, a, get_plen(b));\n    memcpy(a, b, get_plen(b));\n    memcpy(b, tem, get_plen(tem));\n    free(tem);\n}\n```\n### 实现累计应答\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/vKkuC1ibGfmo2sM.png\" width=\"60%\" />\n\nFigure 1. 累计应答\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )`函数中添加累计应答处理。当发送方收到任意大于当前base的ack报文后，直接把当前base进行更新即可。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    if (sock->window.wnd_send->base == sock->window.wnd_send->nextseq) return;\n    if (get_ack(pkt) < sock->window.wnd_send->base) return;\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        ``````\n        ``````\n        ``````\n        while(pthread_mutex_lock(&(sock->send_lock)) != 0); //加锁\n        while(sock->window.wnd_send->base < get_ack(pkt) && sock->window.wnd_send->base < sock->window.wnd_send->nextseq ){   \n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            int datalen = pkt_len - DEFAULT_HEADER_LEN;\n            sock->sending_len -= datalen;\n            sock->window.wnd_send->base += datalen;\n            sock->packetl = (sock->packetl + 1) % TCP_SENDWN_SIZE;\n        }\n        pthread_mutex_unlock(&(sock->send_lock)); //解锁\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n### 超时重传\n**1. tju_send( )**\n`tju_send( )` 中创建了一个新的线程判断是否要进行重传。\n```C\nint resend_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    ``````\n    ``````\n    ``````\n    if (!resend_thread_flag){\n        resend_thread_flag = 1;\n        pthread_t resendthreadid;\n        int ret = pthread_create(&resendthreadid, NULL,resend_pkt, (void *)sock);\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n**2. resend_pkt( )**\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    struct timeval start_time,now_time;\n    gettimeofday(&start_time, NULL);\n    long deltatime = 0;\n    while (1){\n        if (sock->window.wnd_send->base < sock->window.wnd_send->nextseq){\n            gettimeofday(&now_time, NULL);\n            deltatime = now_time.tv_sec - start_time.tv_sec;\n            if (deltatime > 100) break; //不理解\n            long nowtimeval = 1000000 * (now_time.tv_sec - sock->window.wnd_send->send_time.tv_sec) +  (now_time.tv_usec - sock->window.wnd_send->send_time.tv_usec);\n            long timeoutval = 1000000 * (sock->window.wnd_send->timeout.tv_sec) + (sock->window.wnd_send->timeout.tv_usec);\n            if (nowtimeval > timeoutval){ //超时重传\n                while(pktlist[sock->packetl] == NULL);\n                uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n                uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n                uint8_t flag = ACK_FLAG_MASK;\n                int pkt_len = pktlist[sock->packetl]->header.plen;\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack,DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n                sendToLayer3(ACK, pkt_len);\n                gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);\n                gettimeofday(&sock->window.wnd_send->send_time, NULL);\n            }\n        }\n    }\n}\n```\n**3. clientrdt( )**\n`clientrdt( )` 函数中添加动态设置超时间隔的实现。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        //更新RTO\n        struct timeval nowtime;\n        gettimeofday(&nowtime, NULL);\n        long ntime = 1000000 * nowtime.tv_sec + nowtime.tv_usec;\n        long samplertt = 1000000 * (nowtime.tv_sec-pktlist[sock->packetl]->sent_time.tv_sec)+nowtime.tv_usec-pktlist[sock->packetl]->sent_time.tv_usec;\n        long estmatedrtt = sock->window.wnd_send->estmated_rtt;\n        long devrtt = sock->window.wnd_send->dev_rtt;\n        estmatedrtt = 1.0 * estmatedrtt * 7 / 8 + samplertt / 8;\n        devrtt = 1.0 * devrtt * 3 / 4 + (samplertt > 1.0 * estmatedrtt ? (samplertt - estmatedrtt) : (estmatedrtt - samplertt)) / 4;\n        sock->window.wnd_send->timeout.tv_usec = (estmatedrtt + 4 * devrtt) % 1000000;\n        sock->window.wnd_send->timeout.tv_sec = (estmatedrtt + 4 * devrtt) / 1000000;\n        sock->window.wnd_send->estmated_rtt = estmatedrtt;\n        sock->window.wnd_send->dev_rtt = devrtt;\n        double dsamplertt=(double)samplertt/(double)1000000;\n        double destmatedrtt=(double)estmatedrtt/(double)1000000;\n        double ddevrtt=(double)devrtt/(double)1000000;\n        double dtimegap=(double)(estmatedrtt + 4 * devrtt)/(double)1000000;\n        \n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt = 1;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n        ``````\n        ``````\n        ``````\n    }\n}\n```\n### 快速重传\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/cj2PfZsz8abBVW9.png\" width=\"60%\" />\n\nFigure 1. 快速重传\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )` 函数中添加快速重传的实现。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) == sock->window.wnd_send->base){ //冗余ACK\n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt++;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n        if(sock->window.wnd_send->ack_cnt == 3){ //快速重传 \n            ``````\n            uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n            uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n            uint8_t flag = ACK_FLAG_MASK;\n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, pkt_len, ACK_FLAG_MASK, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n            sendToLayer3(ACK, pkt_len);\n            sock->window.wnd_send->ack_cnt = 0;\n            gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);            \n        }\n        return;\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n## 流量控制\n### 接收方计算接受缓冲区大小\n**1. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){// 服务端处理数据包\n    ``````\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_recv->expect_seq;\n    uint8_t flag = ACK_FLAG_MASK;\n    char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n    ``````\n}\n```\n### 发送方调整发送缓冲区大小\n**1. clientrdt( )**\n`clientrdt( )`函数确定window_size大小。\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){\n    ``````\n    ``````get_advertised_window(pkt)``````\n    ``````\n}\n```\n**2. get_advertised_window( )**\n```C\nuint16_t get_advertised_window(char* msg){\n    int offset = 17;\n    uint16_t var;\n    memcpy(&var, msg+offset, SIZE16);\n    return ntohs(var);\n}\n```\n### 0窗口探测\n**1. send_pkt( )**\n`send_pkt( )`发送数据的线程中加入一个判断条件。\n0窗口探测用于在ADVERTISED WINDOW为0的情况下，发送大小为1的数据报文以获得实时的窗口返回值。  \n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    ``````\n    if((sock->window.wnd_send->nextseq > sock->window.wnd_send->base)&&sock->window.wnd_send->rwnd == 0){\n        len = 1;\n    }\n    if (len > 0){\n        ``````\n        ``````\n        ``````        \n    }\n    ``````\n}\n```\n## 拥塞控制\n### 慢启动\n**1. 套接字的初始化使得发送方从其他状态进入慢启动状态。**\n```C\ntju_tcp_t* tju_socket(){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n**2. `resend_pkt( )`函数超时事件使得发送方从其他状态进入慢启动状态。**\n```C\nif (nowtimeval > timeoutval){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n在慢启动状态下，发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS（MAX_DLEN）。虽然是不断的自增 MSS，但是由于拥塞窗口的增大（进而导致发送窗口的增大），每次自增的次数为 1->2->4->8 直至达到ssthresh，所以拥塞窗口整体上呈现指数增长的趋势。\n**3. clientrdt( )**\n`clientrdt( )` 函数中发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS。\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //慢启动\n        ``````    \n        else if(get_ack(pkt) > sock->window.wnd_send->base){ // new ack\n            sock->window.wnd_send->cwnd += MSS;\n            \n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            ``````\n        }\n        ``````\n    }\n    ``````\n}\n```\n**4. resend_pkt( )**\n`resend_pkt( )` 函数中处理超时重传导致慢启动参数变化。\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    ``````\n    if (nowtimeval > timeoutval){\n        sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2; //拥塞阈值变成拥塞窗口大小的一半\n        if(sock->window.wnd_send->ssthresh < MAX_DLEN) sock->window.wnd_send->ssthresh = MSS; //调整\n        sock->window.wnd_send->cwnd = MSS; //拥塞窗口变成1MSS\n        sock->window.wnd_send->congestion_status = SLOW_START; //拥塞状态不变\n    }\n    ``````\n}\n```\n### 拥塞避免\n**1. 拥塞窗口超过 ssthresh 进入拥塞避免状态。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //慢启动\n        ``````\n        if(sock->window.wnd_send->cwnd >= sock->window.wnd_send->ssthresh){ //cwnd达到ssthresh，转为拥塞避免状态\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n        ``````\n    }\n    ``````\n}\n```\n**2. 快速恢复阶段收到正确的 ACK 使得发送方从其他状态进入拥塞避免状态。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //快速恢复\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n          \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n}\n```\n**3. 在拥塞避免状态下，发送方每当收到一个正确的 ACK 报文，拥塞窗口就会增大（1/cwnd）个 MSS。拥塞窗口整体上呈现线性增长的趋势。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    else if (sock->window.wnd_send->congestion_status == CONGESTION_AVOIDANCE) { //拥塞避免\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd += MSS * ((double)MSS / (double)sock->window.wnd_send->cwnd);\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n        }\n    }\n    ``````\n}\n```\n### 快速恢复\n**1. `clientrdt( )` 发送方收到 3 个冗余 ACK 时，进入快速恢复状态。**\n```C\nif(sock->window.wnd_send->ack_cnt == 3){  //快速重传\n    sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2;\n    sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh + 3 * MSS;\n    sock->window.wnd_send->congestion_status = FAST_RECOVERY; //快速恢复\n    ``````\n}\n```\n**2. 在快速恢复状态下，如果还是收到冗余 ACK，那么依然在此状态，cwnd+=MSS；当收到正确 ACK 时，则进入拥塞避免状态 ，cwnd=ssthresh；当超时时，回到慢启动，cwnd=1MSS。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    ``````\n    ``````    \n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //快速恢复\n        if(get_ack(pkt) == sock->window.wnd_send->base){//dup ack\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt++;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n            sock->window.wnd_send->cwnd += MSS;\n                        \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = FAST_RECOVERY;\n            return;\n        }\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));  \n         \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n    ``````\n    ``````\n}\n```","tags":["实践","计算机网络"]},{"title":"C语言手写Httpd网站服务器","url":"/2024/09/26/C语言手写Httpd网站服务器/","content":"\n---\n## 执行WEB服务前的准备工作\n### 创建项目\n```C\n#include <stdio.h>\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port){\n    return 0;\n}\n\nint main(void){\n    //httpd默认的端口是80，这里指定了8000端口，也可以使用其它端口\n    unsigned short port = 8000;\n\n    // 初始化网络，并使用指定端口来创建服务端的套接字\n    int server_sock = startup(&port);\n    printf(\"httpd running on port %d\\n\", port);\n\n    return(0);\n}\n```\n### 网络通信初始化\n```C\n//网络通信需要包含的头文件、需要加载的库文件\n#include <winsock2.h>\n#pragma comment (lib, \"WS2_32.lib\")\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    WSADATA wsaData; // 网络通信相关的版本等信息\n    int ret = WSAStartup( // WSAStartup 网络通信初始化，\n        MAKEWORD(1, 1),   // 指定使用Windows Sockets规范的1.1版本\n        &wsaData);        // 存储初始化后的版本等信息结果\n    if (ret) {\n        return -1;\n    }\n\n    return 0;\n}\n```\n### 创建套接字\n```C\nvoid error_die(const char* sc) {\n    perror(sc); //打印错误原因\n    exit(1);\n}\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    int server_socket = socket(PF_INET, //套接字的类型（网络套接字、文件套接字，此处是前者）\n        SOCK_STREAM,  //数据包的类型（数据流、数据报，此处是前者）               \n        IPPROTO_TCP); //具体协议\n    if (server_socket == -1) { //打印错误提示，并结束程序\n        error_die(\"socket\");\n    }\n}\n```\n### 设置套接字属性--端口可复用\n```C\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    //设置端口可复用（端口复用）\n    int opt = 1;\n    ret = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n    if (ret == -1) {\n        error_die(\"setsockopt\");\n    }\n}\n```\n### 绑定套接字和网络地址\n```C\nint startup(unsigned short* port) {\n    //配置服务器的网络地址\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(*port);\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    //绑定套接字\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        error_die(\"[bind]\");\n    }\n}\n```\n### 获取动态端口\n```C\nint startup(unsigned short* port) {\n    // 动态分配端口\n    if (*port == 0) {\n        int namelen = sizeof(server_addr);\n        if (getsockname(server_socket, (struct sockaddr*)&server_addr, &namelen) <0) {\n            error_die(\"getsockname\");\n        }\n        *port = ntohs(server_addr.sin_port);\n    }\n    return server_socket;\n}\n```\n### 创建监听队列\n```C\nint startup(unsigned short* port) {\n    //创建监听队列\n    if (listen(server_socket, 5) < 0) {\n        error_die(\"listen\");\n    }\n    return server_socket;\n}\n```","tags":["c","服务器"]},{"title":"C语言手写植物大战僵尸","url":"/2024/09/26/C语言手写植物大战僵尸/","content":"\n---\n## C语言手写植物大战僵尸\n### 创建主场景\n```C\n#include<stdio.h>\n#include<graphics.h>\n\n#define WIN_WIDTH 900\n#define WIN_HEIGHT 600\n\nIMAGE imgBg;\n\n//游戏初始化\nvoid gameInit() {\n\tloadimage(&imgBg, \"res/bg.jpg\");\n\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT);\n}\n\n//更新窗口\nvoid updateWindow() {\n\tputimage(0, 0, &imgBg);\n}\n\nint main(void) {\n\t//游戏初始化\n\tgameInit();\n\n\t//更新窗口\n\tupdateWindow();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物卡牌\n```C\n#include \"tools.h\"\n\n//#define ZHI_WU_CUNT 3\n\nenum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT };\n\nIMAGE imgBar;\nIMAGE imgCards[ZHI_WU_COUNT];\n\nvoid gameInit() {\n\tloadimage(&imgBar, \"res/bar.png\");\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\t//生成植物卡牌的文件名\n\t\tsprintf_s(name, sizeof(name), \"res/Cards/card_%d.png\", i + 1);\n\t\tloadimage(&imgCards[i], name);\n\t}\n}\n\nvoid updateWindow() {\n\t//putimage(250, 0, &imgBar); //有黑边\n\tputimagePNG(250, 0, &imgBar);\n\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tint x = 338 + i * 65;\n\t\tint y = 6;\n\t\tputimage(x, y, &imgCards[i]);\n\t}\n}\n```\n### 实现植物的选择和拖动\n```C\nIMAGE* imgZhiWu[ZHI_WU_COUNT][20];\n\nint curX, curY; //当前选中的植物，在移动过程中的位置\nint curZhiWu; //0:没有选中，1:选择了第一种植物 etc.\n\nbool fileExist(const char* name) {\n\tFILE* fp = fopen(name, \"r\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfclose(fp);\n\t\treturn true;\n\t}\n}\n\nvoid gameInit() {\n\tmemset(imgZhiWu, 0, sizeof(imgZhiWu));\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tsprintf_s(name, sizeof(name), \"res/zhiwu/%d/%d.png\", i, j + 1);\n\t\t\t//先判断这个文件是否存在\n\t\t\tif (fileExist(name)) {\n\t\t\t\timgZhiWu[i][j] = new IMAGE;\n\t\t\t\tloadimage(imgZhiWu[i][j], name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurZhiWu = 0;\n\t//创建游戏的图形窗口\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT, 1); //加一个参数1，保留后台界面，方便调试\n}\n\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲（先打印到内存中）\n\n\t//渲染 拖动过程中的植物\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲（再一次性打印到窗口）\n}\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;//状态变量（先点击再拖动）\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\t\t\t\tint index = (msg.x - 338) / 65; //选择卡牌序号\n\t\t\t\tprintf(\"%d\\n\", index);\n\t\t\t\tstatus = 1; //可以拖动\n\t\t\t\tcurZhiWu = index + 1;\n\t\t\t}\n\t\t}\n\t\telse if (msg.message == WM_MOUSEMOVE && status == 1) { //鼠标移动\n\t\t\tcurX = msg.x;\n\t\t\tcurY = msg.y;\n\n\t\t}\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\n\t\t}\n\t}\n\n}\nint main(void) {\n\tgameInit();\n\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物的种植\n```C\nstruct zhiwu {\n\tint type;\t\t//0:没有选中，1:第一种植物\tetc.\t\t\t\t\n\tint frameIndex; //序列帧的序号\n};\n\nstruct zhiwu map[3][9];\n\nvoid gameInit() {\n\tmemset(map, 0, sizeof(map));\n}\n\nvoid updateWindow() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tint x = 256 + j * 81;\n\t\t\t\tint y = 179 + i * 102 + 14;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tputimagePNG(x, y, imgZhiWu[zhiWuType][index]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid userClick() {\n\tif (peekmessage(&msg)) {\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\t\t\tif (msg.x > 256 && msg.y > 179 && msg.y < 489) {\n\t\t\t\tint row = (msg.y - 179) / 102;\n\t\t\t\tint col = (msg.x - 256) / 81;\n\t\t\t\t//printf(\"%d, %d\\n\", row, col);\n\t\t\t\tif (map[row][col].type == 0) {\n\t\t\t\t\tmap[row][col].type = curZhiWu;\n\t\t\t\t\tmap[row][col].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurZhiWu = 0;\n\t\t\tstatus = 0;\n\t\t}\n\t}\n}\n```\n### 实现植物的摇摆\n```C\n//更新游戏相关数据\nvoid updateGame() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tmap[i][j].frameIndex++;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tif (imgZhiWu[zhiWuType][index] == NULL) {\n\t\t\t\t\tmap[i][j].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t\tupdateGame(); //更新游戏相关数据\n\n\t\tSleep(10);//帧等待\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 优化游戏循环和游戏渲染循序\n```C\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲\n\n\t//渲染 拖动过程中的植物（放到了最后）\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲\n}\n\nint main(void) {\n\tgameInit();\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 制作启动菜单\n```C\nvoid startUI() { //启动菜单\n\tIMAGE imgBg,imgMenu1,imgMenu2;\n\tloadimage(&imgBg, \"res/menu.png\");\n\tloadimage(&imgMenu1, \"res/menu1.png\");\n\tloadimage(&imgMenu2, \"res/menu2.png\");\n\n\tint flag = 0;\n\twhile (1) {\n\t\tBeginBatchDraw();\n\t\tputimage(0, 0, &imgBg);\n\t\tputimagePNG(474, 75, flag ? &imgMenu2: &imgMenu1);\n\n\t\tExMessage msg;\n\t\tif (peekmessage(&msg)) {\n\t\t\tif (msg.message == WM_LBUTTONDOWN&&\n\t\t\t\t\tmsg.x>474&&msg.x<474+300&&\n\t\t\t\t\tmsg.y>75&&msg.y<75+140){\n\t\t\t\tflag = 1;\n\t\t\t\t//EndBatchDraw();\n\t\t\t}\n\t\t\telse if (msg.message == WM_LBUTTONUP&&flag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEndBatchDraw();\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\n\tstartUI();\n\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\n\t\tSleep(10);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 创建随机阳光\n```C\n#include<time.h>\n\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n};\n\n//阳光池\nstruct sunshineBall balls[10];\nIMAGE imgSunshineBall[29];\n\n\nvoid gameInit() {\n\tmemset(balls, 0, sizeof(balls));\n\tfor (int i = 0; i < 29; i++) {\n\t\tsprintf_s(name, sizeof(name), \"res/sunshine/%d.png\", i + 1);\n\t\tloadimage(&imgSunshineBall[i], name);\n\t}\n\n\t//配置随机种子\n\tsrand(time(NULL));\n}\n\nvoid creatSunshine() {\n\tstatic int count = 0;\n\tstatic int fre = 400;\n\tcount++;\n\tif (count >= fre) { //每fre帧创建一个阳光，fre随机改变\n\t\tfre = 200 + rand() % 200;\n\t\tcount = 0;\n\n\t\t//从阳光池中取一个可以使用的\n\t\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\n\t\tint i;\n\t\tfor (i = 0; i < ballMax && balls[i].used; i++);\n\t\tif (i >= ballMax) return;\n\n\t\tballs[i].used = true;\n\t\tballs[i].frameIndex = 0;\n\t\tballs[i].x = 260 + rand() % (900 - 260);\n\t\tballs[i].y = 60;\n\t\tballs[i].destY = 200 + (rand() % 4) * 90;\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine();\n}\n```\n### 显示随机阳光\n```C\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n\tint timer; //计时器\n};\n\nvoid updateWindow() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tIMAGE* img = &imgSunshineBall[balls[i].frameIndex];\n\t\t\tputimagePNG(balls[i].x, balls[i].y, img);\n\t\t}\n\t}\n}\n\t\nvoid creatSunshine() {\n\tif (count >= fre) {\n\t\tballs[i].timer = 0;\n\t}\n}\n\nvoid updateSunshine() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tballs[i].frameIndex = (balls[i].frameIndex + 1) % 29;\n\t\t\tif (balls[i].timer == 0) { //未到达地面\n\t\t\t\tballs[i].y += 2;\n\t\t\t}\n\t\t\tif (balls[i].y >= balls[i].destY) {\n\t\t\t\t//balls[i].used = false;\n\t\t\t\tballs[i].timer++;\n\t\t\t\tif (balls[i].timer > 100) { //掉到地面100帧之后\n\t\t\t\t\tballs[i].used = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine(); //创建阳光\n\tupdateSunshine(); //更新阳光的状态\n}\n```\n### 收集阳光、显示阳光值\n```C\n#include<mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\nint sunshine; //总阳光值\n\nvoid gameInit() {\n\tsunshine = 150;\n\n\t//设置字体\n\tLOGFONT f;\n\tgettextstyle(&f);                     // 获取当前字体设置\n\tf.lfHeight = 30;                      // 设置字体高度为 48\n\tf.lfWidth = 15;\n\tstrcpy(f.lfFaceName, \"Segoe UI Black\"); \n\tf.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  \n\tsettextstyle(&f);                     // 设置字体样式\n\tsetbkmode(TRANSPARENT);\t\t\t\t  //背景模式透明\n\tsetcolor(BLACK);\t\t\t\t\t  //字体颜色\n}\n\nvoid updateWindow() {\n\tchar scoreText[8];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", sunshine);\n\touttextxy(276, 67, scoreText); //在指定位置输出文本--分数\n}\n\nvoid collectSunshine(ExMessage* msg) {\n\tint count = sizeof(balls) / sizeof(balls[0]);\n\tint w = imgSunshineBall[0].getwidth(); //阳光球宽度\n\tint h = imgSunshineBall[0].getheight();//阳光球高度\n\tfor (int i = 0; i < count; i++) {\n\t\tif (balls[i].used) {\n\t\t\tint x = balls[i].x;\n\t\t\tint y = balls[i].y;\n\t\t\tif (msg->x > x && msg->x < x + w && msg->y > y && msg->y < y + h) {\n\t\t\t\tballs[i].used = false;\n\t\t\t\tsunshine += 25;\n\t\t\t\tmciSendString(\"play res/sunshine.mp3\", 0, 0, 0); //添加音效\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollectSunshine(&msg);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```","tags":["c","PvZ"]},{"title":"Java 综合实战（一）","url":"/2024/09/24/Java 综合实战/","content":"\n---\n## Java 综合实战（一）\n### 健康计算器\n**需求：开发一个简单的健康计算器应用程序，它可以接受用户的输入（如年龄、性别、体重、身高），并计算出用户的 BMI（身体质量指数）和 BMR（基础代谢率）。**\n```Java\npackage test;\n\nimport java.util.Scanner;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请您输入您的身高：\");\n        double height=sc.nextDouble();\n\n        System.out.println(\"请您输入您的体重：\");\n        double weight=sc.nextDouble();\n\n        System.out.println(\"请您输入您的性别（男/女）：\");\n        String sex=sc.next();\n\n        System.out.println(\"请您输入您的年龄：\");\n        int age=sc.nextInt();\n\n        double bmi=calcBMI(height,weight);\n        System.out.println(\"您的BMI值为：\"+bmi);\n\n        double bmr=calcBMR(height,weight,age,sex);\n        System.out.println(\"您的BMR值为：\"+bmr);\n    }\n\n    public static double calcBMI(double height,double weight){\n        return weight/(height*height);\n    }\n\n    public static double calcBMR(double height,double weight,int age,String sex){\n        double bmr=0;\n        if(sex.equals(\"男\")){\n            bmr=88.362+13.397*weight+4.799*height-5.677*age;\n        }\n        else{\n            bmr=447.593+9.247*weight+3.098*height-4.330*age;\n        }\n        return bmr;\n    }\n}\n```\n### 简单计算器\n**需求：设计一个可以执行基本数学运算（加、减、乘、除）的计算器程序。** \n**功能描述：用户输入两个数字、一个运算符（+、-、*、/）。根据所选运算符执行相应的数学运算，显示运算结果。**\n```Java\npackage test1;\n\nimport java.util.Scanner;\n\npublic class test1 {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请输入第一个数字：\");\n        double num1=sc.nextDouble();\n\n        System.out.println(\"请输入第二个数字：\");\n        double num2=sc.nextDouble();\n\n        System.out.println(\"请输入运算符（+、-、*、/）：\");\n        String operator=sc.next();\n\n        double result=calculate(num1,num2,operator);\n        System.out.println(\"计算结果为：\"+result);\n    }\n\n    public static double calculate(double num1,double num2,String operator){\n        double result=0;\n        switch (operator){\n            case \"+\":\n                result=num1+num2;\n                break;\n            case \"-\":\n                result=num1-num2;\n                break;\n            case \"*\":\n                result=num1*num2;\n                break;\n            case \"/\":\n                result=num1/num2;\n                break;\n            default:\n                System.out.println(\"输入的运算符有误！\");\n        }\n        return result;\n    }\n}\n```\n### 猜数字小游戏\n**需求：随机生成一个1-100之间的数据，提示用户猜测，猜大提示过大，猜小提示过小，直到猜中结束游戏。**\n```Java\npackage test1;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class test2 {\n    public static void main(String[] args) {\n        guessNumber();\n    }\n\n    public static void guessNumber(){\n        /*方法一*/\n        //Math.random()返回[0,1)之间的随机小数\n        //(int)(Math.random()*100)==>[0,100)的整数==>[0,99]+1==>[1,100]\n        //int number=(int)(Math.random()*100)+1;\n\n        /*方法二*/\n        Random r=new Random();\n        int number=r.nextInt(100)+1;\n\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            System.out.println(\"请输入一个1~100之间的数字：\");\n            int guess=sc.nextInt();\n            if(guess<number){\n                System.out.println(\"猜小了，再试试吧！\");\n            }\n            else if(guess>number){\n                System.out.println(\"猜大了，再试试吧！\");\n            }\n            else{\n                System.out.println(\"恭喜你猜对了！\");\n                break;\n            }\n        }\n    }\n}\n```\n### 开发一个验证码\n**需求：开发一个程序，可以生成指定位数的验证码，每位可以是数字，大小写字母。**\n```Java\npackage test1;\n\npublic class test3 {\n    public static void main(String[] args) {\n        System.out.println(getCode(6));\n    }\n\n    public static String getCode(int n){\n        String code=\"\";\n\n        for(int i=0;i<n;i++){\n            int type=(int)(Math.random()*3); //数字0/大写1/小写2\n            \n            switch(type){\n                case 0:\n                    int num=(int)(Math.random()*10);\n                    code+=num;\n                    break;\n                case 1:\n                    int num1=(int)(Math.random()*26)+65;\n                    code+=(char)num1;\n                    break;\n                case 2:\n                    int num2=(int)(Math.random()*26)+97;\n                    code+=(char)num2;\n                    break;\n            }\n        }\n        return code;\n    }\n}\n```\n### 找素数\n**需求：输出101-200之间的所有素数以及总个数。**\n```Java\npackage test1;\n\npublic class test4 {\n    public static void main(String[] args) {\n        //目标：找出101-200之间的全部素数\n        int count=0;\n        for(int i=101;i<=200;i++){\n            if(isPrime(i)){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println(\"素数的个数为：\"+count);\n    }\n\n    public static boolean isPrime(int num){\n        for(int i=2;i*i<=num;i++){\n            if(num%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n### 斗地主游戏\n**需求：开发一个简易版的斗地主游戏，要求只完成做牌（存储54张牌）、洗牌。**\n```Java\npackage test2;\n\npublic class test1 {\n    public static void main(String[] args) {\n       start();\n    }\n    public static void start(){\n        String[] poker=new String[54];\n        String[] colors={\"♠\",\"♥\",\"♣\",\"♦\"};\n        String[] nums={\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"};\n\n        int index=0;\n        for(int i=0;i<colors.length;i++){\n            for(int j=0;j<nums.length;j++){\n                poker[index++]=colors[i]+nums[j];\n            }\n        }\n        poker[index++]=\"Big Joker\";\n        poker[index++]=\"Small Joker\";\n\n        //打印牌\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n\n        //洗牌\n        for(int i=0;i<poker.length;i++){\n            int j=(int)(Math.random()*poker.length);\n            String temp=poker[i];\n            poker[i]=poker[j];\n            poker[j]=temp;\n        }\n\n        System.out.println(\"洗牌后：\");\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n    }\n}\n```\n### 石头迷阵游戏\n**需求：只需完成数据初始化**\n```Java\npackage test2;\n\npublic class test2 {\n    public static void main(String[] args) {\n        start(5);\n    }\n    public static void start(int n) {\n       int[][] arr=new int[n][n];\n\n       int count=1;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               arr[i][j]=count++;\n           }\n       }\n\n       print(arr);\n\n       //打乱二维数组中的元素顺序\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                int x=(int)(Math.random()*arr.length);\n                int y=(int)(Math.random()*arr[i].length);\n                int temp=arr[i][j];\n                arr[i][j]=arr[x][y];\n                arr[x][y]=temp;\n            }\n        }\n        System.out.println(\"------------------\");\n        System.out.println(\"打乱后：\");\n        print(arr);\n    }\n    public static void print(int[][] arr){\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                System.out.print(arr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```","tags":["Java"]},{"title":"Markdown 语法","url":"/2024/09/09/Markdown语法/","content":"\n## Markdown 标题\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n```\n&nbsp;**或者在文本下方添加任意数量的 = 或 - 分别用于表示一级标题或二级标题**\n``` markdown\n一级标题\n=========\n\n二级标题\n---------\n```\n\n## Markdown 字体\n``` markdown\n*斜体文字*\n\n_斜体文字_\n\n**粗体文字**\n\n__粗体文字__\n\n***粗斜体文字***\n\n___粗斜体文字___\n```\n\n## Markdown 引用\n``` markdown\n>这是引用的内容\n\n>>这是引用的内容\n\n>>>>>>>>>>这是引用的内容\n```\n\n## Markdown 分割线\n&nbsp;**三个或者三个以上的 - 或者 * 或者 _ 都可以**\n``` markdown\n---\n\n****\n\n____\n```\n  \n## Markdown 下划线\n``` markdown\n<u>带下划线文本</u>   \n```\n\n## Markdown 删除线\n``` markdown \n~~tencent.com~~\n```\n\n## Markdown 图片\n### 插入互联网上图片\n``` markdown\n![图片描述](图片链接 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n### 插入本地图片\n``` markdown\n![图片描述](图片本地路径 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n## Markdown 超链接\n``` markdown\n[超链接名](超链接地址 \"超链接title\")\n```\n&nbsp;**注：title可加可不加**\n\n## Markdown 列表\n### 无序列表\n&nbsp;**无序列表用 - + * 任何一种都可以**\n``` markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n### 有序列表\n``` markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n### 嵌套列表\n&nbsp;**上一级和下一级之间敲一个Tab键即可**\n``` markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n## Markdown 表格\n``` markdown\n|表头|表头|表头|\n|---|:--:|---:|\n|内容|内容|内容|\n|内容|内容|内容|\n```\n\n>第二行分割表头和内容\n>-有一个就行，为了对齐，多加了几个\n>文字默认居左\n>-两边加：表示文字居中\n>-右边加：表示文字居右\n\n## Markdown 代码\n### 单行代码\n``` markdown\n`hello world`\n```\n\n### 代码块\n``` markdown\n(```)语言\n  代码内容\n(```)\n```\n\n## Markdown 流程图\n``` markdown\n(```)flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n(```)\n```\n## Markdown 换行\n``` markdown\n连续两个以上空格+回车\n```\n&nbsp;**或者**\n``` markdown\n使用html语言换行标签<br>\n```\n\n## Markdown 缩进字符\n``` markdown\n&nbsp;  缩进1/4中文\n&ensp;  缩进半个中文，一个字符\n&emsp;  缩进一个中文，2个字符\n```","tags":["Markdown"]},{"title":"Hello World","url":"/2024/09/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]