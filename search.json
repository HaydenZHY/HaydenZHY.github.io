[{"title":"《编译原理与技术》结课作业记录","url":"/post/30b6c037.html"},{"title":"利用PyTorch实现基于LSTM+CRF的命名实体识别模型","url":"/post/45705220.html","content":"```python\n%matplotlib inline\n```\n# Making Dynamic Decisions and the Bi-LSTM CRF\n\n## 1. Bi-LSTM Conditional Random Field Discussion\n\n### 1.1 Bi-LSTM-CRF的模型结构\n\n回顾Bilstm-CRF的模型结构：\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/基于LSTM+CRF的命名实体识别/Bilstm-CRF的模型结构.png)\n\nBiLSTM层的输出经过一个线性层为每一个标签的预测分值，然后将BiLSTM的输出值作为CRF层的输入，最后结果就是每个词的标签。\n\n### 1.2 CRF的作用\n\n虽然BiLSTM就可以完成标注工作，但是没有办法添加约束条件，通过CRF层就可以添加标签之间的约束关系。\n\n### 1.3 理解损失函数\n\n回顾CRF计算概率的方式： $y$是标签序列，$x$是一个输入的词序列.\n\n计算：\n\n$$P(y|x) = \\frac{\\exp(\\text{Score}(x, y))}{\\sum_{y'} \\exp(\\text{Score}(x, y'))}$$\n\n这里，我们定义$Score(x,y)$分数为特征函数 $\\log \\psi_i(x,y)$， 有\n\n$$\\text{Score}(x, y) = \\sum_{i} \\log \\psi_i(x, y)$$\n\n便于计算，我们只定义特征函数只有local特征（全局特征就升级为了NP-hard问题，复杂度太高）\n\n在Bi-LSTM CRF的模型中, 我们定义两种特征输入: 发射概率（emission） 和转移概率（transition）。 \n\n每个词$w_i$的发射概率来自于第$i$步的LSTM层的隐状态。\n\n转移概率存储在$|T|x|T|$ 矩阵中 $\\textbf{P}$, 其中$T$是标签集合. \n\n在下面的代码实现中, $\\textbf{P}_{j,k}$ 是从标签 $k$ 转移到标签 $j$ 的概率。\n\n所以，对于输入序列 $x$ 对应的输出序列 $y$，定义分数为：\n\n$$\\begin{align*}\n\\text{Score}(x, y) &= \\sum_{i} \\log \\psi_{\\text{EMIT}}(y_i \\rightarrow x_i) + \\log \\psi_{\\text{TRANS}}(y_{i-1} \\rightarrow y_i) \\\\\n&= \\sum_{i} h_i[y_i] + \\sum_{i=1}^n P_{y_i, y_{i-1}}\n\\end{align*}$$\n\n更详细的关于CRF的公式推导可以参考 [这里](http://www.cs.columbia.edu/%7Emcollins/crf.pdf)\n\n### 1.4 损失函数的计算细节\n\n利用Softmax函数，我们为每一个正确的tag序列定义一个概率值（代表所有的tag序列，包括不可能出现的）\n\n$$p(y|X) = \\frac{e^{S(X, y)}}{\\sum_{\\tilde{y} \\in Y_x} e^{S(X, \\tilde{y})}} $$\n\n因而在训练中，我们只需要最大化似然概率$p(y|X)$即可，这里我们利用对数似然\n\n$$\\begin{align*}\n\\log(p(y|X)) &= \\log\\left(\\frac{e^{S(X, y)}}{\\sum_{\\tilde{y} \\in Y_x} e^{S(X, \\tilde{y})}}\\right) \\\\\n&= S(X, y) - \\log \\sum_{\\tilde{y} \\in Y_x} e^{S(X, \\tilde{y})}\n\\end{align*}$$\n\n所以我们将损失函数定义为$-log(p(y|X))$，就可以利用梯度下降法来进行网络的学习了。\n\n在对损失函数进行计算的时候，$S(X,y)$的计算很简单，而$log(\\sum_{\\tilde y \\in Y_x} e^{S(X,\\tilde y)})$（下面记作logsumexp）的计算稍微复杂一些，因为需要计算每一条可能路径的分数。\n\n这里用一种简便的方法，对于到词$w_i$的所有可能路径的分数的logsumexp（[什么是logsumexp?](https://en.wikipedia.org/wiki/LogSumExp)），可以先把到词$w_{i-1}$的logsumexp计算出来。\n\n这里的推倒我在看了[知乎](https://zhuanlan.zhihu.com/p/27338210)和[csdn](https://blog.csdn.net/cuihuijun1hao/article/details/79405740)这两位博主的解释后，一头雾水，他们的博文里公式实在是写的前后不一致，定义极其模糊，理解全靠意会。我自己又重新推倒了一遍，现在记录下来。\n\n假设输入的序列$x$的长度为$m$，我们知道计算 $S(x,y)$ 分数的时候，是从$i=1$时候开始累加每个$x_i, y_i$对应的分数，即公式(3)。\n\n当$i=n (n<m)$时，有路径的得分分数\n\n$$\\begin{align*}\n\\text{Score}(x[1:n], y) = \\sum_{i=1}^n \\log \\psi_{\\text{EMIT}}(y_i \\rightarrow x_i) + \\log \\psi_{\\text{TRANS}}(y_{i-1} \\rightarrow y_i)\n\\end{align*}$$\n\n当$i=n+1$时，则路径的得分分数为\n\n$$\n\\text{Score}(x[1:n+1], y) = \\text{Score}(x[1:n], y)\n\\begin{align} + \\log \\psi_\\text{EMIT}(y_{n+1} \\rightarrow x_{n+1}) + \\log \\psi_\\text{TRANS}(y_{n} \\rightarrow y_{n+1})\\end{align}\n$$\n\n我们令$i=n+1$时，$y_{n+1}$的得分为K，也就是\n\n$$\nK= \\log \\psi_\\text{EMIT}(y_{n+1} \\rightarrow x_{n+1}) + \\log \\psi_\\text{TRANS}(y_{n} \\rightarrow y_{n+1}) \n$$\n\n我们要计算的$i=n+1$时的loss的第一项为：\n\n$$\\begin{align*}\n\\log \\sum_{\\tilde{y} \\in Y_x} e^{S(X[1:n+1], \\tilde{y})} &= \\log \\sum_{\\tilde{y} \\in Y_x} e^{\\text{Score}(x[1:n], \\tilde{y}) + K} \\\\\n&= \\log \\sum_{\\tilde{y} \\in Y_x} e^{\\text{Score}(x[1:n], \\tilde{y})} \\cdot e^K \\\\\n&= \\log \\sum_{\\tilde{y} \\in Y_x} e^{\\text{Score}(x[1:n], \\tilde{y})} + \\log e^K \\\\\n&= \\log \\sum_{\\tilde{y} \\in Y_x} e^{\\text{Score}(x[1:n], \\tilde{y})} + K\n\\end{align*}$$\n\n因此我们可以得到这样的结论：\n\n> 当$i=n+1$时，序列$x_1,x_2, ..., x_n, x_{n+1}$对应的所有可能的标签路径的分数的\n> logsumexp，等于序列$x_1,x_2, ..., x_n$对应的所有可能的标签路径的分数的\n> logsumexp加上$x_{n+1}, y_{n+1}$的特征分数。\n\n这一步是实现求loss函数的关键。这样的转化操作，可以让我们使用动态规划算法来计算所有可能路径分数的logsumexp。\n\n### 1.5 维特比算法回顾\n\n为了找出S到E之间的最短路径，我们先从S开始从左到右一列一列地来看。\n\n首先起点是S，从S到A列的路径有三种可能：S-A1、S-A2、S-A3，如下图：\n![viterbi_1.jpg](./image/viterbi_1.jpg)\n\n我们不能武断地说S-A1、S-A2、S-A3中的哪一段必定是全局最短路径中的一部分，目前为止任何一段都有可能是全局最短路径的备选项。\n\n我们继续往右看，到了B列。按B列的B1、B2、B3逐个分析。\n\n![](./image/viterbi_2.jpg)\n\n先看B1：\n经过B1的所有路径只有3条：\n - S-A1-B1\n - S-A2-B1\n - S-A3-B1\n \n以上这三条路径，各节点距离加起来对比一下，我们就可以知道其中哪一条是最短的。\n\n假设S-A3-B1是最短的，那么我们就知道了经过B1的所有路径当中S-A3-B1是最短的，我们只保留这一条路径。\n![](./image/viterbi_3.jpg)\n\n接下来，我们继续看B2：\n![](./image/viterbi_4.jpg)\n同理，如上图，经过B2的路径有3条：\n - S-A1-B2\n - S-A2-B2\n - S-A3-B2\n\n这三条路径中，各节点距离加起来对比一下，我们肯定也可以知道其中哪一条是最短的。\n\n假设S-A1-B2是最短的，那么我们就知道了经过B2的所有路径当中S-A1-B2是最短的，我们只保留这一条路径。\n![](./image/viterbi_5.jpg)\n接下来我们继续看B3：\n![](./image/viterbi_6.jpg)\n同理，如上图，经过B3的路径也有3条：\n- S-A1-B3\n- S-A2-B3\n- S-A3-B3\n这三条路径中我们也肯定可以算出其中哪一条是最短的，假设S-A2-B3是最短的，那么我们就知道了经过B3的所有路径当中S-A2-B3是最短的，我们只保留这一条路径。\n![](./image/viterbi_7.jpg)\n\n现在对于B列的所有节点我们都过了一遍，B列的每个节点我们都删除了一些不可能是答案的路径，看看我们把剩下的备选的最短路径汇总，就是这张图。\n![](./image/viterbi_8.jpg)\nS-A3-B1、S-A1-B2、S-A2-B3都有可能是全局的最短路径的备选路径，我们还没有足够的信息判断哪一条一定是全局最短路径的子路径。\n\n所以我们继续往后看C列。\n\n![](./image/viterbi_9.jpg)\n\n和B列的做法一样，我们分别找出C1、C2、C3的最优路径的备选路径并保存下来，最后到E的时候，我们只需要把到达C列的得分和C列分别到E的三条路径相加比较一下，就能得到最优路径了。\n\n![](./image/viterbi_10.jpg)\n\n\n## 2. Implementation Notes\n\nThe example below implements the forward algorithm in log space to compute the partition function, and the viterbi algorithm to decode. Backpropagation will compute the gradients automatically for us. We don't have to do anything by hand.\n\nThe implementation is not optimized. If you understand what is going on, you'll probably quickly see that iterating over the next tag in the forward algorithm could probably be done in one big operation. I wanted to code to be more readable. If you want to make the relevant change,you could probably use this tagger for real tasks.\n\n```python\n# Author: Robert Guthrie\n\nimport torch\nimport torch.autograd as autograd\nimport torch.nn as nn\nimport torch.optim as optim\n\ntorch.manual_seed(1)\n```\n\n    <torch._C.Generator at 0x7fed7f7b88d0>\n\nHelper functions to make the code more readable.\n\n```python\ndef argmax(vec):\n    # return the argmax as a python int\n    _, idx = torch.max(vec, 1)\n    return idx.item()\n\n# 把seq转化为tensor的形式\ndef prepare_sequence(seq, to_ix):\n    # seq是分词后语料，to_ix是语料库每个词对应的编号\n    # step 1: 先转化为id的形式\n    idxs = [to_ix[w] for w in seq]\n    # step2: 再把id转化为tensor\n    return torch.tensor(idxs, dtype=torch.long)\n\n\n# Compute log sum exp in a numerically stable way for the forward algorithm\ndef log_sum_exp(vec):\n    max_score = vec[0, argmax(vec)]\n    max_score_broadcast = max_score.view(1, -1).expand(1, vec.size()[1])\n    return max_score + \\\n        torch.log(torch.sum(torch.exp(vec - max_score_broadcast)))\n```\n\n创建模型\n\nloss函数：\n$$\\begin{align*}\n-\\log(p(y|X)) = \\sum_{\\tilde{y} \\in Y_x} e^{S(X, \\tilde{y})} - S(X, y)\n\\end{align*}$$\n\n其中，`_forward_alg`计算loss的第一项（概率的分母）\n\n`_score_sentence`计算loss的第二项（概率的分子）\n\n```python\nclass BiLSTM_CRF(nn.Module):\n\n    def __init__(self, vocab_size, tag_to_ix, embedding_dim, hidden_dim):\n        '''\n        初始化模型\n        parameters：\n            vocab_size：词的字典的大小\n            tag_to_ix：标签与对应编号的字典\n            embedding_dim：词向量维度\n            hidden_dim：LSTM的个数\n      '''\n        super(BiLSTM_CRF, self).__init__()\n        self.embedding_dim = embedding_dim\n        self.hidden_dim = hidden_dim\n        self.vocab_size = vocab_size\n        self.tag_to_ix = tag_to_ix\n        self.tagset_size = len(tag_to_ix)\n        \n        # 输入层，vocab_size*embedding_dim大小的矩阵\n        self.word_embeds = nn.Embedding(vocab_size, embedding_dim)\n        \n        # LSTM层\n        # input_size：embedding_dim，输入维度\n        # hiden_size: hidden_dim // 2, 每一层lstm有多少个特征抽取器，也就是多少个LSTM单元\n        # num_layers: Number of recurrent layers. \n        #       E.g., setting num_layers=2 would mean stacking two LSTMs together to form a stacked LSTM, \n        #       with the second LSTM taking in outputs of the first LSTM and computing the final results. Default: 1\n        # bidirectional: 是否是双向LSTM\n        self.lstm = nn.LSTM(embedding_dim, hidden_dim // 2,\n                            num_layers=1, bidirectional=True)\n\n        # 将LSTM的输出映射到标签空间，也就是0-1的范围内.\n        self.hidden2tag = nn.Linear(hidden_dim, self.tagset_size)\n\n        # 转移矩阵，Matrix of transition parameters.  Entry i,j is the score of\n        # transitioning  *from* j *to* i\n        self.transitions = nn.Parameter(\n            torch.randn(self.tagset_size, self.tagset_size))\n\n        # 定义强制性约束： \n        # 任何状态都不能转移到开始状态，结束状态不能转移到其它任何状态。\n        self.transitions.data[tag_to_ix[START_TAG], :] = -10000\n        self.transitions.data[:, tag_to_ix[STOP_TAG]] = -10000\n\n        self.hidden = self.init_hidden()\n\n    def init_hidden(self):\n        return (torch.randn(2, 1, self.hidden_dim // 2),\n                torch.randn(2, 1, self.hidden_dim // 2))\n\n    # 计算loss的第一项（分母项），也就是需要计算所有路径的总分数的log\n    def _forward_alg(self, feats):\n        \n        #feats表示发射矩阵(emit score)，实际上就是LSTM的输出，意思是经过LSTM的sentence的每个word对应于每个label的得分\n        \n        # Do the forward algorithm to compute the partition function（）\n        \n        # 用-10000.来填充一个形状为[1,tagset_size]的tensor\n        init_alphas = torch.full((1, self.tagset_size), -10000.)\n        \n        # 因为start tag是4，所以tensor([[-10000., -10000., -10000., 0., -10000.]])，\n        # 将start的值设零，表示开始进行网络的传播，\n        # START_TAG has all of the score.\n        init_alphas[0][self.tag_to_ix[START_TAG]] = 0.\n\n        # Wrap in a variable so that we will get automatic backprop\n        forward_var = init_alphas  # 初始状态的forward_var，随着step t变化\n\n        # Iterate through the sentence\n        for feat in feats:\n            alphas_t = []  # The forward tensors at this timestep\n            for next_tag in range(self.tagset_size):\n                # broadcast the emission score: it is the same regardless of\n                # the previous tag\n                # LSTM的生成矩阵是emit_score，维度为1*5\n                emit_score = feat[next_tag].view(\n                    1, -1).expand(1, self.tagset_size)\n                # the ith entry of trans_score is the score of transitioning to\n                # next_tag from i\n                trans_score = self.transitions[next_tag].view(1, -1)\n                # The ith entry of next_tag_var is the value for the\n                # edge (i -> next_tag) before we do log-sum-exp\n                \n                # 对于到词$w_i$的路径，以先把到词$w_{i-1}$的logsumexp计算出来，再加上当前tag产生的分数\n                next_tag_var = forward_var + trans_score + emit_score\n                alphas_t.append(log_sum_exp(next_tag_var).view(1))\n            \n            forward_var = torch.cat(alphas_t).view(1, -1)\n            \n        # 最后还需要加上最后一个词转移到结束位置的概率\n        terminal_var = forward_var + self.transitions[self.tag_to_ix[STOP_TAG]]\n        alpha = log_sum_exp(terminal_var)\n        return alpha\n\n    # 计算 LSTM 发射概率\n    def _get_lstm_features(self, sentence):\n        self.hidden = self.init_hidden()\n        embeds = self.word_embeds(sentence).view(len(sentence), 1, -1)\n        lstm_out, self.hidden = self.lstm(embeds, self.hidden)\n        lstm_out = lstm_out.view(len(sentence), self.hidden_dim)\n        lstm_feats = self.hidden2tag(lstm_out)\n        return lstm_feats\n\n    # 计算一条路径对应的分数，也就是loss的第二项\n    def _score_sentence(self, feats, tags):\n        # Gives the score of a provided tag sequence\n        score = torch.zeros(1)\n        \n        # 将START_TAG的id拼接到tag序列最前面\n        tags = torch.cat([torch.tensor([self.tag_to_ix[START_TAG]], dtype=torch.long), tags])\n        for i, feat in enumerate(feats):\n            # self.transitions[tags[i + 1], tags[i]] 实际得到的是从标签i到标签i+1的转移概率\n            # feat[tags[i+1]], feat是step i 的输出结果，有5个值，\n            # 对应B, I, E, START_TAG, END_TAG, 取对应标签的值\n            # transition【j,i】 就是从i ->j 的转移概率值\n            score = score + \\\n                self.transitions[tags[i + 1], tags[i]] + feat[tags[i + 1]]\n            \n        # 分数最后还要加上最后一个词转移到STOP_TAG的转移概率\n        score = score + self.transitions[self.tag_to_ix[STOP_TAG], tags[-1]]\n        return score\n\n    def _viterbi_decode(self, feats):\n        # 预测序列的得分，维特比解码，输出得分与路径值\n        backpointers = []\n\n        # Initialize the viterbi variables in log space\n        init_vvars = torch.full((1, self.tagset_size), -10000.) # 保证了一定是从START到其他标签\n        init_vvars[0][self.tag_to_ix[START_TAG]] = 0\n\n        # forward_var at step i holds the viterbi variables for step i-1\n        forward_var = init_vvars\n        for feat in feats:\n            bptrs_t = []  # holds the backpointers for this step\n            viterbivars_t = []  # holds the viterbi variables for this step\n\n            for next_tag in range(self.tagset_size):\n                # next_tag_var[i] holds the viterbi variable for tag i at the\n                # previous step, plus the score of transitioning\n                # from tag i to next_tag.\n                # We don't include the emission scores here because the max\n                # does not depend on them (we add them in below)\n                next_tag_var = forward_var + self.transitions[next_tag]  #forward_var保存的是之前的最优路径的值\n                best_tag_id = argmax(next_tag_var) #返回最大值对应的那个tag的id\n                bptrs_t.append(best_tag_id)\n                viterbivars_t.append(next_tag_var[0][best_tag_id].view(1))\n            # Now add in the emission scores, and assign forward_var to the set\n            # of viterbi variables we just computed\n            forward_var = (torch.cat(viterbivars_t) + feat).view(1, -1)\n            backpointers.append(bptrs_t)\n\n        # Transition to STOP_TAG\n        terminal_var = forward_var + self.transitions[self.tag_to_ix[STOP_TAG]]\n        best_tag_id = argmax(terminal_var)\n        path_score = terminal_var[0][best_tag_id]\n\n        # Follow the back pointers to decode the best path.\n        # 从最后一步的best_path的选择，根据backpointers倒推整个的best_path\n        best_path = [best_tag_id]\n        for bptrs_t in reversed(backpointers):\n            best_tag_id = bptrs_t[best_tag_id]\n            best_path.append(best_tag_id)\n        # Pop off the start tag (we dont want to return that to the caller)\n        start = best_path.pop()\n        assert start == self.tag_to_ix[START_TAG]  # Sanity check\n        best_path.reverse()\n        return path_score, best_path\n\n    # 计算loss，训练时候用\n    def neg_log_likelihood(self, sentence, tags):\n        feats = self._get_lstm_features(sentence)\n        forward_score = self._forward_alg(feats)\n        gold_score = self._score_sentence(feats, tags)\n        return forward_score - gold_score\n\n    # 计算一个句子的分数和最优的标注序列，预测时候用\n    def forward(self, sentence):  # dont confuse this with _forward_alg above.\n        # Get the emission scores from the BiLSTM\n        lstm_feats = self._get_lstm_features(sentence)\n\n        # Find the best path, given the features.\n        score, tag_seq = self._viterbi_decode(lstm_feats)\n        return score, tag_seq\n```\n\nRun training\n\n```python\nSTART_TAG = \"<START>\"\nSTOP_TAG = \"<STOP>\"\nEMBEDDING_DIM = 5 \nHIDDEN_DIM = 4 # 这其实是BiLSTM的隐藏层的特征数量，因为是双向所以是2倍，单向为2\n\n# Make up some training data\ntraining_data = [(\n    \"the wall street journal reported today that apple corporation made money\".split(),\n    \"B I I I O O O B I O O\".split()\n), (\n    \"georgia tech is a university in georgia\".split(),\n    \"B I O O O O B\".split()\n)]\n\n# 构造训练数据中的word_to_ix的映射关系，给每一个词对应一个唯一的编码\n# 比如‘HELLO WORLD’就是{'HELLO':0,'WORLD:1'}\nword_to_ix = {}\nfor sentence, tags in training_data:\n    for word in sentence:\n        if word not in word_to_ix:\n            word_to_ix[word] = len(word_to_ix)\n\n    \n# 构造tag_to_ix词典，每一个tag有一个唯一的编码\ntag_to_ix = {\"B\": 0, \"I\": 1, \"O\": 2, START_TAG: 3, STOP_TAG: 4}\n\n# 模型\nmodel = BiLSTM_CRF(len(word_to_ix), tag_to_ix, EMBEDDING_DIM, HIDDEN_DIM)\n# 优化器\noptimizer = optim.SGD(model.parameters(), lr=0.01, weight_decay=1e-4)\n\n# Check predictions before training\nwith torch.no_grad():\n    precheck_sent = prepare_sequence(training_data[0][0], word_to_ix)\n    precheck_tags = torch.tensor([tag_to_ix[t] for t in training_data[0][1]], dtype=torch.long)\n    print(model(precheck_sent))\n\n# Make sure prepare_sequence from earlier in the LSTM section is loaded\nfor epoch in range(\n        300):  # again, normally you would NOT do 300 epochs, it is toy data\n    for sentence, tags in training_data:\n        # Step 1. 一定要记住Pytorch会累积梯度\n        # 所以我们在每个样本训练之前需要清除梯度\n        model.zero_grad()\n\n        # Step 2. 准备模型的输入，把输入的样本数据转化为模型需要的格式\n        # 把输入的词序列和标签转化为id，再把id转化为Tensor\n        sentence_in = prepare_sequence(sentence, word_to_ix)\n        targets = torch.tensor([tag_to_ix[t] for t in tags], dtype=torch.long)\n\n        # Step 3. 让模型前向传播计算Loss\n        loss = model.neg_log_likelihood(sentence_in, targets)\n\n        # Step 4. 反向传播计算梯度，用optimizer.step()来更新参数\n        loss.backward()\n        optimizer.step()\n\n# Check predictions after training\nwith torch.no_grad():\n    precheck_sent = prepare_sequence(training_data[0][0], word_to_ix)\n    print(model(precheck_sent))\n# We got it!\n```\n\n    (tensor(2.6907), [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1])\n    (tensor(20.4906), [0, 1, 1, 1, 2, 2, 2, 0, 1, 2, 2])\n","tags":["PyTorch","LSTM","BiLSTM","CRF","NER"]},{"title":"《智能搜索与问答》实验记录","url":"/post/4311997a.html","content":"一、基于LSTM+CRF的命名实体识别\n原理分析见：[LSTM+CRF的命名实体识别](https://haydenzhy.github.io/post/45705220)\n<embed src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/NER_LSTM_CRF/利用PyTorch实现基于LSTM+CRF的命名实体识别模型.pdf\" width=\"100%\" height=\"700px\" type=\"application/pdf\">\n二、基于Word2Vec_Skip-Gram的文本相似度计算\n<embed src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/Word2Vec_Skip-Gram/利用PyTorch实现基于Word2Vec_Skip-Gram的文本相似度计算.pdf\" width=\"100%\" height=\"700px\" type=\"application/pdf\">","tags":["实验","LSTM","BiLSTM","CRF","BiLSTM_CRF","NER","Word2Vec","Skip-Gram"],"categories":["人工智能","自然语言处理"]},{"title":"《计算机视觉技术》实验记录","url":"/post/d1bf3f24.html","content":"## 一、手写数字识别\n\n【题目】：使用Python实现手写数字识别模型\n\n【使用数据集】：MNIST数据集，下载地址https://www.kaggle.com/datasets/hojjatk/mnist-dataset?resource=download\n\n【完成步骤】：\n1. 安装Linux操作系统（版本自定，推荐 Fedora Core 系列最新版，或 Ubuntu 最新版） \n2. 安装Python环境，推荐Python3.X，安装适用的IDE，推荐 VS Code。 \n3. 下载 MNIST数据集，并读懂数据集的相关说明，了解数据格式。 \n4. 对MNIST进行数据预处理，根据给出的preprocess.py将.idx3-ubyte文件类型转换成.csv文件类型。\n5. 以给出的代码框架为基础，编程实现其中的forward和backward函数；对MNIST数据集进行训练，并验证模型的效能。\n\n【作业要求】：\n1. 严禁抄袭，一旦发现抄袭（包括抄袭人与被抄袭人）则本次作业 0 分； \n2. 严禁使用现成的pytorch模型包，即要求自己动手实现模型，可以使用其它必须的第三方库。\n3. 提交作业电子版至智慧树，邮件标题以“计算机视觉第一次大作业+姓名+学号”命名，截止时间为2025年3月20日23:59。\n4. 作业接受补交，迟交一天扣10%分数，分数扣完为止。\n\n【实验代码】：\n1.preprocess.py\n```python\ndef convert(imgf, labelf, outf, n):\n    f = open(imgf, \"rb\")\n    o = open(outf, \"w\")\n    l = open(labelf, \"rb\")\n\n    f.read(16)\n    l.read(8)\n    images = []\n\n    for i in range(n):\n        image = [ord(l.read(1))]\n        for j in range(28*28):\n            image.append(ord(f.read(1)))\n        images.append(image)\n\n    for image in images:\n        o.write(\",\".join(str(pix) for pix in image)+\"\\n\")\n    f.close()\n    o.close()\n    l.close()\n\nconvert(\"train-images.idx3-ubyte\", \"train-labels.idx1-ubyte\",\n        \"mnist_train.csv\", 60000)\nconvert(\"t10k-images.idx3-ubyte\", \"t10k-labels.idx1-ubyte\",\n        \"mnist_test.csv\", 10000)\n```\n2.train_homework.py\n```python\n# code for a 3-layer neural network,and code for learning the MNIST daeaset\n# 一个用于MNIST数字识别的三层神经网络程序（输入层，隐藏层，输出层）\n\nfrom turtle import forward\nimport numpy as np  # 用于进行数组和矩阵的运算操作\nimport scipy.special as ssp  # 里面有激活函数sigmoid函数，可以直接调用\n# import pyplot as plt\n# from matplotlib import pyplot as plt\nimport matplotlib\nimport matplotlib.pyplot as plt  # 用于进行数字矩阵的图像输出，该函数库时进行图像处理常用到的函数库\n# %matplotlib inline\n\n# neural network class definition\n# 制作一个神经网络算法的类，其名为神经网络，相当于函数库，直接进行调用里面的函数即可。\nclass neuralNetwork:\n    # initialise the neural network\n    # 对神经网络的参数进行初始化\n    def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate): # 用于类的初始值的设定\n        # set number of nodes in each input, hidden, output layer\n        # 设置节输入层、隐藏层、输出层的节点数  （self表示类所自带的不能改变的内容）\n        self.inodes = inputnodes # 输入层节点数\n        self.hnodes = hiddennodes # 隐藏层节点数\n        self.onodes = outputnodes # 输出层节点数\n        \n        # link weight matrices, wih and who\n        # 设置输入层与隐藏层直接的权重关系矩阵以及隐藏层与输出层之间的权重关系矩阵\n        # （一开始随机生成权重矩阵的数值，利用正态分布，均值为0，方差为隐藏层节点数的-0.5次方，）\n        self.wih = np.random.normal(0.0, pow(self.hnodes, -0.5), (self.hnodes, self.inodes)) #矩阵大小为隐藏层节点数×输入层节点数\n        self.who = np.random.normal(0.0, pow(self.hnodes, -0.5), (self.onodes, self.hnodes)) #矩阵大小为输出层节点数×隐藏层节点数\n        \n        # learning rate\n        # 设置学习率α\n        self.lr = learningrate\n        \n        # activation function is the sigmoid function\n        # 将激活函数sigmoid定义为self.activation_function\n        self.activation_function = lambda x: ssp.expit(x) \n        # lambda x:表示快速生成函数f(x) 并将其命名为self.activation_function\n        \n        pass\n    \n    def forward(self, inputs):\n        # 计算输入层到隐藏层的信号\n        hidden_inputs = np.dot(self.wih, inputs)\n        hidden_outputs = self.activation_function(hidden_inputs)\n        # 计算隐藏层到输出层的信号\n        final_inputs = np.dot(self.who, hidden_outputs)\n        final_outputs = self.activation_function(final_inputs)\n        return hidden_outputs, final_outputs\n\n    def backward(self, inputs, targets, hidden_outputs, final_outputs):\n        # 计算输出层的误差信号：目标值减去实际输出\n        output_errors = targets - final_outputs\n        # 隐藏层误差：由输出层误差反推得到\n        hidden_errors = np.dot(self.who.T, output_errors)\n        # 更新隐藏层到输出层的权重\n        self.who += self.lr * np.dot((output_errors * final_outputs * (1.0 - final_outputs)), hidden_outputs.T)\n        # 更新输入层到隐藏层的权重\n        self.wih += self.lr * np.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)), inputs.T)\n        \n    # train the neural network\n    # 训练数据集所要用到的函数定义为：train()\n    def train(self, inputs_list, targets_list):\n        # convert inputs list to 2d array\n        # 将导入的输入列表数据和正确的输出结果转换成二维矩阵\n        inputs = np.array(inputs_list, ndmin = 2).T # array函数是矩阵生成函数，将输入的inputs_list转换成二维矩阵，ndmin=2表示二维矩阵\n        targets = np.array(targets_list, ndmin = 2).T # .T表示矩阵的转置，生成后的矩阵的转置矩阵送入变量targets\n        hidden_outputs, final_outputs = self.forward(inputs)\n        self.backward(inputs, targets, hidden_outputs, final_outputs)\n       \n        pass\n    \n    # query the nerual network\n    # 查询函数，用于在训练算法完成训练之后检验训练所得的权重矩阵是否准确\n    def query(self, inputs_list):\n        # convert inputs lst to 2d array\n        # 将输入的测试集数据转换成二维矩阵\n        inputs = np.array(inputs_list, ndmin = 2).T\n\n        # 以下程序为计算输出结果的程序，与上面前向传播算法一致（到 return final_outputs结束）\n        # calculate signals into hidden layer\n        hidden_inputs = np.dot(self.wih, inputs)\n        # calculate the signals emerging from hidden layer\n        hidden_outputs = self.activation_function(hidden_inputs)\n\n        # calculate signal into final output layer\n        final_inputs = np.dot(self.who, hidden_outputs)\n        # calculate the signals emerging from final output layer\n        final_outputs = self.activation_function(final_inputs)\n\n        return final_outputs\n# 神经网络算法的类定义完毕\n\n# number of input, hidden and output nodes\n# 设置输入节点数、隐藏层节点数、输出节点数\ninput_nodes = 784 # 因为有784个像素值（28×28），所以相当于输入有784个\nhidden_nodes = 200  # 隐藏层节点数设置为200，可以随意设置，理论上节点数越多，得到的算法准确率越高\n# 实际上达到一定值后将会基本不变，而且节点数越多，训练算法所需花费时间越长，因此节点数不宜设置的过多\noutput_nodes = 10 # 因为从0到9一共十个数，所以输出节点数为10\n\n# learning rate\nlearning_rate = 0.1 # 学习率设置为0.1，可以随意设置，但是经过测试，当为0.1时，得到的算法准确率最高\n\n# create instance of neural network\n# 建立神经网络的类，取名为\"n\"，方便后面使用\nn = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)\n\n\n# load the mnist training data CSV file into a list\n# 将mnist_train.csv文件导入\ntraining_data_file = open(\"mnist_train.csv\", 'r') # ‘r’表示只读\ntraining_data_list = training_data_file.readlines()\ntraining_data_file.close()\n\n# train the neural network\n# 利用导入的数据训练神经网络算法\n\nepochs = 5\n# epochs为世代，让算法循环5次\n\nfor e in range(epochs):\n    # go through all records in the training data set\n    # 遍历所有输入的数据\n    for record in training_data_list:\n        # split the record by the ',' commas\n        # 将所有数据通过逗号分隔开\n        all_values = record.split(',')\n        # scale and shift the inputs\n        # 对输入的数据进行处理，取后784个数据除以255，再乘以0.99，最后加上0。01，是所有的数据都在0.01到1.00之间\n        inputs = (np.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01\n        # create the target output values (all 0.01, except the desired label which is 0.99)\n        # 建立准确输出结果矩阵，对应的位置标签数值为0.99，其他位置为0.01\n        targets = np.zeros(output_nodes) + 0.01\n        # all_values[0] is the target label for this record\n        targets[int(all_values[0])] = 0.99\n        n.train(inputs, targets) # 利用训练函数训练神经网络\n        pass\n    \n    pass\n\n# load the mnist test data CSV file into a list\n# 导入测试集数据\ntest_data_file = open(\"mnist_test.csv\", 'r')\ntest_data_list = test_data_file.readlines()\ntest_data_file.close()\n\n# test the neural network\n# 用query函数对测试集进行检测\n# go through all the records in the test data set for record in the test_data_list:\nscorecard = 0 # 得分卡，检测对一个加一分\n\nfor record in test_data_list:\n    # split the record by the ',' comas\n    # 将所有测试数据通过逗号分隔开\n    all_values = record.split(',')\n    # correct answer is first value\n    # 正确值为每一条测试数据的第一个数值\n    correct_lebal = int(all_values[0])\n    print(\"correct lebal\", correct_lebal) # 将正确的数值在屏幕上打印出来\n    # scale and shift the inputs\n    # 对输入数据进行处理，取后784个数据除以255，再乘以0.99，最后加上0。01，是所有的数据都在0.01到1.00之间\n    inputs = (np.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01\n    # query the network\n    # 用query函数对测试集进行检测\n    outputs = n.query(inputs)\n    # the index of the highest value corresponds to out label\n    # 得到的数字就是输出结果的最大的数值所对应的标签\n    lebal = np.argmax(outputs) # argmax()函数用于找出数值最大的值所对应的标签\n    print(\"Output is \", lebal) # 在屏幕上打出最终输出的结果\n    \n    # output image of every digit\n    # 输出每一个数字的图片\n    image_correct = np.asfarray(all_values[1:]).reshape((28, 28))\n    plt.imshow(image_correct, cmap = 'Greys', interpolation = 'None')\n    plt.show()\n    # append correct or incorrect to list\n    if (lebal == correct_lebal):\n        # network's answer matchs correct answer, add 1 to scorecard\n        scorecard += 1\n    else:\n        # network's answer doesn't match correct answer, add 0 to scorecard\n        scorecard += 0\n        pass\n    pass\n\n# calculate the performance score, the fraction\n# 计算准确率 得分卡最后的数值/10000（测试集总个数）\nprint(\"performance = \", scorecard / 10000)\n```\n\n## 二、语义分割\n\n【题目】：使用Python实现语义分割模型\n\n【使用数据集】：PASCAL VOC 2012数据集，下载地址http://host.robots.ox.ac.uk/pascal/VOC/voc2012/\n\n【完成步骤】： \n1. 安装Python3环境，安装anaconda并建立虚拟环境，在虚拟环境内安装cuda与pytorch，安装适用的 IDE，推荐VS Code。\n2. 下载PASCAL VOC 2012数据集，并读懂数据集的相关说明，了解数据格式。在train集合上训练分割模型，在val集合上测试分割模型。\n3. 对PASCAL VOC 2012进行数据预处理。\n4. 以给出的代码框架为基础，实现分割网络，并且应用合理的损失函数；对PASCAL VOC 2012数据集进行训练，并利用mIoU、Dice、HD、Accuracy、Recall、F1 score指标验证分割模型性能。\n5. 对模型分割结果可视化，分析实验结果。\n\n【作业要求】：\n1. 严禁任何形式的抄袭行为，一经发现，抄袭者与被抄袭者的本次作业成绩均计为0分；\n2. 提交作业电子版至智慧树，邮件标题以“计算机视觉第二次大作业+姓名+学号”命名，截止时间为2025年3月30日23:59。\n3. 作业接受补交，迟交一天扣10%分数，分数扣完为止。\n\n【实验报告】：\n<embed src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@master/pdf/FCN/基于PyTorch的FCN语义分割网络构建与性能分析.pdf\" width=\"100%\" height=\"700px\" type=\"application/pdf\">","tags":["实验","计算机视觉技术"],"categories":["人工智能","计算机视觉技术"]},{"title":"从零构建大模型","url":"/post/3e062841.html","content":"[项目地址](https://github.com/MLNLP-World/LLMs-from-scratch-CN?tab=readme-ov-file)：https://github.com/rasbt/LLMs-from-scratch\n\n[项目中文地址](https://github.com/MLNLP-World/LLMs-from-scratch-CN?tab=readme-ov-file)：https://github.com/MLNLP-World/LLMs-from-scratch-CN?tab=readme-ov-file","tags":["LLM","Transformer","NLP"],"categories":["人工智能","机器学习","自然语言处理"]},{"title":"Windows---CMD常用指令","url":"/post/289f3202.html","content":"以下是一些常用的Windows命令提示符（cmd）命令：\n\n1. **dir**  \n   列出当前目录下的文件和文件夹。\n\n2. **cd**  \n   切换目录。  \n   - `cd ..` 返回上一级目录。  \n   - `cd \\` 返回根目录。  \n   - `cd 文件夹名` 进入指定文件夹。\n\n3. **mkdir** 或 **md**  \n   创建新目录。  \n   - `mkdir 文件夹名`\n\n4. **rmdir** 或 **rd**  \n   删除目录。  \n   - `rmdir 文件夹名`\n\n5. **del**  \n   删除文件。  \n   - `del 文件名`\n\n6. **copy**  \n   复制文件。  \n   - `copy 源文件 目标文件`\n\n7. **move**  \n   移动文件或重命名文件。  \n   - `move 源文件 目标文件`\n\n8. **ren**  \n   重命名文件或文件夹。  \n   - `ren 旧名称 新名称`\n\n9. **type**  \n   显示文本文件内容。  \n   - `type 文件名`\n\n10. **echo**  \n    显示消息或打开/关闭回显功能。  \n    - `echo 消息`  \n    - `echo on` 或 `echo off`\n\n11. **cls**  \n    清屏。\n\n12. **ipconfig**  \n    显示网络配置信息。  \n    - `ipconfig /all` 显示详细信息。\n\n13. **ping**  \n    测试网络连接。  \n    - `ping 目标地址`\n\n14. **tracert**  \n    跟踪数据包的路由路径。  \n    - `tracert 目标地址`\n\n15. **netstat**  \n    显示网络连接、路由表、接口统计信息等。  \n    - `netstat -a` 显示所有连接和监听端口。\n\n16. **tasklist**  \n    显示当前运行的进程。  \n    - `tasklist`\n\n17. **taskkill**  \n    终止进程。  \n    - `taskkill /PID 进程ID`  \n    - `taskkill /IM 进程名`\n\n18. **shutdown**  \n    关机或重启计算机。  \n    - `shutdown /s` 关机  \n    - `shutdown /r` 重启  \n    - `shutdown /l` 注销  \n    - `shutdown /h` 休眠\n\n19. **systeminfo**  \n    显示系统详细信息。\n\n20. **chkdsk**  \n    检查磁盘并显示状态报告。  \n    - `chkdsk /f` 修复磁盘错误。\n\n21. **sfc /scannow**  \n    扫描并修复系统文件。\n\n22. **attrib**  \n    显示或更改文件属性。  \n    - `attrib +r 文件名` 设置只读属性  \n    - `attrib -r 文件名` 取消只读属性\n\n23. **find**  \n    在文件中搜索字符串。  \n    - `find \"字符串\" 文件名`\n\n24. **tree**  \n    以树状图显示目录结构。\n\n25. **help**  \n    显示命令的帮助信息。  \n    - `help 命令名`\n\n这些命令可以帮助你在Windows命令行中执行各种任务。","tags":["Windows","CMD"]},{"title":"配置 Git 使用 Clash 代理","url":"/post/8c98b106.html","content":"\n## 一、前提条件\n- **Clash 已安装并运行**：确保 Clash 正在运行，并且加载了正确的配置文件。\n- **代理端口**：Clash 的 `mixed-port` 设置为 `7890`（默认 HTTP 和 SOCKS5 代理端口）。\n- **Git 已安装**：确保你已安装 Git，并且可以通过命令行运行 `git --version` 验证。\n\n---\n\n## 二、步骤\n\n### 1. 确认 Clash 代理状态\n- 启动 Clash（例如 Clash for Windows）。\n- 检查配置文件（通常是 `config.yaml`），确认以下内容：\n  ```\n  mixed-port: 7890\n  ```\n- 确保 Clash 已运行，并且代理服务监听在 `127.0.0.1:7890`。可以用以下命令检查：\n  ```\n  netstat -ano | findstr 7890\n  ```\n  如果返回类似 `TCP 127.0.0.1:7890 0.0.0.0:0 LISTENING`，说明端口正常开放。\n\n### 2. 配置 Git 使用 Clash 代理\n- 打开命令行（CMD 或 Git Bash）。\n- 设置 Git 的全局代理，使用 HTTP 协议（因为 Clash 的 `mixed-port` 支持 HTTP）：\n  ```\n  git config --global http.proxy http://127.0.0.1:7890\n  git config --global https.proxy http://127.0.0.1:7890\n  ```\n- **解释**：\n  - `http.proxy`：设置 HTTP 协议的代理。\n  - `https.proxy`：设置 HTTPS 协议的代理（GitHub 使用 HTTPS）。\n  - `127.0.0.1:7890`：Clash 的本地代理地址和端口。\n\n### 3. 验证代理配置\n- 检查 Git 是否正确应用了代理设置：\n  ```\n  git config --global --get http.proxy\n  git config --global --get https.proxy\n  ```\n- 如果返回 `http://127.0.0.1:7890`，说明配置成功。\n\n### 4. 测试代理连接\n- 测试 Git 是否能通过代理访问 GitHub：\n  ```\n  git ls-remote https://github.com/{User}/{RepositoryName}.git\n  ```\n- **成功输出示例**：\n  ```\n  00c87001b3c99bec7a6f1ef4b342c9a4f3d668d7        HEAD\n  00c87001b3c99bec7a6f1ef4b342c9a4f3d668d7        refs/heads/main\n  ...\n  ```\n- 如果失败（例如超时或连接错误），检查 Clash 是否运行，或者端口是否正确。\n\n### 5. 使用 Git 操作\n- 配置成功后，可以正常使用 Git 命令，例如克隆仓库：\n  ```\n  git clone https://github.com/{User}/{RepositoryName}.git\n  ```\n- 或者拉取更新：\n  ```\n  git pull\n  ```\n\n---\n\n## 三、常见问题及解决方法\n\n1. **错误：无法连接到 127.0.0.1:7890**\n   - **原因**：Clash 未运行，或端口未监听。\n   - **解决**：\n     - 启动 Clash，确保配置文件中的 `mixed-port` 是 `7890`。\n     - 检查端口：`netstat -ano | findstr 7890`。\n     - 如果端口被占用，修改 Clash 配置中的 `mixed-port`（例如改为 7891），然后更新 Git 配置：\n       ```\n       git config --global http.proxy http://127.0.0.1:7891\n       git config --global https.proxy http://127.0.0.1:7891\n       ```\n\n2. **Clash 运行正常，但 Git 仍无法连接**\n   - **原因**：Clash 的代理规则可能将 GitHub 设为直连（DIRECT）。\n   - **解决**：\n     - 编辑 Clash 配置文件，添加规则：\n       ```\n       - DOMAIN-SUFFIX,github.com,PROXY\n       ```\n     - 保存并重启 Clash。\n\n3. **不需要代理时如何取消**\n   - 清除代理设置：\n     ```\n     git config --global --unset http.proxy\n     git config --global --unset https.proxy\n     ```\n\n---\n\n## 四、可选：使用环境变量（临时配置）\n如果你不想修改全局配置，可以在当前命令行会话中设置环境变量：\n- CMD：\n  ```\n  set HTTP_PROXY=http://127.0.0.1:7890\n  set HTTPS_PROXY=http://127.0.0.1:7890\n  git clone https://github.com/{User}/{RepositoryName}.git\n  ```\n- Git Bash：\n  ```\n  export HTTP_PROXY=http://127.0.0.1:7890\n  export HTTPS_PROXY=http://127.0.0.1:7890\n  git clone https://github.com/{User}/{RepositoryName}.git\n  ```\n这种方式只在当前会话有效，关闭窗口后失效。\n\n---\n\n## 五、总结\n通过以上步骤，你应该能成功配置 Git 使用 Clash 代理。如果你的 Clash 端口不是 7890，只需将教程中的端口号替换为实际值即可。配置完成后，Git 将通过 Clash 访问远程仓库（如 GitHub），非常适合需要代理的网络环境。","tags":["教程","Git","Clash"]},{"title":"Anaconda新手安装和环境配置","url":"/post/2161ae63.html","content":"## 一、Anaconda 简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🥰Anaconda 是一个开源的 Python 和 R 语言的发行版本，主要用于数据科学、机器学习和科学计算。它包含了大量的科学计算库和工具，并且提供了一个方便的环境管理工具，使得用户可以**轻松地创建、管理和切换不同的 Python 环境。**（我使用的原因是可以方便地切换python环境，每个环境包与包的版本不冲突，以及可以很方便的导入与导出包，用anaconda比较方便）\n\n### Anaconda 的主要特点\n\n1. **包管理**：\n\n   * Anaconda 使用 `conda` 作为包管理工具，可以方便地安装、更新和删除 Python 包。\n\n   * 支持多种操作系统和平台（Windows、macOS、Linux）。\n\n2. **环境管理**：\n\n   * Anaconda 允许用户创建独立的 Python 环境，每个环境可以有不同的 Python 版本和包依赖。\n\n   * 使用\n     ```bash\n     conda env\n     ```\n     命令可以轻松创建、激活、删除和管理环境。\n\n3. **集成开发环境（IDE）**：\n\n   * Anaconda 提供了 Jupyter Notebook 和 JupyterLab，这些工具非常适合数据分析和可视化。\n\n   * 还集成了 Spyder，一个专门为科学计算设计的 IDE。\n\n4. **预装包**：\n\n   * Anaconda 发行版预装了大量的科学计算库，如 NumPy、Pandas、Matplotlib、SciPy、Scikit-learn 等。\n\n   * 还包括一些常用的数据科学工具，如 TensorFlow、PyTorch 等。\n\n5. **社区支持**：\n\n   * Anaconda 有一个活跃的社区，用户可以在社区中获取帮助、分享经验和学习资源。\n\n***\n\n## 二、Anaconda 的下载\n\n**下载方式**有两种：\n\n### 1. 在Anaconda的官网上进行安装（国内网络的问题，下载速度很慢，不推荐）\n\n[Anaconda官网](https://www.anaconda.com/download/success \"Anaconda官网\")\nAnaconda可以在Windows、MacOS、Linux系统平台中安装和使用，下载的时候找到对应的点击即可。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-1.png)\n\n**<p align=\"center\">选择对应的系统下载</p>**\n\n### 2. 使用清华镜像源下载（下载速度快，推荐）\n\n[Anaconda清华镜像源下载](https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M\\&O=D \"Anaconda清华镜像源下载\")\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-2.png)\n\n**<p align=\"center\">选择对应的系统和版本进行下载</p>**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的电脑是windows系统，我这里选择下载最新版本的Anaconda3-2024.10-1-Windows-x86\\_64.exe 下载完成我们就可以得到一个exe文件。\n\n## 三、Anaconda 的安装\n\n下载完成后，只需要一步一步按照提示安装即可，以下说明安装过程中需要特别**注意的步骤**。\n\n**Step1: 直接点击【Next】。**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-3.png\" width=\"70%\" />\n\n**Step2: 点击【I Agree】。**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-4.png\" width=\"70%\" />\n\n**Step3: 选择【ALL users】（选择仅个人的话，后面使用可能会报错），然后点击【Next】。**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-5.png\" width=\"70%\" />\n\n**Step4: 选择 Anaconda 的安装位置。**\n> **🔔Tips：这里建议修改为其他盘,要不然下载的包和创建的环境都在C盘，占用空间，我这里修为为D盘（专门安装软件的盘），后面介绍如何把创建的环境和下载的包都装在自己想装的盘里。**\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-6.png\" width=\"70%\" />\n\n**Step5: 这里把三个勾全部打上，然后点击【Install】,Anaconda开始安装。**\n> * 🔒创建开始菜单\n> * 🔒base环境以python3.12创建\n> * 🔒清除包缓存\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-7.png\" width=\"70%\" />\n\n**Step6: 安装进行中，等待即可，这一步取决于电脑的性能。**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-8.png\" width=\"70%\" />\n\n**Step7: 点击【Next】——再次点击【Next】。**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-9.png\" width=\"70%\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-10.png\" width=\"70%\" />\n\n**Step8: 接着来到最后一步，两个勾取消，不要框选。点击【Finish】。**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-11.png\" width=\"70%\" />\n\n> **📍到这里anaconda的安装基本完成，接下来要对anaconda进行一些配置。**\n\n## 四、Anaconda 的基本配置\n\n### 环境变量的配置\n\n> 电脑设置搜索栏搜索“高级系统设置”，点击打开。\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-12.png\" width=\"70%\" />\n\n> 选择环境变量。\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-13.png\" width=\"55%\" />\n\n> 系统变量选择 path，双击进入。\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-14.png\" width=\"65%\" />\n\n> 新建环境变量 **【根据自己安装的盘，选择对应的盘】**。\n> D:\\Software\\anaconda3\\\n> D:\\Software\\anaconda3\\Scripts\\\n> D:\\Software\\anaconda3\\Library\\bin\\\n> D:\\Software\\anaconda3\\Library\\mingw-w64\\bin\n\n> 在windows菜单栏搜索 Anaconda,打开 Anaconda Prompt。\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-16.png\" width=\"70%\" />\n\n输入这行代码，查看版本号，检查是否成功安装。\n\n```\nconda --version\n```\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-17.png\" width=\"70%\" />\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;成功安装会显示Anaconda的版本号，这里anaconda就安装完成了，但是并没有结束，因为还涉及到环境和包的下载，这里默认是下载在C盘的，我们需要更改下载的位置，以免占C盘系统盘内存；最后再添加镜像源方便下载环境的包（网速更快）。\n\n## 五、Anaconda 默认环境保存路径和下载源修改\n\n因为更改环境保存路径和更改下载源都可以在.condarc文件中修改，这里一次性配置完。\n\n> 打开上面的anaconda prompt命令窗口，输入\n>\n> ```\n> conda info\n> ```\n\n没有修改的conda的pkgs和envs均保存在C盘，为了不占用系统盘的空间，我们需要修改保存的位置。\n\n> 在C盘-用户-用户名，找到.condarc,如果找不到打开anaconda prompt输入以下命令\n>\n> ```\n> conda config --set show_channel_urls yes\n> ```\n\n即可找到，用记事本打开\n\n> 删除其他的，输入以下指令【注意修改为自己想要安装的盘，我这里修改为D盘】\n>\n> ```\n> envs_dirs:\n>   - D:\\Software\\anaconda3\\envs\n> pkgs_dirs:\n>   - D:\\Software\\anaconda3\\pkgs\n> ```\n\n> CTRL + S保存\n\n> conda镜像源的配置，因为conda很多下载的东西在国外，默认的下载速度往往会很慢，这里建议修改为清华的镜像源，打开anaconda prompt，输入以下指令\n>\n> ```\n> # 添加清华源\n> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\n>  \n> # 添加阿里云镜像源\n> conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/free/\n> conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/main/\n>  \n> # 添加中科大源\n> conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n> conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n> conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\n> conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/\n> conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/\n> conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/\n>  \n>  \n>  \n> # （可选）设置搜索时显示通道地址\n> conda config --set show_channel_urls yes\n> ```\n\n> 最后我们验证一下上面的内容是否成功配置\n>\n> ```\n> conda info\n> ```\n\n> 首先pkgs和envs都修改为D盘了\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-18.png\" width=\"70%\" />\n\n其次我们看镜像源也成功配置。\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Anaconda新手安装和配置环境创建/Anaconda-19.png\" width=\"70%\" />\n\n😍这里Anaconda的安装和基本配置已经完成，快去创建一个自己的环境吧！！！！😍\n\n😍具体的指令可以去anaconda官网上学习保存，咱们CSDN也有很多同学总结的指令哦！！😍\n\n## 六、Anaconda 中创建虚拟环境\n\n以下是在Anaconda中创建虚拟环境的详细步骤：\n\n1. **打开Anaconda Prompt**  \n   在你的操作系统中，打开Anaconda Prompt（Windows用户可以在开始菜单中找到它，Mac或Linux用户可以在终端中启动）。\n\n2. **查看现有环境（可选）**  \n   如果你想先确认当前有哪些虚拟环境，可以输入以下命令：  \n   ```\n   conda env list\n   ```\n   这会列出所有已创建的环境，当前激活的环境会标有 `*`。\n\n3. **创建新的虚拟环境**  \n   使用 `conda create` 命令创建一个新的虚拟环境。你需要指定环境名称和所需的Python版本。例如，要创建一个名为 `myenv`、使用 Python 3.9 的环境，输入：  \n   ```\n   conda create --name myenv python=3.9\n   ```\n   - `--name myenv`：指定虚拟环境的名称，可以替换为任何你喜欢的名字。\n   - `python=3.9`：指定Python版本，可以根据需要改为其他版本（如 3.8、3.10 等）。\n\n4. **确认创建（若提示）**  \n   系统可能会显示需要安装的包列表，并询问是否继续。输入 `y` 并按回车以确认。\n\n5. **激活虚拟环境**  \n   创建完成后，激活新环境以开始使用它。命令如下：  \n   - Windows:  \n     ```\n     conda activate myenv\n     ```\n   - Mac/Linux:  \n     ```\n     conda activate myenv\n     ```\n   激活后，你会看到命令行前出现 `(myenv)`，表示当前处于该虚拟环境中。\n\n6. **安装额外的包（可选）**  \n   在激活的环境中，可以使用 `conda install` 或 `pip install` 安装所需的包。例如：  \n   ```\n   conda install numpy pandas\n   ```\n   或  \n   ```\n   pip install requests\n   ```\n\n7. **退出虚拟环境**  \n   使用完成后，可以通过以下命令退出虚拟环境：  \n   ```\n   conda deactivate\n   ```\n\n8. **删除虚拟环境（可选）**  \n   如果你不再需要某个虚拟环境，可以删除它。例如：  \n   ```\n   conda env remove --name myenv\n   ```\n\n### 注意事项\n- 确保你的Anaconda已正确安装并更新到最新版本，可以通过 `conda update conda` 更新。\n- 如果需要特定版本的包，可以在安装时指定，例如 `conda install numpy=1.19.2`。","tags":["Anaconda","教程"]},{"title":"电脑基础操作","url":"/post/aaf29fca.html","tags":["电脑基础操作"]},{"title":"VSCode中运行Python程序","url":"/post/6e3f7550.html","content":"VSCode是一个代码编辑器，支持Windows、Ubuntu等多种主流操作系统。VSCode中有很多实用的拓展工具，借助这些工具，可以很方便地完成代码编写、调试、运行、版本管理。\n\nVSCode的下载地址为：<https://code.visualstudio.com/Download>\n\n以下我将介绍四种在 VSCode 中运行 Python 程序的方法。\n\n### 方法一 使用内置终端运行\n   - 打开你的 Python 文件（例如 `example.py`）\n   - 按快捷键 `Ctrl + ``（反引号）打开终端，或者从顶部菜单选择 \"终端\" > \"新建终端\"\n   - 在终端输入：`python example.py` \n   - 回车即可运行\n\n### 方法二 使用 Code Runner 扩展\n   - 在 VSCode 扩展市场安装 \"Code Runner\" 插件\n   - 打开 Python 文件\n   - 点击右上角的 \"▶️\" 运行按钮，或者按快捷键 `Ctrl + Alt + N`\n   - 输出结果会显示在 \"输出\" 面板中\n\n### 方法三  配置 Python 解释器并运行\n   - 确保已安装 Python 扩展（Microsoft 官方的 Python 扩展）\n   - 按 `F1`或`Ctrl + Shift + P` 打开命令面板\n   - 输入并选择 \"Python: Select Interpreter\"，选择你的 Python 环境\n   - 打开 Python 文件，点击右上角 \"▶️\" 运行按钮\n\n### 方法四 快捷键直接运行\n   - 确保 Python 扩展已安装并配置好解释器\n   - 打开 Python 文件，按 `F5` 或者右击选择 \"Run Python File in Terminal\"\n\n**注意事项**：\n- 确保系统中已安装 Python，并且可以通过命令行运行 `python --version` 或 `python3 --version` 检查版本\n- 如果遇到路径问题，可以在 VSCode 中设置 Python 解释器路径（通过 \"Python: Select Interpreter\"）\n- 如果代码中有输入交互（比如 `input()`），建议在终端运行以便输入数据\n","tags":["教程","Python","VSCode"]},{"title":"《机器学习》基础实验（二）","url":"/post/7eb1e4f1.html","content":"## <p align=\"center\">机器学习大作业</p>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这门课程的主要目标是希望大家将机器学习算法应用于实际任务中，并具备相应的算法开发基础。\n\n### 项目要求\n\n1. 选择一项任务，使用课程上讲过的机器学习方法进行，可以使用信号处理或特征提取方法进行辅助。\n\n2. 给出相应任务结果，训练集和测试集精度，以及特征降维后的可视化。\n\n### 项目主题\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要选择一个项目主题，可以从下面两种项目中选择一个：\n\n1. 应用项目：选择感兴趣的应用场景，探索如何最好地应用机器学习算法解决它。\n\n2. 算法项目：针对目前机器学习算法存在的一些问题，对现有算法进行改进或开发新的算法来解决这些问题。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，也有一些项目需要结合应用和算法两方面的任务。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些可能的项目主题：\n\n1. 无人机目标检测\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体介绍&dataset：[http://aiskyeye.com/](http://aiskyeye.com/)\n\n2. 工业数据故障诊断\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataset：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[https://ww2.mathworks.cn/matlabcentral/fileexchange/50938-a-benchmark-case-for-statistical-process-monitoring-cranfield-multiphase-flow-facility](https://ww2.mathworks.cn/matlabcentral/fileexchange/50938-a-benchmark-case-for-statistical-process-monitoring-cranfield-multiphase-flow-facility)\n\n### 最终提交：项目主题、大作业实验报告和 PPT 汇报\n\n1. 项目主题。具体包括以下信息：\n   动机：想解决什么问题？\n   方法：打算使用哪些机器学习技术？\n   预期实验：打算进行什么实验？如何评估自己的机器学习算法？\n   提交划分后的数据集，自己了解到的相关研究示例，以及自己实现的算法代码。\n\n2. 实验报告：包括方法、实验流程、结果和分析等。\n\n3. 最后每位同学需要整理自己所做的工作，并形成一个 5 分钟学术报告 PPT（可选，加分）。\n\n### 作业提交：\n\n1. 提交时间：2024 年 5 月 26 日前；\n2. 提交方式：将实验报告、讲解 PPT、算法代码、划分后的数据集等材料压缩打包后以姓名+学号为文件名，上传到智慧树。\n","tags":["实验","机器学习"],"categories":["人工智能","机器学习"]},{"title":"《机器学习》基础实验（一）","url":"/post/1c5e69c3.html","content":"## 机器学习实验（一）机器学习绪论\n\n### 一、实验目标\n\n1. 下载并熟悉 `python`。\n2. 下载 `UCI 鸢尾花数据集`并对数据进行分析说明。\n\n### 二、实验任务\n\n1. 安装 `python` 和 `scikit-learn` 开发包，请详细列出安装步骤并截图，并执行任意命令证明工具安装成功。\n2. 下载 `UCI Iris 鸢尾花数据集`并对数据进行分析说明。\n（1）下载地址：[https://archive.ics.uci.edu/dataset/53/iris](https://archive.ics.uci.edu/dataset/53/iris)\n（2）直接加载数据集：\n    ```python\n    from sklearn.datasets import load_iris\n    iris_dataset = load_iris()\n    ```\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n3. 已经安装好软件后可以直接运行一些命令表示安装成功即可，不需要记录安装过程。\n4. 输出数据集的标签值、标签名称、属性名称等数据集信息。可视化画出2-3种图即可。\n\n### 四、实验记录\n\n**任务一：安装 `python` 和 `scikit-learn` 开发包并验证安装成功。**\n**Python 安装步骤及验证:**\n1.进入 [python 官网](https://www.python.org/)下载 `python` 的安装包。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-1.png)\n\n2.双击安装包进入自动安装设置，如果按照默认路径安装就选 `Install now`，如果要选则安装路径就选 `Customize installation`，并且勾选安装界面下方的 `Add python.exe to PATH` 自动将 `python` 添加到 `PATH` 中。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-2.png\" width=\"70%\" />\n\n3.等待自动安装。安装完成后打开命令提示符输入 `python` 进入 `python` 环境，再输入 `import this` 出现如下内容就说明安装成功了。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-3.png\" width=\"80%\" />\n\n4.在 `VScode` 安装 `python 插件`。在 `VScode` 左侧找到扩展，然后输入 `python` 安装同名扩展并安装。\n5.在 `VScode` 中新建 `test.py` 文件，输入并运行`print(\"Hello word!\")`\n能够成功在控制台输出如下就代表成功运行了。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-4.png\" width=\"100%\" />\n\n到这里 `python` 的安装和验证就结束了。\n**scikit-learn 安装步骤及验证：**\n1.打开命令提示符在 `python 安装目录`下输入以下语句并运行，将 `pip` 升级到最新版本。\n```\npython.exe -m pip install --upgrade pip\n```\n2.打开 `VScode` 在工作目录的终端中输入以下语句并运行，安装最新版本的 `scikit-learn`。\n```\npip install scikit-learn\n```\n3.在命令提示符输入以下语句并运行查看已经安装完成的包。\n```\npip list\n```\n可以在其中找到 `scikit-learn` 就说明安装成功了，如下图：\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-5.png\" width=\"50%\" />\n\n这里有 `scikit-learn`，所以已经成功安装。\n**任务二：下载 `UCI Iris 鸢尾花数据集`并对数据进行分析说明。**\n进入网址后点击 `DOWNLOAD` 下载压缩包，然后将内容解压到工作目录中，开始对数据进行分析。\n输出数据集的标签值、标签名称、属性名称等数据集信息以及可视化画出 3 种图的代码如下:\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn import datasets\nimport pandas as pd\n\nplt.rcParams['font.sans-serif'] = ['SimHei']\nplt.rcParams['axes.unicode_minus'] = False\n\niris = datasets.load_iris()\nX = iris.data\ny = iris.target\ntarget_names = iris.target_names\nfeature_names = iris.feature_names\n\n# 输出数据集信息\nprint(\"数据集标签值:\")\nprint(y)\n\nprint(\"\\n数据集标签名称:\")\nprint(target_names)\n\nprint(\"\\n数据集属性名称:\")\nprint(feature_names)\n\n# 可视化绘制散点图\nplt.figure(figsize=(18, 6))\n\n# 绘制 Sepal Length 和 Sepal Width 的散点图\nplt.subplot(1, 3, 1)\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.Set1)\nplt.xlabel('花萼长度 (cm)')\nplt.ylabel('花萼宽度 (cm)')\nplt.title('花萼长度 vs 花萼宽度')\n\n# 绘制 Petal Length 和 Petal Width 的散点图\nplt.subplot(1, 3, 2)\nplt.scatter(X[:, 2], X[:, 3], c=y, cmap=plt.cm.Set1)\nplt.xlabel('花瓣长度 (cm)')\nplt.ylabel('花瓣宽度 (cm)')\nplt.title('花瓣长度 vs 花瓣宽度')\n\n# 绘制 Sepal Length 和 Petal Length 的散点图\nplt.subplot(1, 3, 3)\nplt.scatter(X[:, 0], X[:, 2], c=y, cmap=plt.cm.Set1)\nplt.xlabel('花萼长度 (cm)')\nplt.ylabel('花瓣长度 (cm)')\nplt.title('花萼长度 vs 花瓣长度')\n\nplt.tight_layout()\nplt.show()\n\n# 创建数据框\niris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)\niris_df['target'] = iris.target\n\n# 直方图\nplt.figure(figsize=(18, 6))\n\n# 绘制 Sepal Length 直方图\nplt.subplot(1, 3, 1)\nsns.histplot(data=iris_df, x='sepal length (cm)', hue='target', kde=True)\nplt.title('花萼长度 直方图')\n\n# 绘制 Sepal Width 直方图\nplt.subplot(1, 3, 2)\nsns.histplot(data=iris_df, x='sepal width (cm)', hue='target', kde=True)\nplt.title('花萼宽度 直方图')\n\n# 绘制 Petal Length 直方图\nplt.subplot(1, 3, 3)\nsns.histplot(data=iris_df, x='petal length (cm)', hue='target', kde=True)\nplt.title('花瓣长度 直方图')\n\nplt.tight_layout()\nplt.show()\n\n# 热力分布图\nplt.figure(figsize=(8, 6))\nsns.heatmap(iris_df.corr(), annot=True, cmap='coolwarm')\nplt.title('特征相关性热力图')\nplt.show()\n```\n\n1.运行结果得到的数据集的标签值、标签名称、属性名称等数据集信息如下图：\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-6.png)\n\n2.运行得到的三个可视化二维散点图如下：\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-7.png)\n\n3.运行得到的三个可视化直方图如下：\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-8.png)\n\n4.运行得到的可视化热力图如下：\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《机器学习》基础实验（一）/Experiment1-9.png\" width=\"70%\" />\n\n---\n\n\n## 机器学习实验（二）感知机\n\n### 一、实验目标\n\n1. 理解感知机算法原理，能实现感知机算法；\n2. 掌握机器学习算法的代码构建流程；\n3. 掌握随机梯度下降法更新权重；\n4. 针对特定应用场景及数据，能构建感知机模型并进行预测。\n\n### 二、实验任务\n\n1. 自己生成一个 2 维空间有 6 个样本的可分两分类任务，每次样本更新记住权值的变化，并画出分类面。\n2. 熟悉 `iris 数据集`，并能使用感知机算法对该数据集构建模型并应用。\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n\n### 四、实验记录\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom sklearn.datasets import load_iris\nimport matplotlib.pyplot as plt\n\n# load data\niris = load_iris() #获取数据\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)# 获取列的属性值\ndf['label'] = iris.target# 增加一个新列\n\n\ndf.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] # 重命名各个列\ndf.label.value_counts() # 计算label列0、1、2出现的次数\n\n\"\"\"\n绘制散点图\n\"\"\"\nplt.scatter(df[:50]['sepal length'], df[:50]['sepal width'], label='0')\nplt.scatter(df[50:100]['sepal length'], df[50:100]['sepal width'], label='1')\nplt.scatter(df[100:]['sepal length'], df[100:]['sepal width'], label='2')\nplt.xlabel('sepal length')\nplt.ylabel('sepal width')\nplt.legend()\nplt.show()\n\ndata = np.array(df.iloc[:100, [0, 1, -1]])# 按行索引,取前100行,取第0，1列以及最后1列\n\nX, y = data[:,:-1], data[:,-1] #X: {ndarray:(100, 2)}y: {ndarray:(100, )}\n\ny = np.array([1 if i == 1 else -1 for i in y])# 将存在y中的数据为0的值改为-1\n\n\n# 数据线性可分，二分类数据\n# 此处为一元一次线性方程 \nclass Model:\n def __init__(self):# 初始化数据\n self.w = np.ones(len(data[0]) - 1, dtype=np.float32)\n self.b = 0\n self.l_rate = 0.1 \n # self.data = data\n\n def sign(self, x, w, b):\n y = np.dot(x, w) + b\n return y\n\n # 随机梯度下降法\n def fit(self, X_train, y_train):\n is_wrong = False\n while not is_wrong:\n wrong_count = 0# 初始设置错误次数为0\n for d in range(len(X_train)):\n X = X_train[d]\n y = y_train[d]\n if y * self.sign(X, self.w, self.b) <= 0:\n#权重self.w和截距self.b更新\n XXX\n XXX\n wrong_count += 1\n if wrong_count == 0:# 误分点数目为0跳出循环\n is_wrong = True\n return 'Perceptron Model!'\n\n def score(self):\n pass\n\nperceptron = Model()\nperceptron.fit(X, y)\n\nx_points = np.linspace(4, 7, 10)\n#计算输出值y\nXXX\nplt.plot(x_points, y_)\nplt.plot(data[:50, 0], data[:50, 1], 'bo', color='blue', label='0')\nplt.plot(data[50:100, 0], data[50:100, 1], 'bo', color='orange', label='1')\nplt.xlabel('sepal length')\nplt.ylabel('sepal width')\nplt.legend()\nplt.show()\n\n\n\nfrom sklearn.linear_model import Perceptron# 使用scikit-learn自带的感知机模型\n\n#配置导入的感知机模型clf\nXXX\n#使用上面的训练数据代入模型中进行训练\nXXX\n\n# Weights assigned to the features.\nprint(clf.coef_)\n\n# 截距 Constants in decision function.\nprint(clf.intercept_)\n\nx_ponits = np.arange(4, 8)\n#计算输出值y_\nXXX\nplt.plot(x_ponits, y_)\nplt.plot(data[:50, 0], data[:50, 1], 'bo', color='blue', label='0')\nplt.plot(data[50:100, 0], data[50:100, 1], 'bo', color='orange', label='1')\nplt.xlabel('sepal length')\nplt.ylabel('sepal width')\nplt.legend()\nplt.show()\n```\n\n### 五、运行结果\n\n### 六、实验小结\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次实验是理解感知机算法的原理并实现感知机算法，感知机称为单层感知机模型，其输入是实例的特征向量，输出为实例的分类类别。它是一种使用阶梯函数激活的人工神经元，以产生二分类输出，用于将数据分为两部分，因此也称为线性二分类器。实验中使用 `VScode` 进行编译，并使用到了`pandas`、`numpy`、`Matplotlib`、`sklearn`等机器学习库，可对机器学习有初步理解。\n\n---\n\n\n## 机器学习实验（三）logistic regression\n\n### 一、实验目标\n\n1. 理解 `Logistic` 回归算法原理，能实现 `Logistic` 回归算法；\n2. 理解 `Logistic` 回归和线性回归的区别，损失函数的不同；\n3. 掌握梯度下降法更新权重；\n4. 能够熟练使用归一化方法，并深刻理解归一化的意义；\n5. 针对特定应用场景及数据，能构建 `Logistic` 回归模型并进行预测。\n\n### 二、实验任务\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用 `sklearn` 的 `Breast_cancer 数据集`，设计一个基于 `Logistic` 回归的二分类模型。以 $80\\%$ 的训练集， $20\\%$ 的测试集。观察训练集的损失和精度变化，以及测试集上的精度变化，并绘制出来。（可以参考样例，需补充标 XXX 的部分）\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程；\n2. 报告中涉及到的代码，每一个模块需要有详细的注释；\n3. 绘制出对数据用归一化和不用归一化的结果，以及用不同的归一化的结果。\n\n### 四、参考样例\n\n```python\n# -*- coding: utf-8 -*-\nimport csv\nimport numpy as np\nimport  pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\n\ncancers = datasets.load_breast_cancer()\ntrain_X = cancers['data'][:450]\ntrain_Y = cancers['target'][:450]\ntest_X = cancers['data'][450:]\ntest_Y = cancers['target'][450:]\n\nclass LR:\n    def  __init__(self, data, data_test):\n        self.m = data.shape[0]\n        self.cols = data.shape[1] + 1\n        self.w = np.zeros(self.cols)\n        self.b = np.ones(self.m).reshape(self.m, 1)\n        self.lr = 0.001\n        self.train_X = np.hstack([self.b,data])\n\n        self.m_test = data_test.shape[0]\n        self.b_test = np.ones(self.m_test).reshape(self.m_test, 1)\n        self.test_X = np.hstack([self.b_test,data_test])\n\n    def sigmoid(self,x):\n        res = 1/(1 + np.exp(-x))\n        return np.clip(res, 1e-8, (1-(1e-8)))\n\n    def stop_stratege(self,loss,loss_update,threshold):\n        return  loss-loss_update <threshold\n\n    def Logistic_Regression(self, X, Y, X_test, Y_test, epochs):  # Logistic \n        i = 0\n        loss_record = []\n        acc_record = []\n        acc_test_record = []\n        for i in range(epochs):\n\n            ## predict\n            XXX\n            \n            ## compute loss\n            ### -sum((Y * ln(f(x))+(1-Y) * ln(1-f(x))))\n            loss = XXX\n            print(loss)\n            loss_record.append(loss)\n            \n            ## compute gradiant\n            grad = XXX\n            \n            ## update weight\n            self.w = XXX\n\n            ## compute acc in training\n            acc = XXX\n            acc_record.append(acc)\n\n            ## print every 20 iteration\n            if i % 500 == 1 and i>500:\n                self.visulization(i, X, Y)\n            \n            ## test each epoch\n            acc_test = self.test(X_test, Y_test)\n            acc_test_record.append(acc_test)\n\n        return  loss_record, acc_record, acc_test_record\n    \n\n    def train(self, X, Y, X_test, Y_test, epochs):\n        loss_record, acc_record, acc_test_record = self.Logistic_Regression(X, Y, X_test, Y_test, epochs)\n        \n        return loss_record, acc_record, acc_test_record\n\n    def test(self, X, Y):\n        z = np.dot(X, self.w)\n        y = self.sigmoid(z)\n        acc_test = XXX\n        return acc_test\n\n    def visulization(self,which_step,X_,Y_):\n        x = np.linspace(-10,10)\n        y = -(self.w[0] +self.w[1]*x)/self.w[2]\n        plt.plot(x,y)\n\n        index_0 = np.where(Y_==0)[0]\n        index_1 = np.where(Y_==1)[0]\n\n        plt.plot(X_[index_0, 1], X_[index_0, 2], 'bo', color='blue', label='0')\n        plt.plot(X_[index_1, 1], X_[index_1, 2], 'bo', color='orange', label='0')\n        plt.xlabel('x')\n        plt.ylabel('y')\n        plt.title('The '+str(which_step)+' update figure')\n        plt.xlim(-10,10)\n        plt.ylim(-10,10)\n        plt.show()\n\ndef AllNorm(X):\n\n    minVals=np.min(X)\n    maxVals=np.max(X)\n\n    ranges=maxVals-minVals\n    normDataSet=np.zeros(np.shape(X))\n    m=X.shape[0]\n    normDataSet=X-np.tile(minVals,(m,1))#在行方向重复minVals m次和列方向上重复minVals 1次\n    normDataSet=normDataSet/np.tile(ranges,(m,1))\n    return normDataSet\n\ndef ChannalNorm(X):\n    XXX\n    return normDataSet \n\ndef plot_history(loss_record, acc_record, acc_test_record, epochs):\n        plt.figure(figsize=(10,5))\n        plt.subplot(2,2,1)\n        plt.xlabel('Epoch')\n        plt.ylabel('loss')\n        plt.plot(range(epochs), loss_record, label='loss')\n        plt.legend()\n        plt.subplot(2,2,2)\n        plt.xlabel('Epoch')\n        plt.ylabel('acc_train')\n        plt.plot(range(epochs), acc_record, label='acc_train')\n        plt.subplot(2,1,2)\n        plt.xlabel('Epoch')\n        plt.ylabel('acc_test')\n        plt.plot(range(epochs), acc_test_record, label='acc_test', color = 'red')\n\n        #plt.plot(hist['epoch'], hist['acc'], label = 'acc',color = 'red')\n        plt.legend()\n        plt.show()\n\nif __name__ == \"__main__\":\n\n    '''\n    data = [[-1,-1],[2,-1],[5,3],[-1,6],[-4,-1],[1,4]]\n    label = [1,1,1,0,0,0]\n    train_X = np.array(data)\n    train_Y = np.array(label)\n    '''\n    #train_X = AllNorm(train_X)\n    #test_X = AllNorm(test_X)\n    Logist = LR(train_X, test_X)   # 实例化\n\n    epochs = 500\n    \n    loss_record, acc_record, acc_test_record = Logist.train(Logist.train_X, train_Y, Logist.test_X, test_Y, epochs)\n\nplot_history(loss_record, acc_record, acc_test_record, epochs)\n```\n\n### 五、运行结果\n\n### 六、实验小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次实验是理解 `logistic` 回归算法的原理并实现，`logistic` 回归属于分类模型，采用极大似然估计作为优化目标，形式上和交叉熵一致，并且可以使用梯度下降法或牛顿法作为优化算法。由于其模型中以非线性函数 `sigmoid` 作为激活函数，因此属于非线性分类器的一种。在进行数据处理的时候，往往需要对数据进行归一化，否则会出现梯度方向不稳定，导致损失函数波动剧烈，收敛性变差。\n\n---\n\n\n## 机器学习实验（四）决策树\n\n### 一、实验目标\n\n1. 理解 `ID3`、`C4.5` 和 `CART` 算法原理，能实现这三种算法；\n2. 掌握决策树的构建和利用决策树进行推断,并进行有效剪枝；\n3. 理解决策树的优缺点。\n\n### 二、实验任务\n\n1. 利用 `WDBC 数据集`，设计分别基于 `ID3`、`C4.5` 和 `CART` 算法的决策树。以 2/3 的数据为训练集，1/3 为测试集。\nIndex of /ml/machine-learning-databases/breast-cancer-wisconsin (uci.edu)\n   - breast-cancer-wisconsin.data\n2. 利用 1 实现的决策树算法在验证集上进行后剪枝。\n3. 用感知器的二维线性可分数据集构建决策树并绘制决策边界，并与感知器的决策边界进行比较。\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n3. 给出基于 `ID3`、`C4.5` 和 `CART` 算法的决策树三个算法的精度和预测结果，以及基于其中一个算法剪枝后的精度。\n4. 给出感知器的二维线性可分数据集构建决策树的决策边界。\n\n### 四、参考样例\n\n1.ID3、C4.5示例\n\n```python\n# encoding=utf-8\nimport copy\nimport time\nfrom collections import Counter\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\nclass Tree(object):\n    def __init__(self,node_type,Class = None, attribute = None):\n        self.node_type = node_type  # 节点类型（internal或leaf）\n        self.dict = {} # dict的键表示属性Ag的可能值ai，值表示根据ai得到的子树\n        self.Class = Class  # 叶节点表示的类，若是内部节点则为none\n        self.attribute = attribute # 表示当前的树即将由第attribute个属性划分（即第attribute属性是使得当前树中信息增益最大的属性）\n\n    def add_tree(self,key,tree):\n        self.dict[key] = tree\n\n    def predict(self,attributes):\n        #print('attribute', self.attribute)\n        if self.node_type == 'leaf' or (attributes[self.attribute] not in self.dict):\n            #print('self.Class', self.Class)\n            return self.Class\n\n        tree = self.dict.get(attributes[self.attribute])\n        return tree.predict(attributes)\n\n# 计算数据集x的经验熵H(x)\ndef calc_ent(x):\n    XXX\n\n# 计算条件熵H(y/x)\ndef calc_condition_ent(x, y):\n    XXX\n\n# 计算信息增益\ndef calc_ent_gain(x,y):\n    XXX\n\n# ID3算法\ndef recurse_train_ID3(train_set,train_label,attributes):\n    LEAF = 'leaf'\n    INTERNAL = 'internal'\n\n    # 步骤1——如果训练集train_set中的所有实例都属于同一类C, 则将该类表示为新的叶子节点\n    label_set = set(train_label)\n    if len(label_set) == 1:\n        return Tree(LEAF, Class=label_set.pop())\n\n    # 步骤2——如果属性集为空，表示不能再分了，将剩余样本中样本数最多的一类赋给叶子节点\n    class_len = [(i, len(list(filter(lambda x: x == i, train_label)))) for i in label_set]  # 计算每一个类出现的个数\n    (max_class, max_len) = max(class_len, key=lambda x: x[1])  # 出现个数最多的类\n\n    if len(attributes) == 0:\n        return Tree(LEAF, Class=max_class)\n\n    # 步骤3——计算信息增益,并选择信息增益最大的属性\n    max_attribute = 0\n    max_gain = 0\n    D = train_label\n    for attribute in attributes:\n        # print(type(train_set))\n        A = np.array(train_set[:,attribute].flat) # 选择训练集中的第attribute列（即第attribute个属性）\n        #计算信息增益并更新max_gain和max_attribute\n        gain = XXX\n        XXX\n\n    # 步骤4——依据样本在最大增益属性的取值，划分非空子集，进而构建树或子树\n    sub_attributes = list(filter(lambda x:x!=max_attribute,attributes))\n    tree = Tree(INTERNAL,attribute=max_attribute)\n\n    max_attribute_col = np.array(train_set[:,max_attribute].flat)\n    attribute_value_list = set([max_attribute_col[i] for i in range(max_attribute_col.shape[0])]) # 保存信息增益最大的属性可能的取值 (shape[0]表示计算行数)\n    for attribute_value in attribute_value_list:\n\n        index = list(np.where(train_set[:,max_attribute] == attribute_value)[0])\n\n        sub_train_set = train_set[index]\n        sub_train_label = train_label[index]\n        #递归建树\n        XXX\n\n    return tree\n\n\n# C4.5算法\ndef recurse_train_C45(train_set,train_label,attributes):\n\n    LEAF = 'leaf'\n    INTERNAL = 'internal'\n    # 步骤1——如果训练集train_set中的所有实例都属于同一类C, 则将该类表示为新的叶子节点\n    label_set = set(train_label)\n    if len(label_set) == 1:\n        return Tree(LEAF,Class = label_set.pop())\n\n    # 步骤2——如果属性集为空，表示不能再分了，将剩余样本中样本数最多的一类赋给叶子节点\n    class_len = [(i,len(list(filter(lambda x:x==i,train_label)))) for i in label_set] # 计算每一个类出现的个数\n    (max_class,max_len) = max(class_len,key = lambda x:x[1])  #出现个数最多的类\n\n    if len(attributes) == 0:\n        return Tree(LEAF,Class = max_class)\n    # 步骤3——计算信息增益率,并选择信息增益率最大的属性\n    max_attribute = 0\n    max_gain_r = 0\n    D = train_label\n    for attribute in attributes:\n        A = np.array(train_set[:,attribute].flat) # 选择训练集中的第attribute列（即第attribute个属性）\n        gain = XXX\n        ####### 计算信息增益率，并更新max_attribute，max_gain_r\n        XXX\n    # 步骤4——如果最大的信息增益率小于阈值,说明所有属性的增益都非常小，那么取样本中最多的类为叶子节点\n    if max_gain_r < epsilon:\n        return Tree(LEAF,Class = max_class)\n\n    # 步骤5——依据样本在最大增益率属性的取值，划分非空子集，进而构建树或子树\n    sub_attributes = list(filter(lambda x:x!=max_attribute,attributes))\n    tree = Tree(INTERNAL,attribute=max_attribute)\n    max_attribute_col = np.array(train_set[:,max_attribute].flat)\n    attribute_value_list = set([max_attribute_col[i] for i in range(max_attribute_col.shape[0])]) # 保存信息增益最大的属性可能的取值 (shape[0]表示计算行数)\n    for attribute_value in attribute_value_list:\n\n        index = list(np.where(train_set[:,max_attribute] == attribute_value)[0])\n\n        sub_train_set = train_set[index]\n        sub_train_label = train_label[index]\n\n        #递归建树\n        XXX\n    return tree\n\ndef train(train_set,train_label,attributes):\n    return recurse_train_ID3(train_set,train_label,attributes)\n\ndef predict(test_set,tree):\n    result = []\n\n    for attributes in test_set:\n        tmp_predict = tree.predict(attributes)\n        if tmp_predict == None:\n            tmp_predict = epsilon\n        result.append(tmp_predict)\n\n    return np.array(result)\n\ndef post_pruning(val_data, val_label, dataset, tree, features):\n    path = []\n    DFS.val_data = val_data\n    DFS.val_label = val_label\n    DFS.dataset = dataset\n    DFS.root = tree\n    DFS.features = features\n    DFS(tree, path)\n    return tree\n\ndef DFS(tree, path):\n    if tree.node_type == \"leaf\":\n        return\n\n    # 没有return，该节点是内部节点，检测该节点的子节点是不是都是叶子节点\n    leafs_parent = True\n    for sub_tree in tree.dict.values():\n        if sub_tree.node_type != \"leaf\":\n            leafs_parent = False\n            break\n    # 如果该节点的子节点全部是叶子节点\n    if leafs_parent and len(path) > 0:\n        process_leafs_parent(DFS.val_data, DFS.val_label,\n                             DFS.dataset, DFS.root, DFS.features, tree, path)\n\n    # 如果该节点的子节点也是内部节点，继续递归\n    else:\n        for key, sub_tree in tree.dict.items():\n            path.append((DFS.features[tree.attribute], key))\n            DFS(sub_tree, path)\n            path.pop()\n\n        # 对子节点的递归结束，\n        # 再次检测该节点的子节点是不是都是叶子节点\n        leafs_parent = True\n        for sub_tree in tree.dict.values():\n            if sub_tree.node_type != \"leaf\":\n                leafs_parent = False\n                break\n        # 如果该节点的子节点全部是叶子节点\n        if leafs_parent and len(path) > 0:\n            process_leafs_parent(DFS.val_data, DFS.val_label,\n                                 DFS.dataset, DFS.root, DFS.features, tree, path)\n\n\ndef process_leafs_parent(val_data, val_label,\n                         dataset, root, features, tree, path):\n    # 在未剪枝的决策树上进行验证，并得出准确率\n    old_score = accuracy_score(val_label.astype('int32'), predict(val_data, root).astype('int32'))\n    # 将未剪枝的子树保存起来\n    temp_tree = copy.deepcopy(tree)\n\n    # 根据路径找到训练集中能到达该节点的数据\n    df = pd.DataFrame(dataset, columns=features + ['label'])\n    df = df[df[path[0][0]]==path[0][1]]\n    if len(path) >= 2:\n        for each in path[1:]:\n            df = df[df[each[0]]==each[1]]\n\n    # 进行剪枝\n    tree.Class = XXX\n    tree.node_type = XXX\n    tree.dict = XXX\n\n    # 若剪枝后分数变低，那么还原子树\n    new_score = accuracy_score(val_label.astype('int32'), predict(val_data, root).astype('int32'))\n    if (new_score < old_score):\n        tree.Class = temp_tree.Class\n        tree.node_type = temp_tree.node_type\n        tree.dict = temp_tree.dict\n\nclass_num = 2  # wdbc数据集有2种labels，分别是“2,4”\nattribute_len = 9  # wdbc数据集每个样本有9个属性\nepsilon = 0.001  # 设定阈值\n\nif __name__ == '__main__':\n\n    print(\"Start read data...\")\n\n    time_1 = time.time()\n\n    raw_data = pd.read_csv('breast-cancer-wisconsin.data', header=None)  # 读取csv数据\n    data = raw_data.values\n    \n    features = data[:, 1:-1]\n    # 删除缺失值\n    index0 = np.where(features[:,5]!='?')\n    features = features[index0].astype('int32')\n    labels = data[:,-1][index0]\n\n    # 避免过拟合，采用交叉验证，随机选取33%数据作为测试集，剩余为训练集\n    train_attributes, test_attributes, train_labels, test_labels = train_test_split(features, labels, test_size=0.33, random_state=0)\n\n    # 通过C4.5算法生成决策树\n    print('Start training...')\n    tree = train(train_attributes,train_labels,list(range(attribute_len)))\n\n    print('Start predicting...')\n    test_predict = predict(test_attributes,tree)\n    print(test_predict)\n    score = accuracy_score(test_labels.astype('int32'), test_predict.astype('int32'))\n    print(\"The accruacy score is %f\" % score)\n    #剪枝\n    new_tree = post_pruning(test_attributes, test_labels, np.c_[train_attributes,train_labels], tree, list(range(attribute_len)))\n    new_test_predict = predict(test_attributes,new_tree)\n    for i in range(len(test_predict)):\n        if new_test_predict[i] == None:\n            new_test_predict[i] = epsilon\n    score = accuracy_score(test_labels.astype('int32'), new_test_predict.astype('int32'))\n    print(\"The new accruacy score is %f\" % score)\n```\n\n2.CART\n\n```python\nimport time\nfrom math import log\nimport numpy as np\nimport pandas as pd\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\n\n# 计算当前集合的Gini系数\ndef calcGini(dataset):\n    # 求总样本数\n    XXX\n\n# 提取子集合\n# 功能：从dataSet中先找到所有第axis个标签值 = value的样本\n# 然后将这些样本删去第axis个标签值，再全部提取出来成为一个新的样本集\ndef create_sub_dataset(dataset, index, value):\n    sub_dataset = []\n    for example in dataset:\n        current_list = []\n        if example[index] == value:\n            current_list = example[:index]\n            current_list.extend(example[index + 1:])\n            sub_dataset.append(current_list)\n    return sub_dataset\n\n# 将当前样本集分割成特征i取值为value的一部分和取值不为value的一部分（二分）\ndef split_dataset(dataset, index, value):\n    sub_dataset1 = []\n    sub_dataset2 = []\n    for example in dataset:\n        current_list = []\n        if example[index] == value:\n            current_list = example[:index]\n            current_list.extend(example[index + 1:])\n            sub_dataset1.append(current_list)\n        else:\n            current_list = example[:index]\n            current_list.extend(example[index + 1:])\n            sub_dataset2.append(current_list)\n    return sub_dataset1, sub_dataset2\n\ndef choose_best_feature(dataset):\n    # 特征总数\n    numFeatures = len(dataset[0]) - 1\n    # 当只有一个特征时\n    if numFeatures == 1:\n        return 0\n    # 初始化最佳基尼系数\n    bestGini = 1\n    # 初始化最优特征\n    index_of_best_feature = -1\n    # 遍历所有特征，寻找最优特征和该特征下的最优切分点\n    for i in range(numFeatures):\n        # 去重，每个属性值唯一\n        uniqueVals = set(example[i] for example in dataset)\n        # Gini字典中的每个值代表以该值对应的键作为切分点对当前集合进行划分后的Gini系数\n        Gini = {}\n        # 对于当前特征的每个取值\n        for value in uniqueVals:\n            # 先求由该值进行划分得到的两个子集\n            sub_dataset1, sub_dataset2 = split_dataset(dataset, i, value)\n            # 求两个子集占原集合的比例系数prob1 prob2\n            prob1 = XXX\n            prob2 = XXX\n            # 计算子集1的Gini系数\n            Gini_of_sub_dataset1 = calcGini(sub_dataset1)\n            # 计算子集2的Gini系数\n            Gini_of_sub_dataset2 = calcGini(sub_dataset2)\n            # 计算由当前最优切分点划分后的最终Gini系数\n            Gini[value] = XXX\n            # 更新最优特征和最优切分点\n            XXX\n    return index_of_best_feature, best_split_point\n\n# 返回具有最多样本数的那个标签的值（'yes' or 'no'）\ndef find_label(classList):\n    # 初始化统计各标签次数的字典\n    # 键为各标签，对应的值为标签出现的次数\n    labelCnt = {}\n    for key in classList:\n        if key not in labelCnt.keys():\n            labelCnt[key] = 0\n        labelCnt[key] += 1\n    # 将classCount按值降序排列\n    # 例如：sorted_labelCnt = {'yes': 9, 'no': 6}\n    sorted_labelCnt = sorted(labelCnt.items(), key=lambda a: a[1], reverse=True)\n    # 下面这种写法有问题\n    # sortedClassCount = sorted(labelCnt.iteritems(), key=operator.itemgetter(1), reverse=True)\n    # 取sorted_labelCnt中第一个元素中的第一个值，即为所求\n    return sorted_labelCnt[0][0]\n\ndef create_decision_tree(dataset, features):\n    # 求出训练集所有样本的标签\n    label_list = [example[-1] for example in dataset]\n    # 先写两个递归结束的情况：\n    # 若当前集合的所有样本标签相等（即样本已被分“纯”）\n    # 则直接返回该标签值作为一个叶子节点\n    if label_list.count(label_list[0]) == len(label_list):\n        return label_list[0]\n    # 若训练集的所有特征都被使用完毕，当前无可用特征，但样本仍未被分“纯”\n    # 则返回所含样本最多的标签作为结果\n    if len(features) == 0:\n        return find_label(label_list)\n    # 下面是正式建树的过程\n    # 选取进行分支的最佳特征的下标和最佳切分点\n    index_of_best_feature, best_split_point = choose_best_feature(dataset)\n    # 得到最佳特征\n    best_feature = features[index_of_best_feature]\n    # 初始化决策树\n    decision_tree = {best_feature: {}}\n    # 使用过当前最佳特征后将其删去\n    del (features[index_of_best_feature])\n    # 子特征 = 当前特征（因为刚才已经删去了用过的特征）\n    sub_labels = features[:]\n    # 递归调用create_decision_tree去生成新节点\n    # 生成由最优切分点划分出来的二分子集\n    sub_dataset1, sub_dataset2 = split_dataset(dataset, index_of_best_feature, best_split_point)\n    # 构造左子树\n    decision_tree[best_feature][best_split_point] = create_decision_tree(sub_dataset1, sub_labels)\n    # 构造右子树\n    decision_tree[best_feature]['others'] = create_decision_tree(sub_dataset2, sub_labels)\n    return decision_tree\n\n# 用上面训练好的决策树对新样本分类\ndef predict(decision_tree, features, test_example):\n    # 根节点代表的属性\n    first_feature = list(decision_tree.keys())[0]\n    # second_dict是第一个分类属性的值（也是字典）\n    second_dict = decision_tree[first_feature]\n    # 树根代表的属性，所在属性标签中的位置，即第几个属性\n    index_of_first_feature = features.index(first_feature)\n    # 对于second_dict中的每一个key\n    for key in second_dict.keys():\n        # 不等于'others'的key\n        if key != 'others':\n            if test_example[index_of_first_feature] == key:\n                # 若当前second_dict的key的value是一个字典\n                if type(second_dict[key]).__name__ == 'dict':\n                    # 则需要递归查询\n                    classLabel = predict(second_dict[key], features, test_example)\n                # 若当前second_dict的key的value是一个单独的值\n                else:\n                    # 则就是要找的标签值\n                    classLabel = second_dict[key]\n            # 如果测试样本在当前特征的取值不等于key，就说明它在当前特征的取值属于'others'\n            else:\n                # 如果second_dict['others']的值是个字符串，则直接输出\n                if isinstance(second_dict['others'], int):\n                    classLabel = second_dict['others']\n                # 如果second_dict['others']的值是个字典，则递归查询\n                else:\n                    classLabel = predict(second_dict['others'], features, test_example)\n    return classLabel\n\nclass_num = 2  # wdbc数据集有2种labels，分别是“2,4”\nattribute_len = 9  # wdbc数据集每个样本有9个属性\nepsilon = 0.001  # 设定阈值\n\nif __name__ == '__main__':\n    print(\"Start read data...\")\n\n    time_1 = time.time()\n\n    raw_data = pd.read_csv('breast-cancer-wisconsin.data', header=None)  # 读取csv数据\n    data = raw_data.values\n\n    features = data[:, 1:-1]\n    # 删除缺失值\n    index0 = np.where(features[:, 5] != '?')\n    features = features[index0].astype('int32')\n    labels = data[:, -1][index0]\n    # 避免过拟合，采用交叉验证，随机选取33%数据作为测试集，剩余为训练集\n    train_attributes, test_attributes, train_labels, test_labels = train_test_split(features, labels, test_size=0.33,\n                                                                                    random_state=0)\n    train_data = (np.concatenate((train_attributes,train_labels[:,np.newaxis]),axis=1)).tolist()\n    time_2 = time.time()\n    #创建决策树\n    dicision_Tree = create_decision_tree(train_data,list(range(attribute_len)))\n    #测试数据\n    test_predict = []\n    for value in test_attributes:\n        test_predict.append(predict(dicision_Tree,list(range(attribute_len)),value))\n    score = accuracy_score(test_labels.astype('int32'), test_predict)\n    print(\"The accruacy score is %f\" % score)\n```\n\n### 五、运行结果\n\n### 六、实验小结\n\n---\n\n\n## 机器学习实验（五）神经网络\n\n### 一、实验目标\n\n1. 理解神经网络分类算法原理，能实现神经网络分类算法；\n2. 掌握激活函数计算方式、前向传播和反向传播过程。\n\n### 二、实验任务\n\n1. 使用 `Python` 调用现有库和手动实现神经网络分类算法；\n2. 用 $80\\%$ 的数据训练，余下的做测试，计算分类准确度，调整模型参数使分类的准确率达到较高值。\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n\n### 四、实验记录\n\n```python\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets\nfrom pandas import DataFrame\nimport numpy as np\n\niris=datasets.load_iris()\ndf=DataFrame(iris.data,columns=iris.feature_names)\ndf['target']=list(iris.target)\nX=df.iloc[:,0:4]\nY=df.iloc[:,4]\n#划分数据\nXXX\nsc=StandardScaler()\nsc.fit(X)\nstandard_train=sc.transform(X_train)\nstandard_test=sc.transform(X_test)\n\n#python调用\n#构建mlp模型\nXXX\n#拟合数据\nXXX\n#得到预测结果\nXXX\n\n\n\n#查看模型结果\nprint(\"测试集合的y值：\",list(Y_test))\nprint(\"神经网络预测的的y值：\",list(result))\nprint(\"预测的准确率为：\",mlp.score(standard_test,Y_test))\nprint(\"层数为：\",mlp.n_layers_)\nprint(\"迭代次数为：\",mlp.n_iter_)\nprint(\"损失为：\",mlp.loss_)\nprint(\"激活函数为：\",mlp.out_activation_)\n\n#手动实现\nclass NeuralNetwork:\n   def __init__(self, input_size, hidden_size, output_size):\n       self.input_size = input_size\n       self.hidden_size = hidden_size\n       self.output_size = output_size\n\n       # 初始化权重\n       self.weights_input_hidden = np.random.randn(self.input_size, self.hidden_size)\n       self.weights_hidden_output = np.random.randn(self.hidden_size, self.output_size)\n\n       # 初始化偏置\n       self.bias_hidden = np.zeros((1, self.hidden_size))\n       self.bias_output = np.zeros((1, self.output_size))\n\n   def sigmoid(self, x):\n       return XXX  #sigmoid计算方式\n\n   def sigmoid_derivative(self, x):\n       return XXX  #sigmoid导数计算方式\n\n   def forward(self, X):\n       # 计算隐藏层的输入\n       self.hidden_input = XXX\n       # 计算隐藏层的输出\n       self.hidden_output = self.sigmoid(self.hidden_input)\n       # 计算输出层的输入\n       self.output_input = np.dot(self.hidden_output, self.weights_hidden_output) + self.bias_output\n       # 计算输出层的输出\n       self.output = self.sigmoid(self.output_input)\n       return self.output\n\n   def backward(self, X, y, output, learning_rate):\n       # 计算输出层的误差\n       output_error = y - output\n       # 计算输出层的梯度\n       output_delta = XXX\n       # 计算隐藏层的误差\n       hidden_error = np.dot(output_delta, self.weights_hidden_output.T)\n       # 计算隐藏层的梯度\n       hidden_delta = hidden_error * self.sigmoid_derivative(self.hidden_output)\n\n       # 更新权重和偏置\n       self.weights_hidden_output += XXX\n       self.bias_output += learning_rate * np.sum(output_delta, axis=0, keepdims=True)\n       self.weights_input_hidden += learning_rate * np.dot(X.T, hidden_delta)\n       self.bias_hidden += learning_rate * np.sum(hidden_delta, axis=0, keepdims=True)\n\n\n   def train(self, X, y, epochs, learning_rate):\n       for epoch in range(epochs):\n           output = self.forward(X)\n           loss = np.mean(0.5 * (y - output) ** 2)\n           self.backward(X, y, output, learning_rate)\n           if epoch % 100 == 0:\n               print(f\"Epoch {epoch + 1}, Loss: {loss}\")\n\n   def predict(self, X):\n       return np.round(self.forward(X))\n\n\n# 将标签转换为独热编码\ndef one_hot_encode(labels):\n   num_classes = len(np.unique(labels))\n   one_hot_labels = np.zeros((len(labels), num_classes))\n   for i, label in enumerate(labels):\n       one_hot_labels[i][label] = 1\n   return one_hot_labels\n\n\n# 构建神经网络\ninput_size = X_train.shape[1]\nhidden_size = 10\noutput_size = len(np.unique(Y_train))  # 根据训练集标签确定输出层大小\nnn = NeuralNetwork(input_size, hidden_size, output_size)\n\n# 将标签转换为独热编码\nY_train_encoded = one_hot_encode(Y_train)\n\n# 训练神经网络\nprint('training.......')\nnn.train(standard_train, Y_train_encoded, epochs=1000, learning_rate=0.1)\n\n# 预测测试集\npredictions = nn.predict(standard_test)\n\n# 计算准确率\naccuracy = accuracy_score(Y_test, np.argmax(predictions, axis=1))\n\n# 查看模型结果\nprint(\"测试集合的y值：\", list(Y_test))\nprint(\"神经网络预测的的y值：\", list(np.argmax(predictions, axis=1)))\nprint(\"预测的准确率为：\", accuracy)\n```\n\n### 五、运行结果\n\n### 六、实验小结\n\n---\n\n\n## 机器学习实验（六）朴素贝叶斯\n\n### 一、实验目标\n\n1. 理解朴素贝叶斯分类算法原理和工作流程；\n2. 掌握实现高斯朴素贝叶斯分类器的方法。\n\n### 二、实验任务\n\n1. 用 $80\\%$ 的数据训练，余下的做测试，计算分类准确度。\n2. 调用 `Scikit-learn 库`实现高斯朴素贝叶斯分类器模型。\n3. 实现自定义的高斯朴素贝叶斯分类器模型。\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n\n### 四、实验记录\n\n```python\nimport numpy as np\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.datasets import load_iris\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\n\n# 加载鸢尾花数据集\nX, y = load_iris(return_X_y=True)\nsc=StandardScaler()\nsc.fit(X)\nX=sc.transform(X)\n# 将数据集划分为训练集、测试集\nX_train, X_test, y_train, y_test = XXX\n\n# 调用sklearn库的朴素贝叶斯模型\nXXX\n# 训练模型\nXXX\n# 预测结果\nXXX\n# 评估在测试集上的预测准确率\nacc=XXX\nprint(f\"调用sklearn库的朴素贝叶斯分类器的准确率: {acc:.2f}\")\n\n# 构建自定义的朴素贝叶斯模型\nclass myGaussianNB:\n    \"\"\"\n    原理：\n        贝叶斯公式: P(Y|X)=P(X|Y)P(Y)/P(X);\n        属性条件独立性假设: P(X|Y)=P(c1|Y)P(c2|Y)...P(cn|Y);\n        GaussianNB是朴素贝叶斯分类器的一种,它假设数据的每个属性都服从高斯分布。\n    -----------------------\n    训练:\n\t对每个类别y：\n        提取属于该类别的样本；\n        计算该类别样本在每个属性上的均值、方差；\n        计算该类别的先验概率 P(Y)。\n    -----------------------\n    预测：\n    对每个类别 y:\n        获取该类别的先验概率 P(Y);\n        计算每个属性在该类别下的条件概率P(c|Y);\n        根据属性独立性假设,将每个属性的概率密度相乘得到 P(X|Y);\n        根据贝叶斯公式计算后验概率 P(Y|X) = P(X|Y) * P(Y);\n    选择后验概率最大的类别作为预测结果.\n    \"\"\"\n\n    def fit(self, X, y):\n        self.classes = np.unique(y)\n        self.params = {}\n\n        for cls in self.classes:\n            ## 按类别提取样本\n            X_cls =XXX\n            ## 计算均值\n            X_mean=XXX\n            ## 计算方差\n            X_var=XXX\n            ## 计算先验P(Y)\n            X_prior=XXX\n            self.params[cls] = {\n                'mean':X_mean,\n                'var':X_var,\n                'prior':X_prior\n            }\n\n    def predict(self, X):\n        n_samples, n_features = X.shape\n        predictions = []\n        for x in X:\n            posteriors = []\n            for cls in self.classes:\n                # 获取先验概率\n                prior = np.log(self.params[cls]['prior'])\n                # 计算每个属性的类条件概率P(C|Y)\n                conditional_c=np.log(self.Gaussian_pdf(cls, x))\n                # 依据P(C|Y)计算类条件概率P(X|Y)\n                conditional = XXX\n                # 依据贝叶斯公式计算后验概率\n                posterior = XXX\n\n                posteriors.append(posterior)\n            # 获取分类结果\n            pred_class=self.classes[np.argmax(posteriors)]\n            predictions.append(pred_class)\n        return np.array(predictions)\n\n    def Gaussian_pdf(self, cls, x):\n        mean = self.params[cls]['mean']\n        var = self.params[cls]['var']\n        # 计算高斯分布的分子部分\n        numerator = XXX\n        # 计算高斯分布的分母部分\n        denominator = XXX\n        return numerator / denominator\n\nnb =myGaussianNB()\nnb.fit(X_train, y_train)\npredictions = nb.predict(X_test)\n\naccuracy = accuracy_score(y_test, predictions)\nprint(f\"自定义朴素贝叶斯分类器的准确率: {accuracy:.2f}\")\n```\n\n### 五、运行结果\n\n### 六、实验小结\n\n---\n\n\n## 机器学习实验（七）神经网络\n\n### 一、实验目标\n\n1. 掌握集成学习的基本思想；\n2. 掌握 `boosting` 策略；\n3. 了解基于 `Adaboost` 集成器实现多分类任务\n\n### 二、实验任务\n\n1. 使用 `Python` 编写 `Adaboost` 算法框架；\n2. 利用 `sklearn` 提供的基学习器构建 `Adaboost` 算法模型，读取 `Iris 数据集`信息并进行多分类预测，并根据精确率、召回率和 F1 值度量模型性能。\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n\n### 四、实验记录\n\n（1）实现 `Adaboost-SAMME` 算法和 `Adaboost-SAMME.R` 算法\n`SAMME` 算法首先初始化权重。随后进行 M 次迭代，每次迭代需要训练基分类并进行预测，根据预测结果计算错误率，并根据错误率调整样本分布情况，最后根据处理分类器权重并归一化，完成本次迭代； \n\n`SAMME.R` 算法首先初始化权重。随后进行 M 次迭代，每次迭代需要训练及分类并进行预测，随后根据预测结果计算加权概率估计 `h(x)`，再根据 `h(x)` 的值调整样本分布情况及分类器权重并归一化处理。\n\n```python\nimport numpy as np\nfrom copy import deepcopy\n\nclass AdaBoostClassifier(object):\n    def __init__(self, *args, **kwargs):\n        if kwargs and args:\n            raise ValueError(\n                '''AdaBoostClassifier can only be called with keyword\n                   arguments for the following keywords: base_estimator ,n_estimators,\n                    learning_rate,algorithm,random_state''')\n        allowed_keys = ['base_estimator', 'n_estimators', 'learning_rate', 'algorithm', 'random_state']\n        keywords_used = kwargs.keys()\n        for keyword in keywords_used:\n            if keyword not in allowed_keys:\n                raise ValueError(keyword + \":  Wrong keyword used --- check spelling\")\n\n        n_estimators = 50\n        learning_rate = 1\n        algorithm = 'SAMME.R'\n        random_state = None\n\n        if kwargs and not args:\n            if 'base_estimator' in kwargs:\n                base_estimator = kwargs.pop('base_estimator')\n            else:\n                raise ValueError('''base_estimator can not be None''')\n            if 'n_estimators' in kwargs: n_estimators = kwargs.pop('n_estimators')\n            if 'learning_rate' in kwargs: learning_rate = kwargs.pop('learning_rate')\n            if 'algorithm' in kwargs: algorithm = kwargs.pop('algorithm')\n            if 'random_state' in kwargs: random_state = kwargs.pop('random_state')\n        # 弱评估器\n        self.base_estimator_ = base_estimator\n        # 集成算法中弱评估器的数量\n        self.n_estimators_ = n_estimators\n        self.learning_rate_ = learning_rate\n        # 采用的集成学习策略\n        self.algorithm_ = algorithm\n        # 控制每次建立决策树之前随机抽样过程的随机数种子\n        self.random_state_ = random_state\n        self.estimators_ = list()\n        # 每个弱评估器的权重\n        self.estimator_weights_ = np.zeros(self.n_estimators_)\n        # 每个弱评估器的错误率\n        self.estimator_errors_ = np.ones(self.n_estimators_)\n\n    def _samme_proba(self, estimator, n_classes, X): # 计算h(x)\n        proba = estimator.predict_proba(X)\n        proba[proba < np.finfo(proba.dtype).eps] = np.finfo(proba.dtype).eps\n        log_proba = np.log(proba)\n        return (n_classes - 1) * (log_proba - (1. / n_classes)\n                                  * log_proba.sum(axis=1)[:, np.newaxis])\n\n    def fit(self, X, y):\n        self.n_samples = X.shape[0]\n        self.classes_ = np.array(sorted(list(set(y))))\n        self.n_classes_ = len(self.classes_)\n        for iboost in range(self.n_estimators_):\n            if iboost == 0: # 初始化权重为1/n\n                sample_weight = np.ones(self.n_samples) / self.n_samples\n            # 循环迭代弱分类器\n            sample_weight, estimator_weight, estimator_error = self.boost(X, y, sample_weight)\n            # 提前结束，训练失败\n            if estimator_error == None:\n                break\n            # 存储弱分类器权重\n            self.estimator_errors_[iboost] = estimator_error\n            self.estimator_weights_[iboost] = estimator_weight\n            if estimator_error <= 0:\n                break\n        return self\n\n    def boost(self, X, y, sample_weight):\n        if self.algorithm_ == 'SAMME':\n            return self.boost_SAMME(X, y, sample_weight)\n        elif self.algorithm_ == 'SAMME.R':\n            return self.boost_SAMMER(X, y, sample_weight)\n\n    def boost_SAMMER(self, X, y, sample_weight): # SAMME.R\n        estimator = deepcopy(self.base_estimator_)\n        if self.random_state_:\n            estimator.set_params(random_state=1)\n        # 训练弱分类器\n        XXX\n        # 计算错误率\n        y_pred = XXX\n        incorrect = y_pred != y\n        estimator_error = XXX\n        \n        # 比随机猜还差，抛弃\n        if estimator_error >= 1.0 - 1 / self.n_classes_:\n            return None, None, None\n            \n        # 计算h(x)\n        y_predict_proba = estimator.predict_proba(X)\n        y_predict_proba[y_predict_proba < np.finfo(y_predict_proba.dtype).eps] = np.finfo(y_predict_proba.dtype).eps\n        y_codes = np.array([-1. / (self.n_classes_ - 1), 1.])\n        y_coding = y_codes.take(self.classes_ == y[:, np.newaxis])\n        \n        # 更新样本权重\n        intermediate_variable = (-1. * self.learning_rate_ * (((self.n_classes_ - 1) / self.n_classes_) * XXX\n        sample_weight = XXX\n        sample_weight_sum = np.sum(sample_weight, axis=0)\n        if sample_weight_sum <= 0:\n            return None, None, None\n        # 归一化权重\n        XXX\n        \n        # 存储当前弱分类器\n        self.estimators_.append(estimator)\n        return sample_weight, 1, estimator_error\n\n    def boost_SAMME(self, X, y, sample_weight): # SAMME\n        estimator = deepcopy(self.base_estimator_)\n        if self.random_state_:\n            estimator.set_params(random_state=1)\n\n        # 训练基分类器，计算结果\n        XXX\n        y_pred = XXX\n        incorrect = y_pred != y\n        \n        # 计算错误率\n        estimator_error = XXX\n        \n        # 分类效果比随机数还差，抛弃这种情况\n        if estimator_error >= 1 - 1 / self.n_classes_:\n            return None, None, None\n            \n        # 计算当前分类器权重\n        estimator_weight = XXX\n        \n        # 权重为负，无意义，抛弃\n        if estimator_weight <= 0:\n            return None, None, None\n            \n        # 更新样本权重\n        sample_weight = XXX\n        sample_weight_sum = np.sum(sample_weight, axis=0)\n        if sample_weight_sum <= 0:\n            return None, None, None\n            \n        # 归一化权重\n        sample_weight /= sample_weight_sum\n        \n        # 存储当前弱分类器\n        self.estimators_.append(estimator)\n        return sample_weight, estimator_weight, estimator_error\n\n    def predict(self, X):\n        n_classes = self.n_classes_\n        classes = self.classes_[:, np.newaxis]\n        pred = None\n        if self.algorithm_ == 'SAMME.R':\n            # SAMME.R权重均为1\n            pred = sum(self._samme_proba(estimator, n_classes, X) for estimator in self.estimators_)\n        else:  # SAMME\n            pred = sum((estimator.predict(X) == classes).T * w\n                       for estimator, w in zip(self.estimators_,\n                                               self.estimator_weights_))\n        pred /= self.estimator_weights_.sum()\n        if n_classes == 2:\n            pred[:, 0] *= -1\n            pred = pred.sum(axis=1)\n            return self.classes_.take(pred > 0, axis=0)\n        return self.classes_.take(np.argmax(pred, axis=1), axis=0)\n\n    def predict_proba(self, X):\n        if self.algorithm_ == 'SAMME.R':\n            # SAMME.R权重均为1\n            proba = sum(self._samme_proba(estimator, self.n_classes_, X)\n                        for estimator in self.estimators_)\n        else:  # SAMME\n            proba = sum(estimator.predict_proba(X) * w\n                        for estimator, w in zip(self.estimators_,\n                                                self.estimator_weights_))\n        proba /= self.estimator_weights_.sum()\n        proba = np.exp((1. / (self.n_classes_ - 1)) * proba)\n        normalizer = proba.sum(axis=1)[:, np.newaxis]\n        normalizer[normalizer == 0.0] = 1.0\n        proba /= normalizer\n        return proba\n``` \n\n<font color=red>注意：以上代码存储为文件 Multi_AdaBoost.py</font>\n\n（2）利用实现好的 `Adaboost` 框架（存储为文件`Multi_AdaBoost.py`）读取 `Iris数据集`，用80%的数据训练，20%的数据测试并进行多分类预测，根据精确率、召回率和 F1 值度量模型性能;\n`Iris数据集`包含了150个样本，每个样本有四个特征：花萼长度(sepal length)、花萼宽度(sepal width)、花瓣长度(petal length)和花瓣宽度(petal width)。除了样本数据外，每个样本还有一个对应的目标类别，即鸢尾花的品种。数据集内容如下表所示。\n\n| 特征名称  | 描述 |\n|----------|------|\n| 花萼长度 | 鸢尾花花萼的长度（单位：厘米） |\n| 花萼宽度 | 鸢尾花花萼的宽度（单位：厘米） |\n| 花瓣长度 | 鸢尾花花瓣的长度（单位：厘米） |\n| 花瓣宽度 | 鸢尾花花瓣的宽度（单位：厘米） |\n\n| 目标类别  | 描述 |\n|----------|------|\n| 山鸢尾   | 鸢尾花的一种品种（0） |\n| 变色鸢尾 | 鸢尾花的一种品种（1） |\n| 维吉尼亚鸢尾 | 鸢尾花的一种品种（2） |\n\n```python\nfrom sklearn import datasets\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier\nfrom Multi_AdaBoost import AdaBoostClassifier\n\n# 加载鸢尾花数据集\nXXX\n# 划分数据集，80%的训练数据，20%的测试数据\nXXX\nprint('数据集样本数：{},训练样本数：{},测试集样本数：{}'.format(len(X),len(X_train),len(X_test)))\n\n\n# 构造一个AdaBoost分类器并拟合训练数据，要求：\n\t# 使用的算法为SAMME.R\n\t# 弱分类器为DecisionTreeClassifier，最大深度为2\n\t# 弱分类器数量为4\n\t# 学习率为1\nXXX\nXXX\n\n# 构造一个AdaBoost分类器并拟合训练数据，要求：\n\t# 使用的算法为SAMME\n\t# 弱分类器为DecisionTreeClassifier，最大深度为2\n\t# 弱分类器数量为4\n\t# 学习率为1\nXXX\nXXX\n\nprint(\"SAMME\")\ny_pred = SAMME.predict(X_test)\nprint(\"精确率\",precision_score(y_test, y_pred, average='weighted'))\nprint(\"召回率\",recall_score(y_test, y_pred, average='weighted'))\nprint(\"F1度量值\",f1_score(y_test, y_pred, average='weighted'))\n\nprint(\"SAMME.R\")\nr_y_pred = SAMMER.predict(X_test)\nprint(\"精确率\",precision_score(y_test, r_y_pred, average='weighted'))\nprint(\"召回率\",recall_score(y_test, r_y_pred, average='weighted'))\nprint(\"F1度量值\",f1_score(y_test, r_y_pred, average='weighted'))\n```\n\n<font color=red>注意：以上代码存储为文件 AdaBoost_test.py</font>\n\n### 五、运行结果\n\n### 六、实验小结\n\n---\n\n\n## 机器学习实验（八）聚类分析\n\n### 一、实验目标\n\n1. 理解无监督聚类的基本含义；\n2. 理解 `k-means` 算法、谱聚类和层次聚类的基本思想；\n3. 掌握常用距离度量方法；\n4. 掌握 `k-means` 算法。\n\n### 二、实验任务\n\n1. 随机初始化一个数据集，基本构造有三个簇；\n2. 实现 `k-means` 算法，掌握欧式距离计算，调试不同的 k 值。\n\n### 三、实验要求\n\n1. 按实验内容撰写实验过程。\n2. 报告中涉及到的代码，每一个模块需要有详细的注释。\n\n### 四、实验记录\n\n```python\n# -*- encoding: utf8 -*-\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef eucl_distance(p1, p2):\n    \"\"\"\n    计算欧式距离\n    \"\"\"\n    return XXX\n\n\ndef init_centroids(data_set, k):\n    \"\"\"\n    随机初始化k个中心点\n    \"\"\"\n    num_samples, dim = data_set.shape\n    centroids = np.zeros((k, dim))\n    for i in range(k):\n        index = int(np.random.uniform(0, num_samples))\n        centroids[i, :] = data_set[index, :]\n    return centroids\n\n\ndef kmeans(data_set, k):\n    num_samples = data_set.shape[0]\n    cluster_assment = np.mat(np.zeros((num_samples, 2)))\n    cluster_changed = True\n    # step 1: 初始化k个中心点\n    centroids = init_centroids(data_set, k)\n    while cluster_changed:\n        cluster_changed = False\n        for i in range(num_samples):\n            min_dist = 100000.0\n            min_index = 0\n            # step 2: 计算最近距离的一个中心点\n            for j in range(k):\nXXX\n            ## step 3: 更新族群点\n\t\t\t\tXXX\n        ## step 4: 更新中心点\n        for j in range(k):\n \t\t\tXXX\n\n    return centroids, cluster_assment\n\n\ndef show_cluster(data_set, k, centroids, cluster_assment):\n    plt.title(u'Kmeans')\n    num_samples, dim = data_set.shape\n    mark = ['or', 'ob', 'og', 'ok', '^r', '+r', 'sr', 'dr', '<r', 'pr']\n    for i in range(num_samples):\n        mark_index = int(cluster_assment[i, 0])\n        plt.plot(data_set[i, 0], data_set[i, 1], mark[mark_index])\n\n    mark = ['Dr', 'Db', 'Dg', 'Dk', '^b', '+b', 'sb', 'db', '<b', 'pb']\n    for i in range(k):\n        plt.plot(centroids[i, 0], centroids[i, 1], mark[i], markersize=12)\n\n    plt.xlim(0.0, 100)\n    plt.ylim(0.0, 100)\n    plt.show()\n\n\ndef init_data(num, min, max):\n    data = []\n    for i in range(num):\n        data.append([np.random.randint(min, max), np.random.randint(min, max)])\n\n    return data\n\n\nif __name__ == \"__main__\":\n    data_set1 = init_data(10, 0, 30)\n    data_set2 = init_data(10, 30, 60)\n    data_set3 = init_data(10, 60, 100)\n    data_set = data_set1+data_set2+data_set3\n    data_set = np.mat(data_set)\n    k = 3\n    centroids, cluster_assment = kmeans(data_set, k)\n    show_cluster(data_set, k, centroids, cluster_assment)\nprint('finished')\n```\n\n### 五、运行结果\n\n1. 绘制出分类结果的图（k=3）\n\n2. 绘制出分类结果的图（k=6）\n\n### 六、实验小结","tags":["实验","机器学习"],"categories":["人工智能","机器学习"]},{"title":"DeepSeek接入到WPS（Word）中","url":"/post/c12ae0dc.html","content":"## 一、安装Office AI插件\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Office AI插件是一款基于人工智能的办公插件，支持Word、Excel、PPT等Office软件，可以帮助用户提高工作效率，提供了文档翻译、语音转文字、文档搜索等功能。用户可以在Office软件中直接使用这些功能，无需切换到其他应用，提高工作效率。插件[官网](https://www.office-ai.cn/)：https://www.office-ai.cn/\n\n1.下载`Office AI`插件安装包，单击`立即下载`按钮。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-1.png)\n\n2.选择下载途径，这里我选择`官方下载（速度快）`。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-2.png)\n\n3.下载完成后，双击安装包，按照提示安装插件,选择`我同意此协议(A)`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-3.png\" width=\"70%\" />\n\n4.选择`Office AI`插件安装位置。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-4.png\" width=\"70%\" />\n\n5.默认点击`Next`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-5.png\" width=\"70%\" />\n\n6.默认点击`I Agree`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-6.png\" width=\"70%\" />\n\n7.点击`Finish`完成下载。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-7.png\" width=\"70%\" />\n\n8.打开`WPS`，选项卡中多出了`OfficeAI`插件选项，点击后显示其功能。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-8.png)\n\n## 二、获取DeepSeek的API Key\n1.访问`DeepSeek`官网，注册账号并登录后点击`API开放平台`按钮。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-17.png)\n\n2.点击`API keys`按钮，创建`API key`并复制`key`。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-18.png)\n\n## 三、WPS（Word）中配置DeepSeek的API Key\n1.点击`Office AI`选项的`设置`。\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-9.png)\n\n2.在弹出的对话框中选择`大模型设置`，依次选择`模型平台`和`模型名`并填写步骤二获得的`API_KEY`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-10.png\" width=\"70%\" />\n\n3.安装私有化服务器。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-11.png\" width=\"70%\" />\n\n4.选择私有化服务器安装位置。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-12.png\" width=\"70%\" />\n\n5.默认点击`Next`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-13.png\" width=\"70%\" />\n\n6.选择`OfficeAI 本地服务开机自启动`并点击`Next`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-14.png\" width=\"70%\" />\n\n7.默认点击`Install`。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-15.png\" width=\"70%\" />\n\n8.点击`Finish`完成下载。\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/DeepSeek接入到WPS（Word）中/DeepSeek-Office-16.png\" width=\"70%\" />","tags":["教程","DeepSeek","WPS","Word"]},{"title":"firework","url":"/post/8ba9c08.html","content":"## 跨年快乐放烟花网页\n\n点击屏幕任意地方即可放烟花！\n\n<div id=\"fireworks-container\" style=\"position: relative; width: 100%; height: 100vh; background-color: #000; overflow: hidden;\">\n    <canvas id=\"fireworks-canvas\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\"></canvas>\n</div>\n\n<script>\n    const canvas = document.getElementById('fireworks-canvas');\n    const ctx = canvas.getContext('2d');\n\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n\n    function randomColor() {\n        return `hsl(${Math.random() * 360}, 100%, 50%)`;\n    }\n\n    function randomRange(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    class Firework {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n            this.color = randomColor();\n            this.particles = [];\n            this.createParticles();\n        }\n\n        createParticles() {\n            for (let i = 0; i < 50; i++) {\n                const angle = Math.random() * Math.PI * 2;\n                const speed = randomRange(2, 6);\n                const particle = {\n                    x: this.x,\n                    y: this.y,\n                    angle,\n                    speed,\n                    color: this.color,\n                    life: randomRange(60, 120),\n                    age: 0\n                };\n                this.particles.push(particle);\n            }\n        }\n\n        update() {\n            this.particles.forEach(particle => {\n                particle.x += Math.cos(particle.angle) * particle.speed;\n                particle.y += Math.sin(particle.angle) * particle.speed;\n                particle.age++;\n                if (particle.age >= particle.life) {\n                    particle.speed *= 0.95;\n                }\n            });\n        }\n\n        draw() {\n            this.particles.forEach(particle => {\n                ctx.fillStyle = particle.color;\n                ctx.beginPath();\n                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);\n                ctx.fill();\n            });\n        }\n    }\n\n    const fireworks = [];\n\n    function addFirework(event) {\n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        const firework = new Firework(x, y);\n        fireworks.push(firework);\n    }\n\n    canvas.addEventListener('click', addFirework);\n\n    function animate() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        fireworks.forEach((firework, index) => {\n            firework.update();\n            firework.draw();\n            if (firework.particles.every(particle => particle.age >= particle.life)) {\n                fireworks.splice(index, 1);\n            }\n        });\n        requestAnimationFrame(animate);\n    }\n\n    function enterFullScreen() {\n        const elem = document.getElementById('fireworks-container');\n        if (elem.requestFullscreen) {\n            elem.requestFullscreen();\n        } else if (elem.mozRequestFullScreen) { /* Firefox */\n            elem.mozRequestFullScreen();\n        } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */\n            elem.webkitRequestFullscreen();\n        } else if (elem.msRequestFullscreen) { /* IE/Edge */\n            elem.msRequestFullscreen();\n        }\n    }\n\n    window.onload = enterFullScreen;\n\n    animate();\n</script>","tags":["HTML","JavaScript","烟花"]},{"title":"从零开始学写脚本【第二天】","url":"/post/bc49d0da.html"},{"title":"从零开始学写脚本【第一天】","url":"/post/39ccbdd3.html","content":"## 一、新建项目\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-1.png)\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-2.png)\n\n## 二、安装 selenium\n\n> selenium 是浏览器自动化测试工具。\n\n控制台输入\n\n```bash\npip install selenium\n```\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-3.png)\n\n## 三、下载 Microsoft Edge WebDriver\n\n> 浏览器驱动，代码打开浏览器必须要有浏览器的驱动,不同版本的浏览器驱动也是不一样的\n>\n> **下载地址**：<https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/?form=MA13LH>\n\n**Microsoft Edge 浏览器 查看版本**\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-4.png)\n\n\n打开 <https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/?form=MA13LH>\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-5.png)\n\n**随意解压至一个目录**\n\n## 四、代码打开浏览器\n1.新建 openEdgedriver.py 文件\n\n2.写入代码\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.edge.service import Service\n\n# 指定 WebDriver 路径\npath = \"D:/temp/msedgedriver.exe\"  # 替换为你的 msedgedriver.exe 路径\n\n# 使用 Service 类\nservice = Service(path)\nbrowser = webdriver.Edge(service=service)\n\n# 打开 百度网页\nbrowser.get('[edge://newtab/](https://www.baidu.com)')\n\n# 防止浏览器退出\ninput(\"按回车键退出...\")\nbrowser.quit()\n```\n3.运行 openEdgedriver.py 文件\n\n**将自动打开浏览器并且访问目标页面 [edge://newtab/](https://www.baidu.com)**\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-6.png)\n\n## 五、实现页面里搜索框输入内容，并点击查询\n\n既然是脚本，我们不能只是访问页面，肯定还要有点击事件\n\n> 进入页面 <https://www.baidu.com> 查看页面源代码，我们发现，输入框\\<input>标签的 id 为 search-blog-words ；查询按钮\\<a> 标签有个属性 class ,为 btn-search-blog\n\n查询 id 为 search-blog-words的属性，向其输入“京东准点秒杀脚本”\n\n> browser.find\\_element\\_by\\_id(\"search-blog-words\").send\\_keys(\"京东准点秒杀脚本\")\n\n查询按钮 clsss 名称为 btn-search-blog 的标签，点击按钮\n\n> browser.find\\_element\\_by\\_class\\_name('btn-search-blog').click()\n\n**分别是输入内容，点击查询。新修改后的代码为**\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.edge.service import Service\nfrom selenium.webdriver.common.by import By  # 导入 By 类\n\n# 指定 WebDriver 路径\npath = \"D:/temp/msedgedriver.exe\"  # 替换为你的 msedgedriver.exe 路径\n\n# 使用 Service 类\nservice = Service(path)\nbrowser = webdriver.Edge(service=service)\n\n# 打开百度首页\nbrowser.get('https://www.baidu.com')\n\n# 定位搜索框并输入内容\nbrowser.find_element(By.ID, \"kw\").send_keys(\"人间词话\")  # 输入内容\n\n# 定位搜索按钮并点击\nbrowser.find_element(By.ID, \"su\").click()  # 点击搜索按钮\n\n# 防止浏览器退出\ninput(\"按回车键退出...\")\nbrowser.quit()\n```\n\n再次运行代码\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/脚本/day1-7.png)","tags":["Script"]},{"title":"Mirror Maze","url":"/post/593f2d9e.html","content":"# [I-Mirror Maze\\_2024牛客暑期多校训练营1](https://ac.nowcoder.com/acm/contest/81596/I)\n\n## **题目大意**\n\n有一个 *n × m* 的矩形镜子迷宫，镜子有 “*\\\\*, /, -, |” 四种，每种镜子有特定的光线反射方向，注意直接通过镜子的情况不算被反射。\n\n有 *q* 个询问，每个询问给定一个点光源 (*x, y, dir*)，表示在 (*x, y*) 位置向 *dir* 方向发射一束光线，问经过足够的时间之后，这束光线被多少个不同的镜子反射过。\n\n*1 ≤ n, m ≤ 1000, 1 ≤ q ≤ 10<sup>5</sup>*   \n\n## **题解**\n\n因为光路可逆，所以不可能有光束分叉或者汇合的情况，所以所有的光束会构成若干个环和若干条链。\n\n所以我们要做的就是把这些光环和光链抽出来，然后预处理出每个点光源的答案，询问就查表 *O(1)* 回答即可。\n\n时间复杂度：*O(nm + q)*。\n\n## **代码**\n```CPP\n#include \n#define pii pair\n#define tii tuple\n#define all(a) a.begin(), a.end()\nusing namespace std;\nconst int maxn = 1e3 + 10;\nchar ch[maxn][maxn];\nint n, m, ans[maxn][maxn][4];\nint vis[maxn][maxn][4];\nvector vec;//存储经过了哪些镜子的哪些状态\nbool istan(int x, int y, int dir) {  // 标记某个状态是否会经过镜子的反射\n    char tem = ch[x][y];\n    if (tem == '/' || tem == '\\\\')\n        return 1;\n    if (tem == '-' && (dir == 0 || dir == 1))\n        return 1;\n    if (tem == '|' && (dir == 2 || dir == 3))\n        return 1;\n    return 0;\n}\nvoid dfs(int x, int y, int dir) {\n    // 根据题意模拟反射过程，越界（链）或者访问过（环）退出\n    if (x < 1 || x > n || y < 1 || y > m)  // 链的退出条件\n        return;\n    if (vis[x][y][dir])  // 环的退出条件\n        return;\n    vec.push_back(tii(x, y, dir));\n    vis[x][y][dir] = 1;\n    if (ch[x][y] == '/') {\n        if (dir == 0) {\n            dfs(x, y + 1, 3);\n        } else if (dir == 1) {\n            dfs(x, y - 1, 2);\n        } else if (dir == 2) {\n            dfs(x + 1, y, 1);\n        } else {\n            dfs(x - 1, y, 0);\n        }\n    } else if (ch[x][y] == '\\\\') { //注意多加一个'\\'\n        if (dir == 0) {\n            dfs(x, y - 1, 2);\n        } else if (dir == 1) {\n            dfs(x, y + 1, 3);\n        } else if (dir == 2) {\n            dfs(x - 1, y, 0);\n        } else {\n            dfs(x + 1, y, 1);\n        }\n    } else if (ch[x][y] == '-') {\n        if (dir == 0) {\n            dfs(x + 1, y, 1);\n        } else if (dir == 1) {\n            dfs(x - 1, y, 0);\n        } else if (dir == 2) {\n            dfs(x, y - 1, 2);\n        } else\n            dfs(x, y + 1, 3);\n    } else if (ch[x][y] == '|') {\n        if (dir == 0)\n            dfs(x - 1, y, 0);\n        else if (dir == 1)\n            dfs(x + 1, y, 1);\n        else if (dir == 2) {\n            dfs(x, y + 1, 3);\n        } else {\n            dfs(x, y - 1, 2);\n        }\n    }\n}\nvoid solve1(int x, int y, int dir) {\n    // 处理链\n    vec.clear();\n    dfs(x, y, dir);\n    reverse(all(vec));  // 倒叙遍历状态更新答案\n    set s;\n    for (auto [a, b, c] : vec) {\n        if (istan(a, b, c))\n            s.insert(pii(a, b));\n        ans[a][b][c] = s.size();\n    }\n}\nvoid solve2(int x, int y, int dir) {\n    // 处理环\n    vec.clear();\n    dfs(x, y, dir);\n    set s;\n    for (auto [a, b, c] : vec) {\n        if (istan(a, b, c))\n            s.insert(pii(a, b));\n    }\n    for (auto [a, b, c] : vec)\n        ans[a][b][c] = s.size();  // 环上的答案都一样\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            cin >> ch[i][j];\n    /***** 0，1，2，3分别表示为向上、下、左、右射入的光线 *****/\n    // 从边界射入的光线一定是链\n    for (int i = 1; i <= n; i++)\n        solve1(i, 1, 3), solve1(i, m, 2);\n    for (int j = 1; j <= m; j++)\n        solve1(1, j, 1), solve1(n, j, 0);\n    // 还未访问的状态，一定是环上的状态\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            for (int k = 0; k < 4; k++)\n                if (!vis[i][j][k]) {\n                    solve2(i, j, k);\n                }\n    int q;\n    cin >> q;\n    map mp;\n    mp[\"above\"] = 0;\n    mp[\"below\"] = 1;\n    mp[\"left\"] = 2;\n    mp[\"right\"] = 3;\n    while (q--) {\n        int x, y;\n        string str;\n        cin >> x >> y >> str;\n        // 先根据方向偏移一格\n        int tem = mp[str];\n        if (tem == 0)\n            x--;\n        else if (tem == 1)\n            x++;\n        else if (tem == 2)\n            y--;\n        else\n            y++;\n        cout << ans[x][y][tem] << \"\\n\";\n    }\n    return 0;\n}\n```","tags":["Mirror Maze","ACM"]},{"title":"脚本","url":"/post/72b5a919.html","content":"### 一、脚本是什么？\n脚本（Script）是一种由计算机执行的程序代码，通常用于自动化任务或控制软件行为。它由一系列指令组成，解释器或脚本引擎可以直接执行这些指令，而无需编译成机器码。脚本语言（如Python、JavaScript、Bash等）常用于编写脚本。\n\n### 二、脚本的主要特点：\n1. **解释执行**：脚本通常由解释器逐行执行，无需编译。\n2. **轻量级**：适合快速开发和小型任务。\n3. **跨平台**：许多脚本语言可在多个操作系统上运行。\n4. **自动化**：常用于自动化重复性任务，如文件处理、系统管理等。\n\n### 三、常见脚本语言：\n- **Python**：广泛用于自动化、数据处理和Web开发。\n- **JavaScript**：主要用于Web前端和Node.js后端开发。\n- **Bash**：用于Linux/Unix系统的命令行脚本。\n- **PowerShell**：Windows系统的自动化脚本语言。\n- **Ruby**：适合Web开发和脚本编写。\n\n### 四、脚本的应用场景：\n- **自动化任务**：如批量文件处理、定时任务。\n- **系统管理**：如配置服务器、监控系统。\n- **Web开发**：如前端交互、后端逻辑。\n- **数据处理**：如数据清洗、分析。\n\n### 五、示例：\n- **Python脚本**：\n  ```python\n  print(\"Hello, World!\")\n  ```\n- **Bash脚本**：\n  ```bash\n  #!/bin/bash\n  echo \"Hello, World!\"\n  ```\n\n总结来说，脚本是一种灵活的工具，适用于快速开发和任务自动化。\n\n### 六、十五个Python脚本\n#### 1. Hello, World!\n\n所有程序员的经典起点，这个脚本介绍了Python语法的基础。\n\n```Python\nprint(\"Hello, World!\")   \n```\n\n#### 2. 简易计算器\n\n创建一个基本的计算器，执行加法、减法、乘法和除法。\n\n```Python\ndef calculator():       operation = input(\"选择操作（+，-，*，/）：\")       num1 = float(input(\"输入第一个数字：\"))       num2 = float(input(\"输入第二个数字：\"))          if operation == '+':           print(f\"{num1} + {num2} = {num1 + num2}\")       elif operation == '-':           print(f\"{num1} - {num2} = {num1 - num2}\")       elif operation == '*':           print(f\"{num1} * {num2} = {num1 * num2}\")       elif operation == '/':           print(f\"{num1} / {num2} = {num1 / num2}\")       else:           print(\"无效操作\")      calculator()   \n```\n\n#### 3. 猜数字\n\n这个游戏随机选择一个1到100之间的数字，玩家必须猜出它。\n\n```Python\nfrom PIL import Image   import os      def batch_resiimport random   def guess_the_number():       number_to_guess = random.randint(1, 100)       guess = None          while guess != number_to_guess:           guess = int(input(\"猜一个1到100之间的数字：\"))           if guess < number_to_guess:               print(\"太低了！\")           elif guess > number_to_guess:               print(\"太高了！\")           else:               print(\"恭喜你！你猜对了。\")      guess_the_number()import random   def guess_the_number():       number_to_guess = random.randint(1, 100)       guess = None          while guess != number_to_guess:           guess = int(input(\"猜一个1到100之间的数字：\"))           if guess < number_to_guess:               print(\"太低了！\")           elif guess > number_to_guess:               print(\"太高了！\")           else:               print(\"恭喜你！你猜对了。\")      guess_the_number()ze(folder, width, height):       for filename in os.listdir(folder):           if filename.endswith(('.jpeg', '.jpg', '.png')):               img = Image.open(os.path.join(folder, filename))               img = img.resize((width, height))               img.save(os.path.join(folder, f\"resized_{filename}\"))               print(f'调整了 {filename} 的大小')      batch_resize('/path/to/images', 800, 600)   \n```\n\n#### 4. 石头剪刀布\n\n实现经典的石头、剪刀、布游戏。\n\n```Python\nimport random   def rock_paper_scissors():       choices = ['rock', 'paper', 'scissors']       computer_choice = random.choice(choices)       user_choice = input(\"选择石头、剪刀或布：\").lower()          if user_choice not in choices:           print(\"无效选择\")           return          print(f\"计算机选择了：{computer_choice}\")       if user_choice == computer_choice:           print(\"平局！\")       elif (user_choice == 'rock' and computer_choice == 'scissors') or \\            (user_choice == 'scissors' and computer_choice == 'paper') or \\            (user_choice == 'paper' and computer_choice == 'rock'):           print(\"你赢了！\")       else:           print(\"你输了！\")      rock_paper_scissors()   \n```\n\n#### 5. 待办事项列表\n\n创建一个简单的待办事项列表应用程序。\n\n```Python\ndef to_do_list():       tasks = []          while True:           action = input(\"输入 'add' 添加任务，'remove' 删除任务，'view' 查看所有任务，或 'quit' 退出：\").lower()           if action == 'add':               task = input(\"输入一个任务：\")               tasks.append(task)           elif action == 'remove':               task = input(\"输入要删除的任务：\")               if task in tasks:                   tasks.remove(task)               else:                   print(\"任务未找到\")           elif action == 'view':               print(\"任务：\", tasks)           elif action == 'quit':               break           else:               print(\"无效操作\")      to_do_list()   \n```\n\n#### 6. 基础网页抓取器\n\n学习使用BeautifulSoup进行基础的网页抓取。\n\n```Python\nimport requests   from bs4 import BeautifulSoup      def web_scraper():       url = 'http://example.com'       response = requests.get(url)       soup = BeautifulSoup(response.content, 'html.parser')       print(soup.prettify())   web_scraper()   \n```\n\n#### 7. 天气应用\n\n使用API获取指定城市的天气数据。\n\n```Python\nimport requests   def weather_app():       api_key = 'your_api_key'       city = input(\"输入城市名称：\")       url = f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}'          response = requests.get(url)       data = response.json()          if data['cod'] == 200:           main = data['main']           temperature = main['temp']           weather = data['weather'][0]['description']           print(f\"温度：{temperature}\")           print(f\"天气：{weather}\")       else:           print(\"城市未找到\")      weather_app()   \n```\n\n#### 8. 填词游戏生成器\n\n创建一个有趣的填词游戏，用户通过输入完成一个故事。\n\n```Python\ndef mad_libs():       noun = input(\"输入一个名词：\")       adjective = input(\"输入一个形容词：\")       verb = input(\"输入一个动词：\")       place = input(\"输入一个地点：\")          story = f\"从前，有一个喜欢在{place}做{verb}的{adjective} {noun}。\"       print(story)      mad_libs()   \n```\n\n#### 9. 斐波那契数列\n\n生成到指定数字的斐波那契数列。\n\n```Python\ndef fibonacci_sequence(n):       sequence = [0, 1]       while len(sequence) < n:           sequence.append(sequence[-1] + sequence[-2])       print(sequence)   fibonacci_sequence(10)   \n```\n\n#### 10. 密码生成器\n\n创建一个脚本，生成一个随机的安全密码。\n\n```Python\nimport random   import string      def password_generator(length=12):       characters = string.ascii_letters + string.digits + string.punctuation       password = ''.join(random.choice(characters) for i in range(length))       print(password)      password_generator()   \n```\n\n#### 11. 吊死鬼游戏\n\n创建一个经典的吊死鬼游戏，玩家猜测字母以揭示隐藏的单词。\n\n```Python\nimport random   def hangman():       words = ['python', 'java', 'swift', 'javascript']       word = random.choice(words)       guessed_letters = set()       attempts = 6          while attempts > 0:           display_word = ''.join([letter if letter in guessed_letters else '_' for letter in word])           print(display_word)                      if '_' not in display_word:               print(\"恭喜你！你猜对了单词。\")               break              guess = input(\"猜一个字母：\").lower()           if guess in guessed_letters:               print(\"你已经猜过那个字母了。\")           elif guess in word:               guessed_letters.add(guess)           else:               attempts -= 1               print(f\"猜错了。你还有{attempts}次机会。\")              if attempts == 0:           print(f\"游戏结束！单词是'{word}'。\")      hangman()   \n```\n\n#### 12. 质数检查器\n\n编写一个脚本，检查给定的数字是否为质数。\n\n```Python\ndef is_prime(n):       if n <= 1:           return False       for i in range(2, int(n**0.5) + 1):           if n % i == 0:               return False       return True      number = int(input(\"输入一个数字：\"))   if is_prime(number):       print(f\"{number} 是一个质数。\")   else:       print(f\"{number} 不是一个质数。\")\n```\n\n#### 13. 货币转换器\n\n创建一个简单的货币转换器，使用 API 获取最新的汇率。\n\n```Python\nimport requests   def currency_converter():       api_key = 'your_api_key'       base_currency = input(\"输入基准货币（例如，USD）：\").upper()       target_currency = input(\"输入目标货币（例如，EUR）：\").upper()       amount = float(input(\"输入金额：\"))          url = f'https://api.exchangerate-api.com/v4/latest/{base_currency}'       response = requests.get(url)       data = response.json()              if target_currency in data['rates']:           exchange_rate = data['rates'][target_currency]           converted_amount = amount * exchange_rate           print(f\"{amount} {base_currency} 等于 {converted_amount:.2f} {target_currency}\")       else:           print(\"货币不支持。\")      currency_converter()   \n```\n\n#### 14. BMI计算器\n\n创建一个脚本，根据用户输入计算身体质量指数（BMI）。\n\n```Python\ndef bmi_calculator():       height = float(input(\"输入身高（米）：\"))       weight = float(input(\"输入体重（千克）：\"))       bmi = weight / (height ** 2)       print(f\"你的BMI是：{bmi:.2f}\")              if bmi < 18.5:           print(\"你体重过轻。\")       elif 18.5 <= bmi < 24.9:           print(\"你体重正常。\")       elif 25 <= bmi < 29.9:           print(\"   \n```\n\n#### 15. 井字棋游戏\n\n创建一个可供两人游玩的井字棋游戏。\n\n```Python\ndef print_board(board):       for row in board:           print(\" | \".join(row))           print(\"-\" * 5)   def check_winner(board, player):       for row in board:           if all([cell == player for cell in row]):               return True       for col in range(3):           if all([board[row][col] == player for row in range(3)]):               return True       if all([board[i][i] == player for i in range(3)]) or all([board[i][2-i] == player for i in range(3)]):           return True       return False   def tic_tac_toe():       board = [[' ' for _ in range(3)] for _ in range(3)]       players = ['X', 'O']       turn = 0          for _ in range(9):           print_board(board)           player = players[turn % 2]           print(f\"Player {player}'s turn\")           row = int(input(\"Enter row (0, 1, 2): \"))           col = int(input(\"Enter column (0, 1, 2): \"))              if board[row][col] == ' ':               board[row][col] = player               if check_winner(board, player):                   print_board(board)                   print(f\"Player {player} wins!\")                   return               turn += 1           else:               print(\"Cell already taken. Try again.\")          print_board(board)       print(\"It's a tie!\")      tic_tac_toe()   \n```\n\n### 总结\n\n这十五个脚本涵盖了一系列基础的Python概念，并为初学者提供了坚实的基础。通过这些项目的实践，新程序员可以建立起信心，并逐渐解决Python中更复杂的问题。\n","tags":["Script"]},{"title":"Python爬虫","url":"/post/c386cf1b.html","content":"# 前言\n\n由于专业选修大数据的结课小组作业里，有一个爬虫的分工，我自告奋勇选择这部分工作，希望以此作为动力让自己学习一下早就听说但一直没有去做的爬虫工作，这里就把学习到的部分以及作业过程里的一些经验和代码分享一下，希望能够帮助到需要爬取**B站**，**知乎**和**微博**数据的人们。\n\n过程中参考了一些文章，以下3个链接是源代码的来源：\\\n[知乎爬虫](https://zhuanlan.zhihu.com/p/587307689 \"知乎爬虫\")\\\n[B站爬虫](https://gitcode.com/gh_mirrors/bi/Bilivideoinfo \"B站爬虫\")\\\n[微博爬虫](https://blog.csdn.net/m0_46235332/article/details/122682412 \"微博爬虫\")\n\n所有的完整源码放在我的Github仓库里\\\n[爬虫完整代码Github链接](https://github.com/FunTotal/Crawler \"爬虫完整代码Github链接\")\n\n# 基础知识\n\n如果有学习过计算机网络的话，应该会对浏览器的原理有一些基本了解。（下面这些是我凭自己的认识说的，不一定保真）浏览器在访问网址时，会发送数据包，服务器接收请求后就会把网站的HTML代码发过来，最后我们看到的效果是这段HTML代码渲染后的结果，当然我们需要的信息肯定也包含正在这段HTML代码里。\n\n而爬虫就是模拟浏览器，快速向需要的网页发送请求，接受HTML代码后直接从里面提取需要的信息，之后继续向下一个网页发送请求。所以实际上爬虫能爬取到的信息，从人工角度也都是手动能看到的信息。但是由于爬虫因为速度远快于真实的人类，所以会对网站造成负担，所以大部分的网站都是不支持爬虫这种行为，当然我们在爬虫的过程也会通过伪装，让网站看不出来我们是爬虫。而且爬虫的时候还要注意遵守法律，不要做违法的事情。\n\n## Cookie\n\n### Cookie介绍\n\n然后是大部分网站的爬虫都需要我们提供一个Cookie才能进行爬取，Cookie在我的理解里就是网站登录账号后的凭证，有了Cookie后对网页发送请求，在网页的视角上看就是一个登录账号的用户发送的请求。不然现在很多网站都有登录才能查看完整内容的限制，没有Cookie就爬取不了，而且某种程度上需要Cookie也起到了反爬虫的效果。\n\n### Cookie查看\n\n那么要如何查看自己的Cookie，首先在浏览器（我以EDGE浏览器为例）打开目标网站后按下F12启动开发者模式，然后选择**网络**一栏，并且注意**禁用缓存**。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120110442096-862140735.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120110442096-862140735.png>)\\\n此时浏览器就可以进入类似Wireshark一样的抓包模式，再次**按下F5刷新网页**，就能够看到浏览器捕获了很多的数据包，在筛选器一栏选中**Fetch/XHR**后，随便点几个包，往下拉就能够看到在请求标头里会有Cookie字段。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120110731085-1650259284.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120110731085-1650259284.png>)\\\n上图中马赛克掉的一大段就是知乎的Cookie（Cookie是有隐私性的，拥有别人的Cookie相当于登录别人的账号，所以Cookie需要保护好，不能在网上暴露）\\\n如果再下拉，还能看到UA字段\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120112912925-619349750.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120112912925-619349750.png>)\\\n这个就代表着你的电脑的信息，所以在爬虫的时候，一般也会附上这个信息，来伪装的更像一个浏览器，为了装的更像一点，可以多准备几个UA，每次爬虫的时候随机选取一个，能够伪装的更好。\n\n# Bilibili\n\n## 功能\n\n需要自己准备希望爬取的链接代码，可以爬取对应链接视频的标题、标签、作者、播放量、点赞投币收藏等数据，不需要Cookie。\n\n## 介绍\n\n爬取B站视频我采用的是下面仓库地址的源代码\\\n[B站爬虫](https://gitcode.com/gh_mirrors/bi/Bilivideoinfo \"B站爬虫\")\\\n它需要你先准备好一个文件，里面是需要爬取的B站链接，之后运行代码就可以爬取这些链接的很多信息，并且爬取失败的也会记录下来哪些失败了。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120113509501-1345055223.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120113509501-1345055223.png>)\n\n那么怎么准备待爬取链接，我的做法是去Github上找一下别人备份的B站热门榜历史数据，里面有记录每一天B站热门视频的链接，然后把那些链接提取到一个文件里，之后就可以进行爬取。\n\n## 代码\n\n点击查看代码\n\n**\n\nhighlighter- python\n\n```\nimport re\nimport requests\nfrom bs4 import BeautifulSoup\nfrom openpyxl import Workbook\nimport random\nimport time\n\ndef write_error_log(message):\n    with open(\"video_errorlist.txt\", \"a\") as file:\n        file.write(message + \"\\n\")\n\ndef is_url(video_id_or_url):\n    return video_id_or_url.startswith(\"http\") or video_id_or_url.startswith(\"https\")\n\ndef get_video_url(video_id_or_url):\n    if is_url(video_id_or_url):\n        return video_id_or_url\n    else:\n        return f\"https://www.bilibili.com/video/{video_id_or_url}\"\n\n# 反爬虫\nagent = [\n            'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0',\n            'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)',\n            'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11',\n            'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'\n            'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Mobile Safari/537.36'\n        ]\nua = random.choice(agent)\n\n\nheaders = {\n    'user-agent': ua,#UserAgent().chrome,\n    'Referer':'https://www.bilibili.com/',\n    'x-requested-with': 'XMLHttpRequest'\n}\n\ninput_file = \"idlist.txt\" #待爬取链接存在这个文件里\noutput_file = \"output.xlsx\"\n\nnew_wb = Workbook()\nnew_ws = new_wb.active\nnew_ws.append(\n    [\"标题\", \"链接\", \"up主\", \"up主id\", \"精确播放数\", \"历史累计弹幕数\", \"点赞数\", \"投硬币枚数\", \"收藏人数\", \"转发人数\",\n     \"发布时间\", \"视频时长(秒)\", \"视频简介\", \"作者简介\", \"标签\", \"视频aid\"])\n\nwith open(input_file, \"r\") as file:\n    id_list = file.readlines()\n\ni = 0\nfor video_id_or_url in id_list:\n    i += 1\n    url = get_video_url(video_id_or_url.strip())\n    try:\n        # time.sleep(1)\n        response = requests.get(url, headers=headers)\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # 视频 aid、视频时长和作者 id\n        initial_state_script = soup.find(\"script\", text=re.compile(\"window.__INITIAL_STATE__\"))\n        initial_state_text = initial_state_script.string\n\n        author_id_pattern = re.compile(r'\"mid\":(\\d+)')\n        video_aid_pattern = re.compile(r'\"aid\":(\\d+)')\n        video_duration_pattern = re.compile(r'\"duration\":(\\d+)')\n\n        author_id = author_id_pattern.search(initial_state_text).group(1)\n        video_aid = video_aid_pattern.search(initial_state_text).group(1)\n        video_duration_raw = int(video_duration_pattern.search(initial_state_text).group(1))\n        video_duration = video_duration_raw - 2\n\n        # 提取标题\n        title_raw = soup.find(\"title\").text\n        title = re.sub(r\"_哔哩哔哩_bilibili\", \"\", title_raw).strip()\n\n        # 提取标签\n        keywords_content = soup.find(\"meta\", itemprop=\"keywords\")[\"content\"]\n        content_without_title = keywords_content.replace(title + ',', '')\n        keywords_list = content_without_title.split(',')\n        tags = \",\".join(keywords_list[:-4])\n\n        meta_description = soup.find(\"meta\", itemprop=\"description\")[\"content\"]\n        numbers = re.findall(\n            r'[\\s\\S]*?视频播放量 (\\d+)、弹幕量 (\\d+)、点赞数 (\\d+)、投硬币枚数 (\\d+)、收藏人数 (\\d+)、转发人数 (\\d+)',\n            meta_description)\n\n        # 提取作者\n        author_search = re.search(r\"视频作者\\s*([^,]+)\", meta_description)\n        if author_search:\n            author = author_search.group(1).strip()\n        else:\n            author = \"未找到作者\"\n\n        # 提取作者简介\n        author_desc_pattern = re.compile(r'作者简介 (.+?),')\n        author_desc_match = author_desc_pattern.search(meta_description)\n        if author_desc_match:\n            author_desc = author_desc_match.group(1)\n        else:\n            author_desc = \"未找到作者简介\"\n\n        # 提取视频简介\n        meta_parts = re.split(r',\\s*', meta_description)\n        if meta_parts:\n            video_desc = meta_parts[0].strip()\n        else:\n            video_desc = \"未找到视频简介\"\n\n        if numbers:\n            views, danmaku, likes, coins, favorites, shares = [int(n) for n in numbers[0]]\n            publish_date = soup.find(\"meta\", itemprop=\"uploadDate\")[\"content\"]\n            new_ws.append([title, url, author, author_id, views, danmaku, likes, coins, favorites, shares, publish_date, video_duration, video_desc, author_desc, tags, video_aid])\n            print(f\"第{i}行视频{url}已完成爬取\")\n        else:\n            print(f\"第{i}行视频 {url}未找到相关数据，可能为分集视频\")\n\n    except Exception as e:\n        write_error_log(f\"第{i}行视频发生错误：{e}\")\n        print(f\"第{i}行发生错误，已记录到错误日志:出错数据为{video_id_or_url}\")\n\nnew_wb.save(output_file)\n```\n\n# 知乎\n\n## 功能\n\n爬取一个问题下的回答内容和回答的创建时间\n\n## 介绍\n\n知乎的爬取是依据以下链接文章里的教程\\\n[知乎爬虫](https://zhuanlan.zhihu.com/p/587307689 \"知乎爬虫\")\\\n大致思路是发现知乎的回答里会有一个包，指向下一个回答的id，就类似链表一样，从一个初始的链接开始，不断地把下一个回答的id存起来，就把问题下的回答的id都记录下来，之后再根据这些id爬取对应的回答内容。\\\n具体的，分为两个文件，第一个crawler.py就是记录answer\\_id，第二个crawler2.py是根据answer\\_id爬取内容，下面会介绍一下具体怎么修改代码来爬取需要的内容。\n\n## 需要修改的内容\n\n首先是crawler.py里的template\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120115908028-348043365.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120115908028-348043365.png>)\n\n需要在待爬取问题，类似找Cookie一样，找到下面这个包 feeds?...这个包，里面的请求URL替换掉crawler.py里的template。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120114629184-286111761.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120114629184-286111761.png>)\n\n记得网址里面的offset=后面要加一个{offset}，就是模仿之前写在那里的格式\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120120257903-1894029061.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120120257903-1894029061.png>)\n\n然后是代码里的Cookie替换为自己知乎的Cookie，贴在单引号里面\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120120403580-3517804.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120120403580-3517804.png>)\n\n最后把代码里headers里的refer也换一下（这个好像不换也行，但我是换了），refer字段就在Cookie下面一点\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120120550647-1354037006.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120120550647-1354037006.png>)\n\n**\n\nhighlighter- 1c\n\n```\nheaders = {\n    'cookie' : cookie,\n    'user-agent': ua,#UserAgent().chrome,\n    'Referer':'https://www.zhihu.com/question/654859896/answer/3487198664',\n    'x-requested-with': 'XMLHttpRequest'\n}\n```\n\n之后就可以爬取，对于保存信息方面，实测知乎的反爬有点强，爬个两百多面就提示说对方主机强制断开连接，所以可以在代码设置一下每爬取若干页就保存一次。\n\n**\n\nhighlighter- reasonml\n\n```\n    # 每隔100条保存一次信息\n    if (page % 100 == 0):\n        df = pd.DataFrame({'answer_id': answer_ids})  # 重新创建df\n        df.to_csv('answer_id.csv', index=True)\n```\n\n然后就可以使用crawler2.py来爬取这些answerid对应的回答，需要在crawler2.py里修改下面红线标出的部分，Cookie和refer和前面类似，下面那个url那里记得把问题的id换成对应的你要爬取的那个问题的id，就是网页地址里面能明显看出来。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120121047473-648090074.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120121047473-648090074.png>)\n\n之后运行就可以爬取了，同样记得每隔一段保存一次，代码里是直接保存在不同的文件里，我通过clean.py进行整合和去重。具体的应该看看clean.py就知道怎么改了，只要修改一下文件路径基本就ok。\n\n## 完整代码\n\n### crawler.py\n\n点击查看代码\n\n**\n\nhighlighter- llvm\n\n```\nimport requests\nimport pandas as pd\nimport time\nimport random\n\ntemplate = 'https://www.zhihu.com/api/v4/questions/656533798/feeds?include=data%5B*%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cattachment%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Cis_labeled%2Cpaid_info%2Cpaid_info_content%2Creaction_instruction%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%3Bdata%5B*%5D.author.follower_count%2Cvip_info%2Ckvip_info%2Cbadge%5B*%5D.topics%3Bdata%5B*%5D.settings.table_of_content.enabled&offset={offset}&limit=3&order=default&ws_qiangzhisafe=1&platform=desktop'\n\n\n\ndf = pd.DataFrame()\n# df有三列，answer_id和content以及创建日期\ndf['answer_id'] = []\ndf['content'] = []\ndf['created_time'] = []\n\nanswer_ids = []\n\nagent = [\n            'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0',\n            'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)',\n            'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11',\n            'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'\n            'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Mobile Safari/537.36'\n        ]\nua = random.choice(agent)\n\ncookies = [\n    ''\n]\ncookie = random.choice(cookies)\nheaders = {\n    'cookie' : cookie,\n    'user-agent': ua,#UserAgent().chrome,\n    'Referer':'https://www.zhihu.com/question/654859896/answer/3487198664',\n    'x-requested-with': 'XMLHttpRequest'\n}\n\n\n# 第一条使用模版，后面的都是next来获取\nurl0 = template.format(offset=0)\nresp0 = requests.get(url0, headers=headers)\nfor data in resp0.json()['data']:\n        answer_id = data['target']['id']\n        answer_ids.append(answer_id)\nnext = resp0.json()['paging']['next']\n\nfor page in range(1,5001):# 这里自己估算一下，每页是5条数据\n    #对第page页进行访问\n    headers1 = {\n    'cookie' : random.choice(cookies),\n    'user-agent': random.choice(agent),#UserAgent().chrome,\n    'Referer':'https://www.zhihu.com/question/654859896/answer/3487198664',\n    'x-requested-with': 'XMLHttpRequest'\n    }\n    resp = requests.get(next, headers=headers1)\n    print('正在爬取第' + str(page) + '页')\n    \n    for data in resp.json()['data']:\n        answer_id = data['target']['id']\n        # 添加answer_id到df中\n        answer_ids.append(answer_id)\n    next = resp.json()['paging']['next']\n    time.sleep(random.randint(1,4))\n    # 每隔100条保存一次信息\n    if (page % 100 == 0):\n        df = pd.DataFrame({'answer_id': answer_ids})  # 重新创建df\n        df.to_csv('answer_id.csv', index=True)\n```\n\n### crawler2.py\n\n点击查看代码\n\n**\n\nhighlighter- python\n\n```\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nimport random\nimport requests\nimport pandas as pd\nimport time\nimport random\n\ncontents = []\ncreated_times = []\nagent = [\n            'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0',\n            'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)',\n            'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11',\n            'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'\n            'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Mobile Safari/537.36'\n        ]\nua = random.choice(agent)\n\n\n\nheaders = {\n    'cookie' : '',\n    'user-agent': ua,#UserAgent().chrome,\n    'Referer':'https://www.zhihu.com/question/654859896/answer/3487198664',\n    'x-requested-with': 'XMLHttpRequest'\n}\n\n# 读取answer_id.csv文件\ndf = pd.read_csv('answer_id.csv')\n\n# 提取answer_id列\nanswer_ids = df['answer_id'].tolist()\ncookies = [\n    ''\n]\nbatch = 0\nfor answer_id in answer_ids:\n    print('正在爬取answer_id为{answer_id}的数据'.format(answer_id=answer_id))\n    url = 'https://www.zhihu.com/question/654859896/answer/{answer_id}'.format(answer_id=answer_id)\n    try:\n        headers1 = {\n        'cookie' : random.choice(cookies),\n        'user-agent': random.choice(agent),#UserAgent().chrome,\n        'Referer':'https://www.zhihu.com/question/654859896/answer/3487198664',\n        'x-requested-with': 'XMLHttpRequest'\n        }\n        resp = requests.get(url, headers=headers1)\n        soup = BeautifulSoup(resp.text, 'html.parser')\n        # 查找content\n        content = soup.find('div', class_='RichContent-inner').text\n        contents.append(content)\n        time_element = soup.find('span', {'data-tooltip': True})\n        if time_element:\n            created_time = time_element['data-tooltip'].replace('发布于 ', '')\n            created_times.append(created_time)\n        else:\n            created_times.append('-')\n    except Exception as e:\n        print(f'爬取answer_id为{answer_id}的数据时出现异常：{e}')\n        break\n    \n    time.sleep(random.randint(1,2))\n\n    # 每爬取500个回答就保存一次数据,保存在不同的文件中\n    if len(contents) % 500 == 0:\n        new_data = {'answer_id': answer_ids[:len(contents)], 'content': contents, 'created_time' : created_times[:len(contents)]}\n        new_df = pd.DataFrame(new_data)\n        new_df.to_csv(f'text_{batch}.csv', index=True)\n        batch += 1\n```\n\n# 微博\n\n## 功能\n\n对于一个话题，爬取话题链接,楼主ID,话题内容,楼主昵称,楼主性别,是否认证,认证类型,是否认证金v,发博数量,关注人数,粉丝数,微博等级,发布日期,发布时间,转发量,评论量,点赞量。这些信息。\n\n## 介绍\n\n微博的爬虫代码是来源于以下链接，链接里面有爬取评论的内容，但是我作业里不需要，我就把这个功能删了，需要爬取评论的可以去下面链接看看。\\\n[微博爬虫](https://blog.csdn.net/m0_46235332/article/details/122682412 \"微博爬虫\")\n\n## 具体操作\n\n微博爬虫比较麻烦，好像是有限制一次性最多爬取50面，所以只能手动通过筛选时间，爬50面后看最后一条消息的时间，把筛选时间截止到那里，再接着爬50面，每次都得手动调，很麻烦。\n\n需要修改的内容如下：\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122007874-1159636649.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122007874-1159636649.png>)\n\n里面的Cookie和Referer就不用说了，老生常谈，主要说一下最底下那个baseurl，就是在微博里面高级搜索，筛选时间后，得到的网址。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122145488-1694643046.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122145488-1694643046.png>)\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122206095-1956403865.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122206095-1956403865.png>)\\\n上面的网址就是baseurl，替换后直接运行就可以开爬了，需要注意的是，代码里有一段是写csv的表头的语句，因为前面说了得多次爬取，所以只有第一次爬取的时候需要写表头，后面就得把写表头的语句注释掉。\\\n[![](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122359649-689719132.png>)](<./Python爬虫个人总结_Bilibili，知乎，微博 - TJUHuangTao - 博客园_files/3483649-20250120122359649-689719132.png>)\n\n## 完整代码\n\n点击查看代码\n\n**\n\nhighlighter- python\n\n```\n# -*- coding: utf-8 -*-\n \n'''\n微博爬虫，爬取一个主题下的博文内容，博主信息，评论等各种信息\n'''\n \nimport requests, random, re\nimport time\nimport os\nimport csv\nimport sys\nimport json\nimport importlib\n# from fake_useragent import UserAgent\nfrom lxml import etree\nimport datetime\nimport pandas as pd\nfrom selenium import webdriver\nimport urllib.request\n \n# 记录起始时间\nimportlib.reload(sys)\nstartTime = time.time()\n'''\n设置文件储存的路径 \n'''\npath1='./weibo_content_gaokao.csv'#存取的是微博博文的信息（不包含评论）\ncsvfile1 = open(path1, 'a', newline='', encoding='utf-8-sig') #'a'是追加模式, 'w'是重写\nwriter_1=csv.writer(csvfile1)\n\n# csv头部\nwriter_1.writerow(('话题链接',  '楼主ID', '话题内容','楼主昵称', '楼主性别','是否认证','认证类型',\n                   '是否认证金v','发博数量','关注人数','粉丝数','微博等级', '发布日期',\n                   '发布时间', '转发量', '评论量', '点赞量'))        #微博博文的信息（不包含评论）\n\n# --------------------------------------------头部信息-----------------------------------------------------\nip_list = [\n            {'http': 'http://118.193.47.193:8118'}, # 湖南长沙\n            {'http': 'http://58.20.234.243:9091'}, # 湖南湘潭\n            {'http': 'http://58.20.235.180:9091'}, # 湖南湘潭\n            {\"http\": \"http://112.115.57.20:3128\"},\n            {'http': 'http://121.41.171.223:3128'},\n            {\"http\": \"http://124.88.67.54:80\"},\n            {\"http\": \"http://61.135.217.7:80\"},\n            {\"http\": \"http://42.231.165.132:8118\"},\n            {\"http\": \"http://10.10.1.10:3128\"},\n            {\"https\": \"http://10.10.1.10:1080\"}\n        ]\nip = random.choice(ip_list)\n\n# 反爬虫\nagent = [\n            'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',\n            'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0',\n            'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)',\n            'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',\n            'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11',\n            'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)',\n            'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'\n            'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Mobile Safari/537.36'\n        ]\nua = random.choice(agent)\n\ncookie_list = [\n    # 手机号\n    {'cookie':''}\n]\n\ncookie = random.choice(cookie_list)['cookie']\n\nheaders = {\n    'cookie': cookie,\n    'user-agent': ua,#UserAgent().chrome,\n    'Referer':'https://m.weibo.cn/search?containerid=100103type%3D1%26q%3D%E6%98%A5%E8%8A%82',\n    'x-requested-with': 'XMLHttpRequest'\n}\n \n# # -----------------------------------爬取该主题首页的每个主题的ID------------------------------------------\n'''\n找出发布者id，并存入列表，用于找每个具体博客的网址\n'''\ncomments_ID = []\nbaseurl = 'https://s.weibo.com/weibo?q=%23%E9%AB%98%E8%80%83%23&xsort=hot&suball=1&timescope=custom%3A2015-01-01%3A2016-05-12-20&Refer=g'\ndef get_title_id():\n    for page in range(1, 51):  # 每个页面大约有9个话题\n        headers = {\n            'cookie': cookie,\n            'user-agent': ua,\n            'Referer': f'{baseurl}&page={page}',\n            'x-requested-with': 'XMLHttpRequest'\n        }\n        time.sleep(1)\n        api_url = f\"{baseurl}&page={page}\"\n \n        rep1 = requests.get(url=api_url, headers=headers)\n        try:\n            rep=rep1.text # 获取ID值并写入列表comment_ID中\n            comment_ID=re.findall('(?<=mid=\")\\d{16}', rep)\n            comments_ID.extend(comment_ID)\n            print(page,\"页id获取成功！\",comment_ID)\n        except:\n            print(page,\"页id获取有误！\")\n \n \n# -----------------------------------爬取该主题下每个博客的详情页面 ------------------------------------------\n \n'''\n该主题下每个博客主的详情（包括话题内容、楼主id、楼主昵称、楼主性别、发布时间、日期、\n发布时间、转发量、评论量、点赞量）\n（利用正则表达式抓取）\n'''\nis_continue='y'\nstart_date = pd.to_datetime('2015/01/01')\nend_date = pd.to_datetime('2024/12/31')\ndef spider_title(comment_ID):\n\n    article_url = 'https://m.weibo.cn/detail/' + comment_ID\n    print(\"article_url = \", article_url)\n    time.sleep(1)\n\n    try:\n        html_text = requests.get(url=article_url, headers=headers).text\n        # 发布日期\n        created_title_time = re.findall('.*?\"created_at\": \"(.*?)\".*?', html_text)[0].split(' ')\n        # print(created_title_time)\n        # 日期\n        if 'Jan' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '01', created_title_time[2])\n        elif 'Feb' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '02', created_title_time[2])\n        elif 'Mar' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '03', created_title_time[2])\n        elif 'Apr' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '04', created_title_time[2])\n        elif 'May' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '05', created_title_time[2])\n        elif 'Jun' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '06', created_title_time[2])\n        elif 'July' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '07', created_title_time[2])\n        elif 'Aug' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '08', created_title_time[2])\n        elif 'Sep' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '09', created_title_time[2])\n        elif 'Oct' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '10', created_title_time[2])\n        elif 'Nov' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '11', created_title_time[2])\n        elif 'Dec' in created_title_time:\n            title_created_YMD = \"{}/{}/{}\".format(created_title_time[-1], '12', created_title_time[2])\n        # print(\"title_created_YMD = \", title_created_YMD)\n \n        print('发布日期：',title_created_YMD)\n        time2 = pd.to_datetime(title_created_YMD)\n \n        if start_date<= time2 <= end_date:\n            # 话题内容\n            find_title = re.findall('.*?\"text\": \"(.*?)\",.*?', html_text)[0]\n            title_text = re.sub('<(S*?)[^>]*>.*?|<.*? />', '', find_title)  # 正则匹配掉html标签\n\n            # 楼主ID\n            title_user_id = re.findall('.*?\"id\": (.*?),.*?', html_text)[1]\n\n            # 楼主昵称\n            title_user_NicName = re.findall('.*?\"screen_name\": \"(.*?)\",.*?', html_text)[0]\n\n            # 楼主性别\n            title_user_gender = re.findall('.*?\"gender\": \"(.*?)\",.*?', html_text)[0]\n\n            verified=re.findall('.*?\"verified\": (.*?),.*?', html_text)[0]#楼主是否认证\n            if verified=='true':\n                verified_type_ext = re.findall('.*?\"verified_type_ext\": (.*?),.*?', html_text)[0] # 楼主是否金v\n            else:\n                verified_type_ext=0\n            # print(verified_type_ext)\n            content_num=re.findall('.*?\"statuses_count\": (.*?),.*?', html_text)[0] #楼主发博数量\n            verified_type=re.findall('.*?\"verified_type\": (.*?),.*?', html_text)[0]#楼主认证类型\n            urank=re.findall('.*?\"urank\": (.*?),.*?', html_text)[0]#楼主微博等级\n            guanzhu=re.findall('.*?\"follow_count\": (.*?),.*?', html_text)[0]#楼主关注数\n            fensi=eval(re.findall('.*?\"followers_count\": (.*?),.*?', html_text)[0])#楼主粉丝数\n\n            # 发布时间\n            add_title_time = created_title_time[3]\n            print(\"add_title_time = \", add_title_time)\n            #当该条微博是是转发微博时，会有一个原微博的转发评论点赞量，以及本条微博的转发评论点赞量，此时需要的是第2个元素\n            if len(re.findall('.*?\"reposts_count\": (.*?),.*?', html_text))>1:\n                # 转发量\n                reposts_count = re.findall('.*?\"reposts_count\": (.*?),.*?', html_text)[1]\n                # 评论量\n                comments_count = re.findall('.*?\"comments_count\": (.*?),.*?', html_text)[1]\n                print(\"comments_count = \", comments_count)\n                # 点赞量\n                attitudes_count = re.findall('.*?\"attitudes_count\": (.*?),.*?', html_text)[1]\n                # 每个ajax一次加载20条数据\n                comment_count = int(int(comments_count) / 20)\n            else:\n                # 转发量\n                reposts_count = re.findall('.*?\"reposts_count\": (.*?),.*?', html_text)[0]\n                # print(\"reposts_count = \", reposts_count)\n\n                # 评论量\n                comments_count = re.findall('.*?\"comments_count\": (.*?),.*?', html_text)[0]\n                print(\"comments_count = \", comments_count)\n\n                # 点赞量\n                attitudes_count = re.findall('.*?\"attitudes_count\": (.*?),.*?', html_text)[0]\n                # print(\"attitudes_count = \", attitudes_count)\n\n                # 每个ajax一次加载20条数据\n                comment_count = int(int(comments_count) / 20)\n\n            # position1是记录\n            position11 = (article_url, title_user_id, title_text, title_user_NicName, title_user_gender, verified, verified_type,\n            verified_type_ext, content_num, guanzhu, fensi, urank, title_created_YMD, add_title_time,reposts_count, comments_count, attitudes_count)\n\n            # 写入数据\n            writer_1.writerow(position11)\n            print('写入博文信息数据成功！')\n            return comment_count, title_user_id, title_created_YMD,title_text\n\n            global is_continue\n        else:\n            is_continue = input('日期超出范围,是否继续爬取博文信息?(y/n, 默认: y) ——> ')#输入是否继续爬取\n            if is_continue == 'y' or is_continue == 'yes' or not is_continue:\n                pass\n            else:\n                print('日期超出范围，停止爬取博文信息！')\n                # 计算使用时间\n                endTime = time.time()\n                useTime = (endTime - startTime) / 60\n                print(\"该次所获的信息一共使用%s分钟\" % useTime)\n                sys.exit(0)\n            return is_continue\n    except:\n        print('博文网页解析错误，或微博不存在或暂无查看权限！')\n        pass\n \n \n\n# -------------------------------------------------主函数---------------------------------------------------\ndef main():\n    count_title = len(comments_ID)\n    for count, comment_ID in enumerate(comments_ID):\n        print(\"正在爬取第%s条微博，一共找到个%s条微博需要爬取\" % (count + 1, count_title))\n\n        try:\n            maxPage,title_user_id,title_created_YMD,title_text = spider_title(comment_ID)\n        except:\n            if is_continue == 'y' or is_continue == 'yes' or not is_continue:\n                print(\"--------------------------分隔符---------------------------\")\n                pass\n            else:\n                sys.exit(0)\n        print(\"--------------------------分隔符---------------------------\")\n    csvfile1.close()\n    \nif __name__ == '__main__':\n    # 获取话题ID\n    get_title_id()\n    # 主函数操作\n    main()\n    # 计算使用时间\n    endTime = time.time()\n    useTime = (endTime - startTime) / 60\n    print(\"该次所获的信息一共使用%s分钟\" % useTime)\n    # print('错误页面:',error_page_list)\n```","tags":["Python","爬虫"]},{"title":"24251寒假","url":"/post/e4bd7c43.html","content":"回家后的第一天。不出意外的话，我将开始给高一小孩补课18天。🤓\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/24251寒假/24251winterholiday-1.jpg\" width=\"70%\" style=\"display: inline-block; margin: 0;\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/24251寒假/24251winterholiday-2.jpg\" width=\"70%\" style=\"display: inline-block; margin: 0;\" />\n\n今天高一物理试课，可能因为我讲得太好（bushi），负责人说数学也让我讲。😂","tags":["生活"]},{"title":"Git版本控制","url":"/post/4257a649.html","content":"# 方式一\nhexo是当前最火的静态博客框架，支持Markdown格式文章编辑并自动生成对应的静态网页，简单高效令人爱不释手。\\\n使用hexo写博客的流程通常是，\n\n1. 通过`hexo new post_name`命令，会自动在`source/_post`目录下生成一个待写的`post_name.md`文件\n2. 编写完该md文件后，用`hexo generate`编译生成对应的HTML文件\n3. 发布之前，可以用`hexo s`本地预览，然后通过`hexo deploy`发布到远程仓库的**main**分支，然后你的个人站点就能看到刚才新加的文章了\n\n[]()\n\n## [](#困扰 \"困扰\")困扰\n\n然而，使用过hexo搭建个人博客的朋友们想必都会遇到博客源码保存的问题。即远程仓库只会保存hexo发布后的静态HTML文件，你的博客md源文件、主题配置等还在本地，一旦电脑磁盘坏了或者换了电脑，就无法在之前仓库的基础上继续写博客。针对此问题，有不少博主会在github上单独另起一个**repository**来专门保存博客源文件，每次发布完新文章，需要手动地将`source/post`下的md文件上传到源文件对应的**repository**，确实也能解决问题，但总归是麻烦。后来偶然看到聪明的网友借助git分支来巧妙地实现用同一个仓库保存静态网页和博客源码，自己试了下确实很赞，故总结之。\n\n## [](#解决办法 \"解决办法\")解决办法\n\n### [](#新建git分支 \"新建git分支\")新建git分支\n\n因Github Page要求使用main分支作为发布网站的源代码，我们只能用main分支来保存hexo生成的静态网页，对于博客源码，可以新建一个source分支来存储。在github上打开Pages对应的仓库，也就是以”username.github.io”命名的仓库，然后建立一个source分支，如下图：\n\n![create\\_branch](/2019/06/29/save-hexo-source-post-with-git-branch/create_branch.png)\n\n因为我已经创建过source分支，故下方会显示目前该仓库上有main和source两个分支。其中source分支显示打钩，表示当前仓库的默认分支已经是source而不是main了，下面会讲。\n\n### [](#更改仓库的默认分支 \"更改仓库的默认分支\")更改仓库的默认分支\n\ngithub上的仓库初始都会有个main分支，也就是默认分支。对于一个仓库`project_name`，当我们通过`git clone https://github.com/sherlockyb/project_name.git`下载代码时，实际拉取的是默认分支main对应的代码。而我们用hexo写博客时，通常是与md源文件打交道，对于deploy生成的main分支代码并不需要我们关注，因此可将仓库的默认分支改为保存源码的source分支，这样通过`git clone`拉取的就是source分支代码了。\n\n在仓库的主页面，通过Settings -> Branchs，可以看到**Default branch**的Tab，显示的默认分支是main，可以勾选source，然后update即可将默认分支设置为source，如下图：\n\n![switch\\_default\\_branch](/2019/06/29/save-hexo-source-post-with-git-branch/default_branch.png)\n\n### [](#将本地hexo目录与远程仓库关联 \"将本地hexo目录与远程仓库关联\")将本地hexo目录与远程仓库关联\n\n进入到本地hexo工程目录，也就是我们通常执行`hexo new post`等命令的目录，执行如下操作：\n```\ngit remote add origin https://github.com/sherlockyb/sherlockyb.github.io.git\n``` \n\n### [](#推送博客源码 \"推送博客源码\")推送博客源码\n\n将本地的md源文件、站点配置文件等推送到source分支。\\\n因为我们只需要保留博客源码，其他无关的文件并不希望推送，需要确保配好了`.gitignore`文件，通常如下：\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n``` \n\n然后依次执行如下命令：\n```\ngit add .\ngit commit -m 'hexo source post'\ngit push origin source\n``` \n\n### [](#删除public等文件（可选） \"删除public等文件（可选）\")删除public等文件（可选）\n\n因为source分支是从main分支新建的，初始代码实际就是main的拷贝，因而main中已有的public等deploy生成的文件也会一起带过来，这些都不算是博客源文件，如果你也觉着source分支还存着这些有些别扭，就可以先在本地把它删掉，然后执行：\n\n```\ngit add .\ngit commit -m 'DEL: public things which only for deploy'\ngit push origin source\n``` \n\n执行完之后，你的仓库大概就是长这个样子：\n\n![source\\_files](/2019/06/29/save-hexo-source-post-with-git-branch/source_files.png)\n\n后续即便你再发布博客时，deploy生成public文件，在提交博客源码时，也不会将其带上去，因为有`.gitignore`将其忽略了。\n\n## [](#新环境 \"新环境\")新环境\n\n假设我们换电脑了，要在新环境继续在原有仓库基础上撸文章，此时通过`git clone`将博客源码拉到本地，然后安装、初始化hexo就能搞定：\n\n```\ngit clone https://github.com/sherlockyb/sherlockyb.github.io.git sherlockyb\ncd sherlockyb\nnpm install hexo\nnpm install hexo-deployer-git -save\n\n// 别忘了安装相关依赖的 NodeJS 包，也就是 _config.xml 中用到的一些插件\nnpm install hexo-wordcount\n...\n\n// hexo环境配置好后，继续像之前一样\nhexo new post_name\n...\n```\n\n## [](#注意事项 \"注意事项\")注意事项\n\n确保`hexo deploy`推送的是main分支，hexo目录下的\\_config.yml文件通常会配置deploy推送的目标地址，这个一般在最初使用hexo时，就会配置为main，不用改动：\n\n```YAML\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/sherlockyb/sherlockyb.github.io.git\n  branch: main\n```\n# 方式二\n## 新建仓库\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Git版本控制/1.png\" width=\"70%\" />\n\n若成功创建仓库将如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Git版本控制/2.png\" width=\"70%\" />\n\n## 创建`.gitignore`文件\n博客根目录下创建`.gitignore`文件，添加如下内容：\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n_multiconfig.yml\n.vscode/\n.idea/\n/.idea/\n.deploy_git*/\n.idea\nthemes/butterfly/.git\n```\n\n## 本地Git仓库初始化\n```bash\ngit init\n```\n出现如下提示，说明初始化成功。\n```bash\nInitialized empty Git repository in your/blog's/path/.git/\n```\n```\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/HaydenZHY/Blog.git\ngit push -u origin main\n```\n成功上传到GitHub后，GitHub上的仓库将如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/Git版本控制/3.png\" width=\"70%\" />","tags":["教程","Git"]},{"title":"博客中嵌入PDF文件常见方法","url":"/post/b093ff5b.html","content":"在Hexo框架中使用Butterfly主题时，可以在博客文章中插入PDF文件。以下是几种常见的方法：\n\n---\n\n### **方法一：使用`<embed>`标签**\n直接在Markdown文件中使用HTML的`<embed>`标签嵌入PDF文件。\n\n```markdown\n<embed src=\"/path/to/your/file.pdf\" width=\"100%\" height=\"600px\" type=\"application/pdf\">\n```\n\n- **`src`**：PDF文件的路径（可以是相对路径或绝对路径）。\n- **`width` 和 `height`**：设置嵌入PDF的宽度和高度。\n- **`type`**：指定文件类型为`application/pdf`。\n\n---\n\n### **方法二：使用`<iframe>`标签**\n使用`<iframe>`标签嵌入PDF文件。\n\n```markdown\n<iframe src=\"/path/to/your/file.pdf\" width=\"100%\" height=\"600px\">\n</iframe>\n```\n\n- **`src`**：PDF文件的路径。\n- **`width` 和 `height`**：设置嵌入PDF的宽度和高度。\n\n---\n\n### **方法三：使用PDF.js**\nPDF.js 是一个开源的PDF阅读器库，可以在网页中嵌入PDF文件。\n\n1. **下载PDF.js**：\n   - 从 [PDF.js官网](https://mozilla.github.io/pdf.js/) 下载最新版本。\n   - 解压后将文件夹（例如`pdfjs`）放到Hexo博客的`source`目录下。\n\n2. **在文章中嵌入PDF**：\n   在Markdown文件中插入以下代码：\n\n   ```markdown\n   <iframe src=\"/pdfjs/web/viewer.html?file=/path/to/your/file.pdf\" width=\"100%\" height=\"600px\">\n   </iframe>\n   ```\n\n   - **`src`**：指向PDF.js的`viewer.html`文件，并通过`file`参数指定PDF文件的路径。\n   - **`width` 和 `height`**：设置嵌入PDF的宽度和高度。\n\n3. **部署**：\n   确保PDF文件和PDF.js文件夹在部署后能够正确访问。\n\n---\n\n### **方法四：使用Google Docs Viewer**\n通过Google Docs Viewer在线预览PDF文件。\n\n```markdown\n<iframe src=\"https://docs.google.com/viewer?url=https://yourdomain.com/path/to/your/file.pdf&embedded=true\" width=\"100%\" height=\"600px\">\n</iframe>\n```\n\n- **`src`**：指向Google Docs Viewer的URL，并通过`url`参数指定PDF文件的完整URL。\n- **`width` 和 `height`**：设置嵌入PDF的宽度和高度。\n\n---\n\n### **方法五：使用Butterfly主题的标签插件**\nButterfly主题支持自定义标签插件，你可以创建一个PDF嵌入插件。\n\n1. **创建标签插件**：\n   在Hexo博客的`scripts`文件夹中创建一个新的JavaScript文件，例如`pdf.js`：\n\n   ```javascript\n   hexo.extend.tag.register('pdf', function(args) {\n     const path = args[0];\n     const width = args[1] || '100%';\n     const height = args[2] || '600px';\n     return `<embed src=\"${path}\" width=\"${width}\" height=\"${height}\" type=\"application/pdf\">`;\n   });\n   ```\n\n2. **在文章中使用标签插件**：\n   在Markdown文件中使用以下语法：\n\n   ```markdown\n   {% pdf /path/to/your/file.pdf %}\n   ```\n\n   或者指定宽度和高度：\n\n   ```markdown\n   {% pdf /path/to/your/file.pdf 100% 800px %}\n   ```\n\n---\n\n### **方法六：直接链接PDF文件**\n如果不需要嵌入PDF文件，可以直接提供下载链接。\n\n```markdown\n[下载PDF文件](/path/to/your/file.pdf)\n```\n\n---\n\n### **注意事项**\n1. **路径问题**：\n   - 如果PDF文件放在`source`目录下，路径应该是相对于`source`目录的路径。\n   - 例如，如果PDF文件放在`source/files/example.pdf`，路径应为`/files/example.pdf`。\n\n2. **文件大小**：\n   - 如果PDF文件较大，加载时间可能会较长，建议优化PDF文件大小。\n\n3. **部署测试**：\n   - 在本地测试时，确保路径和文件都能正确访问。\n   - 部署后检查PDF文件是否能够正常加载。\n\n通过以上方法，你就可以在Hexo博客的Butterfly主题中轻松插入PDF文件啦。"},{"title":"利用 Pytorch 构建与分析 Pix2Pix 模型的优化与改进","url":"/post/76830c84.html","content":"<embed src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/Pix2Pix/利用Pytorch构建与分析Pix2Pix模型的优化与改进.pdf\" width=\"100%\" height=\"700px\" type=\"application/pdf\">","tags":["Pytorch","Pix2Pix","cGAN","条件生成对抗网络模型"]},{"title":"利用 Pytorch 构建与分析 Perceptron（感知机） 单层神经网络","url":"/post/ac348add.html","tags":["Pytorch","Perceptron","单层神经网络"]},{"title":"利用 Pytorch 构建与优化 AlexNet 深层卷积神经网络","url":"/post/5feefdcb.html","content":"**AlexNet的模型归一化方法的比较分析**\nI. 对 AlexNet 的归一化方法进行比较分析或改进；\nII. 比较至少三种的归一化方法（例如无归一化 , BN, LN, GN等）；\nIII. 在MNIST/Cifar-10数据集分析比较不同归一化方法在不同Batch-size下的性能。\n\n{% pdf https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/AlexNet/利用Pytorch构建与优化AlexNet深层卷积神经网络.pdf 100% 700px %}","tags":["AlexNet","Pytorch","深层卷积神经网络"]},{"title":"我的2024","url":"/post/6bc0cde8.html","content":"**2024年校园卡支出统计**\n\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/1.png)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/2.png)\n{% endgallery %}\n\n哈哈，我怎么这么“爱”兰园，主要是因为近。无论是寒暑假留在实验室集训，还是平时上课在45教/46教，午饭选择在兰园吃真的是个不错的选择，吃完后顺路回宿舍睡午觉。\n\n晚饭在**喜家德**。\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-0.jpg)\n{% endgallery %}\n\n**世纪钟**~~好多人啊~~好多气球啊，“2025，你好”，“新年快乐”。\n\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/ball-2.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/ball-3.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/ball-1.jpg)\n{% endgallery %}\n\n午饭在**克茗香港茶餐厅**。\n\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-1.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-2.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-3.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-4.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-5.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-6.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/food-7.jpg)\n{% endgallery %}\n\n下午打卡了一直想去的**钟书阁**。\n\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/library-4.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/library-1.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/library-2.jpg)\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/我的2024/library-3.jpg)\n{% endgallery %}"},{"title":"分盘","url":"/post/7e23b7a4.html","content":"\n# 新电脑如何从C盘分出D盘？其实很简单！\n\n新购买的电脑通常只有一个分区，也就是[只有C盘](https://www.disktool.cn/jiaocheng-new/how-to-partition-hard-drive-in-windows10.html)，这意味着系统和软件都会被安装在这个盘上，文件也会存储在同一个位置，这样使用起来并不方便。如果电脑遭受病毒攻击或者系统故障需要重新安装系统，很可能会导致重要文件的丢失。此外，文件的存储和管理也会变得不便，难以进行有效的分类、查找和浏览。\n\n新电脑如何从C盘分出D盘？其实很简单！操作也并不复杂，即便是电脑小白也能轻松完成。接下来，我们来看一下具体的步骤，而且操作完成后无需重启电脑，只需几分钟就能搞定。\n\n## 方法一：使用磁盘管理从C盘分出D盘\n\n[磁盘管理](https://www.disktool.cn/content-center/win10-comes-with-hard-disk-partition-369.html)是Windows中自带系统实用程序，可以帮助我们管理磁盘和分区。我们可以通过它对分区进行一些简单的基础调整，比如压缩卷、扩展卷、删除卷、更改盘符等。\n\n1. 同时按**Win+R**输入**diskmgmt.msc**并按**回车**键打开磁盘管理。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/diskmgmt.png)\n\n\n2. 选择一个空闲空间比较大的磁盘进行压缩，比如我们希望把D盘的一些磁盘空间调整到C盘，那么我们可以选中D盘，然后再其上点击鼠标右键，在弹出的菜单中选择**“压缩卷”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/ys1.png)\n\n3. 然后在输入压缩空间量（MB）里填写要压缩出的空间，然后点击**“压缩”**即可。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/ys2.png)\n\n\n**✍ 公式：** 输入压缩空间总量=压缩前的总计大小-压缩后的总计大小（C 盘空间大小），1GB=1024MB，举例：总大小 1000GB，预留C盘 200GB，输入压缩空间量=1000GB-200GB=800GB=1024MBx800=819200MB。\n\n4. 压缩完后，我们可以看到磁盘卷中会多出一个黑色分区的**“未分区磁盘”**；然后我们只需要将该未分区磁盘空间分配给C盘即可。右键点击需要扩充容量的盘符，然后在弹出的菜单中选择**“扩展卷”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/kz1.png)\n\n\n**✍ 注意：** 扩展卷只能合并相邻的未分配空间，若压缩出的未分配空间与你想要合并的分区不相邻，你可以[移动分区](https://www.disktool.cn/jiaocheng-new/2019/how-to-move-partition.html)将未分配空间移动到相邻的位置。\n\n5. 之后会弹出如下扩展卷操作向导对话框界面，选择你想要将多少未分配空间用于扩展分区，设置完毕后单击**“下一步”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/kz2.png)\n\n\n6. 按照提示流程操作完毕之后，单击**“完成”**以退出扩展卷向导即可。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/kz3.png)\n\n\n## 方法二：使用分区助手从C盘分出D盘\n\n如果你觉得磁盘管理创建分区步骤太多，可以使用免费的磁盘分区管理软件--[傲梅分区助手](https://www.disktool.cn/feature.html)，它的“拆分分区”功能可以直接拆分C盘，创建新的分区。轻松的将大分区拆分为一个或多个小分区。\n\n1. 下载安装启动傲梅分区助手，右键单击有多余空间的C盘，选择**“拆分分区”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/1.png)\n\n2. 左右移动中间的圆圈调整分区大小，点击**“高级”**设置分区卷标等，无误后点击**“确认”**。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/2.png)\n\n**✍ 注意：**如果分区存在于SSD上，你可以点击高级，勾选**“允许分区对齐以优化SSD的性能”**。\n\n3. 返回主界面，点击**“提交”**以查看操作预览，无误后点击**“执行”**开始创建新分区。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/3.png)\n\n\n## 方法三：使用Diskpart分区磁盘\n\nDiskpart是Windows中的命令提示符，使用这个命令去分区后不用重启系统也可以生效。通过Diskpart也可以对[硬盘进行重新分区](https://www.disktool.cn/content-center/hard-disk-repartition-method-369.html)，不过需要掌握一定的知识才能操作。具体的步骤如下：\n\n1.按**“Windows + R”**键，在弹出的**“运行”**对话框中输入**“diskpart”**，并按**“回车”**键。\n\n2.输入**“list disk”**命令，查看电脑磁盘的所有磁盘的情况。\n\n3.输入**“select disk A”**命令，其中A代表需要创建的分区的编号。\n\n4.输入**“clean”**命令，清空A磁盘分区，使之成为未分配磁盘分区。\n\n![](https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/%E5%88%86%E7%9B%98/clean.png)\n\n\n5.根据实际的创建磁盘分区的需求键入以下命令。\n\n🧰 **create partition primary size=n**(创建主分区)\n🧰 **create partition primary size=n**(创建主分区)\n🧰 **create partition logical size=n**(创建逻辑分区)\n\n## 结语\n\n以上就是新电脑从C盘分出D盘的3种方法，建议使用分区助手新建D盘，简单有效。希望本文对你有所帮助！傲梅分区助手除了可以新建分区。它还提供了很多Windows自带磁盘管理工具无法完成的分区功能，比如制作启动光盘、[无损转换MBR与GPT](https://www.disktool.cn/content-center/gpt-mbr/how-to-convert-gpt-to-mbr-without-data-loss.html)、磁盘测速等。赶紧下载试一试吧！\n","tags":["分盘"]},{"title":"AlexNet 图像分类（PyTorch框架）","url":"/post/91cba6d6.html","content":"\n# [手撸代码：从零开始的 AlexNet 图像分类（PyTorch框架） ](https://www.cnblogs.com/xing9/p/18002038/AlexNet-PyTorch \"发布于 2024-02-03 14:16\")\n\n## 摘要：\n\n本文在 PyTorch 框架下搭建了 AlexNet ，并在 CIFAR10 上完成了图片分类。同时，更正了一些原论文中的小错误（如：输入图像尺寸）。由于 CIFAR10 没有验证集，本文将训练集的 10% 当作验证集。\n\n完整代码已上传至 GitHub：<https://github.com/TiezhuXing01/AlexNet_in_PyTorch>\n\n***\n\n## 1. 引入库\n\n```python\n    import torch\n    import torch.nn as nn\n    import numpy as np\n    from torchvision import datasets\n    from torchvision import transforms\n    from torch.utils.data.sampler import SubsetRandomSampler\n```\n\n`SubsetRandomSampler` 是 PyTorch 中的一个采样器（sampler）。\n具体可以看这篇文章：[SubsetRandomSampler 是什么？](https://www.cnblogs.com/xing9/articles/18004465/SubsetRandomSampler)\n\n***\n\n## 2. 选择设备\n\n```python\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n```\n\n通常情况下，我们都会选择在GPU上训练网络模型，因为神经网络的训练需要大量的计算，而英伟达的GPU提供了CUDA（一个加速计算库）。但如果你的电脑显卡是AMD的，那么有很大概率不支持使用CUDA，此时只能用CPU训练。但在CPU上训练模型是十分缓慢的。如果你暂时没法换电脑，那我建议你去租一个服务器。或者使用阿里云、百度飞桨、谷歌Colab等平台。\n\n***\n\n## 3. 加载数据集\n\nCIFAR-10 是一个经典的计算机视觉数据集，用于图像分类任务。它包含了来自 10 个不同类别的 60,000 张彩色图像，每个类别有 6,000 张图像。数据集被分为训练集和测试集，其中训练集包含 50,000 张图像，测试集包含 10,000 张图像。本文拿出训练集的 10% 作为验证集。\n\n### 3.1 定义获取训练集和验证集的数据加载器\n\n```python\ndef get_train_val_loader(data_dir, batch_size, augment,\n                         random_seed, valid_size = 0.1, shuffle = True):\n \n  # ------------- 设置图像变换 ------------- #\n  # (1) 归一化\n  normalize = transforms.Normalize(mean = [0.4914, 0.4822, 0.4465],\n                                   std = [0.2023, 0.1994, 0.2010])\n  # (2) 验证集图像变换\n  val_transform = transforms.Compose([transforms.Resize(227),\n                                   transforms.ToTensor(),\n                                   normalize])\n  # (3) 训练集是否数据增强\n  if augment:\n    train_transform = transforms.Compose([transforms.RandomHorizontalFlip(),\n                                      transforms.Resize(227),\n                                      transforms.ToTensor(),\n                                      normalize])\n  else:\n    train_transform = transforms.Compose([transforms.Resize(227),\n                                       transforms.ToTensor(),\n                                       normalize])\n  # ---------- 👆 数据变换设置完毕 -------------- #\n \n  # 下载并加载训练集\n  train_dataset = datasets.CIFAR10(root = data_dir,\n                                  train = True,\n                                  download = True,\n                                  transform = train_transform)\n  val_dataset = datasets.CIFAR10(root = data_dir,\n                                  train = True,\n                                  download = True,\n                                  transform = val_transform)\n \n  # ---------- 划分验证集和训练集 ----------  #\n  # (1) 计算训练集图片数量\n  num_train = len(train_dataset)\n  # (2) 计算验证集数量，并向下取整\n  num_val = np.floor(valid_size * num_train)\n  # (3) 设置训练集和验证集的划分界限\n  split = int(num_val)\n  # (4) 生成一个列表索引，其内容为 0 ~ (num_train - 1) 的全部整数\n  indices = list(range(num_train))    # 为数据\"洗牌\"做准备\n  if shuffle:\n    np.random.seed(random_seed) # 根据种子生成随机数\n    np.random.shuffle(indices)  # 根据随机数打乱图片\n  # (5) 划分验证集和训练集(根据索引列表 indices 和划分界限 split 划分)\n  val_idx = indices[:split]     # 验证集索引列别\n  train_idx = indices[split:]   # 训练集索引列表\n  # (6) 根据验证集和训练集的索引列表采样数据\n  train_sampler = SubsetRandomSampler(train_idx)\n  val_sampler = SubsetRandomSampler(val_idx)\n  # ---------- 👆 训练集和验证集划分完毕 ---------- #\n \n  # 设置数据加载器\n  train_loader = torch.utils.data.DataLoader(train_dataset,\n                                             batch_size = batch_size,\n                                             sampler = train_sampler)\n  val_loader = torch.utils.data.DataLoader(val_dataset,\n                                           batch_size = batch_size,\n                                           sampler = val_sampler)\n \n  return (train_loader, val_loader)\n```\n\n***\n\n### 3.2 定义获取测试集的数据加载器\n\n```python\ndef get_test_loader(data_dir, batch_size, shuffle = True):\n \n  # ------------- 设置图像变换 ------------- #\n  # 归一化\n  normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                  std=[0.229, 0.224, 0.225],)\n  # 图像变换\n  test_transform = transforms.Compose([transforms.Resize(227),\n                                transforms.ToTensor(),\n                                normalize])\n \n  # 下载并加载测试集\n  test_dataset = datasets.CIFAR10(root = data_dir,\n                                  train = False,\n                                  download = True,\n                                  transform = test_transform)\n \n  # 加载测试数据\n  test_loader = torch.utils.data.DataLoader(test_dataset,\n                                            batch_size = batch_size,\n                                            shuffle = shuffle)\n \n  return test_loader\n```\n\n***\n\n### 3.3 调用函数，加载数据\n\n```python\n# 设置数据集下载路径\ndata_dir = \"./data\"\n# 设置批尺寸\nbatch_size = 64\n# 调用训练集和验证集的 DataLoader\ntrain_loader, val_loader = get_train_val_loader(data_dir = data_dir,\n                                                batch_size = batch_size,\n                                                augment = True,\n                                                random_seed = 1)\n# 调用测试集的 DataLoader\ntest_loader = get_test_loader(data_dir = data_dir,\n                              batch_size = batch_size,\n                              shuffle = False)\n```\n\n***\n\n## 4. 认识网络\n\n![AlexNet 结构图](<https://s2.loli.net/2024/12/26/6yosugXcIEOVGFl.png>)\n\nAlexNet 是卷积神经网络的奠基之作，发表时间较早，所以今天看来有一些错误或者局限性：\n\n(1) 在2012年 AlexNet 被提出时，GPU 的算力相对今天来说非常小。为了训练这个网络，他们把 AlexNet **从中间切开**，使用多 GPU 训练，分别在 2 块 GTX 580 3G 上花了五、六天时间。\n\n(2) 这种切割只是一种**技术细节**，以后几年的模型大多都不会这么切割，多 GPU 训练也不是通过切割模型来实现。所以本文的代码并**没有切割**网络，也没有用到多 GPU 训练。\n\n(3) 论文中写到，输入图片的尺寸是 $24*24*3$ ，即 3 个通道的 $24*24$ 图片。但事实上，这是作者的小错误。正确尺寸应为 $27*27*3$ .\n\n如果按照论文说的输入尺寸做，会出现错误。可以来算一下， 卷积输出尺寸公式为：  \n$output size=\\frac{input size-kernel size+2*padding}{stride}+1$\n第一次卷积后：$output size=\\frac{224-11+2*0}{4}+1=54.25$ 出现小数了。\n\n***\n\n在一块 GPU 上训练的正确 AlexNet 结构及其输入输出尺寸应为下表。\n\n|                  |                  |                  |            |          |          |                                 |\n| ---------------- | ---------------- | ---------------- | ---------- | -------- | -------- | ------------------------------- |\n| **操作**<br>**名称** | **输入**<br>**通道** | **输出**<br>**通道** | **核尺寸** | **步幅** | **填充** | **输出尺寸**<br>**输入: 227×227×3** |\n| conv1            | 3                | 96               | 11×11      | 4        | 0        | 55×55×96                        |\n| pool             |                  |                  | 3 × 3      | 2        |          | 27×27×96                        |\n| conv2            | 96               | 256              | 5 × 5      | 1        | 2        | 27×27×256                       |\n| pool             |                  |                  | 3 × 3      | 2        |          | 13×13×256                       |\n| conv3            | 256              | 384              | 3 × 3      | 1        | 1        | 13×13×384                       |\n| conv4            | 384              | 384              | 3 × 3      | 1        | 1        | 13×13×384                       |\n| conv5            | 384              | 256              | 3 × 3      | 1        | 1        | 13×13×256                       |\n| pool             |                  |                  | 3 × 3      | 2        |          | 6×6×256                         |\n| fc1              |                  |                  |            |          |          | 9216                            |\n| fc2              |                  |                  |            |          |          | 4096                            |\n| fc3              |                  |                  |            |          |          | num_classes(=10)               |\n\n***\n\n## 5. 搭建网络\n\n```python\nclass AlexNet(nn.Module):\n    def __init__(self, num_classes=10):\n        super(AlexNet, self).__init__()\n        self.conv_block1 = nn.Sequential(\n                        nn.Conv2d(3, 96, kernel_size=11, stride=4, padding=0),\n                        nn.BatchNorm2d(96),\n                        nn.ReLU()\n                        )\n        self.conv_block2 = nn.Sequential(\n                        nn.Conv2d(96, 256, kernel_size=5, stride=1, padding=2),\n                        nn.BatchNorm2d(256),\n                        nn.ReLU()\n                        )\n        self.conv_block3 = nn.Sequential(\n                        nn.Conv2d(256, 384, kernel_size=3, stride=1, padding=1),\n                        nn.BatchNorm2d(384),\n                        nn.ReLU()\n                        )\n        self.conv_block4 = nn.Sequential(\n                        nn.Conv2d(384, 384, kernel_size=3, stride=1, padding=1),\n                        nn.BatchNorm2d(384),\n                        nn.ReLU()\n                        )\n        self.conv_block5 = nn.Sequential(\n                        nn.Conv2d(384, 256, kernel_size=3, stride=1, padding=1),\n                        nn.BatchNorm2d(256),\n                        nn.ReLU()\n                        )\n        self.pool = nn.MaxPool2d(kernel_size = 3, stride = 2)\n        self.fc1 = nn.Sequential(nn.Dropout(0.5),nn.Linear(9216, 4096),nn.ReLU())\n        self.fc2 = nn.Sequential(nn.Dropout(0.5),nn.Linear(4096, 4096),nn.ReLU())\n        self.fc3 = nn.Sequential(nn.Linear(4096, num_classes))\n \n    def forward(self, x):\n        out = self.conv_block1(x)\n        out = self.pool(out)\n        out = self.conv_block2(out)\n        out = self.pool(out)\n        out = self.conv_block3(out)\n        out = self.conv_block4(out)\n        out = self.conv_block5(out)\n        out = self.pool(out)\n        out = out.reshape(out.size(0), -1)\n        out = self.fc1(out)\n        out = self.fc2(out)\n        out = self.fc3(out)\n        return out\n```\n\n* `Dropout`：让一部分神经元输出为0. 目前认为它是一个正则项，防止过拟合。由于目前很少使用全连接了，所以`Dropout`不是那么重要了。\n\n***\n\n## 6. 设置超参数\n\n```python\nnum_classes = 10\nepochs = 20\nlearning_rate = 0.005\n \nmodel = AlexNet(num_classes).to(device)\n \n# 设置损失函数\ncost = nn.CrossEntropyLoss()\n \n# 设置优化器\noptimizer = torch.optim.SGD(model.parameters(),     # SGD 随机梯度下降\n                            lr = learning_rate,\n                            weight_decay = 0.005,   # 正则化项的权重是 0.005\n                            momentum = 0.9)\n \n# 一个 epoch 训练的总 step 数\ntrain_step = len(train_loader)\n```\n\n* `len(train_loader)`返回加载器中的批次数量。$\\frac{5000*(1-0.1)}{64}=703.125$，结果出现小数，向上取整为704.\n\n* 随机梯度下降（SGD）现在是深度学习最主流的优化算法，因为其内部的噪声使模型有更好的泛化能力。\n\n* `weight_decay`：是 L2 的正则项。\n\n* **正则化**：在机器学习中，正则化是一种用于**防止过拟合**的技术。限制模型的复杂性，防止模型对训练数据中的噪声过于敏感，从而提高其在未知数据上的泛化能力。在 AlexNet 提出那年（2012），人们普遍认为正则化对解决模型过拟合问题是很重要的。但在后期，这个观点被推翻了。取而代之的是，网络的**设计**对防止过拟合更重要的。\n\n* `momentum`：动量是一种优化算法中常用的技术，通常与随机梯度下降（SGD）结合使用，用于加速模型的训练过程。它的功能是 **避免因下降曲线不平滑而落入局部最优解中。** 动量的引入主要是为了解决随机梯度下降的一些问题，例如在梯度更新中存在的震荡和收敛速度慢的问题。动量算法引入了一个指数衰减的累积变量，用来持续跟踪梯度的历史信息。这个累积变量就是动量。动量在更新参数时不仅考虑当前梯度，还考虑了之前梯度的方向。这有助于平滑更新过程，减少参数更新的震荡，提高模型训练的稳定性和速度。\n\n***\n\n## 7. 训练和验证\n\n训练需要 2 个循环的嵌套：外部循环用于循环 epoch ；内部循环用于循环每个 epoch 中的每个 batch 的图片，一个 batch 一步（step）。\n\n```python\nfor epoch in range(epochs):\n  for i, (images, labels) in enumerate(train_loader):\n    images = images.to(device)\n    labels = labels.to(device)\n \n    outputs = model(images)\n    loss = cost(outputs, labels)\n \n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n \n  print(\"Epoch [{}/{}], Step [{}/{}], Loss:{:.4f}\".format(\n      epoch+1, epochs, i+1, train_step, loss.item()))   # loss是张量，需要.item()转为浮点型\n \n  # 一个epoch完成之后，进入验证\n  with torch.no_grad():\n    correct = 0\n    total = 0\n    for images, labels in val_loader:\n      images = images.to(device)\n      labels = labels.to(device)\n      outputs = model(images)\n      _, predicted = torch.max(outputs.data, 1)\n      total += labels.size(0)\n      correct += (predicted == labels).sum().item()\n      # del images, labels, outputs   # 删除变量以释放内存\n \n    # 输出验证结果\n    print(\"Accuracy on validation: {} %\".format(100 * (correct / total)))\n```\n\n* **注意**：`enumerate(train_loader)` 返回的是 `(index, (images, labels))` 的元组，所以`for i, images, labels in enumerate(train_loader):`是错的，应该为`for i, (images, labels) in enumerate(train_loader):`. 相关文章：[enumerate(train_loader) 返回什么？](https://www.cnblogs.com/xing9/articles/18004447/enumerate)\n\n* `torch.max(outputs.data, 1)`返回每一行的最大值以及这些最大值所在的索引。第一个返回值（`_`）是最大值，第二个返回值（`predicted`）是最大值的索引。在这种情况下，我们只关心索引，因为它表示了模型的预测类别。\n\n* `labels.size(0)`返回的是当前批次中标签的数量。[如何理解 labels.size(0)](https://www.cnblogs.com/xing9/articles/18004411/labels_size)\n\n* `del images, labels, outputs` 是手动删除变量以释放内存。在Python中，这通常是不必要的，因为Python的垃圾回收器会自动处理不再使用的对象。\n\n* `for images, labels in val_loader:`不需要`numerate(val_loader)`是因为验证阶段不需要索引，看的是验证集整体的准确度。\n\n训练结果如下图：\n![](https://s2.loli.net/2024/12/26/sT6eduMPiQboJXZ.png)\n\n***\n\n## 8.测试\n\n```python\nwith torch.no_grad():\n  correct = 0\n  total = 0\n  for images, labels in test_loader:\n    images = images.to(device)\n    labels = labels.to(device)\n    outputs = model(images)\n    _, predicted = torch.max(outputs.data, 1)\n    total += labels.size(0)\n    correct += (predicted == labels).sum().item()\n    # del images, labels, outputs   # 删除变量以释放内存\n \n  # 输出测试结果\n  print(\"Accuracy on test: {} %\".format(100 * (correct / total)))\n```\n\n测试结果如下图：\n![](<https://s2.loli.net/2024/12/26/Ut3OzesQmKc8wJI.png>)\n\n***\n\n以上，就是 AlexNet 实现图像分类的全部内容。","tags":["AlexNet","PyTorch"]},{"title":"LeNet5 图像分类（PyTorch 框架）","url":"/post/1b5c5745.html","content":"# [手撸代码：从零开始的 LeNet5 图像分类（PyTorch 框架） ](https://www.cnblogs.com/xing9/p/17997507/LeNet5-PyTorch \"发布于 2024-01-31 14:13\")\n\n## **摘要：**\n\n本文介绍了如何从0开始构建 LeNet5 去识别手写数字（在MNIST数据集上）。代码包括三大部分：**网络**结构部分、**训练**部分、**测试**部分。在编LeNet5部分代码之前，本文详细地梳理了LeNet5的结构，对于初学者十分友好。训练和测试部分也都有详细的代码说明。\n\n在实现 LeNet5 手写数字识别的同时，补充了很多CNN的基础概念和Python编程知识。包括：PyTorch中的常用库和其中的模块，特征图在卷积过程中尺寸如何变化，如何把数据加载进训练程序等。\n\n本文不是通过复制粘贴代码介绍如何实现 LeNet5 的手写数字识别，而是通过内在逻辑，深层次地阐述这一过程，力求“知其然，知其所以然。”\n\n完整代码已经上传至GitHub：<https://github.com/TiezhuXing01/LeNet5_in_PyTorch.git>\n\n***\n\n**温馨提示：**\n（1）本文主要介绍如何从0实现LeNet5，注重编程思路的讲解，对于一些前置知识不做赘述。\n（2）请确保你已经**配置好**并进入了深度学习**环境**。\n（3）目录导航见页面**右上角**黄色方块。\n**前置知识：**\n（1）概念：PyTorch、卷积、池化、全连接、ReLU、前向传播、反向传播\n（2）对python语法有基本的了解\n\n***\n\n在从0开始编程前，我们首先思考一下，一个由LeNet5完成的图像分类任务（如：手写数字识别），都需要哪些组成部分？\n\n首先，肯定要有**LeNet5**网络结构的代码。\n其次，还要有在训练集上**训练**的代码，让网络学习特征表示。\n最后，训练完要在测试集上**测试**，不然咋知道训练得效果怎样呢？\n\n***\n\n## 1. 引入库（Import the Libraries）\n\n“库”是一组已经写好的代码，可以理解为一个“工具箱”。对于某些功能的实现，开发者可以从引入的“工具箱”中拿出工具直接使用，而不是从头开始“造工具”（即编代码）。所以在所有工作之前，要把“工具箱”引入进来，以方便后续编程。但有时候，我们引入库时可能会漏掉一些库，在编程到后面才意识到。不用担心，我们再回到开头这里引入库就好了。\n\n```haskell\n    import torch\n    import torch.nn as nn\n    import torchvision\n    import torchvision.transforms as transforms\n```\n\n* `torch`库提供了各种用于张量（tensor）操作、神经网络搭建、优化算法等方面的函数。\n  什么是张量？如果你对张量（tensor）不了解，不用担心，你只需要记住这是图片经过某种处理之后的一种形式，就像你已知的图片有.jpg和.png格式一样。但对于.jpg和.png格式的图像，神经网络并不喜欢，无法直接处理它们。而张量（tensor）这种形式，适用于神经网络的处理。\n\n* `torch.nn`库可以理解为大工具箱`torch`里面的小工具箱`nn`。这个模块里包含构建神经网络层和模型的类和函数。`import torch.nn as nn`表示，引入之后，模块`torch.nn`的名字就可以简称`nn`了。\n\n* `torchvision`库提供了一系列用于图像处理、计算机视觉数据集加载、图像变换、以及许多流行的计算机视觉模型的实现。\n\n* `torchvision.transforms`模块用于进行图像的变换和预处理。这个模块包含了一系列用于处理图像的转换函数，可用于数据增强、数据清理和准备图像数据以输入神经网络等任务。\n\n***\n\n## 2. 选择在哪个设备上训练模型（GPU或CPU）\n\n通常情况下，我们都会选择在GPU上训练网络模型，因为神经网络的训练需要大量的计算，而英伟达的GPU提供了CUDA（一个加速计算库）。但如果你的电脑显卡是AMD的，那么有很大概率不支持使用CUDA，此时只能用CPU训练。但在CPU上训练模型是十分缓慢的。如果你暂时没法换电脑，那我建议你去租一个服务器。或者使用阿里云、百度飞桨、谷歌Colab等平台。\n\n```ini\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n```\n\n* `torch.cuda.is_available()`函数的功能是检查系统中是否安装了可用的 CUDA并且 GPU 是可用的。如果 GPU 可用，返回 True，否则返回 False。\n\n* `'cuda' if torch.cuda.is_available() else 'cpu'`表示如果GPU可用，则返回字符串`'cuda'`。如果不可用，则返回字符串`'cpu'`。\n\n* 如果函数`torch.device(...)`接收到的是`'cuda'`，则选择在GPU上计算，如果接收到的是`'cpu'`，则选择在CPU上进行计算。\n\n***\n\n## 3. 认识网络\n\n充分地认识网络，才能在编程时思路清晰、游刃有余。下图是LeNet5的结构图，请你直观地认识一下LeNet5。如果你不想了解，可以直接去 4. 构建网络，不过我不建议你这样。\n本例中LeNet5处理的MNIST数据集图片尺寸都是32×32. 所以下图的输入图片是32×32.\n\n![](<https://s2.loli.net/2024/12/26/QN6wUGncvDbgiyY.png>)\n\n我把上图的网络结构具体为下面的表格，以便我们后续编程。注意：画表格并不是编程所需的必要步骤，只是我希望表达得更清晰。\n\n| 层的名称  | 具体操作 | 输入通道数 | 输出通道数 | 核或池的尺寸 | 步幅 |\n| --------- | -------- | ---------- | ---------- | ------------ | ---- |\n| 卷积层1   | 卷积     | 1          | 6          | 5×5          | 1    |\n|           | 批归一化 | 6          | 6          | --           | --   |\n|           | ReLU     | 6          | 6          | --           | --   |\n| 下采样    | 最大池化 | 6          | 6          | 2×2          | 2    |\n| 卷积层2   | 卷积     | 6          | 16         | 5×5          | 1    |\n|           | 批归一化 | 16         | 16         | --           | --   |\n|           | ReLU     | 16         | 16         | --           | --   |\n| 下采样    | 最大池化 | 16         | 16         | 2×2          | 2    |\n| 全连接层1 | 全连接   | 400        | 120        | --           | --   |\n|           | ReLU     | 120        | 120        | --           | --   |\n| 全连接层2 | 全连接   | 120        | 84         | --           | --   |\n|           | ReLU     | 84         | 84         | --           | --   |\n| 高斯连接  | 全连接   | 84         | 类别总数10 | --           | --   |\n\n下面我们梳理一下LeNet5的详细流程，这样到后面编程的时候不会懵。\n\n***\n\n### （1）卷积层1：提取低级特征\n\n#### a) 第一次卷积\n\n在图中可以看到，第一次卷积操作之后，不仅通道**由1变6**，原图32×32的尺寸也变成了28×28，这与卷积核大小、步幅和 $padding$ 有关（LeNet5中，2次卷积padding都为0）。输出特征图像尺寸公式如下：\n$output size=\\frac{W-kernel size+2*padding}{stride}+1$\n其中， $W$ 表示输入图像的宽度。\n\n将数代入公式：\n$output size=\\frac{32-5+2*0}{1}+1=28$\n#### b) 批归一化\n\n批归一化 (Batch Normalization) 是一种用于提高神经网络训练稳定性和加速收敛的方法。在卷积神经网络中，每个通道都有一个独立的归一化参数。因此输入是6通道，输出还是**6**通道。\n\n#### c) ReLU激活函数\n\n产生非线性映射，通道数还是**6**，不变。\n\n***\n\n### （2）下采样\n\n最大池化，通道数不变，还是**6**，特征图尺寸由28×28下降到14×14. 计算公式如下：\n$output size=\\frac{W-pool size}{stride}+1=\\frac{28-2}{2}+1=14$\n***\n\n### （3）卷积层2：提取高级特征\n\n#### a) 第二次卷积\n\n通道由6变**16**，输出特征图尺寸为10×10.具体计算公式如下：\n$output size=\\frac{W-kernel size+2*padding}{stride}+1=\\frac{14-5+2*0}{1}+1=10$\n#### b) 批归一化+ReLU\n\n输出通道还是**16**。\n\n***\n\n### （4）下采样\n\n特征图尺寸由10×10变成5×5，输出通道还是**16**。\n$output size=\\frac{W-pool size}{stride}+1=\\frac{10-2}{2}+1=5$\n***\n\n### （5）全连接层1\n\n将输入维度为 400 的向量（一维数组）映射到维度为 120 的输出向量。\n其中，400为16个通道的5×5大小的所有像素数量。$16*5*5=400$\n120是研究人员通过在实验中不断调整得到的。\n\n### （6）全连接层2\n\n将前一层的 120 个节点映射到 84 个节点。\n\n### （7）高斯连接（全连接层3）\n\n将84个节点映射到10个具体类别上，即0~9这10个数字上。\n\n***\n\n## 4. 搭建网络\n\n在搭建之前，我将介绍一个“工具”。`nn.Sequential()`是 PyTorch 中用于构建容器（container）的类。通俗地讲，这个工具的作用就是把好几个操作串到一起，按顺序执行。\n\n```python\n    # 定义名为 LeNet5 的类，该类继承自 nn.Module\n    class LeNet5(nn.Module):\n        def __init__(self, num_classes):\n            super(LeNet5, self).__init__()\n            # 卷积层 1\n            self.layer1 = nn.Sequential(\n                nn.Conv2d(1, 6, kernel_size=5, stride=1, padding=0),    # 卷积\n                nn.BatchNorm2d(6),      # 批归一化\n                nn.ReLU(),)\n            # 下采样\n            self.subsampel1 = nn.MaxPool2d(kernel_size = 2, stride = 2)     # 最大池化\n            # 卷积层 2\n            self.layer2 = nn.Sequential(\n                nn.Conv2d(6, 16, kernel_size=5, stride=1, padding=0),\n                nn.BatchNorm2d(16),\n                nn.ReLU(),)\n            # 下采样\n            self.subsampel2 = nn.MaxPool2d(kernel_size = 2, stride = 2)\n            # 全连接\n            self.L1 = nn.Linear(400, 120)\n            self.relu = nn.ReLU()\n            self.L2 = nn.Linear(120, 84)\n            self.relu1 = nn.ReLU()\n            self.L3 = nn.Linear(84, num_classes)\n        # 前向传播\n        def forward(self, x):\n            out = self.layer1(x)\n            out = self.subsampel1(out)\n            out = self.layer2(out)\n            out = self.subsampel2(out)\n            # 将上一步输出的16个5×5特征图中的400个像素展平成一维向量，以便下一步全连接\n            out = out.reshape(out.size(0), -1)\n            # 全连接\n            out = self.L1(out)\n            out = self.relu(out)\n            out = self.L2(out)\n            out = self.relu1(out)\n            out = self.L3(out)\n            return out\n```\n\n发现没有？套路就是：先self.各种层，一顿定义。然后到前向传播（`forward`）那里，开始用上一步定义的`self.something()`。最后，`return out`返回输出值。\n\n对于初学者而言，如果Python基础不牢，最开始那三行代码理解起来可能比较吃力。其实用多了就会发现，这就是个套路，不理解也不耽误编程。\n\n***\n\n此处展开前三行代码\n\n```haskell\n    class LeNet5(nn.Module):\n        def __init__(self, num_classes):\n            super(LeNet5, self).__init__()\n```\n\n* 我们来看第一行代码。这行代码定义了一个名为 `LeNet5` 的类，它继承自 `nn.Module`（别忘了，在最开始引入库时，引入过`nn`），说明这是一个 PyTorch 框架中神经网络模型的基类。所有的神经网络模型都应该继承自 `nn.Module`，这样它们就能够利用 PyTorch 提供的模型管理和训练的功能。\n\n* 第二行代码：是类的构造函数（initializer）。构造函数用于初始化类的实例。`num_classes`是类别数，这里是我们构造的网络所接收的参数，后续要用到这个参数。\n\n* 第三行代码：调用了父类 `nn.Module` 的构造函数，确保正确地初始化 LeNet5 类的父类部分。这是 Python 中用于调用父类方法的一种方式。\n\n如果读完这些解释还是不理解，没关系，你可以把这三行当作一个套路，用多了自然就会记住。\n\n套路如下：\n\n```ruby\n    class 网络名字(nn.Module):\n        def __init__(self, 需要接受的参数)：\n            super(网络名字, self).__init__()\n```\n\n***\n\n## 5. 准备（加载）数据集\n\n在上一步中，LeNet5已经搭建好了，现在该编写训练部分的程序了。但是在这之前有一步不能落下，那就是数据加载。\n\n要把数据集里的一堆数据“码好”了，一批一批地“喂”给LeNet5.\n\nMNIST 数据集是一个手写数字图像数据集，包含了大量的手写数字图片，每张图片都标注了对应的数字。\n`torchvision.datasets.MNIST(...)`是 PyTorch 中用于加载 MNIST 数据集的类。\n`torch.utils.data.DataLoader(...)` 是 PyTorch 中用于批量加载数据的工具类，是一个数据加载器。\n\n注意：前者用于加载数据**集**，后者用于加载数据，不要混淆。\n\n把一个数据集比作一副扑克牌，那么一张扑克牌就是一个数据。把DataLoader比作神经网络的手，手去抓牌。一次抓几张，抓牌有没有顺序，等等，这些都是通过设置DataLoader的参数决定的。batch_size等于几就是一次抓几张牌，即一次“喂”给神经网络几张图片。\n\n```ini\n    # 加载训练集\n    train_dataset = torchvision.datasets.MNIST(root = './data', # 数据集保存路径\n                                               train = True,    # 是否为训练集\n                                               # 数据预处理\n                                               transform = transforms.Compose([\n                                                      transforms.Resize((32,32)),\n                                                      transforms.ToTensor(),\n                                                      transforms.Normalize(mean = (0.1307,), \n                                                                         std = (0.3081,))]),\n                                               download = True) #是否下载\n\n    # 加载测试集\n    test_dataset = torchvision.datasets.MNIST(root = './data',\n                                              train = False,\n                                              transform = transforms.Compose([\n                                                      transforms.Resize((32,32)),\n                                                      transforms.ToTensor(),\n                                                      transforms.Normalize(mean = (0.1325,), \n                                                                         std = (0.3105,))]),\n                                              download=True)\n    # 一次抓64张牌\n    batch_size = 64\n    # 加载训练数据\n    train_loader = torch.utils.data.DataLoader(dataset = train_dataset,\n                                               batch_size = batch_size,\n                                               shuffle = True)  # 是否打乱\n    # 加载测试数据\n    test_loader = torch.utils.data.DataLoader(dataset = test_dataset,\n                                               batch_size = batch_size,\n                                               shuffle = False) # 是否打乱\n```\n\n* 训练阶段的`shuffle=True`：将数据集打乱顺序，有助于模型学习更泛化的特征。通过打乱数据顺序，模型在每个 epoch 中都能够看到不同的样本，防止模型过度拟合训练集中的特定顺序。\n\n* 测试阶段的`shuffle=False`：在测试阶段，通常不需要打乱数据的顺序。测试时模型是在未见过的数据上进行评估，因此希望模型看到的是原始数据的有序顺序，以便能够更好地评估模型的泛化性能。如果在测试时也打乱数据，可能会导致模型在评估时看到的数据分布与实际场景不一致。（其实如果是`True`影响也不大）\n\n***\n\n## 6. 设置超参数\n\n在训练之前，我们需要设置一些超参数，为训练阶段要用到的模型、损失函数、优化器做准备。\n\n### （1）创建 LeNet5 模型\n\n```ini\n    num_classes = 10\n    model = LeNet5(num_classes).to(device)\n```\n\n* `LeNet5(num_classes)`：创建一个 LeNet5 类的实例。还记得么？前文提到过，该类是继承自 nn.Module 的神经网络模型，接受 num_classes 参数，表示模型输出的类别数目。\n* `to(device)`：将模型移动到指定的设备上，其中 `device` 是一个设备对象，可以是 `'cuda'`（GPU）或者 `'cpu'`。这一步是为了确保模型在训练和推理时使用的是正确的计算设备。\n* `model = ...`：将创建并移动到指定设备的模型赋值给变量 model，以便后续对模型的引用和操作。\n\n### （2）创建损失函数\n\n在这里，损失函数设置为交叉熵损失函数\n\n```ini\n    cost = nn.CrossEntropyLoss()\n```\n\n* `nn.CrossEntropyLoss()`是 PyTorch 中用于计算多类别交叉熵损失的损失函数。交叉熵损失通常用于分类问题，特别是当目标是多类别标签时。它的计算涉及到模型的预测值和实际类别标签之间的比较，以衡量模型输出与真实标签之间的差异。\n\n### （3）创建优化器\n\n```ini\n    learning_rate = 0.001\n    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\n```\n\n* `torch.optim.Adam`：这是 PyTorch 中提供的 Adam 优化器的实现。Adam 是一种常用的随机梯度下降算法的变体，它通过自适应地调整学习率来优化模型参数。\n* `model.parameters()`：指定要被优化的参数，就是告诉优化器去优化谁，这里选择了模型 model 中的所有参数。\n* `lr=learning_rate`：设置学习率，即每次参数更新时的步进大小。\n\n### （4）确定每轮共需几步\n\n```ini\n    total_step = len(train_loader)\n```\n\n* `len(train_loader) `返回加载器中的批次数量。\n* MNIST数据集中有 60000 张图片作为训练集。我们每次抓64张牌，那么一共要抓 $\\frac{60000}{64}=937.5$ ，937.5 向上取整是 938 个批次。也就是说，由于数据加载器DataLoader的存在，LeNet5 把训练集所有图片遍历一遍要 938 步（step）。训练一轮（epoch）需要 938 步（step）。总结一下，一轮需要很多步，**一步就是一个批次**。\n\n***\n\n## 7. 训练\n\n我们将用 2 个 for 循环的嵌套来实现训练过程。\n\n先让我们梳理一下应该如何训练。首先，训练分很多轮（epoch），每轮训练都需要把全部训练集过一遍。所以需要一个 for 循环，一轮一轮地进行循环。这个“过一遍”是通过数据加载器 DataLoader 实现的。其次，在一轮训练中，完整遍历一次训练集需要一个 for 循环，去循环从 DataLoader 加载过来的每个批次的图片（本例为64张图）。\n\n在本例中，我设置共训练 10 轮。\n\n```python\n    # 设置一共训练几轮（epoch）\n    num_epochs = 10\n    # 外部循环用于遍历轮次\n    for epoch in range(num_epochs):\n        # 内部循环用于遍历每轮中的所有批次\n        for i, (images, labels) in enumerate(train_loader):  \n            images = images.to(device)\n            labels = labels.to(device)\n\n            # 前向传播\n            outputs = model(images)   # 通过模型进行前向传播，得到模型的预测结果 outputs\n            loss = cost(outputs, labels)    # 计算模型预测与真实标签之间的损失\n\n            # 反向传播和优化\n            optimizer.zero_grad()   # 清零梯度，以便在下一次反向传播中不累积之前的梯度\n            loss.backward()     # 进行反向传播，计算梯度\n            optimizer.step()    # 根据梯度更新（优化）模型参数\n\n            # 定期输出训练信息\n            # 在每经过一定数量的批次后，输出当前训练轮次、总周轮数、当前批次、总批次数和损失值\n            if (i+1) % 400 == 0:\n                print ('Epoch [{}/{}], Step [{}/{}], Loss: {:.4f}' \n                               .format(epoch+1, num_epochs, i+1, total_step, loss.item()))\n```\n\n* 在内部循环`for i, (images, labels) in enumerate(train_loader):`中`enumerate(train_loader)` 返回一个可迭代的对象，其中包含每个批次的图像和标签。\n\n* `images = images.to(device)` 和 `labels = labels.to(device)`：将加载的图像和标签移动到设备（通常是 GPU），以便在设备上执行模型的前向和后向传播。\n\n* 对初学者而言，“定期输出训练信息”部分的代码用`print`输出即可，后期熟练了可以尝试用`tqdm`库显示进度条。这不是本文重点，有兴趣的可以自行了解。\n\n***\n\n训练时输出的结果：\n![](https://s2.loli.net/2024/12/26/iecCf3X6SpkQIz4.png)\n\n938 跟我们之前手动计算的总批次数（步数）数是吻合的。\n\n## 8. 测试\n\n```python\n    with torch.no_grad():   # 指示 PyTorch 在接下来的代码块中不要计算梯度\n        # 初始化计数器\n        correct = 0     # 正确分类的样本数\n        total = 0       # 总样本数\n\n        # 遍历测试数据集的每个批次\n        for images, labels in test_loader:\n            # 将加载的图像和标签移动到设备（通常是 GPU）上\n            images = images.to(device)\n            labels = labels.to(device)\n\n            # 模型预测\n            outputs = model(images)\n\n            # 计算准确率\n            # 从模型输出中获取每个样本预测的类别\n            _, predicted = torch.max(outputs.data, 1)\n            # 累积总样本数\n            total += labels.size(0)\n            # 累积正确分类的样本数\n            correct += (predicted == labels).sum().item()\n\n        # 输出准确率，正确的 / 总的\n        print('Accuracy of the network on the 10000 test images: {} %'.format(100 * correct / total))\n```\n\n* 在测试阶段，我们通常不需要计算梯度，以提高内存效率。\n\n* 注意看 `_, predicted = torch.max(outputs.data, 1)` 中的 `torch.max(xxx, 1)`表示对于每个输入 `xxx` 而言，`torch.max` 返回一个元组，其中包含两个张量，第一个张量是最大值，第二个张量是最大值所在的索引（也就是属于哪一类）。\n  举个例子，在图像处理中，神经网络通常输出一个二维张量。什么样的二维张量呢？在3分类问题中输出二维张量：\n\n  ```lua\n    tensor([[0.1, 0.8, 0.3],\n            [0.4, 0.2, 0.9],\n            [0.7, 0.5, 0.2],\n            [0.6, 0.2, 0.4]])\n  ```\n\n  上面的二维张量，由 4 个长度为 3 的一维张量构成。`torch.max(xxx, 1)`在每一行中寻找最大值。\n  `torch.max(xxx, 1)`返回结果为元组：\n\n  ```scss\n    (tensor([0.8, 0.9, 0.7, 0.6]), tensor([1, 2, 0, 0]))\n  ```\n\n  其中，0.8, 0.9, 0.7, 0.6 分别为属于索引（类别）1, 2, 0, 0 的概率（或得分）。\n\n* 而 `_, predicted = torch.max(outputs.data, 1)` 中的 `_` 。它是一个通常用作占位符的变量名。在 Python 中，通常使用 `_` 表示一个临时或不使用的变量。在本例中，我们不要属于索引（类别）的概率（或得分），只要最终结果，即属于哪个索引（类别），把它的值赋给`predicted`\n  测试阶段运行的结果：\n  ![](https://s2.loli.net/2024/12/26/DI6rmZHU3cbkysE.png)\n  可以看到达到了99.12%\n\n***\n以上，就是从0开始敲LeNet5的全部过程。","tags":["PyTorch","LeNet5"]},{"title":"entertainment","url":"/post/5dcf0f53.html","content":"```C++\n/*\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠣⡀⠀⣀⣀⣤⣤⣤⣶⣶⣶⣶⣶⣶⣶⣶⣶⣦⣤⣤⣤⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣦⣤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠤⠤⣄⣀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⢿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⣠⠋⣸⣷⣤⡀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠋⠉⠉⠛⠓⠦⡀⠈⠢⡀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠐⠂⠉⠉⠉⠉⠁⠒⠂⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣠⢁⣼⣿⣿⣿⣿⣦⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⠉⠉⠁⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⡈⢆⠀⠀⠀⠀⠠⠊⠁⠀⠀⠀⠀⣀⣠⣤⠤⠤⠤⠤⣈⠐⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢⣧⠀⠀⡔⠁⠀⠀⠀⣠⣴⡿⠿⠭⠤⣄⡀⠀⠀⠀⠉⢺⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠁⠀⠙⠻⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⡰⠀⠀⠀⣠⠞⠋⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠋⠙⢄⠀⠀⠀⠀⠀⠀⠈⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠐⠢⠤⢀⣰⡆⣀⣀⣀⠀⢀⡃⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⢀⣴⣿⣿⣿⣿⡿⠙⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠋⠉⢣⠀⠀⠀⠀⠀⠱⢄⠀⠀⠀⠀⠀⠀⠈⠢⡀⠀⠀⠀⠀⠀⠐⡀⠀⠀⠀⠀⠀⠀⡴⠥⣷⠎⠉⠀⠀⠀⠈⠑⢴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣿⣿⣿⣿⣿⡟⠁⠀⠀⢠⠃⠀⠀⠀⠀⠀⠈⣹⣿⡿⣿⣿⠿⠟⠛⠋⡟⠁⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠈⠳⡀⠀⠀⠀⠀⠀⠀⠈⢢⠀⠀⠀⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⡌⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⢛⢿⣿⣿⠟⠀⠀⠀⢀⠇⠀⡞⠀⠀⠀⠀⠀⣿⠏⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠙⡄⠀⠀⠀⠀⠀⠙⣦⡀⠀⠀⠀⠀⠀⠀⡑⡄⠀⠀⠀⠀⢳⠀⠀⠀⠀⢀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣄⡀⠀⠀⠀⠀⠀⠀⠀⣀⠊⠀⠀⠀⡐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣠⠶⠋⠁⠀⠀⠀⠀⠎⠀⣸⠃⠀⠀⠀⠀⢰⡟⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣄⠀⠀⠀⠀⠀⠘⢿⣦⡀⠀⠀⠀⠀⠘⡌⢆⠀⠀⠀⠈⢏⠉⠁⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⢠⣏⠉⠉⠑⠒⠤⠤⠤⠤⠊⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⡰⠀⢠⣿⠀⠀⠀⠀⠀⣿⠃⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡄⠀⠀⠀⠀⠀⠀⠹⣿⣄⠀⠀⠀⠀⠱⡜⣧⡱⠀⠀⠘⡄⠀⠀⠀⠀⠀⠑⠦⣀⡀⠀⢀⣠⣴⢿⢿⣷⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⡠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢠⠃⠀⣾⡇⠀⠀⠀⠀⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡈⢆⠀⠀⠀⠀⠀⠹⣿⣦⡀⠀⠀⠀⢱⠬⣷⣅⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⣸⡿⠋⠉⠁⡿⠈⢮⢻⡻⠿⣿⣶⣒⡒⠒⠒⠂⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⡈⠀⣸⣿⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠸⡄⠀⠀⠀⠀⠀⢹⡄⠉⠇⠂⠤⣀⠃⠘⣿⡄⠀⠈⡆⠀⠀⠀⠀⢠⡾⠋⠀⠀⠀⠀⠇⠀⢸⠧⡝⢦⡀⠀⠀⠀⠉⠐⠒⠂⠀⢀⣀⠲⠖⠊⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢀⠇⠀⡿⡇⠀⠀⠀⠀⠀⡿⡇⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⢱⡀⠀⠀⠀⠀⠀⢳⠀⠸⡄⠀⠀⠉⢢⣸⣿⡀⠀⢸⠀⠀⢀⠴⠋⠀⠀⠀⠀⢀⡸⠀⠀⠈⡇⠈⠲⣌⠲⢄⡀⠀⠉⠉⠭⣉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢸⠀⠀⡇⡇⠀⠀⠀⠀⠀⡇⡇⠀⠀⠀⠰⠀⠀⠀⠀⢸⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⣇⠀⠀⠀⠀⠀⠈⡇⠀⠈⠑⠲⢤⣤⣽⡏⢃⠀⠈⡄⠐⠀⠀⠀⠀⠀⠀⠀⣾⠃⠀⠀⠀⢳⠀⠀⠀⠙⠢⣝⡲⢤⣀⣀⠀⠉⠀⠒⠠⠤⠄⠀⠀⢤⠔⠀⠀⠀\n⠀⠀⠀⠀⠀⡇⠀⢠⢰⢠⠀⠀⠀⠀⢠⡇⡇⠀⠀⠀⠀⡄⠀⠀⠀⠘⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠸⡄⠀⠀⢸⡀⠀⢻⠀⠀⠀⠀⠀⢫⡩⠵⣮⡆⠀⢱⠐⢄⣀⡀⣀⣀⣀⡾⠃⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠉⠛⠲⠯⣭⡭⠛⠋⠁⢀⣀⠤⠐⠁⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⡇⠀⢸⣸⡘⠀⠀⠀⠀⠀⣧⠃⠀⠀⠀⠀⣇⠀⠀⠀⠀⡟⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⣇⠀⠀⢸⡇⠀⠈⡇⠀⣀⠄⠂⠁⠳⣄⠈⢻⠀⠈⡆⠢⢽⣄⢀⣀⡙⢦⡒⠒⠦⢔⡊⠉⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢸⡇⡇⠀⠀⠀⣀⣀⣿⣰⠀⠀⠀⠀⢸⠀⠀⠀⠀⣇⠘⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣿⠀⠀⢸⣿⠀⣀⣷⠊⠀⠀⠀⠀⠀⠀⠉⠉⡇⡀⣧⣤⣼⠿⢇⡤⠀⠑⣇⠐⠒⢒⣡⣀⣱⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⡀⠀⢸⡇⡇⠀⢯⠭⠭⠵⢶⡞⡇⠀⠀⠀⠈⡇⠀⠀⠀⢸⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣿⠀⠀⢸⣿⡟⠁⢸⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣷⢻⡿⠁⠀⠛⠀⠀⠀⠈⣖⢶⣿⣿⡿⠿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⡇⠀⢸⡇⢧⠀⠀⠀⠀⣀⣤⣷⣿⠀⠀⠀⠀⣿⡀⠀⠀⠘⡆⠀⠈⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⡏⠀⠀⠊⡻⢸⠀⣼⠀⠀⣠⣶⣿⣿⣿⣿⣟⢛⠉⡎⡁⠀⠀⠀⠀⠀⠀⠀⣘⠀⠀⠀⠀⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢃⠀⢸⢹⠸⠀⠀⢰⣿⢿⣛⣿⣽⡦⠀⠀⠀⢹⣷⠀⠀⠀⢱⠀⠀⠀⠳⡀⠀⠀⠰⡀⠀⠀⠀⠀⡼⢰⢧⡀⠀⠀⡇⠸⡎⡇⣴⣿⡿⢛⣿⣿⣿⣿⣿⠸⠀⠇⡇⠀⠀⠀⠀⠀⠀⠀⣿⡆⠀⠀⠀⠀⠘⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠸⡀⠈⢸⠀⠇⠀⠀⠰⠟⠋⠉⣧⠹⡄⠀⠀⠸⣿⢳⡒⠉⠙⡍⠉⠉⠉⠛⣆⠀⠀⠘⢦⡀⠀⢠⢧⡟⠀⢳⡀⢠⠃⢠⢣⢳⡿⠛⢶⣿⣿⣿⣿⣿⣿⠃⡏⠀⢡⠀⠀⠀⠀⢀⠇⢸⡏⣿⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢃⠀⡘⡀⢸⠀⠀⠀⠀⠀⠀⠸⡄⢧⠀⠀⠀⣿⠀⠱⡄⠀⠘⡄⠀⠀⠀⠈⠳⡄⠀⠈⠻⡢⣼⣿⠁⠀⠀⠑⣼⠀⢸⡎⠀⠀⠀⠀⠻⢿⣿⣿⣿⠿⠂⢣⠀⢺⠀⠀⠀⠐⠋⣠⣿⠇⢹⡆⠀⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠈⢆⡇⡇⠀⣆⠀⠀⠀⠀⠀⠀⢳⡈⢧⠀⠀⢸⠀⠀⠈⠢⡀⠙⣄⠀⠀⠒⠒⠨⠳⢄⣀⡼⠫⣙⡦⢄⣀⠀⠈⠳⢯⠁⠀⠀⠀⠀⠀⠈⠉⠁⠀⠀⠀⢸⠀⢸⠀⠀⣾⣐⡴⠟⠉⠀⠀⣧⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠘⣇⢿⡀⢸⡄⠀⠀⠀⠀⠀⠈⢧⠘⢆⠀⠘⡇⠀⠀⠀⠈⠓⠬⣢⡀⠀⠀⠀⠀⠐⠉⠑⠲⢬⠷⣦⣞⡉⠒⠲⠿⠭⠶⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡀⢸⠀⣰⣿⣿⣄⠀⠀⠀⠀⢿⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢀⣸⡼⣗⢺⣿⡛⠛⠛⠛⠲⢦⢸⣧⠈⢆⠀⢱⣄⠀⠀⠀⠀⠀⠀⣉⣑⣢⣤⣤⡤⠀⠀⢠⢇⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⣸⢰⣿⡏⢸⣿⣧⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⢱⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⣠⡶⠋⠑⡌⡟⣿⡿⣧⠀⠀⠀⠀⠀⠀⢻⣷⡈⢣⠈⣿⣷⣤⣴⣿⠿⠿⠛⠟⠛⠉⠀⠀⠀⠠⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⣿⢿⣿⡇⣿⣿⣿⣧⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⣰⠋⠀⠀⠀⠇⢰⡇⢧⠹⣧⠀⠀⠀⠀⠀⠀⢻⣷⣄⠳⡹⣿⣸⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡿⠘⣿⣷⣿⣿⣿⣿⣦⠀⠘⣿⡆⠠⡀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⡀⠠⠁⠀⠀⠀⠀⠸⡘⣇⢸⠀⠘⣷⡀⠀⠀⠀⠀⠀⢻⡎⠢⡙⢿⣿⢿⠙⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⡇⡇⠀⣿⣿⣿⣿⣿⠿⠛⠀⠀⣿⣧⠀⠱⡀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠠⣾⢛⣷⠶⠀⠀⠀⠀⠀⢱⠘⣼⠀⠀⣿⡷⣄⠀⠀⠀⠀⠀⠹⡄⠙⢮⡹⣇⠉⣦⣵⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠂⠀⠀⠀⠀⠀⣠⣾⣦⢁⡇⢰⣿⡟⠋⠉⠀⠀⠀⠀⠀⢸⠈⣇⠀⠘⣆⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⣿⠟⠸⠀⠀⠀⠀⠀⠀⣾⣧⢹⡄⢠⡟⣷⡘⢦⡀⠀⠀⠀⠀⠹⡄⠀⠈⠪⣷⢽⠀⠻⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠤⠐⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⢸⣿⢸⠀⠸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠸⠀⠘⢆⠀⠈⢷⡀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠁⠀⠀⠀⠀⠀⠀⠀⢰⠛⣿⣇⠹⣼⠃⠹⣷⠀⠙⢦⠀⠀⠀⠀⠙⣄⠀⠀⠈⢹⠿⣦⣈⠑⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠈⡇⣾⠀⠀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠈⢿⣦⡀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⡌⠀⠸⣿⣷⡘⢦⡀⠹⡇⠀⠀⢹⣦⡀⠀⠀⠈⢢⡀⠀⢸⠀⠈⠉⠛⠦⣭⡙⠓⠶⢤⠤⣠⣤⣀⣀⣀⣀⣀⣀⣀⡀⠀⣀⠜⠁⠀⠀⠀⠀⢰⢣⣧⡀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⢀⠃⠀⣸⣿⡿⣿⠶⣝⢦⣽⣆⠀⠀⢿⣏⠲⢤⡀⠀⠙⠢⣼⡀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠘⣿⡄⠀⠀⢘⣿⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⡼⡘⠋⠳⣄⢸⡀⠀⠀⠀⡆⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠘⣎⠢⣄⠘⢦⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⡎⠀⢠⣿⡟⠀⠈⠳⣮⣹⣿⠛⢧⡄⠈⢻⡀⠀⠉⠓⠦⢤⣈⣙⡓⠦⣄⣀⣀⡀⠀⠀⠀⢧⠀⠸⡷⠀⣴⠟⢿⡀⠀⠀⠀⠀⠀⠀⠀⣀⡴⡿⣹⠃⠀⠀⠘⢧⡇⠀⠀⠀⡇⠀⠀⠀⠀⡇⠀⠀⠀⢀⣀⣀⣀⣀⣀⣈⣆⠀⠑⢤⡙⢿⣷⣦⣄⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢰⠀⢠⣿⡟⠀⠀⠀⠀⠈⣿⡟⠀⠀⠙⣦⡀⠱⡄⠀⠀⠀⠀⠀⢻⠉⠉⠉⠉⠉⠁⠀⠀⠀⢸⠀⠀⢱⡞⠁⠀⠀⠉⠓⠶⢤⣄⣀⡠⠞⠁⣰⡿⠁⠀⠀⠀⠀⠨⡇⠀⠀⠀⡇⠀⠀⠀⠀⣿⠁⠈⠉⠁⠀⠀⠀⠀⠀⠀⠉⠳⢄⠀⠈⠲⣿⣿⣿⣿⣶⣤⣀⠀\n⠀⠀⠀⠀⠀⠀⢠⢃⠔⣻⡿⠀⠀⠀⠀⠀⢰⣿⠀⡇⠀⢠⣿⣿⠦⣘⢦⡀⠀⠀⠀⠸⡦⠴⠶⠶⠶⠶⠶⠶⠶⠞⠒⠺⣏⠀⠀⠀⠀⠀⠀⢰⡟⠉⠀⠑⣶⣼⠟⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀⢠⠁⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠣⡀⠀⠀⠙⠿⣿⣿⡧⠈⠓\n⠀⠀⠀⠀⠀⠀⡞⠀⣰⣿⠁⠀⠀⠀⠀⠀⢸⡏⠀⡇⠀⢸⣿⣿⠀⠈⠙⠛⠲⠤⡀⠀⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡆⠀⠀⠀⠀⢠⣏⡀⠀⢠⡴⠟⣷⡀⠀⠀⠀⠀⠀⠀⣸⢇⠀⠀⣸⠀⠀⠀⠀⡀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⠀⠀⠀⠀⠈⠻⢿⡀⠀\n⠀⠀⠀⠀⠀⡜⠀⢠⢻⠇⠀⠀⠀⠀⠀⠀⢸⠃⠀⢣⠀⢸⣿⢿⠀⠀⠀⢀⠀⠀⠀⠀⡞⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣷⡀⠀⠀⠀⣿⣿⣿⣦⣀⣀⣴⣿⣷⡄⠀⠀⠀⠀⢠⣿⠈⢦⠀⡇⠀⠀⠀⢸⡇⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⠀⠀⠀⠀⠀⠀⠙⢦\n⠀⠀⠀⠀⢰⠀⠠⠃⡞⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠈⡆⡿⣿⠘⡇⠀⠀⣨⠀⠀⠀⠀⢷⡹⡀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣧⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⢀⣾⡇⠠⡈⢠⠃⠀⠀⠀⢸⣧⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⢠⠃⡠⠃⢀⡇⠀⠀⠀⠀⢀⡄⠀⡇⠀⠀⠀⢸⡇⡏⠀⢧⠀⠀⣿⡆⠀⠀⠀⠘⡗⣝⣄⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣀⣼⣿⣿⣿⣿⡿⠟⠉⢿⣿⣿⣿⣿⣆⢀⣾⣿⠃⠀⢡⡏⠀⠀⠀⠀⢸⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢆⠀⠀⠀⠀⠀⠀\n⠀⠀⢀⠆⡰⠁⠀⢸⠁⠀⠀⠀⠀⢸⡇⠀⡇⠀⠀⠀⠀⣧⡇⠀⠸⡀⠀⣿⣷⡀⠀⠀⠀⢹⡀⠙⠳⠦⣄⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⡏⠀⢀⡼⠀⠀⠀⠀⠀⣾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣦⡀⠀⠀⠀⠀\n⠀⠀⡌⡐⠁⠀⠀⡾⠀⠀⠀⠀⠀⢸⢻⠀⣧⠀⠀⠀⠀⣾⡇⠀⠀⡇⠀⢻⣿⣧⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⣀⣀⠀⣼⣿⣿⣿⣿⣿⡿⠀⢀⣾⠃⠀⠀⠀⠀⣰⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡝⢦⡀⠀⠀\n⠀⡰⡜⠁⠀⠀⢀⡇⠀⠀⠀⠀⠀⡏⠘⡇⢹⠀⠀⠀⢸⣿⢸⠀⠀⠘⡄⠘⣿⣿⣧⠀⠀⠀⠀⢣⡀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠿⣿⡟⠻⣿⣿⣿⣿⣿⣿⠃⣠⣿⠏⠀⠀⠀⠀⢀⣿⣿⠇⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⣆⡙⠢⡀\n⢰⡵⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⢠⠇⠀⢳⡘⡆⠀⢀⠇⢻⡼⡀⠀⠀⠱⡀⠹⡟⣿⣧⡀⠀⠀⠀⠳⡀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⢿⣿⠀⢸⣿⣿⣿⣿⣧⣾⣿⠏⠀⠀⠀⠀⢀⣾⣿⣿⡄⠀⠀⢸⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠤⠒⠉⠀⠀⢳⠀⠈                                \n*/\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=2e6+10;\nconst int mod=1e9+7;\nint r,c;\nvector<int>sum[N],edge[N];\nstring s;\nint vis[N];\nbool dfs(int u,int fa){\n\t//cout<<u<<endl;\n\tfor(auto v:edge[u]){\n\t\tif(v==fa)continue;\n\t\tif(vis[v]==vis[u])return 0;\n\t\telse {\n\t\t\tif(vis[v]==0){\n\t\t\t\tif(vis[u]==1)vis[v]=2;\n\t\t\t\telse vis[v]=1;\n\t\t\t\tdfs(v,u);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nvoid solve(){\n\tcin>>r>>c;\n\tfor(int i=1;i<=c;i++)sum[i].clear();\n\tfor(int i=1;i<=2*r;i++)vis[i]=0,edge[i].clear();\n    for(int i=1;i<=r;i++){\n\t\tcin>>s;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(s[j]=='1')sum[j+1].push_back(i);\n\t\t}\n\t}\n\tif(c&1){\n\t\tif(sum[(c+1)/2].size()>1){\n\t\t\tcout<<0<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor(int i=1;i<=r;i++){\n\t\tedge[i].push_back(i+r);\n\t\tedge[i+r].push_back(i);\n\t}//连边代表不共存\n\tfor(int i=1;i<=c/2;i++){\n\t\tif(sum[i].size()+sum[c-i+1].size()>2){\n\t\t\tcout<<0<<endl;\n\t\t\treturn;\n\t\t}\n\t\tif(sum[i].size()+sum[c-i+1].size()==2){\n\t\t\tif(sum[i].size()==1){//一起翻\n\t\t\t//cout<<\"s\";\n\t\t\t\tint u=sum[i][0],v=sum[c-i+1][0];\n\t\t\t\t//cout<<i<<\" \"<<c-i+1<<\" \"<<u<<\" \"<<v<<endl;\n\t\t\t\tedge[u].push_back(v+r);\n\t\t\t\tedge[v+r].push_back(u);\n\t\t\t\tedge[v].push_back(u+r);\n\t\t\t\tedge[u+r].push_back(v);\n\t\t\t}\n\t\t\telse {//一个翻一个不翻\n\t\t\t\tint u,v;\n\t\t\t\tif(sum[i].size())u=sum[i][0],v=sum[i][1];\n\t\t\t\telse u=sum[c-i+1][0],v=sum[c-i+1][1];\n\t\t\t\tedge[u].push_back(v);\n\t\t\t\tedge[v].push_back(u);\n\t\t\t\tedge[v+r].push_back(u+r);\n\t\t\t\tedge[u+r].push_back(v+r);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1;\n\t/*for(int i=1;i<=2*r;i++){\n\t\tcout<<i<<\"i: \";\n\t\tfor(auto v:edge[i]){\n\t\t\tcout<<v<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=1;i<=2*r;i++){\n\t\tif(vis[i])continue;\n\t\tvis[i]=1;\n\t\tif(dfs(i,i)){\n\t\t\tans=(ans*2)%mod;\n\t\t}\n\t\telse {\n\t\t\tcout<<0<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint T=1;\n\tcin>>T;\n\twhile(T--){solve();}\n}\n\n```"},{"title":"国家海洋博物馆","url":"/post/1a5d7ab5.html"},{"title":"面向智慧驾驶座舱的情感交互平台设计","url":"/post/1fd344c2.html","content":"## 安卓端开发\n[IDE下载](https://developer.android.google.cn/studio?hl=zh-cn)\n**配置注意事项**\n① jdk改为11版本。\n② 在顶层build.gradle文件添加url加速下载 。\n③ 切换摄像头使得虚拟机能用上电脑的摄像头。","tags":["大创"]},{"title":"习概重点","url":"/post/bd442674.html","content":"\n**声明：根据2023年@tjuSE重点整理，由@zhy摘取重合重点而来。**\n\n## 第二章 以中国式现代化全面推进中华民族伟大复兴\n\n### 第二节 中国式现代化是强国建设、民族复兴的唯一正确道路\n\n#### Ⅰ 中国式现代化是中国共产党领导人民长期探索和实践的重大成果\n\n**(问：如何理解中国式现代化是中国共产党领导人民长期探索和实践的重大成果?)**\n① **新民主主义革命时期，**我们党团结带领人民进行革命斗争，取得新民主主义革命的胜利，为实现现代化创造了**根本社会条件**。\n② **改革开放和社会主义现代化建设新时期，**我们党作出把党和国家工作中心转移到经济建设上来、实行改革开放的历史性决策，开启了中国式现代化的**新长征**。\n③ **进入新时代，** 我们党围绕解决现代化建设中存在的突出矛盾和问题，不断实现理论和实践上的 **创新突破，** 成功推进和拓展了中国式现代化。\n\n#### Ⅱ 中国式现代化的中国特色\n\n**(问：中国式现代化中国特色的含义?)**\n① 中国式现代化是**人口规模巨大的现代化**。\n② 中国式现代化是**全体人民共同富裕的现代化**。\n③ 中国式现代化是**物质文明和精神文明相协调的现代化**。\n④ 中国式现代化是**人与自然和谐共生的现代化**。\n⑤ 中国式现代化是**走和平发展道路的现代化**。\n\n#### Ⅲ 中国式现代化的本质要求\n\n**(问一：中国式现代化的本质要求是什么?)**\n**坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。**\n**(问二：为什么要强调党在中国式现代化建设中的领导地位?)**\n① 党的领导决定中国式现代化的根本性质。\n② 党的领导确保中国式现代化锚定奋斗目标行稳致远。\n③ 党的领导激发建设中国式现代化的强劲动力。\n④ 党的领导凝聚建设中国式现代化的磅礴力量。\n\n#### Ⅳ 中国式现代化创造了人类文明新形态\n\n**(问：为什么说中国式现代化创造了人类文明新形态?)**\n① 中国式现代化提供了一种**全新的现代化模式**。\n② 中国式现代化是对**西方式现代化理论和实践**的重大超越。\n③ 中国式现代化为**广大发展中国家**提供了全新选择。\n\n## 第六章 推动高质量发展\n\n### 第一节 完整、准确、全面贯彻新发展理念\n\n#### Ⅰ 我国进入新发展阶段\n\n**(问：新发展阶段的含义?)**\n① 我国**经济增长速度**从高速转向中高速，**发展方式**从规模速度型转向质量效率型，**经济结构**调整从增量扩能为主转向调整存量、做优增量并举，**发展动力**从主要依靠资源和低成本劳动力等要素投入转向创新驱动。\n② 新发展阶段是我国**社会主义初级阶段历史进程中**的一个重要阶段，是中国共产党带领人民迎来从站起来、富起来到强起来**历史性跨越**的新阶段，是**全面建设社会主义现代化国家、向第二个百年奋斗目标进军**的重要阶段。\n③ 进入新发展阶段，我国发展的国内外环境进一步发生深刻变化，面对新的战略机遇、新的战略任务新的战略要求、新的战略环境，**需要解决的矛盾和问题比以往更加错综复杂**。\n\n#### Ⅱ 贯彻新发展理念是关系我国发展全局的一场深刻变革\n\n**(问一：为什么贯彻新发展理念是关系我国发展全局的一场深刻变革?如何理解?)**\n**贯彻新发展理念是新时代我国发展壮大的必由之路。**\n① 发展理念是发展行动的先导，是管全局、管根本、管方向、管长远的东西，是发展思路、发展方式发展着力点的集中体现。\n② 新发展理念具有**丰富的科学内涵**和具体的实践要求。**(创新、协调、绿色、开放、共享)**\n③ 新发展理念是指挥棒、红绿灯，是引领我国发展全局深刻变革的科学指引，必须完整、准确、全面地理解和把握。\n**(问二：新发展理念的丰富科学内涵?)**\n① **创新**是引领发展的第一动力\n② **协调**是持续健康发展的内在要求\n③ **绿色**是永续发展的必要条件和人民对美好生活追求的重要体现\n④ **开放**是国家繁荣发展的必由之路\n⑤ **共享**是中国特色社会主义的本质要求\n**(问三：如何把新发展理念?)**\n① 要**从根本宗旨上**把握新发展理念，坚持以人民为中心的发展思想。\n② 要**从问题导向上**把握新发展理念，切实解决发展不平衡不充分问题，\n③ 要**从忧患意识上**把握新发展理念，积极主动、未雨缪。\n\n#### Ⅲ 以新发展理念引领高质量发展\n\n**(问一：高质量发展的含义?)**\n高质量发展，是能够很好**满足人民日益增长的美好生活需要**的发展，是**体现新发展理念**的发展，是**创新**成为第一动力、**协调**成为内生特点、**绿色**成为普遍形态、**开放**成为必由之路、**共享**成为根本目的的发展。\n**(问二：高质量发展的重大战略意义?)**\n① 高质量发展为全面建设社会主义现代化国家提供更为**坚实的物质基础**。\n② 高质量发展是不断满足人民对美好生活需要的**重要保证**。\n③ 高质量发展是维护国家长治久安的**必然要求**。\n**(问三：如何推动高质量发展?)**\n① 要更好统筹质的有效提升和量的合理增长。\n② 要保持经济社会发展稳定性。\n③ 要以改革创新为根本动力。\n\n### 第二节 坚持和完善社会主义基本经济制度(问:如何坚持和完善社会主义基本经济制度?怎么做?)\n\n#### Ⅰ 坚持和完善社会主义基本经济制度是实现高质量发展的保障\n\n**(问：社会主义基本经济制度的内容?)**\n答:将公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等共同作为社会主义基本经济制度。\n\n#### Ⅱ 坚持“两个毫不动摇”\n\n**(问：“两个毫不动摇”的含义?)**\n答:要毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展。\n\n#### Ⅲ 坚持按劳分配为主体、多种分配方式并存\n\n考点一:基本分配制度是由我国社会主义性质和基本国情决定的。\n考点二:坚持和完善基本分配制度，要努力推动居民收入增长和经济增长同步、劳动报酬提高和劳动生产率提高同步。\n**(问：坚持和完善基本分配制度怎么做?)**\n① 健全工资决定和正常增长机制\n② 健全生产要素由市场评价贡献、按贡献决定报酬的机制。\n\n#### Ⅳ 构建高水平社会主义市场经济体制\n\n**(问：如何构建高水平社会主义市场经济体制?怎么做?)**\n① 构建高水平社会主义市场经济体制，关键是要处理好政府和市场的关系。(市场在资源配置中起决定性作用，更好地发挥政府作用。)\n② 加快建设高标准市场体系。(统一开放、竞争有序、制度完备、治理完善的高标准市场体系)③ 推进宏观经济治理体系和治理能力现代化。\n④ 依法规范和引导资本健康发展。\n\n## 第九章 全面依法治国\n\n### 第一节 坚持中国特色社会主义法治道路\n\n#### Ⅰ 全面依法治国是国家治理的一场深刻革命\n\n**问：全面依法治国是国家治理的一场深刻革命，我们党是如何推进的?(全面依法治国具体体现在哪些方面?如何理解“革命\"?)**\n\n① 坚持依宪治国\n② 完善立法体制\n③ 推进法治政府建设\n④ 深化司法体制改革\n⑤ 实行国家机关普法责任制\n⑥ 深入推进依规治党\n\n#### Ⅱ 全面依法治国的唯一正确道路\n\n我们党领导人民长期探索走出的中国特色社会主义法治道路，是全面依法治国的唯一正确道路。\n\n**问：坚持和拓展中国特色社会主义法治道路要把握的核心要义以及坚持的原则?(走中国特色社会主义法治道路怎么做?中国特色社会主义法治道路的要求?)**\n① 中国特色社会主义法治道路的核心要义，就是要坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论。\n② 坚持中国共产党的领导。\n③ 坚持以人民为中心。\n④ 坚持法律面前人人平等。\n⑤ 坚持依法治国和以德治国相结合。\n⑥ 坚持从中国实际出发。\n\n#### Ⅲ 统筹处理全面依法治国的重大关系\n\n**问：全面依法治国要正确处理哪些重大关系?**\n① 正确处理政治和法治的关系。\n②正确处理改革和法治的关系，\n③正确处理依法治国和以德治国的关系\n④ 正确处理依法治国和依规治党的关系。\n\n## 第十六章 中国特色大国外交和推动构建人类命运共同体\n\n### 第二节 全面推进中国特色大国外交(问:全面推进中国特色大国外交怎么做?)\n\n#### Ⅰ 坚持走和平发展道路\n\n**(问一：中国为什么坚持走和平发展道路?)**\n① 走和平发展道路是由中国共产党性质宗旨和我国社会主义制度决定的。\n② 走和平发展道路是基于中国历史文化传统作出的必然选择。\n③ 走和平发展道路符合历史潮流、顺应世界大势。\n**(问二：如何理解坚持走和平发展道路?)**\n① 走和平发展道路，是对国际社会关注中国发展走向的回应，更是中国人民对实现自身发展目标的自信和自觉。\n怎么做: ② 走和平发展道路，就要坚定奉行独立自主的和平外交政策。\n             ③ 走和平发展道路，既要通过维护世界和平发展自己，又要通过自身发展维护世界和平\n\n#### Ⅱ 推动构建新型国际关系\n\n**(问：推动构建新型国际关系怎么做?)**\n① 推进大国协调合作，构建和平共处、总体稳定、均衡发展的大国关系格局，是中国对外关系的重要内容。\n② 坚持亲诚惠容和与邻为善、以邻为伴周边外交方针，深化同周边国家友好互信和利益融合。\n③ 秉持真实亲诚理念和正确义利观，加强同发展中国家团结合作。\n④ 秉持求同存异、相互尊重、互学互鉴理念，构建新型政党关系。\n\n#### Ⅲ 坚决维护国家主权、安全、发展利益\n\n① 我国外交工作始终站在维护国家利益和民族尊严的前线。\n② 维护国家主权、安全、发展利益，必须敢于斗争、善于斗争。\n\n#### Ⅳ 坚持外交为民\n\n**(问：怎么做?)**\n① 坚持外交为民，就要坚定维护我国海外公民和法人正当权益。\n② 积极开展民间外交。\n\n## 第十七章 全面从严治党\n\n### 第二节 以政治建设为统领深入推进党的建设(问:党的建设的总体布局是什么?)\n\n#### Ⅰ 把党的政治建设摆在首位\n\n**(问：党的政治建设摆在首位，该怎么做?)**\n旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。\n① 保证全党服从中央，维护党中央权威和集中统一领导，是党的政治建设的首要任务。\n② 发挥党的政治建设的统领性作用，必须把准政治方向、站稳政治立场、营造良好政治生态、提高政治\n能力。\n\n#### Ⅱ 思想建设是党的基础性建设\n\n**(问：为什么要加强党的思想建设?)**\n① 加强思想建设是坚守理想信念、坚定革命意志的前提。\n② 加强思想建设是保持政治上清醒坚定、行动上团结统一的要求。\n③ 加强思想建设是贯彻党的理论和路线方针政策、推进党和国家事业发展的重要保障。\n\n#### Ⅲ 贯彻新时代党的组织路线\n\n**(问：如何贯彻新时代党的组织路线?怎么做?)**\n① 严密党的组织体系是重点。\n② 建设高素质专业化干部队伍是关键。\n\n#### Ⅳ 以严的基调强化正风肃纪\n\n**(问：强化正风肃纪的含义?)**\n① 作风问题核心是党同人民群众的关系问题。加强作风建设，必须紧紧围绕保持党同人民群众的血肉联系。\n② 党要管党、从严治党，就要靠严明纪律和规矩。\n\n#### Ⅴ 把制度建设贯穿到党的各项建设之中\n\n**(问：把制度建设贯穿到党的各项建设之中，该怎么做?)**\n① 坚持制度治党、依规治党，就是靠制度管权、管事、官人。\n② 制定制度很重要，更重要的是抓落实。\n\n{% pdf https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/习概/习概重点整理.pdf %}","tags":["复习","习概"]},{"title":"数据库课程实践","url":"/post/73de793a.html","content":"---\n- 天津大学 2024 数据库课程实践\n- Lab Member：海棠未雨，梨花先雪，流萤染夏\n- 最终成绩 91 分捏 😋\n---\n报告如下：\n{% pdf https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/数据库实践/数据库实践报告.pdf %}\n\n答辩PPT如下：\n{% pdf https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/pdf/数据库实践/汇报PPT.pdf %}\n源码如下：\n```sql\n--先删关系表\n--交易系统关系表\nDROP TABLE IF EXISTS sell;\nDROP TABLE IF EXISTS hold_ ;\nDROP TABLE IF EXISTS order_ ;\n--用户系统关系表\nDROP TABLE IF EXISTS consumer_get_coupon ;\nDROP TABLE IF EXISTS consumer_recieve_redpacket ;\nDROP TABLE IF EXISTS consumer_register_address ;\nDROP TABLE IF EXISTS friendship ;\nDROP TABLE IF EXISTS fan ;\nDROP TABLE IF EXISTS user_focus_user ;\nDROP TABLE IF EXISTS manage_subaccount ;\nDROP TABLE IF EXISTS shopping_cart ;\nDROP TABLE IF EXISTS collect ;\nDROP TABLE IF EXISTS watching_history ;\n--聊天系统关系表\nDROP TABLE IF EXISTS friend_and_friend ;\nDROP TABLE IF EXISTS seller_and_agent ;\nDROP TABLE IF EXISTS consumer_and_agent ;\nDROP TABLE IF EXISTS consumer_and_seller ;\nDROP TABLE IF EXISTS member_and_member ;\nDROP TABLE IF EXISTS group_members ;\nDROP TABLE IF EXISTS friend_request ;\nDROP TABLE IF EXISTS group_request ;\nDROP TABLE IF EXISTS reply ;\nDROP TABLE IF EXISTS consumer_give_evaluation ;\nDROP TABLE IF EXISTS consumer_ask_question ;\nDROP TABLE IF EXISTS consumer_reply_question ;\nDROP TABLE IF EXISTS consumer_focus_question ;\nDROP TABLE IF EXISTS consumer_have_archive ;\n\n--再删实体表\n--交易系统实体表\nDROP TABLE IF EXISTS mark ;\nDROP TABLE IF EXISTS logistics ;\nDROP TABLE IF EXISTS food ;\nDROP TABLE IF EXISTS cloth ;\nDROP TABLE IF EXISTS ele_appliment ;\nDROP TABLE IF EXISTS ele_product ;\nDROP TABLE IF EXISTS makeup ;\nDROP TABLE IF EXISTS sport ;\nDROP TABLE IF EXISTS toy ;\nDROP TABLE IF EXISTS daily_necessarity ;\nDROP TABLE IF EXISTS discount ;\nDROP TABLE IF EXISTS store ;\nDROP TABLE IF EXISTS commodity ;\nDROP TABLE IF EXISTS historical_price ;\n--用户系统实体表\nDROP TABLE IF EXISTS red_packet ;\nDROP TABLE IF EXISTS taobao_history ;\nDROP TABLE IF EXISTS address ;\nDROP TABLE IF EXISTS archive ;\nDROP TABLE IF EXISTS coupon ;\nDROP TABLE IF EXISTS users ;\nDROP TABLE IF EXISTS consumer ;\nDROP TABLE IF EXISTS seller ;\n--聊天系统实体表\nDROP TABLE IF EXISTS official_agent ;\nDROP TABLE IF EXISTS groups ;\nDROP TABLE IF EXISTS message ;\nDROP TABLE IF EXISTS conversation_message ;\nDROP TABLE IF EXISTS group_message ;\nDROP TABLE IF EXISTS request ;\nDROP TABLE IF EXISTS evaluation ;\nDROP TABLE IF EXISTS comments ;\nDROP TABLE IF EXISTS question ;\n\n\n\n--创建店铺表\nCREATE TABLE store(\n   store_id VARCHAR(20) PRIMARY KEY,\n   store_name VARCHAR(30) NOT NULL,\n   tag VARCHAR(20),\n   profile_photo  VARCHAR(500),\n   seller_id VARCHAR(20) NOT NULL,\n   address VARCHAR(50),\n   sales DOUBLE PRECISION,\n   vis_num INT,\n   ord_num INT,\n   tr_rate INT,\n   candidate_num INT,\n   Lv INT,\n   credit INT,\n   ct_time TIMESTAMP,\n   sub_account INT\n);\n\n--创建商品表\nCREATE TABLE commodity(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500)\n);\n\n--创建活动表\nCREATE TABLE discount(\n    dis_id VARCHAR(20) PRIMARY KEY,\n    st_time TIMESTAMP,\n    end_time TIMESTAMP,\n    allowance DOUBLE PRECISION\n);\n\n--创建商品历史价格表（弱实体）\nCREATE TABLE historical_price(\n\tcom_id VARCHAR(20) PRIMARY KEY,\n\ttime TIMESTAMP,\n\tprice DOUBLE PRECISION\n);\n\n--创建店铺评分（弱实体）\nCREATE TABLE mark(\n    store_id VARCHAR(20) PRIMARY KEY,\n    quality DOUBLE PRECISION,\n    service DOUBLE PRECISION,\n    distribution DOUBLE PRECISION,\n    com_score DOUBLE PRECISION\n);\n\n--创建商品物流（弱实体）\nCREATE TABLE logistics(\n    com_id VARCHAR(20) PRIMARY KEY,\n    deadline TIMESTAMP,\n    price DOUBLE PRECISION,\n    comp_name VARCHAR(100),\n    send_addr VARCHAR(50),\n    receive_addr VARCHAR(50)\n);\n\n--商品子类表\nCREATE TABLE food(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    shelf_life INT,\n    weight VARCHAR(20),\n    taste VARCHAR(20)\n);\nCREATE table cloth(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    type VARCHAR(20),\n    size VARCHAR(20)\n);\n\n\nCREATE TABLE ele_appliment(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    paymentway VARCHAR(20),\n    type VARCHAR(20),\n    memory VARCHAR(20),\n    safegaurd VARCHAR(20),\n    net_type VARCHAR(20)\n);\nCREATE TABLE ele_product(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    paymentway VARCHAR(20),\n    type VARCHAR(20),\n    safegaurd VARCHAR(20)\n);\n\nCREATE TABLE makeup(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    type VARCHAR(20),\n    weight VARCHAR(20)\n);\n\nCREATE TABLE sport(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    type VARCHAR(20),\n    size VARCHAR(20)\n);\n\nCREATE TABLE toy(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    type VARCHAR(20),\n    suit_age INT\n);\n\nCREATE TABLE daily_necessarity(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    description VARCHAR(500),\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    type VARCHAR(20),\n    weight VARCHAR(20)\n);\n\nCREATE TABLE other(\n    com_id VARCHAR(20) PRIMARY KEY,\n    com_name VARCHAR(30) NOT NULL,\n    category VARCHAR(20),\n    price DOUBLE PRECISION,\n\tdis_price DOUBLE PRECISION,\n    num INT,\n    detail VARCHAR(2000),\n    after_sale VARCHAR(100),\n    up_time TIMESTAMP,\n    com_image VARCHAR(500),\n    description VARCHAR(200)\n);\n\n\n--交易系统的关系\n\n--店铺和商品的关系\n\nCREATE TABLE sell(\n    store_id VARCHAR(20),\n    com_id VARCHAR(20),\n    st_time TIMESTAMP,\n    PRIMARY KEY (store_id,com_id),\n    FOREIGN KEY (store_id) REFERENCES store (store_id),\n    FOREIGN KEY (com_id) REFERENCES commodity (com_id)\n);\n\n--商品和活动的关系\n\nCREATE TABLE hold_(\n    com_id VARCHAR(20),\n    dis_id VARCHAR(20),\n    PRIMARY KEY (com_id,dis_id),\n    FOREIGN KEY (com_id) REFERENCES commodity (com_id),\n    FOREIGN KEY (dis_id) REFERENCES discount (dis_id)\n);\n\n--创建订单表\n\nCREATE TABLE order_(\n    order_id VARCHAR(20) PRIMARY KEY,\n    com_id VARCHAR(20),\n    user_id VARCHAR(20),\n    real_pay DOUBLE PRECISION,\n    ct_time TIMESTAMP,\n    pay_time TIMESTAMP,\n    state VARCHAR(20),\n    pickup_code VARCHAR(20),\n    description VARCHAR(20),\n    com_num INT\n);\n\n-- 用户系统\n-- 创建用户表\nCREATE TABLE users (\n    user_id VARCHAR(20) PRIMARY KEY,\n    user_name VARCHAR(30) NULL DEFAULT NULL,\n    password_ VARCHAR(20) NOT NULL CHECK (LENGTH(password_) >= 8),\n    gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')),\n    telephone CHAR(11) NOT NULL,\n\ttype_ VARCHAR(10) NOT NULL,CHECK (type_ IN ('consumer','seller'))\t\n);\n-- 创建消费者表\nCREATE TABLE consumer (\n    user_id VARCHAR(20) NOT NULL PRIMARY KEY, \n    user_name VARCHAR(30) NULL DEFAULT NULL,\n    password_ VARCHAR(20) NOT NULL CHECK (LENGTH(password_) >= 8),\n    gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')),\n    telephone CHAR(11) NOT NULL,\n    membership BOOLEAN NOT NULL,\n    credit INT NOT NULL CHECK (credit >= 0),\n    headshot VARCHAR(500) NULL DEFAULT NULL, -- 存储用户头像的地址\n    fan_number INT NOT NULL CHECK (fan_number >= 0),\n    focus_number INT NOT NULL CHECK (focus_number >= 0),\n    likes INT NOT NULL CHECK (likes >= 0),\n    change DOUBLE PRECISION NOT NULL CHECK (change >= 0), -- 零钱\n    shopping_coin INT NOT NULL CHECK (shopping_coin >= 0),\n    alipay VARCHAR(20) NULL DEFAULT NULL,\n\ttype_ VARCHAR(10) NOT NULL,CHECK (type_ = 'consumer'),\n\tshopping_cart VARCHAR(3000) NULL DEFAULT NULL\n);\n-- 创建卖家表\nCREATE TABLE seller (\n    user_id VARCHAR(20) NOT NULL PRIMARY KEY, \n    user_name VARCHAR(30) NULL DEFAULT NULL,\n    password_ VARCHAR(20) NOT NULL CHECK (LENGTH(password_) >= 8),\n    gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')),\n    telephone CHAR(11) NOT NULL,\n\ttype_ VARCHAR(10) NOT NULL,CHECK (type_ = 'seller'),\n    service_authority BOOLEAN NOT NULL,\n    operator_authority BOOLEAN NOT NULL\n);\n\n-- 创建红包表\nCREATE TABLE red_packet (\n    red_packet_id SERIAL NOT NULL PRIMARY KEY,\n    name_ VARCHAR(30) NOT NULL,\n    value_ DOUBLE PRECISION NOT NULL,\n    condition_ VARCHAR(20) NOT NULL,\n    end_date DATE NOT NULL\n);\n\n-- 创建优惠券表\nCREATE TABLE coupon (\n    coupon_id SERIAL NOT NULL PRIMARY KEY,\n    store_id VARCHAR(20) NOT NULL, \n    value_ DOUBLE PRECISION NOT NULL,\n    condition_ VARCHAR(20) NOT NULL,\n    end_date DATE NOT NULL,\n\tFOREIGN KEY (store_id) REFERENCES store (store_id)\n);\n\n-- 创建淘宝历程表\nCREATE TABLE taobao_history (\n    user_id VARCHAR(20) NOT NULL,\n    register_date DATE NOT NULL,\n    total_days INT NOT NULL CHECK (total_days >= 0),\n    save_money DOUBLE PRECISION NOT NULL CHECK (save_money >= 0),\n    month_spend_money DOUBLE PRECISION NOT NULL CHECK (month_spend_money >= 0),\n\tPRIMARY KEY (user_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id)\n);\n\n-- 创建收货地址表\nCREATE TABLE address (\n    address_id SERIAL NOT NULL PRIMARY KEY,\n    name_ VARCHAR(30) NOT NULL,\n    telephone CHAR(11) NOT NULL,\n    address VARCHAR(50) NOT NULL\n);\n\n-- 创建档案表\nCREATE TABLE archive (\n    archive_id SERIAL NOT NULL PRIMARY KEY,\n    height DOUBLE PRECISION NOT NULL CHECK (height > 0),\n    weight DOUBLE PRECISION NOT NULL CHECK (weight > 0),\n    shoe_size DOUBLE PRECISION NOT NULL CHECK (shoe_size >= 16 and shoe_size <= 45)\n);\n\n-- 创建好友关系表\nCREATE TABLE friendship (\n    user1_id VARCHAR(20) NOT NULL,\n    user2_id VARCHAR(20) NOT NULL,\n    accept_date DATE NOT NULL,\n    PRIMARY KEY (user1_id, user2_id),\n\tFOREIGN KEY (user1_id) REFERENCES consumer (user_id),\n\tFOREIGN KEY (user2_id) REFERENCES consumer (user_id)\n);\n\n-- 创建收货地址总表\nCREATE TABLE consumer_register_address (\n    user_id VARCHAR(20) NOT NULL,\n    address_id SERIAL NOT NULL,\n\tcommon_address BOOLEAN NOT NULL,\n\tPRIMARY KEY (user_id, address_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (address_id) REFERENCES address (address_id)\n);\n\n-- 创建粉丝列表总表\nCREATE TABLE fan (\n    user_id VARCHAR(20) NOT NULL,\n    fan_id VARCHAR(20) NOT NULL,\n\tPRIMARY KEY (user_id, fan_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (fan_id) REFERENCES consumer (user_id)\n);\n\n-- 创建关注列表总表\nCREATE TABLE user_focus_user (\n    user_id VARCHAR(20) NOT NULL,\n    focus_id VARCHAR(20) NOT NULL,\n\tPRIMARY KEY (user_id, focus_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (focus_id) REFERENCES consumer (user_id)\n);\n\n-- 创建用户红包关系表\nCREATE TABLE consumer_recieve_redpacket (\n    user_id VARCHAR(20) NOT NULL,\n    red_packet_id SERIAL NOT NULL,\n\tPRIMARY KEY (user_id, red_packet_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (red_packet_id) REFERENCES red_packet (red_packet_id)\n);\n\n-- 创建用户优惠券关系表\nCREATE TABLE consumer_get_coupon (\n    user_id VARCHAR(20) NOT NULL,\n    coupon_id SERIAL NOT NULL,\n\tPRIMARY KEY (user_id, coupon_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (coupon_id) REFERENCES coupon (coupon_id)\n);\n\n-- 创建主账号和子账号关系表\nCREATE TABLE manage_subaccount (\n    main_user_id VARCHAR(20) NOT NULL,\n    sub_user_id VARCHAR(20) NOT NULL,\n\tPRIMARY KEY (main_user_id,sub_user_id),\n    FOREIGN KEY (main_user_id) REFERENCES seller (user_id),\n    FOREIGN KEY (sub_user_id) REFERENCES seller (user_id)\n);\n\n--用户档案索引表\nCREATE TABLE consumer_have_archive (\n    user_id VARCHAR(20) NOT NULL,\n    archive_id SERIAL NOT NULL,\n\tPRIMARY KEY (user_id,archive_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (archive_id) REFERENCES archive (archive_id)\n);\n\n--消费者收藏表\nCREATE TABLE collect (\n    user_id VARCHAR(20) NOT NULL,\n    com_id VARCHAR(20) NOT NULL,\n    collect_time DATE NOT NULL,\n    PRIMARY KEY (user_id,com_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (com_id) REFERENCES commodity (com_id)\n);\n\n--消费者浏览记录表\nCREATE TABLE watching_history (\n    user_id VARCHAR(20) NOT NULL,\n    com_id VARCHAR(20) NOT NULL,\n    watch_time DATE NOT NULL,\n    PRIMARY KEY (user_id,com_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (com_id) REFERENCES commodity (com_id)\n);\n\n-- 聊天反馈系统\n-- 创建官方客服总表\nCREATE TABLE official_agent(\n\tofficial_agent_id VARCHAR(20) PRIMARY KEY,\n\ttelephone VARCHAR(20) NOT NULL,\n\tstart_date TIMESTAMP NOT NULL,\n\tend_date TIMESTAMP NOT NULL\n);\n\n-- 创建群组总表\nCREATE TABLE groups(\n\tgroup_id VARCHAR(20) PRIMARY KEY,\n\tgroup_name VARCHAR(30) NOT NULL,\n\tcreated_date TIMESTAMP DEFAULT NULL,\n\tdescription VARCHAR(100) DEFAULT NULL,\n\tmember_num INT CHECK(member_num >= 0)\n);\n\n-- 创建消息总表\nCREATE TABLE message(\n\tmessage_id VARCHAR(20) PRIMARY KEY,\n\tmessage_type VARCHAR(10) CHECK (message_type IN ('文本','语音','图片','视频')),\n\tmessage_content VARCHAR(500) NOT NULL,\n\tmessage_date TIMESTAMP NOT NULL\n);\n\n-- 创建对话消息总表\nCREATE TABLE conversation_message(\n\tmessage_id VARCHAR(20) PRIMARY KEY,\n\tmessage_type VARCHAR(10) CHECK (message_type IN ('文本','语音','图片','视频')),\n\tmessage_content VARCHAR(500) NOT NULL,\n\tmessage_date TIMESTAMP NOT NULL,\n\tisread BOOLEAN  NOT NULL\n);\n\n-- 创建群组消息总表\nCREATE TABLE group_message(\n\tmessage_id VARCHAR(20) PRIMARY KEY,\n\tmessage_type VARCHAR(10) CHECK (message_type IN ('文本','语音','图片','视频')),\n\tmessage_content VARCHAR(500) NOT NULL,\n\tmessage_date TIMESTAMP NOT NULL\n);\n\n-- 创建请求总表\nCREATE TABLE request(\n\trequest_id VARCHAR(20) PRIMARY KEY,\n\trequest_status VARCHAR(10) CHECK (request_status IN ('未处理','已接受','已拒绝')),\n\trequest_description VARCHAR(100) DEFAULT NULL,\n\trequest_date TIMESTAMP NOT NULL\n);\n\n-- 创建用户评价总表\nCREATE TABLE evaluation(\n\tevaluation_id VARCHAR(20) PRIMARY KEY,\n\tevaluation_content_type VARCHAR(10) CHECK (evaluation_content_type IN ('文本','图片','视频')),\n\tevaluation_content VARCHAR(500) NOT NULL,\n\tisanonymous BOOLEAN NOT NULL,\n\tevaluation_type CHAR(1) CHECK (evaluation_type IN ('好','差')),\n\tevaluated_date TIMESTAMP NOT NULL,\n\tisfollow BOOLEAN NOT NULL,\n\tlikes INT CHECK (likes >= 0),\n\tcomment_num INT CHECK (comment_num >=0),\n\tcomprehensive_evaluation INT check(comprehensive_evaluation IN (0,1,2,3,4,5)),\n\tdescription_match INT check(description_match IN (0,1,2,3,4,5)),\n\tlogistics_service INT check(logistics_service IN (0,1,2,3,4,5)),\n\tservice_attitude INT check(service_attitude IN (0,1,2,3,4,5))\n);\n\n-- 创建用户评论总表(弱实体)\nCREATE TABLE comments(\n\tevaluation_id VARCHAR(20),\n\tuser_id VARCHAR(30),\n\tcomment_date TIMESTAMP,\n\tcomment_type VARCHAR(10) CHECK (comment_type IN ('文本','图片','视频')),\n\tcomment_content VARCHAR(500) NOT NULL,\n\tlikes INT,\n\tPRIMARY KEY(evaluation_id, user_id, comment_date),\n\tFOREIGN KEY (evaluation_id) REFERENCES evaluation (evaluation_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id)\n);\n-- 创建问题总表\nCREATE TABLE question(\n\tquestion_id VARCHAR(20) PRIMARY KEY,\n\tquestion_content VARCHAR(500) NOT NULL,\n\tquestion_date TIMESTAMP DEFAULT NULL,\n\treply_num INT CHECK(reply_num >= 0)\n);\n-- 创建好友聊天消息索引表\nCREATE TABLE friend_and_friend(\n\tsender_id VARCHAR(20),\n\treceiver_id VARCHAR(20),\n\tmessage_id VARCHAR(20),\n\tPRIMARY KEY(sender_id, receiver_id, message_id),\n\tFOREIGN KEY (sender_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (receiver_id) REFERENCES consumer (user_id),\n\tFOREIGN KEY (message_id) REFERENCES conversation_message (message_id)\n);\n-- 创建卖家和客服消息索引表\nCREATE TABLE seller_and_agent(\n\tseller_id VARCHAR(20),\n\tofficial_agent_id VARCHAR(20),\n\tmessage_id VARCHAR(20),\n\tsender BOOLEAN NOT NULL, --0表示卖家发的，1表示客服发的\n\tPRIMARY KEY(seller_id, official_agent_id, message_id),\n\tFOREIGN KEY (seller_id) REFERENCES seller (user_id),\n    FOREIGN KEY (official_agent_id) REFERENCES official_agent (official_agent_id),\n\tFOREIGN KEY (message_id) REFERENCES conversation_message (message_id)\n);\n\n\n-- 创建消费者和客服消息索引表\nCREATE TABLE consumer_and_agent(\n\tconsumer_id VARCHAR(20),\n\tofficial_agent_id VARCHAR(20),\n\tmessage_id VARCHAR(20),\n\tsender BOOLEAN NOT NULL, --0表示消费者发的，1表示客服发的\n\tPRIMARY KEY(consumer_id, official_agent_id, message_id),\n\tFOREIGN KEY (consumer_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (official_agent_id) REFERENCES official_agent (official_agent_id),\n\tFOREIGN KEY (message_id) REFERENCES conversation_message (message_id)\n);\n\n-- 创建消费者和卖家消息索引表\nCREATE TABLE consumer_and_seller(\n\tconsumer_id VARCHAR(20),\n\tseller_id VARCHAR(20),\n\tmessage_id VARCHAR(20),\n\tsender BOOLEAN NOT NULL, --0表示消费者发的，1表示卖家发的\n\tPRIMARY KEY(consumer_id, seller_id, message_id),\n\tFOREIGN KEY (consumer_id) REFERENCES consumer (user_id),\n    FOREIGN KEY (seller_id) REFERENCES seller (user_id),\n\tFOREIGN KEY (message_id) REFERENCES conversation_message (message_id)\n);\n\n-- 创建群组消息索引表\nCREATE TABLE member_and_member(\n\tgroup_id VARCHAR(20),\n\tsender_id VARCHAR(20),\n\tmessage_id VARCHAR(20),\n\tPRIMARY KEY(group_id, sender_id, message_id),\n\tFOREIGN KEY (group_id) REFERENCES groups (group_id),\n    FOREIGN KEY (sender_id) REFERENCES consumer (user_id),\n\tFOREIGN KEY (message_id) REFERENCES group_message (message_id)\n);\n\n-- 创建群组成员表\nCREATE TABLE group_members(\n\tgroup_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\trole VARCHAR(10) CHECK (role IN ('群主','管理员','普通成员')),\n\tPRIMARY KEY(group_id, user_id),\n\tFOREIGN KEY (group_id) REFERENCES groups (group_id),\n    FOREIGN KEY (user_id) REFERENCES consumer (user_id)\n);\n-- 创建好友请求表\nCREATE TABLE friend_request(\n\trequest_id VARCHAR(20),\n\tsender_id VARCHAR(20),\n\treceiver_id VARCHAR(20),\n\tPRIMARY KEY(request_id, sender_id, receiver_id),\n\tFOREIGN KEY (request_id) REFERENCES request (request_id),\n    FOREIGN KEY (sender_id) REFERENCES consumer (user_id),\n\tFOREIGN KEY (receiver_id) REFERENCES consumer (user_id)\n);\n-- 创建入群请求表\nCREATE TABLE group_request(\n\trequest_id VARCHAR(20),\n\tgroup_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\tPRIMARY KEY(request_id, group_id, user_id),\n\tFOREIGN KEY (request_id) REFERENCES request (request_id),\n    FOREIGN KEY (group_id) REFERENCES groups (group_id),\n\tFOREIGN KEY (user_id) REFERENCES consumer (user_id)\n);\n-- 创建卖家回评表\nCREATE TABLE reply(\n\tevaluation_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\treply_date DATE,\n\treply_type VARCHAR(10) CHECK (reply_type IN ('文本','图片','视频')),\n\treply_content VARCHAR(500) NOT NULL,\n\tlikes INT CHECK(likes >= 0),\n\tPRIMARY KEY(evaluation_id, user_id, reply_date),\n\tFOREIGN KEY (evaluation_id) REFERENCES evaluation (evaluation_id),\n\tFOREIGN KEY (user_id) REFERENCES seller (user_id)\n);\n\n-- 创建消费者评价关系表\nCREATE TABLE consumer_give_evaluation(\n\tevaluation_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\tcom_id VARCHAR(20),\n\tPRIMARY KEY(evaluation_id, user_id, com_id),\n\tFOREIGN KEY (evaluation_id) REFERENCES evaluation (evaluation_id),\n\tFOREIGN KEY (user_id) REFERENCES consumer (user_id),\n\tFOREIGN KEY (com_id) REFERENCES commodity (com_id)\n);\n-- 创建消费者提问关系表\nCREATE TABLE consumer_ask_question(\n\tquestion_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\tcom_id VARCHAR(20),\n\tPRIMARY KEY(question_id, user_id, com_id),\n\tFOREIGN KEY (question_id) REFERENCES question (question_id),\n\tFOREIGN KEY (user_id) REFERENCES consumer (user_id),\n\tFOREIGN KEY (com_id) REFERENCES commodity (com_id)\n);\n-- 创建消费者回答问题表\nCREATE TABLE consumer_reply_question(\n\tquestion_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\treply_date TIMESTAMP,\n\treply_content VARCHAR(500) NOT NULL,\n\tPRIMARY KEY(question_id, user_id, reply_date),\n\tFOREIGN KEY (question_id) REFERENCES question (question_id),\n\tFOREIGN KEY (user_id) REFERENCES consumer (user_id)\n);\n-- 创建消费者关注问题表\nCREATE TABLE consumer_focus_question(\n\tquestion_id VARCHAR(20),\n\tuser_id VARCHAR(20),\n\tfocus_date TIMESTAMP DEFAULT NULL,\n\tPRIMARY KEY(question_id, user_id),\n\tFOREIGN KEY (question_id) REFERENCES question (question_id),\n\tFOREIGN KEY (user_id) REFERENCES consumer (user_id)\n);\n\n--视图\n--商品各种类别的视图\nCREATE VIEW com_food AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, shelf_life, weight, taste\n\t\t\t\t\t\tFROM commodity join food on commodity.com_id = food.com_id\n\t\t\t\t\t\twhere commodity.category = 'food';\nDROP VIEW com_food;\nCREATE VIEW com_cloth AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, type, size\n\t\t\t\t\t\tFROM commodity join cloth on commodity.com_id = cloth.com_id\n\t\t\t\t\t\twhere commodity.category = 'cloth';\nDROP VIEW com_cloth;\nCREATE VIEW com_ele_appliment AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, paymentway, type, memory, safegaurd, net_type\n\t\t\t\t\t\tFROM commodity join ele_appliment on commodity.com_id = ele_appliment.com_id\n\t\t\t\t\t\twhere commodity.category = 'ele_appliment';\nDROP VIEW com_ele_appliment;\nCREATE VIEW com_ele_product AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, paymentway, type, safegaurd\n\t\t\t\t\t\tFROM commodity join ele_product on commodity.com_id = ele_product.com_id\n\t\t\t\t\t\twhere commodity.category = 'ele_product';\nDROP VIEW com_ele_product;\nCREATE VIEW com_makeup AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, type, weight\n\t\t\t\t\t\tFROM commodity join makeup on commodity.com_id = makeup.com_id\n\t\t\t\t\t\twhere commodity.category = 'makeup';\nDROP VIEW com_makeup;\nCREATE VIEW com_sport AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, type, size\n\t\t\t\t\t\tFROM commodity join sport on commodity.com_id = sport.com_id\n\t\t\t\t\t\twhere commodity.category = 'sport';\nDROP VIEW com_sport;\nCREATE VIEW com_toy AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, type, suit_age\n\t\t\t\t\t\tFROM commodity join toy on commodity.com_id = toy.com_id\n\t\t\t\t\t\twhere commodity.category = 'toy';\nDROP VIEW com_toy;\nCREATE VIEW com_daily_necessarity AS SELECT commodity.com_name, commodity.price, commodity.dis_price, commodity.description, commodity.detail, commodity.com_image, type, weight\n\t\t\t\t\t\tFROM commodity join daily_necessarity on commodity.com_id = daily_necessarity.com_id\n\t\t\t\t\t\twhere commodity.category = 'daily_necessarity';\nDROP VIEW com_daily_necessarity;\n--店铺所拥有的商品创建视图（改store_id）\nCREATE VIEW com_of_store AS SELECT com_name, category, num, price, dis_price, description, detail, com_image, after_sale, up_time\n\t\t\t\t\t\tFROM commodity join sell on commodity.com_id = sell.com_id\n\t\t\t\t\t\twhere store_id = '012345678';\nDROP VIEW com_of_store;\n--每个消费者的浏览记录创建视图（改user_id）\nCREATE VIEW personal_browsing_history AS SELECT com_name, price, dis_price, description, detail, com_image, watch_time\n\t\t\t\t\t\tFROM commodity join watching_history on commodity.com_id = watching_history.com_id\n\t\t\t\t\t\twhere user_id = '000111111';\nDROP VIEW personal_browsing_history;\n--每个商品过去30天的历史价格创建视图\nCREATE VIEW historical_commodity_price AS SELECT com_name, price, time\n\t\t\t\t\t\tFROM commodity join historical_price on commodity.com_id = historical_price.com_id\n\t\t\t\t\t\twhere com_id = '54645645645';\nDROP VIEW historical_commodity_price;\n--每个消费者的收藏记录创建视图（改user_id）\nCREATE VIEW personal_collect_history AS SELECT com_name, price, dis_price, description, detail, com_image, collect_time\n\t\t\t\t\t\tFROM commodity join collect on commodity.com_id = collect.com_id\n\t\t\t\t\t\twhere user_id = '000111111';\nDROP VIEW personal_collect_history;\n--每个消费者的订单创建视图（改user_id）\nCREATE VIEW personal_order AS SELECT com_name, real_pay, pay_time, order_.description, detail, com_image, com_num, pickup_code\n\t\t\t\t\t\tFROM order_ join commodity on commodity.com_id = order_.com_id\n\t\t\t\t\t\twhere user_id = '000111111';\nDROP VIEW personal_order;\n--为好友的聊天记录创建视图(user_id)\nCREATE VIEW chat_history AS SELECT message_content, message_date\n\t\t\t\t\t\tFROM conversation_message join friend_and_friend on conversation_message.message_id = friend_and_friend.message_id\n\t\t\t\t\t\twhere (sender_id = 'tb12345' AND receiver_id = 'tb12342') OR  (sender_id = 'tb12342' AND receiver_id = 'tb12345')\n\t\t\t\t\t\torder by message_date;\nDROP VIEW chat_history;\n\n\nSELECT * FROM com_food;\nSELECT * FROM com_cloth;\nSELECT * FROM com_ele_appliment;\nSELECT * FROM com_ele_product;\nSELECT * FROM com_makeup;\nSELECT * FROM com_sport;\nSELECT * FROM com_toy;\nSELECT * FROM com_daily_necessarity;\nSELECT * FROM chat_history;\n\n--订单表物流表触发器\n\nCREATE OR REPLACE FUNCTION order_insert_trigger()\nRETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO logistics (com_id)\n    VALUES (NEW.com_id);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_order_trigger\nAFTER INSERT ON order_\nFOR EACH ROW\nEXECUTE FUNCTION order_insert_trigger();\n\n--删除触发器\nDROP TRIGGER insert_order_trigger ON order_\n\n--商品表发生变化历史价格表变化触发器\nCREATE OR REPLACE FUNCTION history_insert_trigger()\nRETURNS TRIGGER AS $$\nBEGIN \n    INSERT INTO historical_price (com_id,time,price)\n    VALUES (NEW.com_id,NOW(),NEW.price);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_history_trigger\nAFTER UPDATE ON commodity\nFOR EACH ROW\nEXECUTE FUNCTION history_insert_trigger();\n\n--删除触发器\nDROP TRIGGER insert_history_trigger ON commodity\n\n--商品大表与子表触发器\nCREATE OR REPLACE FUNCTION insert_comsubtable_function()\n  RETURNS TRIGGER AS $$\nBEGIN\n  -- 判断商品类别\n  IF NEW.category = 'food' THEN\n    -- 更新food\n    INSERT INTO food(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'cloth' THEN\n    -- 更新cloth\n    INSERT INTO cloth(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'ele_appliment' THEN\n    -- 更新ele_appliment\n    INSERT INTO ele_appliment(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'ele_product' THEN\n    -- 更新ele_product\n    INSERT INTO ele_product(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'makeup' THEN\n    -- 更新makeup\n    INSERT INTO makeup(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'sport' THEN\n    -- 更新sport\n    INSERT INTO sport(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'toy' THEN\n    -- 更新toy\n    INSERT INTO toy(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSIF NEW.category = 'daily_necessarity' THEN\n    -- 更新daily_necessarity\n    INSERT INTO daily_necessarity(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  ELSE \n    -- 更新other\n    INSERT INTO other(com_id,com_name,category,price,dis_price,num,description,detail,after_sale,up_time,com_image)\n    VALUES (NEW.com_id,NEW.com_name,NEW.category,NEW.price,NEW.dis_price,NEW.num,NEW.description,NEW.detail,NEW.after_sale,NEW.up_time,NEW.com_image);\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_comsubtable_trigger\nAFTER INSERT ON commodity\nFOR EACH ROW\nEXECUTE FUNCTION insert_comsubtable_function();\n\t\t\t\t\t\t\t\t  \nDROP TRIGGER insert_comsubtable_trigger ON commodity\n\n\nCREATE OR REPLACE FUNCTION update_comsubtable_function()\n  RETURNS TRIGGER AS $$\nBEGIN\n  -- 判断商品类别\n  IF OLD.category = 'food' THEN\n    -- 更新food\n    UPDATE food\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'cloth' THEN\n    -- 更新cloth\n    UPDATE cloth\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'ele_appliment' THEN\n    -- 更新ele_appliment\n    UPDATE ele_appliment\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'ele_product' THEN\n    -- 更新ele_product\n    UPDATE ele_product\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'makeup' THEN\n    -- 更新makeup\n    UPDATE makeup\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'sport' THEN\n    -- 更新sport\n    UPDATE sport\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'toy' THEN\n    -- 更新toy\n    UPDATE toy\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSIF OLD.category = 'daily_necessarity' THEN\n    -- 更新daily_necessarity\n    UPDATE daily_necessarity\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  ELSE \n    -- 更新other\n    UPDATE other\n    SET com_name=NEW.com_name,category=NEW.category,price=NEW.price,dis_price=NEW.dis_price,num=NEW.num,\n    description=NEW.description,detail=NEW.detail,after_sale=NEW.after_sale,up_time=NEW.up_time,com_image=NEW.com_image\n    WHERE com_id=NEW.com_id;\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_comsubtable_trigger\nAFTER UPDATE ON commodity\nFOR EACH ROW\nEXECUTE FUNCTION update_comsubtable_function();\n\t\t\t\t\t\t\t\t  \nDROP TRIGGER update_comsubtable_trigger ON commodity\n\n\nCREATE OR REPLACE FUNCTION delete_comsubtable_function()\n  RETURNS TRIGGER AS $$\nBEGIN\n  -- 判断商品类别\n  IF OLD.category = 'food' THEN\n    -- 更新food\n    DELETE FROM food\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'cloth' THEN\n    -- 更新cloth\n    DELETE FROM cloth\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'ele_appliment' THEN\n    -- 更新ele_appliment\n    DELETE FROM ele_appliment\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'ele_product' THEN\n    -- 更新ele_product\n    DELETE FROM ele_product\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'makeup' THEN\n    -- 更新makeup\n    DELETE FROM makeup\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'sport' THEN\n    -- 更新sport\n    DELETE FROM sport\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'toy' THEN\n    -- 更新toy\n    DELETE FROM toy\n    WHERE com_id=OLD.com_id;\n  ELSIF OLD.category = 'daily_necessarity' THEN\n    -- 更新daily_necessarity\n    DELETE FROM daily_necessarity\n    WHERE com_id=OLD.com_id;\n  ELSE \n    -- 更新other\n    DELETE FROM other\n    WHERE com_id=OLD.com_id;\n  END IF;\n\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_comsubtable_trigger\nAFTER DELETE ON commodity\nFOR EACH ROW\nEXECUTE FUNCTION delete_comsubtable_function();\n\t\t\t\t\t\t\t\t  \nDROP TRIGGER delete_comsubtable_trigger ON commodity\n\n\n-- 函数\n-- 计算商品价格\nDROP FUNCTION calculate_price( IN product_id VARCHAR(20),IN user_id VARCHAR(20),INOUT total_payment DOUBLE PRECISION);\nCREATE OR REPLACE FUNCTION calculate_price(\n    IN product_id VARCHAR(20),\n    IN user_id2 VARCHAR(20),\n    INOUT total_payment DOUBLE PRECISION\n) AS $$\nDECLARE\n    product_price DOUBLE PRECISION;\n\tdiscount_price DOUBLE PRECISION;\n    red_packet_discount DOUBLE PRECISION;\n    red_packet_id2 INT;\nBEGIN\n    SELECT price INTO product_price FROM commodity WHERE com_id = product_id;\n\tSELECT dis_price INTO discount_price FROM commodity WHERE com_id = product_id;\n    SELECT red_packet_id INTO red_packet_id2 FROM consumer_recieve_redpacket WHERE user_id = user_id2;\n    SELECT value_ INTO red_packet_discount FROM red_packet WHERE red_packet_id = red_packet_id2;\n\tRAISE INFO 'origin price: %', product_price;\n\tRAISE INFO 'discount_price: %', discount_price;\n\tRAISE INFO 'red_packet_discount: %', red_packet_discount;\n    total_payment := product_price - red_packet_discount - discount_price;\n    -- 更新红包表\n    DELETE FROM consumer_recieve_redpacket WHERE user_id = user_id;\n    DELETE FROM red_packet WHERE red_packet_id = red_packet_id;\n    \n    RETURN;\nEND;\n$$ LANGUAGE plpgsql;\n\n\n\n-- 直接购买商品\nDROP FUNCTION buy_commodity_directly(IN product_id VARCHAR(20),IN user_id VARCHAR(20),IN order_id VARCHAR(20),IN buy_num INT);\nCREATE OR REPLACE FUNCTION buy_commodity_directly(\n    IN product_id VARCHAR(20),\n    IN user_id VARCHAR(20),\n\tIN order_id VARCHAR(20),\n\tIN buy_num INT\n) RETURNS VOID AS $$\nDECLARE\n    total_payment DOUBLE PRECISION;\nBEGIN\n    UPDATE commodity SET num = num - buy_num WHERE com_id = product_id;\n\tSELECT calculate_price(product_id,user_id,total_payment) INTO total_payment;\n\tINSERT INTO order_ VALUES (order_id,product_id,user_id,total_payment,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP,'WAITDELIVER') ;\n\tRAISE INFO 'Calculated Total Payment: %', total_payment;\n\tRAISE INFO 'Insert order';\n\tRAISE INFO 'update Commodity num';\nEND;\n$$ LANGUAGE plpgsql;\n\nINSERT INTO red_packet\nVALUES(1,'无门槛红包',2,'无门槛','2023-12-25');\n\nINSERT INTO consumer_recieve_redpacket\nVALUES ('tb12345',1);\nDELETE FROM order_ WHERE order_id = 'com12347tb12345';\nDELETE FROM logistics WHERE com_id = 'com12347';\nUPDATE commodity SET num = 1000 WHERE com_id = 'com12347';\n\nSELECT buy_commodity_directly('com12347', 'tb12345', 'com12347tb12345', 1);\nSELECT * FROM order_;\n\nSELECT * FROM commodity WHERE com_id = 'com12347';\nSELECT * FROM food WHERE com_id = 'com12347';\nSELECT * FROM logistics;\nSELECT * FROM red_packet;\nSELECT * FROM consumer_recieve_redpacket;\n\n-- 店铺上架商品\nDROP FUNCTION store_launch_commodity(IN product_id VARCHAR(20),IN user_id VARCHAR(20),IN launch_num INT);\nCREATE OR REPLACE FUNCTION store_launch_commodity(\n    IN product_id VARCHAR(20),\n    IN store_id VARCHAR(20),\n\tIN launch_num INT\n) RETURNS VOID AS $$\nBEGIN\n    UPDATE commodity SET num = num - launch_num WHERE com_id = product_id;\n\tINSERT INTO sell VALUES (store_id,com_id,CURRENT_TIMESTAMP) ;\nEND;\n$$ LANGUAGE plpgsql;\n\n\n-- 退货\nDROP FUNCTION return_commodity(IN product_id VARCHAR(20),IN user_id VARCHAR(20),IN buy_num INT);\nCREATE OR REPLACE FUNCTION return_commodity(\n    IN product_id VARCHAR(20),\n    IN user_id VARCHAR(20),\n\tIN buy_num INT\n) RETURNS VOID AS $$\nDECLARE\n    total_payment DOUBLE PRECISION;\nBEGIN\n    UPDATE commodity SET num = num + buy_num WHERE com_id = product_id;\n\tUPDATE order_ SET state = 'REFUNDING' WHERE com_id = product_id AND user_id = user_id;\nEND;\n$$ LANGUAGE plpgsql;\n\nDELETE FROM users WHERE user_id = 'tb12347';\nINSERT INTO users\nVALUES ('tb12345', 'Daming', '123456789', 'F', '13981367234', 'consumer');\nINSERT INTO users\nVALUES ('tb12342', 'Amy', 'a123456789', 'M', '13981367555', 'consumer');\nINSERT INTO users\nVALUES ('tb12341', 'LingLing', 'l123456789', 'M', '13221367234','consumer');\nINSERT INTO users\nVALUES ('tb12343', 'David', 'd123456789', 'F', '13987767234', 'consumer');\nINSERT INTO users\nVALUES ('tb12344', 'sally', 's123456789', 'M', '13984467234', 'consumer');\nINSERT INTO users\nVALUES ('tb12347', 'Tom', 't123456789', 'F', '13984467234', 'seller');\nINSERT INTO users\nVALUES ('tb12346', 'Jerry', 'j123456789', 'M', '13921367234', 'seller');\nINSERT INTO users\nVALUES ('tb12348', 'Jack', 'j1234567689', 'M', '15581367234', 'seller');\nINSERT INTO users\nVALUES ('tb12349', 'Rose', 'r123456789', 'F', '15481367234', 'seller');\nINSERT INTO users\nVALUES ('tb12340', 'Lily', 'l123456789', 'F', '15681367234', 'seller');\n\nALTER TABLE consumer\nALTER COLUMN headshot TYPE VARCHAR(500); \nINSERT INTO consumer\nVALUES ('tb12345', 'Daming', '123456789', 'F', '13981367234', 'T', 5, 'http://img.alicdn.com/sns_logo/i2/2212109088345/O1CN01rsPVu02BW3rihzm8e_!!2212109088345-0-ggpersonal.jpg', 0, 0, 5, 10.5, 500, '13981367234', 'consumer','com12347+1 com12348+1');\nINSERT INTO consumer\nVALUES ('tb12342', 'Amy', 'a123456789', 'M', '13981367555', 'T', 5, 'http://img.alicdn.com/sns_logo/i2/2212109088345/O1CN01rsPVu02BW3rihzm8e_!!2212109088345-0-ggpersonal.jpg', 5, 5, 5, 20.5, 50, '13981367555', 'consumer','com12349+2 com12348+2');\nINSERT INTO consumer\nVALUES ('tb12341', 'LingLing', 'l123456789', 'M', '13221367234', 'T', 5, 'http://img.alicdn.com/sns_logo/i2/2212109088345/O1CN01rsPVu02BW3rihzm8e_!!2212109088345-0-ggpersonal.jpg', 10, 3, 8, 30.5, 900, '13221367234', 'consumer');\nINSERT INTO consumer\nVALUES ('tb12343', 'David', 'd123456789', 'F', '13987767234', 'T', 5, 'http://img.alicdn.com/sns_logo/i2/2212109088345/O1CN01rsPVu02BW3rihzm8e_!!2212109088345-0-ggpersonal.jpg', 10, 10, 5, 100.5, 1500, '13987767234', 'consumer');\nINSERT INTO consumer\nVALUES ('tb12344', 'sally', 's123456789', 'M', '13984467234', 'T', 5, 'http://img.alicdn.com/sns_logo/i2/2212109088345/O1CN01rsPVu02BW3rihzm8e_!!2212109088345-0-ggpersonal.jpg', 30, 30, 9, 120.5, 2500, '13984467234', 'consumer','com12347+1');\n\nSELECT * FROM consumer;\n\n-- 主账号\nINSERT INTO seller\nVALUES ('tb12347', 'Tom', 't123456789', 'F', '13984467234', 'seller','T','T');\nINSERT INTO seller\nVALUES ('tb12346', 'Jerry', 'j123456789', 'M', '13921367234', 'seller','T','F');\nINSERT INTO seller\nVALUES ('tb12348', 'Jack', 'j1234567689', 'M', '15581367234', 'seller','F','T');\nINSERT INTO seller\nVALUES ('tb12349', 'Rose', 'r123456789', 'F', '15481367234', 'seller','T','F');\nINSERT INTO seller\nVALUES ('tb12340', 'Lily', 'l123456789', 'F', '15681367234', 'seller','T','T');\n\n\n\nSELECT * FROM consumer;\nSELECT * FROM users;\nSELECT * FROM seller;\n\n--交易系统数据测试\n\n--店铺大表\n\nINSERT INTO store\nVALUES ('400672256','Time food','food',\n'https://img.alicdn.com/imgextra/i1/O1CN01pz5irY1bhDKceJor2_!!6000000003496-2-tps-144-144.png',\n'tb12346','567 West Main Street, Oakville, Canada',\n1231234.23,421343,21344,67,123134,4,5,'2018-05-15',0\n);\n\nINSERT INTO store\nVALUES ('400672257','Fashion women wear','cloth',\n'https://img.alicdn.com/imgextra/i1/O1CN01pz5irY1bhDKceJor2_!!6000000003496-2-tps-144-144.png',\n'tb12347','1234 Maple Street, Springfield, USA',\n141241.12,214120,12312,70,14223,3,5,'2020-01-10',0\n);\n\nINSERT INTO store\nVALUES ('400672258','happy toy','toy',\n'https://img.alicdn.com/imgextra/i1/O1CN01pz5irY1bhDKceJor2_!!6000000003496-2-tps-144-144.png',\n'tb12348','789 Elmwood Avenue, Portland, USA',\n412442.2,4124,423,40,2223,2,4,'2022-09-23',0\n);\n\n--商品大表\nINSERT INTO commodity\nVALUES ('com12347', 'cookie', 'food', 5.99, 1,1000,'very delicious',\n'Deliciously crisp and golden, these cookies are the perfect blend of sweetness and crunch. Each bite is filled with rich flavors, leaving a lingering vanilla aroma. Indulge in these irresistible treats that will surely satisfy your cravings. Enjoy them with a cup of tea or share them with friends for a delightful snack experience.',\n'Seven days no reason to return','2023-07-01',\n'https://img.alicdn.com/imgextra/i3/1408820149/O1CN01B67UhV1CyHv3krMdJ_!!0-saturn_solar.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com12348', 'River snail rice noodle', 'food', 10.99, 0,5000,'smelly but delicious',\n'A popular dish from southern China, this bowl of noodles is filled with complex flavors and textures. The slippery rice noodles are topped with a savory sauce made from pickled bamboo shoots, spicy chili oil, minced pork, and fragrant herbs. Served with vinegar and peanuts for extra zing and crunch, this dish is a must-try for any food lover.',\n'Seven days no reason to return','2023-05-20',\n'https://img.alicdn.com/imgextra/i1/2485630119/O1CN01XjB5ap1CkY1ioEbec_!!0-saturn_solar.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com12349', 'spicy strip', 'food', 0.5, 0,100000,'Taste of childhood',\n'Spicy and addictive, these chewy strips pack a punch of flavor. Infused with a blend of fiery spices, they offer a satisfying kick with every bite. Whether you enjoy them as a snack on the go or as a zesty addition to your favorite dishes, these spicy sticks are sure to spice up your day.',\n'Seven days no reason to return','2023-01-15',\n'https://img.alicdn.com/imgextra/i4/101025137/O1CN014tAkX81nonUmjbfXL_!!0-saturn_solar.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com12350', 'Braised beef noodles', 'food', 3.5, 0,10000,'filling',\n'Spicy and addictive, these chewy strips pack a punch of flavor. Infused with a blend of fiery spices, they offer a satisfying kick with every bite. Whether you enjoy them as a snack on the go or as a zesty addition to your favorite dishes, these spicy sticks are sure to spice up your day.',\n'Seven days no reason to return','2023-10-02',\n'https://g-search3.alicdn.com/img/bao/uploaded/i4/i1/2371566698/O1CN014qvI8h1zLjhoHxwEH_!!0-item_pic.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com12351', 'jelly', 'food', 20.99, 5.99,10000,'chewy and delicious',\n'Delightfully wobbly and bursting with fruity sweetness, this jelly treat is a playful indulgence for all ages. Each colorful, translucent cube offers a refreshing burst of flavor, making it a fun and satisfying snack. Whether enjoyed on its own or as part of a dessert, this jiggly delight is sure to bring joy.',\n'Seven days no reason to return','2023-11-01',\n'https://img.alicdn.com/imgextra/i3/2908500146/O1CN01UEccf61CwujVuykdl_!!0-saturn_solar.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com13310', 'Down jacket', 'cloth', 399, 100,2000,'Fit like a glove',\n'Designed for warmth and style, this down jacket is the ultimate winter companion. Filled with soft and insulating down feathers, it provides exceptional insulation against the cold. Its sleek and quilted design offers a trendy and modern look, while the cozy hood and zippered pockets add practicality. Stay snug and fashionable in this essential winter apparel.',\n'Seven days no reason to return','2023-10-20',\n'https://g-search1.alicdn.com/img/bao/uploaded/i4/i2/3422193418/O1CN01BV60Ej1b7UcX4Zjyz_!!3422193418.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com13410', 'Midea air conditioner', 'ele_appliment', 2999, 200,2000,'Very cool',\n'This air conditioner is the perfect solution for keeping your home cool and comfortable. With its powerful cooling capabilities, it quickly cools down any room. Its sleek and compact design fits seamlessly into any space, while its energy-efficient technology ensures minimal electricity consumption. Control the temperature with ease using the remote control or programmable timer, making it a convenient and reliable option for hot summer months.',\n'Seven days no reason to return','2023-02-27',\n'https://img.alicdn.com/imgextra/i2/100532851/O1CN01CqyVgR1Wvo3NORkOs_!!2-saturn_solar.png_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com13510', 'vivo mobile phone', 'ele_product', 99999, 2000,2000,'Too expensive',\n'Sleek and powerful, this smartphone is a technological marvel. Its high-resolution display brings visuals to life with vibrant colors and sharp details. With a lightning-fast processor and ample storage capacity, it effortlessly handles multitasking and stores all your important files. Capture stunning photos with its advanced camera system and stay connected with fast internet speeds. This phone merges style and functionality seamlessly, making it a must-have gadget.',\n'Seven days no reason to return','2023-10-27',\n'https://img.alicdn.com/imgextra/i2/14867192/O1CN01mHqjjR22zzPUyJaeD_!!0-saturn_solar.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com13610', 'Liquid foundation', 'makeup', 49, 0,2000,'Flawless coverage, radiant complexion',\n'This foundation is a game-changer. It provides seamless coverage that blurs imperfections, leaving a natural and glowing complexion. Its lightweight formula blends effortlessly, ensuring a smooth and even finish. With long-lasting staying power, it keeps your skin looking flawless all day. Enhance your beauty with this exceptional foundation.',\n'Seven days no reason to return','2023-11-27',\n'https://img.alicdn.com/imgextra/i1/30321366/O1CN01GuqGrB1Lxfims8RoA_!!0-saturn_solar.jpg_460x460q90.jpg_.webp');\n\nINSERT INTO commodity\nVALUES ('com13710', 'Ultraman', 'toy', 20.3, 0,5000,'Children like it very much',\n'Unleash your creativity with this versatile toy. With endless possibilities, it sparks imagination and promotes hands-on learning. Its durable construction ensures long-lasting fun, while its vibrant colors and unique design capture attention. Whether building, stacking, or creating imaginative stories, this toy guarantees hours of entertainment for children of all ages.',\n'Seven days no reason to return','2022-12-15',\n'https://g-search1.alicdn.com/img/bao/uploaded/i4/i1/1898884903/O1CN01YPWF7r1m5coIGl8h2_!!1898884903.jpg_460x460q90.jpg_.webp');\n\n\n--食品小表\nINSERT INTO food\nVALUES ('com12347', 'cookie', 'food', 5.99, 1,1000,'very delicious',\n'Deliciously crisp and golden, these cookies are the perfect blend of sweetness and crunch. Each bite is filled with rich flavors, leaving a lingering vanilla aroma. Indulge in these irresistible treats that will surely satisfy your cravings. Enjoy them with a cup of tea or share them with friends for a delightful snack experience.',\n'Seven days no reason to return','2023-07-01',\n'https://img.alicdn.com/imgextra/i3/1408820149/O1CN01B67UhV1CyHv3krMdJ_!!0-saturn_solar.jpg_460x460q90.jpg_.webp',\n180,'1kg','Original taste');\n\nINSERT INTO food\nVALUES ('com12348', 'River snail rice noodle', 'food', 10.99, 0,5000,'smelly but delicious',\n'A popular dish from southern China, this bowl of noodles is filled with complex flavors and textures. The slippery rice noodles are topped with a savory sauce made from pickled bamboo shoots, spicy chili oil, minced pork, and fragrant herbs. Served with vinegar and peanuts for extra zing and crunch, this dish is a must-try for any food lover.',\n'Seven days no reason to return','2023-05-20',\n'https://img.alicdn.com/imgextra/i1/2485630119/O1CN01XjB5ap1CkY1ioEbec_!!0-saturn_solar.jpg_460x460q90.jpg_.webp',\n90,'225g','Original taste');\n\nINSERT INTO food\nVALUES ('com12349', 'spicy strip', 'food', 0.5, 0,100000,'Taste of childhood',\n'Spicy and addictive, these chewy strips pack a punch of flavor. Infused with a blend of fiery spices, they offer a satisfying kick with every bite. Whether you enjoy them as a snack on the go or as a zesty addition to your favorite dishes, these spicy sticks are sure to spice up your day.',\n'Seven days no reason to return','2023-01-15',\n'https://img.alicdn.com/imgextra/i4/101025137/O1CN014tAkX81nonUmjbfXL_!!0-saturn_solar.jpg_460x460q90.jpg_.webp',\n360,'50g','Original taste');\n\nINSERT INTO food\nVALUES ('com12350', 'Braised beef noodles', 'food', 3.5, 0,10000,'filling',\n'Spicy and addictive, these chewy strips pack a punch of flavor. Infused with a blend of fiery spices, they offer a satisfying kick with every bite. Whether you enjoy them as a snack on the go or as a zesty addition to your favorite dishes, these spicy sticks are sure to spice up your day.',\n'Seven days no reason to return','2023-10-02',\n'https://g-search3.alicdn.com/img/bao/uploaded/i4/i1/2371566698/O1CN014qvI8h1zLjhoHxwEH_!!0-item_pic.jpg_460x460q90.jpg_.webp',\n90,'225g','Braised beef');\n\nINSERT INTO food\nVALUES ('com12351', 'jelly', 'food', 20.99, 5.99,10000,'chewy and delicious',\n'Delightfully wobbly and bursting with fruity sweetness, this jelly treat is a playful indulgence for all ages. Each colorful, translucent cube offers a refreshing burst of flavor, making it a fun and satisfying snack. Whether enjoyed on its own or as part of a dessert, this jiggly delight is sure to bring joy.',\n'Seven days no reason to return','2023-11-01',\n'https://img.alicdn.com/imgextra/i3/2908500146/O1CN01UEccf61CwujVuykdl_!!0-saturn_solar.jpg_460x460q90.jpg_.webp',\n360,'100g','orange');\n\n--店铺商品关系表\n\nINSERT INTO sell\nVALUES ('400672256','com12347','2023-08-01');\nINSERT INTO sell\nVALUES ('400672256','com12348','2023-05-30');\nINSERT INTO sell\nVALUES ('400672256','com12349','2023-02-18');\nINSERT INTO sell\nVALUES ('400672256','com12350','2023-10-07');\nINSERT INTO sell\nVALUES ('400672256','com12351','2023-11-10');\n\nSELECT * FROM commodity;\nSELECT * FROM store;\nSELECT * FROM food;\nSELECT * FROM sell;\n\n--查询一个店铺的所有商品\nSELECT com_id FROM ((store NATURAL JOIN sell)NATURAL JOIN commodity)\nWHERE store_id = '400672256';\n\n--聊天系统的数据测试\nINSERT INTO message\nVALUES ('ms0000000000001','文本','你吃饭了吗？','2022-01-10 12:00:00');\nINSERT INTO message\nVALUES ('ms0000000000002','文本','还没有','2022-01-10 12:00:30');\nINSERT INTO message\nVALUES ('ms0000000000003','文本','今天布置了什么作业了？','2022-01-12 18:00:00');\nINSERT INTO message\nVALUES ('ms0000000000004','文本','数值计算的编程作业','2022-01-12 18:30:53');\nINSERT INTO message\nVALUES ('ms0000000000005','文本','edge detection','2022-01-12 18:44:24');\nINSERT INTO message\nVALUES ('ms0000000000006','文本','一会去哪吃？','2022-01-10 12:00:47');\nINSERT INTO message\nVALUES ('ms0000000000007','文本','兰园二楼','2022-01-10 12:01:20');\nINSERT INTO message\nVALUES ('ms0000000000008','图片','D:\\image\\2.jpg','2022-01-12 18:50:55');\nINSERT INTO message\nVALUES ('ms0000000000009','视频','D:\\video\\2.mp4','2022-01-12 18:51:56');\n--对话消息总表数据\nINSERT INTO conversation_message\nVALUES ('ms0000000000001','文本','你吃饭了吗？','2022-01-10 12:00:00', true);\nINSERT INTO conversation_message\nVALUES ('ms0000000000002','文本','还没有','2022-01-10 12:00:30', false);\nINSERT INTO conversation_message\nVALUES ('ms0000000000006','文本','一会去哪吃？','2022-01-10 12:00:47', false);\nINSERT INTO conversation_message\nVALUES ('ms0000000000007','文本','兰园二楼','2022-01-10 12:01:20', false);\n--群组消息总表数据\nINSERT INTO group_message\nVALUES ('ms0000000000003','文本','今天布置了什么作业了？','2022-01-12 18:00:00');\nINSERT INTO group_message\nVALUES ('ms0000000000004','文本','数值计算的编程作业','2022-01-12 18:30:53');\nINSERT INTO group_message\nVALUES ('ms0000000000005','文本','edge detection','2022-01-12 18:44:24');\nINSERT INTO group_message\nVALUES ('ms0000000000008','图片','D:\\image\\2.jpg','2022-01-12 18:50:55');\nINSERT INTO group_message\nVALUES ('ms0000000000009','视频','D:\\video\\2.mp4','2022-01-12 18:51:56');\nDROP TABLE message;\nDROP TABLE group_message;\nSELECT * FROM message;\nSELECT * FROM conversation_message;\nSELECT * FROM group_message;\n\n--评价消息总表数据\nINSERT INTO evaluation\nVALUES ('ev0000000000001','文本','这件衣服的材质很好,穿起来很舒服', false, '好', '2023-02-22 14:00:00',\n\t   false, 0, 0, 5, 5, 5, 5);\nINSERT INTO evaluation\nVALUES ('ev0000000000002','文本','这个充电宝充电慢，还会漏电', false, '差', '2023-03-12 15:30:53',\n\t   false, 0, 0, 1, 1, 3, 3);\nINSERT INTO evaluation\nVALUES ('ev0000000000003','文本','这个薯片很好吃，值得一买', true, '好', '2023-04-11 08:12:22',\n\t   false, 0, 0, 5, 5, 4, 5);\nINSERT INTO evaluation\nVALUES ('ev0000000000003','文本','这个薯片很好吃，值得一买', true, '好', '2023-04-11 08:12:22',\n\t   false, 0, 0, 5, 5, 4, 2);\nINSERT INTO evaluation\nVALUES ('ev0000000000004','文本','这件衣服真的很好看，还便宜', false, '好', '2023-02-23 10:10:55',\n\t   true, 25, 30, 5, 5, 5, 5);\nINSERT INTO evaluation\nVALUES ('ev0000000000005','图片','D:\\image\\1.jpg', false, '好', '2023-03-23 11:25:35',\n\t   false, 10, 3, 5, 4, 4, 5);\nINSERT INTO evaluation\nVALUES ('ev0000000000006','视频','D:\\video\\1.mp4', false, '好', '2023-01-25 16:55:45',\n\t   false, 0, 0, 5, 5, 5, 5);\nSELECT * FROM evaluation;\nDELETE FROM evaluation WHERE evaluation_id = 'ev0000000000005';\n\nDROP TABLE evaluation;\n--好友消息索引表数据\nINSERT INTO friend_and_friend\nVALUES ('tb12345', 'tb12342', 'ms0000000000001');\nINSERT INTO friend_and_friend\nVALUES ('tb12342', 'tb12345', 'ms0000000000002');\nINSERT INTO friend_and_friend\nVALUES ('tb12345', 'tb12342', 'ms0000000000006');\nINSERT INTO friend_and_friend\nVALUES ('tb12342', 'tb12345', 'ms0000000000007');\nSELECT * FROM friend_and_friend;\n```","tags":["数据库","实践"]},{"title":"ICPC算法模版","url":"/post/23b2b017.html","content":"# Part 1. 数据结构\n\n## 1.线段树（Segment Trees)\n\n关键词：定长序列操作，区间修改与查询。\n\n**ACLibrary对懒标记线段树适配的定义，不涉及区间懒标记的普通线段树没有$F$的限制：**\n\nIt is the data structure for the pair of a monoid $(<S, \\cdot>: S \\cdot S \\to S, e \\in S)$ and a set $F$ of $S \\to S$​ mappings that satisfies the following properties.\n\n1. $F$ contains the identity map $\\mathrm{id}$, where the identity map is the map that satisfies $\\mathrm{id}(x) = x$ for all $x \\in S$.\n2. $F$ is closed under composition, i.e., $f \\circ g \\in F$ holds for all $f, g \\in F$​.\n3. $f(x \\cdot y) = f(x) \\cdot f(y)$ holds for all $f \\in F$ and $x, y \\in S$.\n\nGiven an array $S$ of length $N$, it processes the following queries in $O(\\log N)$ time. \n\n1. Acting the map $f\\in F$ (cf. $x = f(x)$) on all the elements of an interval\n2. Calculating the product of the elements of an interval\n\n**中文翻译：**\n\n懒标记线段树是适配于满足以下条件的***幺半群***$(<S, \\cdot>: S \\cdot S \\to S, e \\in S)$和属于***线性空间*** $V:S\\to S$的子空间$F$:\n\n1. $F$有单位映射$f\\in F,s.t.\\ \\forall x\\in S, f(x)=x$\n2. 代数系统$<F,\\circ>$封闭，其中$\\circ$表函数复合，不满足交换律，复合顺序从右到左，即$(f\\circ g)(x)=f(g(x))$​\n3. $F$必须是线性空间，即$\\forall f \\in F,$ $\\forall x, y \\in S, $  $f(x \\cdot y) = f(x) \\cdot f(y)$​.\n\n给定一个长度为$N$的$S$类型的数组，要求在$O(log\\ N)$的时间内完成以下类型操作：\n\n1. 对一个或者一段区间的值应用线性映射$f$​，并改为对应结果。\n\n   $\\forall x_i\\in S,\\ i\\in[l,r), \\ x_i:=f(x_i)$\n\n2. 求一个或者一段区间的值对幺半群乘法 （$\\cdot$） 运算的结果。\n   $$\n   \\large ans=\\prod_{i=l}^r x_i \\in S\n   $$\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.1 普通线段树（静态开点区间加，永久化懒标记，当心爆标记问题，码量小）\n\n**切记单点修改的if-else必须写全！！！**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int sum;\n    int lazy;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nvoid update(int pos, int val, int rt, int cl, int cr)\n{\n    tree[rt].sum += val;\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(pos, val, rt << 1, cl, mid);\n    else\n        update(pos, val, rt << 1 | 1, mid + 1, cr);\n    return;\n}\nvoid update(int l, int r, int val, int rt, int cl, int cr)\n{\n    tree[rt].sum += val * (min(r, cr) - max(l, cl) + 1);\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].lazy += val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, val, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, val, rt << 1 | 1, mid + 1, cr);\n}\nint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    int res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res + tree[rt].lazy * (min(r, cr) - max(l, cl) + 1);\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        update(i, x, 1, 1, n);\n    }\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, n);\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.2 普通线段树(静态开点区间加，标记永久化)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int sum;\n    int lazy;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nint a[maxn];\nvoid pushup(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid pushdown(int rt, int cl, int cr)\n{\n    int mid = (cl + cr) >> 1;\n    if (tree[rt].lazy)\n    {\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1].sum += tree[rt].lazy * (mid - cl + 1);\n        tree[rt << 1 | 1].sum += tree[rt].lazy * (cr - mid);\n        tree[rt].lazy = 0;\n    }\n    return;\n}\nvoid build(int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt] = {a[cl], 0};\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    build(rt << 1, cl, mid);\n    build(rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nvoid update(int pos, int val, int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt].sum += val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(pos, val, rt << 1, cl, mid);\n    else\n        update(pos, val, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nvoid update(int l, int r, int val, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].sum += val * (cr - cl + 1);\n        tree[rt].lazy += val;\n        return;\n    }\n    pushdown(rt, cl, cr);\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, val, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, val, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    pushdown(rt, cl, cr);\n    int res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        update(i, x, 1, 1, n);\n    }\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, n);\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.3 普通线段树（静态区间加、区间乘，非永久化）\n\n贴出来记得懒标记顺序思考问题。注意，懒标记下传的时候是$f_{rt}\\ \\circ \\ f_{sons}$的复合函数顺序。根据Segtrees.h思想思考。\n\n```cpp\n#include <bits/stdc++.h>\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nusing namespace std;\n#define int long long\nusing mint = MLong<0>;\nstruct node\n{\n    mint sum;\n    mint lazyadd = 0;\n    mint lazymul = 1;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nmint a[maxn];\nvoid pushup(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid pushdown(int rt, int cl, int cr)\n{\n    // 儿子节点已有ax+b,传下来c(ax+b)+d=cax+cb+d);\n    int mid = (cl + cr) >> 1;\n    if (tree[rt].lazyadd != 0 || tree[rt].lazymul != 1)\n    {\n        tree[rt << 1].lazyadd *= tree[rt].lazymul;\n        tree[rt << 1].lazyadd += tree[rt].lazyadd;\n\n        tree[rt << 1 | 1].lazyadd *= tree[rt].lazymul;\n        tree[rt << 1 | 1].lazyadd += tree[rt].lazyadd;\n\n        tree[rt << 1].lazymul *= tree[rt].lazymul;\n        tree[rt << 1 | 1].lazymul *= tree[rt].lazymul;\n\n        tree[rt << 1].sum = tree[rt << 1].sum * tree[rt].lazymul + tree[rt].lazyadd * (mid - cl + 1);\n        tree[rt << 1 | 1].sum = tree[rt << 1 | 1].sum * tree[rt].lazymul + tree[rt].lazyadd * (cr - mid);\n        tree[rt].lazyadd = 0;\n        tree[rt].lazymul = 1;\n    }\n\n    return;\n}\nvoid build(int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt].sum = a[cl];\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    build(rt << 1, cl, mid);\n    build(rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nvoid update(int l, int r, int add, int mul, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].sum *= mul;\n        tree[rt].sum += add * (cr - cl + 1);\n\n        tree[rt].lazyadd *= mul;\n        tree[rt].lazyadd += add;\n\n        tree[rt].lazymul *= mul;\n\n        return;\n    }\n    pushdown(rt, cl, cr);\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, add, mul, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, add, mul, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nmint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    pushdown(rt, cl, cr);\n    mint res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    int m;\n    cin >> m;\n    mint::setMod(m);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, 0, d, 1, 1, n);\n            /*for (int i = 1; i <= n; i++)\n            {\n                cout << query(i, i, 1, 1, n) << \" \";\n            }\n            cout << endl;*/\n        }\n        else if (op == 2)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, 1, n);\n            /*for (int i = 1; i <= n; i++)\n            {\n                cout << query(i, i, 1, 1, n) << \" \";\n            }\n            cout << endl;*/\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.4 Segtree.h/lazy_segtree\n\nACLibrary线段树，非递归模式，线段树下标从0开始。下文所提及区间默认左闭右开。\n\n函数列表\n\n`bit_ceil` : 取比参数大的最近的$2^n$\n\n`countr_zero` : 取参数的二进制结尾有多少个$0$\n\n`pushup` : 字面含义\n\n`upd` : 修改完整线段树节点所代表区间\n\n`pushdown` ： 字面含义\n\n`explicit lazy_segtree(const vector<S> &v)` : 构造函数\n\n`void set(int p, S x)` : 单点修改为$x$（***单点改为***）\n\n`S get(int p)` : 单点查询\n\n`S query(int l, int r)` : 查询区间$[l,r)$进行$op$的结果\n\n`void modify(int p, F f)` : 单点应用修改（***单点加***）\n\n`void modify(int l, int r, F f)` : 区间$[l,r)$应用修改 (***区间加***)\n\n`template <bool (*g)(S)> int max_right(int l)` : 线段树二分查询从$l$开始的最右端点$r$，满足$g(op[l,l+1,\\cdots,\\textcolor{red}{r-1}])=true$.\n\n`template <bool (*g)(S)> int min_left(int r)` : 线段树二分查询到$r$的最左端点$l$，满足$g(op[l,l+1,\\cdots,\\textcolor{red}{r-1}])=true$.\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Segtrees\n{\n    int bit_ceil(int n)\n    {\n        int x = 1;\n        while (x < n)\n            x *= 2;\n        return x;\n    }\n    int countr_zero(unsigned int n)\n    {\n        return __builtin_ctz(n);\n    }\n    template <class S,S (*op)(S, S),S (*e)(),class F,S (*mp)(F, S),F (*comp)(F, F),F (*id)()>\n    struct lazy_segtree\n    {\n    private:\n        int _n, size, log;\n        vector<S> d;\n        vector<F> lz;\n        void pushup(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }\n        void upd(int k, F f)\n        {\n            d[k] = mp(f, d[k]);\n            if (k < size)\n                lz[k] = comp(f, lz[k]);\n        }\n        void pushdown(int k)\n        {\n            upd(k << 1, lz[k]);\n            upd(k << 1 | 1, lz[k]);\n            lz[k] = id();\n        }\n\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        explicit lazy_segtree(int n) : lazy_segtree(vector<S>(n, e())) {}\n        explicit lazy_segtree(const vector<S> &v) : _n(int(v.size()))\n        {\n            size = bit_ceil((_n));\n            log = countr_zero(size);\n            d = vector<S>(2 * size, e());\n            lz = vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                pushup(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            return d[p];\n        }\n        /*查询区间[l,r)的结果,l=r时返回幺元*/\n        S query(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    pushdown(l >> i);\n                if (((r >> i) << i) != r)\n                    pushdown((r - 1) >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_query() { return d[1]; }\n        void modify(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            d[p] = mp(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        void modify(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    pushdown(l >> i);\n                if (((r >> i) << i) != r)\n                    pushdown((r - 1) >> i);\n            }\n            int l2 = l, r2 = r;\n            while (l < r)\n            {\n                if (l & 1)\n                    upd(l++, f);\n                if (r & 1)\n                    upd(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    pushup(l >> i);\n                if (((r >> i) << i) != r)\n                    pushup((r - 1) >> i);\n            }\n        }\n        /*\n         * @brief 线段树二分，查询区间[l,n)满足g的最右端点r\n         * @tparam G 查询函数g，参数类型S\n         * @param l 区间左端点\n         * @return 区间[l,n)满足g( op([l,l+1,···,r) )的最右端点r\n         */\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x)\n                             { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        pushdown(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x)\n                            { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                pushdown((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        pushdown(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.5 Segtree.h/segtree\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Segtrees\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        explicit segtree(int n) : segtree(vector<S>(n, e())) {}\n        explicit segtree(const vector<S> &v) : _n(v.size())\n        {\n            size = bit_ceil(_n);\n            log = countr_zero(size);\n            d = vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                pushup(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        S get(int p) const\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S query(int l, int r) const\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_query() const { return d[1]; }\n        template <bool (*f)(S)>\n        int max_right(int l) const\n        {\n            return max_right(l, [](S x)\n                             { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f) const\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)>\n        int min_left(int r) const\n        {\n            return min_left(r, [](S x)\n                            { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f) const\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        vector<S> d;\n        void pushup(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.6 线段树合并\n\n动态开点线段树合并，常出现于树上问题，父亲节点继承子节点信息。树上差分结合线段树合并维护路径上信息。\n\n示例是非永久化标记的写法。核心就这一个，具体可参考主席树写法。\n\n```cpp\nint merge(int rt1, int rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n        return rt1 | rt2;\n    if (cl == cr)\n    {\n        tree[rt1].maxnum += tree[rt2].maxnum;\n        return rt1;\n    }\n    int mid = (cl + cr) >> 1;\n    tree[rt1].l = merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    tree[rt1].r = merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    pushup(rt1);\n    return rt1;\n}\n```\n\n裸模板见下面线段树分裂中，有线段树合并部分。\n\n自己风格的主席树是用线段树合并写的，思路更清晰。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.7 线段树分裂\n\n八辈子碰不上一个。\n\n给出一个可重集 $a$（编号为 $1$），它支持以下操作：\n\n`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。\n\n`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。\n\n`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。\n\n`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。\n\n`4 p k`：查询在 $p$ 这个可重集中第 $k$​ 小的数，不存在时输出 `-1`。\n\n```cpp\n// 线段树分裂\n// 线段树合并逆向操作\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n// #define DEBUG 1\nconst int maxn = 3e5 + 9;\nint n, m, tot = 0, root[maxn], a[maxn];\nstruct node\n{\n    int l, r, sum;\n    int cl, cr;\n} tree[maxn << 5];\n#define ls(rt) tree[rt].l\n#define rs(rt) tree[rt].r\n#define rcl(rt) tree[rt].cl\n#define rcr(rt) tree[rt].cr\n#define sum(rt) tree[rt].sum\nvoid pushup(int rt)\n{\n    sum(rt) = sum(ls(rt)) + sum(rs(rt));\n}\nvoid update(int &rt, int num, int pos, int cl = 1, int cr = n) // 单点修改权值线段树\n{\n    if (!rt)\n    {\n        rt = ++tot;\n        rcl(rt) = cl, rcr(rt) = cr;\n    }\n    if (cl == cr)\n    {\n        sum(rt) += num;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(ls(rt), num, pos, cl, mid);\n    else\n        update(rs(rt), num, pos, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nint querykth(int &rt, int k, int cl = 1, int cr = n) // 查询区间第k小，线段树上二分\n{\n    if (!rt)\n        return -1;\n    if (cl == cr)\n        return cl;\n    int mid = (cl + cr) >> 1LL;\n    if (sum(ls(rt)) >= k)\n        return querykth(ls(rt), k, cl, mid);\n    else\n        return querykth(rs(rt), k - sum(ls(rt)), mid + 1, cr);\n}\nint queryinterval(int &rt, int l, int r, int cl = 1, int cr = n) // 查询大于等于x小于等于y的元素个数\n{\n    if (l <= cl && cr <= r)\n        return sum(rt);\n    int mid = (cl + cr) >> 1LL, ans = 0;\n    if (l <= mid)\n        ans += queryinterval(ls(rt), l, r, cl, mid);\n    if (r > mid)\n        ans += queryinterval(rs(rt), l, r, mid + 1, cr);\n    return ans;\n}\nvoid segmerge(int &rt1, int &rt2, int cl = 1, int cr = n)\n{\n    if (!rt1 || !rt2)\n        return void(rt1 = rt1 + rt2);\n    if (cl == cr)\n        return void(sum(rt1) += sum(rt2));\n    int mid = (cl + cr) >> 1;\n    segmerge(ls(rt1), ls(rt2), cl, mid);\n    segmerge(rs(rt1), rs(rt2), mid + 1, cr);\n    pushup(rt1);\n    return;\n}\nvoid segsplit(int &rt1, int &rt2, int l, int r, int cl = 1, int cr = n)\n{\n    if (!rt1)\n    {\n        return;\n    }\n    if (l <= cl && cr <= r)\n    {\n        rt2 = rt1;\n        rt1 = 0;\n        return;\n    }\n    if (!rt2)\n    {\n        rt2 = ++tot;\n        rcl(rt2) = cl, rcr(rt2) = cr;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        segsplit(ls(rt1), ls(rt2), l, r, cl, mid);\n    if (r > mid)\n        segsplit(rs(rt1), rs(rt2), l, r, mid + 1, cr);\n    pushup(rt1);\n    pushup(rt2);\n    return;\n}\nint cnt = 1;\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        update(root[1], a[i], i);\n    }\n    while (m--)\n    {\n        int op, x, y, z;\n        cin >> op;\n        switch (op)\n        {\n        case 0:\n            cnt++;\n            cin >> x >> y >> z;\n            segsplit(root[x], root[cnt], y, z);\n            break;\n        case 1:\n            cin >> x >> y;\n            segmerge(root[x], root[y]);\n            break;\n        case 2:\n            cin >> x >> y >> z;\n            update(root[x], y, z);\n            break;\n        case 3:\n            cin >> x >> y >> z;\n            cout << queryinterval(root[x], y, z) << endl;\n            break;\n        case 4:\n            cin >> x >> y;\n            cout << querykth(root[x], y) << endl;\n            break;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.8 扫描线\n\n#### 1.8.1 求矩形面积的并\n\n扫描线问题 ***切记切记*** 维护好***什么时候扫过，扫过的部分怎么算，已经扫完的部分如何删除的边界问题***，也是重点DEBUG部分.\n\n求矩形面积的并每次查询的是整个区间内线段的长度。\n\n***Codeforces***上有一道维护线段的加入和删除，区间查询某个区间是否有线段覆盖的题，***注意，如果涉及到此问题***，**仅**扫描线思想中**标记不下传只维护当前线段树结点所表示的完整区间是否有线段**的类线段树分治思想***还需要额外判定以下内容：***\n\n***如果目标区间$[l,r]$已经被某条长线段完整覆盖，直接返回$true$​​即可。***\n\n```cpp\n// 扫描线模板\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nstruct segtrees\n{\n    int l, r;\n    i64 sum = 0;\n    int tags = 0;\n};\nconst int maxn = 4e5 + 9;\nsegtrees tree[maxn << 2];\nint n, m;\ni64 points[maxn];\nvoid update(int rt, int cl, int cr)\n{\n    if (tree[rt].tags)\n    {\n        tree[rt].sum = points[cr + 1] - points[cl];\n        return;\n    }\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid modifytags(int l, int r, int d, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].tags += d;\n        update(rt, cl, cr);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        modifytags(l, r, d, rt << 1, cl, mid);\n    if (r > mid)\n        modifytags(l, r, d, rt << 1 | 1, mid + 1, cr);\n    update(rt, cl, cr);\n    return;\n}\nstruct node\n{\n    int x1, y1, x2, y2;\n} rem[maxn];\nvector<tuple<int, int, int, int>> op;\nsigned main()\n{\n    cin >> n;\n    int cnt = 0;\n    int S = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 > x2)\n            swap(x1, x2);\n        if (y1 > y2)\n            swap(y1, y2);\n        rem[i] = {x1, y1, x2, y2};\n        points[++cnt] = x1;\n        points[++cnt] = x2;\n    }\n    sort(points + 1, points + 1 + cnt);\n    S = unique(points + 1, points + 1 + cnt) - points - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int x1 = lower_bound(points + 1, points + 1 + S, rem[i].x1) - points;\n        int x2 = lower_bound(points + 1, points + 1 + S, rem[i].x2) - points;\n        op.push_back({rem[i].y1, x1, x2 - 1, 1});\n        op.push_back({rem[i].y2, x1, x2 - 1, -1});\n    }\n    sort(op.begin(), op.end());\n    i64 ans = 0;\n    i64 last = 0;\n    for (auto [y, x1, x2, d] : op)\n    {\n        ans += (y - last) * tree[1].sum;\n        modifytags(x1, x2, d, 1, 1, S);\n        last = y;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.8.2 维护线段的并\n\n其实有点废话，本质上不是扫描线，但是确实是通过维护线段区间的并判断此时有多少个合法情况，来源于牛客多校的$Interval Selection$:\n\n\n\n有一个长度为 $n$ 的数组，当且仅当 $a_l,a_{l+1},\\dots a_r$ 中的每个元素在当前区间内恰好出现 $k$ 次时，数组中的子数组 $[l,r]$ 才是好数组。  \n\n例如，对于$a=[1,1,2,3,2,3,1]$和$k=2$，区间$[1,2]$、$[3,6]$、$[1,6]$等都是好的。但是，$[1,3]$不符合条件，因为元素$2$只出现了一次；$[1,7]$不符合条件，因为元素$1$出现了$3$次。  \n\n请找出可以选择的好区间的个数。\n\n\n\n通过线段并维护不合法区间数量即可，线段交过于难以维护。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\n#define IOS                      \\\n    ios::sync_with_stdio(false); \\\n    cin.tie(0);                  \\\n    cout.tie(0);\nconst int maxn = 2e5 + 9;\nint a[maxn], b[maxn];\nstruct node\n{\n    int l;\n    int r;\n    int cover;\n    int sum;\n} tree[maxn << 2LL];\nint n;\n#define ls(rt) tree[rt << 1LL]\n#define rs(rt) tree[rt << 1LL | 1]\n#define cover(rt) tree[rt].cover\n#define sum(rt) tree[rt].sum\n#define getl(rt) tree[rt].l\n#define getr(rt) tree[rt].r\nvoid pushup(int rt)\n{\n    if (cover(rt))\n        sum(rt) = 0;\n    else if (getl(rt) == getr(rt))\n    {\n        sum(rt) = 1;\n    }\n    else\n        sum(rt) = sum(rt << 1LL) + sum(rt << 1LL | 1);\n    return;\n}\nvoid modify(int l, int r, int d, int rt = 1, int cl = 1, int cr = n)\n{\n    if (l <= cl && cr <= r)\n    {\n        cover(rt) += d;\n        pushup(rt);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        modify(l, r, d, rt << 1LL, cl, mid);\n    if (r > mid)\n        modify(l, r, d, rt << 1LL | 1, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nint querysum(int l, int r, int rt = 1, int cl = 1, int cr = n)\n{\n    if (cover(rt))\n        return 0;\n    if (l <= cl && cr <= r)\n    {\n        return sum(rt);\n    }\n    int mid = (cl + cr) >> 1;\n    int ans = 0;\n    if (l <= mid)\n        ans += querysum(l, r, rt << 1LL, cl, mid);\n    if (r > mid)\n        ans += querysum(l, r, rt << 1LL | 1, mid + 1, cr);\n    return ans;\n}\nvoid build(int rt = 1, int l = 1, int r = n)\n{\n    getl(rt) = l;\n    getr(rt) = r;\n    cover(rt) = 0;\n    if (l == r)\n    {\n        sum(rt) = 1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(rt << 1LL, l, mid);\n    build(rt << 1LL | 1, mid + 1, r);\n    pushup(rt);\n    return;\n}\nint k;\nvector<int> rem[maxn];\nvoid solve()\n{\n    cin >> n >> k;\n    build();\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        b[i] = a[i];\n    }\n    sort(b + 1, b + n + 1);\n    int m = unique(b + 1, b + n + 1) - b - 1;\n    for (int i = 1; i <= m; i++)\n    {\n        rem[i].clear();\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (rem[a[i]].empty())\n        {\n            rem[a[i]].push_back(0);\n        }\n        rem[a[i]].push_back(i);\n        int t = rem[a[i]].size() - 1;\n        int l = rem[a[i]][t - 1] + 1, r = rem[a[i]][t];\n        modify(l, r, 1);\n        if (t >= k)\n        {\n            l = rem[a[i]][t - k] + 1;\n            r = rem[a[i]][t - k + 1];\n            modify(l, r, -1);\n            if (l >= 2)\n                modify(1, l - 1, 1);\n            ans += querysum(l, r);\n        }\n    }\n    cout << ans << endl;\n    return;\n}\nsigned main()\n{\n    IOS;\n    int t = 1;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.9 主席树（静态区间第k小、小于等于第k小的和、小于等于前k小有多少个数）\n\n记住主席树的根本思想在于维护前缀和。\n\n另外，主席树复杂度$O(Knlogn)$，常数较大，$n\\le 5e5$时如果确定必须用到主席树，算法复杂度必须严格纯$O(nlogn)$，$O(nlog^2n)$可能会$\\color{red}TLE$​\n\n***附议：其实主席树根本就不需要离散化，动态开点的属性确保了树深度最多 $logV$，一共 $10^5$级别的数字确保了最多$O(nlogV)$的空间复杂度，一定不会超，就是常数稍微大一点而已。这意味着主席树可以完全做到平替 $01Trie$求异或最值问题。***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nstruct node\n{\n    int l, r;\n    i64 sum;\n    i64 cnt;\n};\nint tot = 0;\nconst int maxn = 5e5 + 9;\ni64 bs[maxn]; // 离散化数组，下标离散化，内存为原数字\ni64 a[maxn];\nnode tree[maxn << 5];\nint root[maxn];\nvoid init(int n)\n{\n    for (int i = 0; i <= n; i++)\n    {\n        root[i] = 0;\n    }\n    tot = 0;\n    return;\n}\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0, 0};\n    return tot;\n}\nvoid update(int &rt, int pos, int cl, int cr)\n{\n    if (!rt)\n    {\n        rt = newnode();\n    }\n    tree[rt].cnt++;\n    tree[rt].sum += bs[pos];\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(tree[rt].l, pos, cl, mid);\n    else\n        update(tree[rt].r, pos, mid + 1, cr);\n}\nvoid merge(int &rt1, int &rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n    {\n        rt1 |= rt2;\n        return;\n    }\n    tree[rt1].cnt += tree[rt2].cnt;\n    tree[rt1].sum += tree[rt2].sum;\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    return;\n}\ntuple<i64, i64, int> querykth(int rt1, int rt2, int k, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        return {bs[cl], tree[rt2].sum - tree[rt1].sum, tree[rt2].cnt - tree[rt1].cnt};\n    }\n    int mid = (cl + cr) >> 1;\n    int nowcnt = tree[tree[rt2].l].cnt - tree[tree[rt1].l].cnt;\n    i64 nowsum = tree[tree[rt2].l].sum - tree[tree[rt1].l].sum;\n    if (nowcnt >= k)\n        return querykth(tree[rt1].l, tree[rt2].l, k, cl, mid);\n    auto [kthrl, rsum, rcnt] = querykth(tree[rt1].r, tree[rt2].r, k - nowcnt, mid + 1, cr);\n    return {kthrl, nowsum + rsum, nowcnt + rcnt};\n}\nint sz = 0;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n附：关于主席树的内存回收问题\n\n需要打标记，一个想删除的点可以被删除当且仅当任何版本都没有再使用这个点。尤其注意`merge`函数的处理问题。理论上涉及主席树老版本删除删除的题目，不应当在内存上进行卡制无内存回收无法通过的数据。\n\n```cpp\nint newnode()\n{\n    if (tot + 1 < inf)\n        tot++;\n    else\n        tot = qs.front(), qs.pop();\n    viscnt[tot]++;\n    tree[tot] = {0, 0, 0};\n    return tot;\n}\nvoid del_tree(int rt)\n{\n    if (!rt)\n        return;\n    del_tree(tree[rt].l);\n    del_tree(tree[rt].r);\n    viscnt[rt]--;\n    if (!viscnt[rt])\n    {\n        qs.push(rt);\n        tree[rt] = {0, 0, 0};\n    }\n    return;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.10 主席树维护区间本质不同的元素个数（HH的项链）\n\n给定数组$a$，每次询问$[l,r]$中有多少个不同元素的值出现？\n\n一个$trival$的做法是数每个元素最后一次出现的那一个。主席树下标开位置，记录该位置是否有颜色。\n\n记录***颜色$k$最后一次出现的位置为 $pre_k$***，当前为$i$位置，颜色为$k$，则将$pos=pre_k$位置的线段树节点$-1$表示该位置不再计算，$pos=i$位置节点$+1$表示该节点计算颜色，更新$pre_k=i$。询问$[l,r]$时查询$root[r]$版本主席树。\n\n第一种做法有点像树状数组离线扫描线，不再写。\n\n***第二个更Trival的主席树做法***：\n\n数每个元素数最左侧出现的那一个。思考，$[l,r]$中位置$i$上的元素如果做出贡献，那么记$pre_i$为***位置 $i$上的颜色在 $i$前最后一次出现的位置***，第一次出现时记作$pre_i=0$，则必然有$pre_i<l$.\n\n对位置开权值树桶，维护$pre$数组中值$v=pre[i]$出现了多少次。查询区间$[l,r]$，则主席树查询$root[l-1]$和$root[r]$的差中，小于$l$的值的和。注意，权树下标从$0$开始，因保证$pre_i=0$表示位置$i$​​上的颜色在整个序列中第一次出现。\n\n第二种方法更方便于维护一些被求和的东西。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.11 主席树二维数点（HEOI2017, SuperBig常数，不推荐，建议离线树状数组扫描线，这里主要贴出来主席树构建时有区间update标记永久化）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Segtree_presistent\n{\n    struct node\n    {\n        int l = 0, r = 0;\n        int sum = 0;\n        int lazy = 0;\n    };\n    vector<node> t;\n    vector<int> root;\n    int cnt = 0, n = 0;\n    void init(int _n)\n    {\n        n = _n;\n        cnt = 0;\n        root.assign(n + 1, 0);\n        t.assign(32 * n + 10, node());\n    }\n    void modify(int &rt, int l, int r, int d, int cl, int cr)\n    {\n        if (!rt)\n        {\n            rt = ++cnt;\n        }\n        t[rt].sum += 1ll * d * (min(r, cr) - max(l, cl) + 1);\n        if (l <= cl && cr <= r)\n        {\n            t[rt].lazy += d;\n            return;\n        }\n        int mid = (cl + cr) >> 1ll;\n        if (l <= mid)\n            modify(t[rt].l, l, r, d, cl, mid);\n        if (r > mid)\n            modify(t[rt].r, l, r, d, mid + 1, cr);\n        return;\n    }\n    int query(int rt, int l, int r, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (l <= cl && cr <= r)\n        {\n            return t[rt].sum;\n        }\n        int mid = (cl + cr) >> 1ll;\n        int res = 0;\n        if (l <= mid)\n            res += query(t[rt].l, l, r, cl, mid);\n        if (r > mid)\n            res += query(t[rt].r, l, r, mid + 1, cr);\n        return res + 1ll * (min(r, cr) - max(l, cl) + 1) * t[rt].lazy;\n    }\n    void merge(int &rt1, int &rt2, int cl, int cr)\n    {\n        if (!rt1 || !rt2)\n        {\n            rt1 = rt1 + rt2;\n            return;\n        }\n        t[rt1].sum += t[rt2].sum;\n        t[rt1].lazy += t[rt2].lazy;\n        if (cl == cr)\n            return;\n        int mid = (cl + cr) >> 1ll;\n        merge(t[rt1].l, t[rt2].l, cl, mid);\n        merge(t[rt1].r, t[rt2].r, mid + 1, cr);\n        return;\n    }\n};\nSegtree_presistent seg;\nconst int maxn = 1e6 + 9;\nstruct interval\n{\n    int l, r;\n    int w;\n};\nstruct Edge\n{\n    int n;\n    vector<vector<interval>> G;\n    void init(int _n)\n    {\n        n = _n;\n        G.assign(n + 1, vector<interval>());\n    }\n    void add_edge(int u, int l, int r, int w)\n    {\n        G[u].push_back({l, r, w});\n    }\n};\nEdge G;\nint a[maxn];\nint l[maxn], r[maxn];\nstack<int> s;\nint n, m, p, q;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> p >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        l[i] = 0, r[i] = n + 1;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        while (!s.empty() && a[s.top()] < a[i])\n        {\n            s.pop();\n        }\n        l[i] = s.empty() ? 0ll : s.top();\n        s.push(i);\n    }\n    while (!s.empty())\n    {\n        s.pop();\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        while (!s.empty() && a[s.top()] < a[i])\n        {\n            s.pop();\n        }\n        r[i] = s.empty() ? 1ll * n + 1 : s.top();\n        s.push(i);\n    }\n    seg.init(n);\n    G.init(n);\n    for (int i = 1; i <= n; i++)\n    {\n        if (i != n)\n        {\n            G.add_edge(i, i + 1, i + 1, p);\n        }\n        if (l[i] && r[i] <= n)\n            G.add_edge(l[i], r[i], r[i], p);\n        if (l[i] && i + 1 <= r[i] - 1)\n        {\n            G.add_edge(l[i], i + 1, r[i] - 1, q);\n        }\n        if (r[i] <= n && l[i] + 1 <= i - 1)\n        {\n            G.add_edge(r[i], l[i] + 1, i - 1, q);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto [l, r, w] : G.G[i])\n        {\n            seg.modify(seg.root[i], l, r, w, 1, seg.n);\n        }\n        seg.merge(seg.root[i], seg.root[i - 1], 1, seg.n);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        cout << seg.query(seg.root[r], l, r, 1, seg.n) - seg.query(seg.root[l - 1], l, r, 1, seg.n) << endl;\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.12 带修主席树/树套树（动态区间第k小，单点修改）\n\n#### 1.12.1 动态区间第k小\n\n这个看怎么理解了，严格意义上根本不算主席树，属于树状数组套权值线段树。但是如果按前缀和理解主席树，`merge`函数视作对各个独立根的树求前缀和，树状数组就像是之前暴力预处理前缀和变成了将树直接绑在树状数组上，用树状数组求前缀和，也算说得过去。\n\n理论上区间修改也可以？\n\n注意潜在的空间爆炸问题。\n\n(显然可以，具体实现参考1.11区间加，1.2区间乘，相同逻辑)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 9;\n#define int long long\nint n;\nstruct node\n{\n    int l, r;\n    int sum;\n};\nnode tree[maxn << 5];\nint tot = 0;\nint root[maxn];\nint sz;\nint bs[maxn];\nint a[maxn];\nint q;\nint cnt = 0;\nint lowbit(int x)\n{\n    return (x & -x);\n}\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0ll};\n    return tot;\n}\nvoid upd(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n    {\n        rt = newnode();\n    }\n    tree[rt].sum += val;\n    if (cl == cr)\n        return;\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        upd(tree[rt].l, pos, val, cl, mid);\n    else\n        upd(tree[rt].r, pos, val, mid + 1, cr);\n    return;\n}\nvoid update(int realrt, int val)\n{\n    for (int i = realrt; i <= n; i += lowbit(i))\n    {\n        upd(root[i], a[realrt], val, 1, sz);\n    }\n}\nint query(vector<int> &rt1s, vector<int> &rt2s, int k, int cl, int cr)\n{\n    if (cl == cr)\n        return cl;\n    int mid = (cl + cr) >> 1;\n    int sums = 0;\n    for (auto j : rt2s)\n        sums += tree[tree[j].l].sum;\n    for (auto j : rt1s)\n        sums -= tree[tree[j].l].sum;\n    if (sums >= k)\n    {\n        for (auto &j : rt2s)\n            j = tree[j].l;\n        for (auto &j : rt1s)\n            j = tree[j].l;\n        return query(rt1s, rt2s, k, cl, mid);\n    }\n    else\n    {\n        for (auto &j : rt2s)\n            j = tree[j].r;\n        for (auto &j : rt1s)\n            j = tree[j].r;\n        return query(rt1s, rt2s, k - sums, mid + 1, cr);\n    }\n}\nint querykth(int l, int r, int k)\n{\n    vector<int> rt1, rt2;\n    for (int i = r; i; i -= lowbit(i))\n    {\n        rt2.push_back(root[i]);\n    }\n    for (int i = l - 1; i; i -= lowbit(i))\n    {\n        rt1.push_back(root[i]);\n    }\n    return query(rt1, rt2, k, 1, sz);\n}\n\nstruct qs\n{\n    int l, r, k;\n};\nstruct cs\n{\n    int pos, val;\n};\nsigned main()\n{\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        bs[++cnt] = a[i];\n    }\n    vector<tuple<char, qs, cs>> v(q + 1);\n    for (int i = 1; i <= q; i++)\n    {\n        char c;\n        cin >> c;\n        if (c == 'Q')\n        {\n            int l, r, k;\n            cin >> l >> r >> k;\n            v[i] = {c, {l, r, k}, {}};\n        }\n        else\n        {\n            int pos, val;\n            cin >> pos >> val;\n            bs[++cnt] = val;\n            v[i] = {c, {}, {pos, val}};\n        }\n    }\n    sort(bs + 1, bs + 1 + cnt);\n    sz = unique(bs + 1, bs + 1 + cnt) - bs - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = lower_bound(bs + 1, bs + 1 + sz, a[i]) - bs;\n        update(i, 1);\n    }\n    for (int i = 1; i <= q; i++)\n    {\n        auto [ch, qss, css] = v[i];\n        if (ch == 'Q')\n        {\n            cout << bs[querykth(qss.l, qss.r, qss.k)] << endl;\n        }\n        else\n        {\n            update(css.pos, -1);\n            a[css.pos] = lower_bound(bs + 1, bs + 1 + sz, css.val) - bs;\n            update(css.pos, 1);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.12.2 静态二维矩形第k小\n\n空间复杂度极高。看数据范围是否选择范围分治。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct node\n{\n    int l, r;\n    int sum;\n    int cnt;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 7];\nint tot = 0;\nconst int sz = 1009;\nint update(int rt, int pos, int cl, int cr)\n{\n    if (!rt)\n        rt = ++tot;\n    tree[rt].cnt++;\n    tree[rt].sum += pos;\n    if (cl == cr)\n    {\n        return rt;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        tree[rt].l = update(tree[rt].l, pos, cl, mid);\n    else\n        tree[rt].r = update(tree[rt].r, pos, mid + 1, cr);\n    return rt;\n}\nint querysum(int &rt, int l, int r, int cl, int cr)\n{\n    if (!rt)\n        return 0;\n    if (l <= cl && cr <= r)\n        return tree[rt].sum;\n    int mid = (cl + cr) >> 1;\n    int res = 0;\n    if (l <= mid)\n        res += querysum(tree[rt].l, l, r, cl, mid);\n    if (r > mid)\n        res += querysum(tree[rt].r, l, r, mid + 1, cr);\n    return res;\n}\nstruct Fenwick\n{\nprivate:\n    int n, m;\n    vector<vector<i64>> c;\n    int lowbit(int x) { return x & -x; }\n\npublic:\n    Fenwick(int n, int m) : n(n), m(m), c(n + 1, vector<i64>(m + 1, 0)) {}\n    Fenwick() : n(0), m(0) {}\n    void init(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        c.assign(n + 1, vector<i64>(m + 1, 0));\n    }\n    void add(int x, int y, i64 v)\n    {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = y; j <= m; j += lowbit(j))\n                c[i][j] = update(c[i][j], v, 1, sz);\n    }\n    vector<int> query(int x, int y)\n    {\n        vector<int> res;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = y; j; j -= lowbit(j))\n                res.push_back(c[i][j]);\n        return res;\n    }\n};\nint querysum(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[j].sum;\n    }\n    return sum;\n}\nint querycnt(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[j].cnt;\n    }\n    return sum;\n}\nint queryrcnt(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[tree[j].r].cnt;\n    }\n    return sum;\n}\nint queryrsum(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[tree[j].r].sum;\n    }\n    return sum;\n}\nvoid didl(vector<int> &rt)\n{\n    for (auto &j : rt)\n    {\n        j = tree[j].l;\n    }\n}\nvoid didr(vector<int> &rt)\n{\n    for (auto &j : rt)\n    {\n        j = tree[j].r;\n    }\n}\nint queryans(int h, int cl, int cr,\n             vector<int> &rt1, vector<int> &rt2, vector<int> &rt3, vector<int> &rt4, int cnts)\n{\n    if (cl == cr)\n    {\n        int sums = querysum(rt1) + querysum(rt4) - querysum(rt2) - querysum(rt3);\n        if (sums >= h)\n        {\n            int nowcnt = querycnt(rt1) + querycnt(rt4) - querycnt(rt2) - querycnt(rt3);\n            while (nowcnt && sums - cl >= h)\n                nowcnt--, sums -= cl;\n            return cnts + nowcnt;\n        }\n        return -1;\n    }\n    int mid = (cl + cr) >> 1;\n    int sum = queryrsum(rt1) + queryrsum(rt4) - queryrsum(rt2) - queryrsum(rt3);\n    int newcnt = queryrcnt(rt1) + queryrcnt(rt4) - queryrcnt(rt2) - queryrcnt(rt3);\n    if (sum >= h)\n    {\n        didr(rt1), didr(rt2), didr(rt3), didr(rt4);\n        return queryans(h, mid + 1, cr, rt1, rt2, rt3, rt4, cnts);\n    }\n    else\n    {\n        didl(rt1), didl(rt2), didl(rt3), didl(rt4);\n        return queryans(h - sum, cl, mid, rt1, rt2, rt3, rt4, cnts + newcnt);\n    }\n}\nFenwick fw;\nint queryfinal(int x1, int x2, int y1, int y2, int h)\n{\n    vector<int> rt1, rt2, rt3, rt4;\n    rt1 = fw.query(x1 - 1, y1 - 1);\n    rt2 = fw.query(x2, y1 - 1);\n    rt3 = fw.query(x1 - 1, y2);\n    rt4 = fw.query(x2, y2);\n    return queryans(h, 1, sz, rt1, rt2, rt3, rt4, 0);\n}\nsigned main()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    fw.init(n + 10, m + 10);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n        {\n            int x;\n            cin >> x;\n            fw.add(i, j, x);\n        }\n    while (k--)\n    {\n        int x1, x2, y1, y2, h;\n        cin >> x1 >> y1 >> x2 >> y2 >> h;\n        int ans = queryfinal(x1, x2, y1, y2, h);\n        if (ans > 0)\n            cout << ans << endl;\n        else\n            cout << \"Poor QLW\" << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.13 主席树可持久化数组\n\n维护这样的一个长度为 $ N $ 的数组，支持如下几种操作\n\n```\n1. 对于操作1，格式为$ v_i \\ 1 \\ {loc}_i \\ {value}_i $，即为在版本$ v_i $的基础上，将 $ a_{{loc}_i} $ 修改为 $ {value}_i $。\n\n2. 对于操作2，格式为$ v_i \\ 2 \\ {loc}_i $，即访问版本$ v_i $中的 $ a_{{loc}_i} $的值，注意：**生成一样版本的对象应为 $v_i$**。\n```\n此外，每进行一次操作（**对于操作2，即为生成一个完全一样的版本，不作任何改动**），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）\n\n***注意和主席树不一样的地方，merge函数不赋值（因为是把剩下未变动的部分直接merge过来），修改时先改再merge，查询时先merge再改***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 2e6 + 9;\nint tot = 0;\nint sz;\nstruct node\n{\n    int l, r;\n    int num;\n};\nnode tree[maxn << 5];\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0};\n    return tot;\n}\nvoid merge(int &rt1, int &rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n    {\n        rt1 |= rt2;\n        return;\n    }\n    if (cl == cr)\n    {\n        // tree[rt1].num = tree[rt2].num;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    return;\n}\nvoid update(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n        rt = newnode();\n    if (cl == cr)\n    {\n        tree[rt].num = val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(tree[rt].l, pos, val, cl, mid);\n    else\n        update(tree[rt].r, pos, val, mid + 1, cr);\n}\nint query(const int rt, int pos, int cl, int cr)\n{\n    if (!rt)\n        return 0;\n    if (cl == cr)\n    {\n        return tree[rt].num;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        return query(tree[rt].l, pos, cl, mid);\n    else\n        return query(tree[rt].r, pos, mid + 1, cr);\n}\nvoid printtree(int rt, int cl = 1, int cr = sz)\n{\n    if (!rt)\n    {\n        cout << 0 << endl;\n        return;\n    }\n    if (cl == cr)\n    {\n        cout << tree[rt].num << endl;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    printtree(tree[rt].l, cl, mid);\n    printtree(tree[rt].r, mid + 1, cr);\n}\nint root[maxn];\nint n, m;\nint ver = 0;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    sz = n;\n    for (int i = 1; i <= n; i++)\n    {\n        int val;\n        cin >> val;\n        update(root[0], i, val, 1, sz);\n    }\n    while (m--)\n    {\n        ver++;\n        int v, op, pos, val;\n        cin >> v >> op >> pos;\n        if (op == 1)\n        {\n            cin >> val;\n            update(root[ver], pos, val, 1, sz);\n            merge(root[ver], root[v], 1, sz);\n        }\n        else\n        {\n            merge(root[ver], root[v], 1, sz);\n            cout << query(root[ver], pos, 1, sz) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.14 主席树可持久化并查集\n\n给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。\n\n有 $m$ 次操作。操作分为 $3$ 种：\n\n - `1 a b` 合并 $a,b$ 所在集合；\n - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；\n - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。\n\n$n\\le 10^5,m\\le 10^5$\n\n只需注意一个点，路径压缩并查集复杂度是均摊的，恶劣情况下单次合并会是$O(n)$​的复杂度。所以要上按秩合并（启发式合并）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 2e5 + 9;\nstruct presistent_array\n{\n    int tot = 0;\n    int sz;\n    struct node\n    {\n        int l, r;\n        int num;\n    };\n    node tree[maxn << 5];\n    int newnode()\n    {\n        tot++;\n        tree[tot] = {0, 0, 0};\n        return tot;\n    }\n    void merge(int &rt1, int &rt2, int cl, int cr)\n    {\n        if (!rt1 || !rt2)\n        {\n            rt1 |= rt2;\n            return;\n        }\n        if (cl == cr)\n        {\n            // tree[rt1].num = tree[rt2].num;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        merge(tree[rt1].l, tree[rt2].l, cl, mid);\n        merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n        return;\n    }\n    void update(int &rt, int pos, int val, int cl, int cr)\n    {\n        if (!rt)\n            rt = newnode();\n        if (cl == cr)\n        {\n            tree[rt].num = val;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            update(tree[rt].l, pos, val, cl, mid);\n        else\n            update(tree[rt].r, pos, val, mid + 1, cr);\n    }\n    int query(const int rt, int pos, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (cl == cr)\n        {\n            return tree[rt].num;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            return query(tree[rt].l, pos, cl, mid);\n        else\n            return query(tree[rt].r, pos, mid + 1, cr);\n    }\n    void printtree(const int rt)\n    {\n        for (int i = 1; i <= sz; i++)\n        {\n            cout << query(rt, i, 1, sz) << \" \";\n        }\n        cout << endl;\n    }\n    int root[maxn];\n};\narray<int, 2> vers[maxn];\nint n, m;\nint ver = 0;\nint verfa = 0, versiz = 0;\npresistent_array fa, siz; // 开两个数组，直接就是可持久化数组封起来\nint getfather(int fart, int x)\n{\n    int getf = fa.query(fart, x, 1, n);\n    if (x == getf)\n        return x;\n    else\n        return getfather(fart, getf);\n}\nbool same(int fart, int u, int v)\n{\n    return getfather(fart, u) == getfather(fart, v);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    fa.sz = siz.sz = n;\n    vers[0] = {0, 0};\n    for (int i = 1; i <= n; i++)\n    {\n        fa.update(fa.root[vers[0][0]], i, i, 1, n);\n        siz.update(siz.root[vers[0][1]], i, 1, 1, n);\n    }\n    // fa.printtree(fa.root[0]);\n    // siz.printtree(siz.root[0]);\n    while (m--)\n    {\n        ver++;\n        vers[ver][0] = vers[ver][1] = ver;\n        int op, k;\n        cin >> op;\n        if (op == 2)\n        {\n            cin >> k;\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[k][0]], 1, n); // 版本回滚\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[k][1]], 1, n);\n        }\n        else if (op == 3)\n        {\n            int u, v;\n            cin >> u >> v;\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[ver - 1][0]], 1, n); // 版本复制\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[ver - 1][1]], 1, n);\n            cout << same(fa.root[vers[ver][0]], u, v) << endl;\n        }\n        else\n        {\n            int u, v;\n            cin >> u >> v;\n            u = getfather(fa.root[vers[ver - 1][0]], u);\n            v = getfather(fa.root[vers[ver - 1][0]], v);\n            if (u != v)\n            {\n                int szu = siz.query(siz.root[vers[ver - 1][1]], u, 1, n);\n                int szv = siz.query(siz.root[vers[ver - 1][1]], v, 1, n);\n                if (szu < szv)\n                {\n                    swap(szu, szv);\n                    swap(u, v);\n                }\n                fa.update(fa.root[vers[ver][0]], v, u, 1, n);           // fa[v]=u,小向大合并\n                siz.update(siz.root[vers[ver][1]], u, szu + szv, 1, n); // siz[u]+=sizv\n            }\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[ver - 1][0]], 1, n); // 先改再复制\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[ver - 1][1]], 1, n);\n        }\n        // fa.printtree(fa.root[vers[ver][0]]);\n        // siz.printtree(siz.root[vers[ver][1]]);\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.15 Li-Chao Tree\n\n要求在平面直角坐标系下维护两个操作：\n\n1. 在平面上加入一条线段。记第 $i$ 条被插入的线段的标号为 $i$。\n2. 给定一个数 $k$，询问与直线 $x = k$ 相交的线段中，交点纵坐标最大的线段的编号。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq k, x_0, x_1 \\leq 39989$，$1 \\leq y_0, y_1 \\leq 10^9$​。\n\n李超树可以优秀的维护平面内添加线性函数线段以及查询$max{f_i(x)}$，可用于斜率优化$dp$​等。不支持加入线段后删除，如有必要，考虑***线段树分治+李超树实现***。\n\n李超树的核心为$upd$函数，更新线段树***完整节点***区间内的信息。\n\n具体来说，设当前区间的中点为$mid$，我们拿新线段$f$在中点处的值与原最优线段$g$在中点处的值作比较。\n\n如果新线段$f$更优，则将$f$和$g$交换。那么现在考虑在中点处$f$不如$g$优的情况：\n\n1. 若在左端点处$f$更优，那么$f$和$g$必然在左半区间中产生了交点，$f$只有在左区间才可能优于 $g$，递归到左儿子中进行下传；\n2. 若在右端点处$f$更优，那么$f$和$g$必然在右半区间中产生了交点，$f$只有在右区间才可能优于 $g$，递归到右儿子中进行下传；\n3. 若在左右端点处$g$都更优，那么$f$不可能成为答案，不需要继续下传。\n\n除了这两种情况之外，还有一种情况是$f$和$g$刚好交于中点，在程序实现时可以归入中点处$f$不如$g$优的的情况，结果会往$f$更优的一个端点进行递归下传。\n\n最后将$g$作为当前区间的懒标记。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\n#define d64 long double\n// #define MOD1 39989\n#define MOD1 39989\n#define MOD2 1000000000\nconst int maxn = 2e5 + 5;\nstruct node\n{\n    // int l, r;\n    int bestcnt;\n} tree[maxn << 2LL];\nint n, m;\nint lastans = 0;\nint cnt = 0;\nstruct segments\n{\n    // int l, r;\n    d64 k, b;\n} segs[maxn];\nint cmp(d64 x, d64 y)\n{\n    if (x - y > 1e-9)\n        return 1;\n    if (y - x > 1e-9)\n        return -1;\n    return 0;\n}\nd64 calc(int id, int x)\n{\n    return segs[id].k * x + segs[id].b;\n}\nvoid add(int x0, int y0, int x1, int y1)\n{\n    cnt++;\n    if (x0 == x1)\n        segs[cnt].k = 0, segs[cnt].b = max(y0, y1);\n    else\n        segs[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), segs[cnt].b = y0 - segs[cnt].k * x0;\n}\nvoid upd(int now, int rt, int cl, int cr)\n{\n    int mid = (cl + cr) >> 1LL;\n    int &v = tree[rt].bestcnt;\n    int bmid = cmp(calc(now, mid), calc(v, mid));\n    if (bmid == 1 || (!bmid && now < v))\n        swap(now, v);\n    int bl = cmp(calc(now, cl), calc(v, cl)), br = cmp(calc(now, cr), calc(v, cr));\n    if (bl == 1 || (!bl && now < v))\n        upd(now, rt << 1LL, cl, mid);\n    if (br == 1 || (!br && now < v))\n        upd(now, rt << 1LL | 1LL, mid + 1, cr);\n    return;\n}\nvoid update(int now, int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        upd(now, rt, cl, cr);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (l <= mid)\n        update(now, l, r, rt << 1LL, cl, mid);\n    if (r > mid)\n        update(now, l, r, rt << 1LL | 1LL, mid + 1, cr);\n    return;\n}\npair<double, int> max(pair<double, int> a, pair<double, int> b)\n{\n    if (cmp(a.first, b.first) == 1)\n        return a;\n    if (cmp(a.first, b.first) == -1)\n        return b;\n    return a.second < b.second ? a : b;\n}\npair<double, int> query(int d, int rt, int cl, int cr)\n{\n    if (cr < d || cl > d)\n        return {0, 0};\n    int mid = (cl + cr) >> 1LL;\n    double res = calc(tree[rt].bestcnt, d);\n    if (cl == cr)\n        return {res, tree[rt].bestcnt};\n    return max({res, tree[rt].bestcnt}, max(query(d, rt << 1LL, cl, mid), query(d, rt << 1LL | 1LL, mid + 1, cr)));\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int opt;\n        cin >> opt;\n        if (opt == 1)\n        {\n            int l, r, a, b;\n            cin >> l >> a >> r >> b;\n            l = (l + lastans - 1) % MOD1 + 1;\n            r = (r + lastans - 1) % MOD1 + 1;\n            a = (a + lastans - 1) % MOD2 + 1;\n            b = (b + lastans - 1) % MOD2 + 1;\n            if (l > r)\n                swap(l, r), swap(a, b);\n            add(l, a, r, b);\n            update(cnt, l, r, 1, 1, MOD1);\n        }\n        else\n        {\n            int x;\n            cin >> x;\n            x = (x + lastans - 1) % MOD1 + 1;\n            pair<double, int> ans = query(x, 1, 1, MOD1);\n            cout << ans.second << endl;\n            lastans = ans.second;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.16 类Li-Chao Tree  /  递归区间合并\n\n思维，和李超树没有关系，在于两个区间合并`pushup`的时候比较困难，需要像李超树的`upd`一样递归处理的情况。\n\n```cpp\nvoid pushup1(int rt)\n{\n    tree[rt].maxn = max(tree[rt << 1].maxn, tree[rt << 1 | 1].maxn);\n}\nint pushup2(d32 tar, int rt, int cl, int cr)\n{\n    if (tree[rt].maxn <= tar)\n        return 0;\n    if (a[cl] > tar)\n        return tree[rt].len;\n    if (cl == cr)\n    {\n        return (a[cl] > tar);\n    }\n    int mid = (cl + cr) >> 1;\n    if (tree[rt << 1].maxn <= tar)\n        return pushup2(tar, rt << 1 | 1, mid + 1, cr);\n    return pushup2(tar, rt << 1, cl, mid) + tree[rt].len - tree[rt << 1].len;\n}\nvoid pushup(int rt, int cl, int cr)\n{\n    pushup1(rt);\n    int mid = (cl + cr) >> 1;\n    tree[rt].len = tree[rt << 1].len + pushup2(tree[rt << 1].maxn, rt << 1 | 1, mid + 1, cr);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.17 线段树分治\n\n假如你需要维护一些信息，这些信息会在某一个时间段内出现，要求在离线的前提下回答某一个时刻的信息并，则可以考虑使用线段树分治的技巧。\n\n实际上线段树分治常有以下用途：\n\n1. 用原本不支持删除但是支持撤销的数据结构来模拟删除操作。如朴素的并查集无法高效支持删边操作。\n2. 不同属性的数据分别计算。如需要求出除了某一种颜色外，其他颜色数据的答案。\n\n首先我们建立一个线段树来维护时刻，每一个节点维护一个 `vector` 来存储位于这一段时刻的信息。\n\n插入一个信息到线段树中和普通线段树的区间修改是类似的。\n\n然后我们考虑如何处理每一个时间段的信息并。考虑从根节点开始分治，维护当前的信息并，然后每到一个节点的时候将这个节点的所有信息进行合并。回溯时撤销这一部分的贡献。最后到达叶子节点时的信息并就是对应的答案。\n\n如果更改信息的时间复杂度为$O(T(n))$，可以通过设置一个栈保留更改，以$O(T(n))$的时间复杂度撤销。撤销不维持均摊复杂度。\n\n整个分治流程的总时间复杂度是$O(nlogn(T(n)+M(n)))$的，其中$O(M(n))$为合并信息的时间复杂度，空间复杂度为$O(nlogn)$​。\n\n并查集不嫌麻烦最好写可持久化，不用栈，速度还偏快一点,缺点是码量确实高，而且一旦抄错了不好DEBUG。***如果写普通并查集，必须写按秩合并，路径压缩因为均摊复杂度不被支持***。撤销时，直接通过栈所记录的`merge`前的信息直接复原即可。\n\n```cpp\n#define ls (i << 1)\n#define rs (i << 1 | 1)\n#define mid ((l + r) >> 1)\n\nvector<Object> tree[N << 2];  // 线段树\n\nvoid update(int ql, int qr, Object obj, int i, int l, int r) {  // 插入\n  if (ql <= l && r <= qr) {\n    tree[i].push_back(obj);\n    return;\n  }\n  if (ql <= mid) update(ql, qr, obj, ls, l, mid);\n  if (qr > mid) update(ql, qr, obj, rs, mid + 1, r);\n}\n\nstack<Object> sta;  // 用于撤销的栈\nObject now;         // 当前的信息并\nObject ans[N];      // 答案\n\nvoid solve(int i, int l, int r) {\n  auto lvl = sta.size();  // 记录一下应当撤销到第几个\n  for (Object x : tree[i]) sta.push(now), now = Merge(now, x);  // 合并信息\n  if (l == r)\n    ans[i] = now;  // 记录一下答案\n  else\n    solve(ls, l, mid), solve(rs, mid + 1, r);  // 分治\n  while (sta.size() != lvl) {                  // 撤销信息\n    now = sta.top();\n    sta.pop();\n  }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.18 线段树维护最大子段和\n\n线段树结点维护区间最值，区间前缀和最值，区间后缀和最值，区间$op$​​的时候比较一下两个区间的区间最大子段和以及前段后缀+后段前缀的和即可。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nconst int maxn = 5e5 + 9;\nstruct segtree\n{\n    struct node\n    {\n        i64 sum, pre, suf, maxans;\n    };\n    node tree[maxn << 2];\n    i64 a[maxn];\n    void pushup(int rt)\n    {\n        int lson = rt << 1, rson = rt << 1 | 1;\n        i64 interval = tree[lson].suf + tree[rson].pre;\n        tree[rt].sum = tree[lson].sum + tree[rson].sum;\n        tree[rt].pre = max(tree[lson].pre, tree[lson].sum + tree[rson].pre);\n        tree[rt].suf = max(tree[rson].suf, tree[rson].sum + tree[lson].suf);\n        tree[rt].maxans = max(max(tree[lson].maxans, tree[rson].maxans), interval);\n        return;\n    }\n    void build(int rt, int cl, int cr)\n    {\n        if (cl == cr)\n        {\n            tree[rt].sum = tree[rt].pre = tree[rt].suf = tree[rt].maxans = a[cl];\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        build(rt << 1, cl, mid);\n        build(rt << 1 | 1, mid + 1, cr);\n        pushup(rt);\n        return;\n    }\n    void modify(int pos, int val, int rt, int cl, int cr)\n    {\n        if (cl == cr)\n        {\n            tree[rt].sum = tree[rt].pre = tree[rt].suf = tree[rt].maxans = val;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            modify(pos, val, rt << 1, cl, mid);\n        else\n            modify(pos, val, rt << 1 | 1, mid + 1, cr);\n        pushup(rt);\n        return;\n    }\n    node query(int l, int r, int rt, int cl, int cr)\n    {\n        if (l <= cl && cr <= r)\n        {\n            return tree[rt];\n        }\n        int mid = (cl + cr) >> 1;\n        if (r <= mid)\n            return query(l, r, rt << 1, cl, mid);\n        if (l > mid)\n            return query(l, r, rt << 1 | 1, mid + 1, cr);\n        node lson = query(l, r, rt << 1, cl, mid);\n        node rson = query(l, r, rt << 1 | 1, mid + 1, cr);\n        node ret;\n        i64 interval = lson.suf + rson.pre;\n        ret.sum = lson.sum + rson.sum;\n        ret.pre = max(lson.pre, lson.sum + rson.pre);\n        ret.suf = max(rson.suf, rson.sum + lson.suf);\n        ret.maxans = max(max(lson.maxans, rson.maxans), interval);\n        return ret;\n    }\n};\nsegtree seg;\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> seg.a[i];\n    }\n    seg.build(1, 1, n);\n    for (int i = 1; i <= m; i++)\n    {\n        int op, x, y;\n        cin >> op >> x >> y;\n        if (op == 1)\n        {\n            if (x > y)\n                swap(x, y);\n            cout << seg.query(x, y, 1, 1, n).maxans << endl;\n        }\n        else\n        {\n            seg.modify(x, y, 1, 1, n);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.19 权值树维护区间有多少个不同的数\n\n$HH$的项链，碰到相同的数就把前面那个出现的位置删掉（权值树-1），后面新出现的位置加上（权值树+1）\n\n这玩意儿没求前缀和，不能算主席树。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n        x = x * 10 + ch - '0', ch = getchar();\n    return x * f;\n}\nvoid write(int x)\n{\n    if (x < 0)\n        putchar('-'), x = -x;\n    if (x > 9)\n        write(x / 10);\n    putchar(x % 10 + '0');\n    return;\n}\nstruct Persistant_segtree\n{\nprivate:\n    struct node\n    {\n        int l = 0, r = 0;\n        int sum = 0;\n    };\n    vector<node> tree;\n    int tot;\n    int n;\n\npublic:\n    Persistant_segtree(int n) : n(n), tot(0)\n    {\n        tree.assign((n << 5) + 9, node());\n    }\n    Persistant_segtree() : n(0), tot(0)\n    {\n        tree.clear();\n    }\n    void init(int n)\n    {\n        this->n = n;\n        tot = 0;\n        tree = vector<node>((n << 5) + 9);\n    }\n    void update(int &rt1, int rt2, int pos, int val, int cl, int cr)\n    {\n        if (!rt1)\n            rt1 = ++tot;\n        tree[rt1].sum = tree[rt2].sum + val;\n        if (cl == cr)\n        {\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            update(tree[rt1].l, tree[rt2].l, pos, val, cl, mid), tree[rt1].r = tree[rt2].r;\n        else\n            update(tree[rt1].r, tree[rt2].r, pos, val, mid + 1, cr), tree[rt1].l = tree[rt2].l;\n    }\n    int query(int &rt, int l, int r, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (l <= cl && cr <= r)\n            return tree[rt].sum;\n        int mid = (cl + cr) >> 1;\n        int res = 0;\n        if (l <= mid)\n            res += query(tree[rt].l, l, r, cl, mid);\n        if (r > mid)\n            res += query(tree[rt].r, l, r, mid + 1, cr);\n        return res;\n    }\n};\nPersistant_segtree pst;\nconst int maxn = 1e6 + 9;\nint a[maxn], lastpos[maxn], root[maxn];\n#define endl '\\n'\nint main()\n{\n    int n, m;\n    n = read();\n    pst.init(maxn);\n    for (int i = 1; i <= n; i++)\n        a[i] = read();\n    for (int i = 1; i <= n; i++)\n    {\n        if (lastpos[a[i]])\n        {\n            pst.update(root[i], root[i - 1], lastpos[a[i]], -1, 1, n);\n            pst.update(root[i], root[i], i, 1, 1, n);\n            lastpos[a[i]] = i;\n        }\n        else\n        {\n            pst.update(root[i], root[i - 1], i, 1, 1, n);\n            lastpos[a[i]] = i;\n        }\n    }\n    m = read();\n    while (m--)\n    {\n        int l, r;\n        l = read(), r = read();\n        write(pst.query(root[r], l, r, 1, n));\n        putchar(endl);\n    }\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.20  线段树优化建图\n\n通过线段树区间的性质实现线段树区间连边建图。需要注意的是，从区间连出需要走出树，向区间连入需要走入树，必须保证建立两棵树，出树向根有向边$(sons\\to fa)$，入树从根向下有向边$(fa\\to sons)$，不可以串行。叶子结点两棵树倒是可以共享，不共享的话叶子结点要做好无向边联通，详情见示例。\n\n<img src=\"https://oi-wiki.org/ds/images/segt6.svg\" alt=\"出树\" style=\"zoom:50%;\" />\n\n<img src=\"https://oi-wiki.org/ds/images/segt5.svg\" alt=\"入树\" style=\"zoom:50%;\" />\n\n有$n$个点、$q$次操作。每一种操作为以下三种类型中的一种:\n\n1. 连一条$u→v$的有向边,权值为$w$。\n2. 对于所有$i∈[l,r]$连一条$u→i$的有向边,权值为$ω$。\n3. 对于所有$i∈[l,r]$连一条$i→u$的有向边,权值为$ω$。\n\n求从点$s$到其他点的最短路。\n\n$1≤n,q≤10^5,1≤w≤10^9$​。\n\n```cpp\n// 线段树优化建图\n// 区间对区间连边，区间对单点连边，单点对区间连边\n// 显然的，需要动态开点线段树，建立的虚点参与跑最短路\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF = 1e18;\nint tottree = 0, cnt = 0;\nint root1 = 0, root2 = 0;\nint n;\nconst int maxn = 4e5 + 9;\nint head[maxn << 3LL], to[maxn << 3LL], nxt[maxn << 3LL], w[maxn << 3LL];\nint rtnum1[maxn], rtnum2[maxn];\nstruct node\n{\n    int l, r;\n    int cl, cr;\n};\nnode tree[maxn << 3LL];\nvoid add_edge(int u, int v, int w)\n{\n    to[++cnt] = v;\n    ::w[cnt] = w;\n    nxt[cnt] = head[u];\n    head[u] = cnt;\n}\nvoid build1(int &rt, int cl = 1, int cr = n) // 出树，区间连出\n{\n    if (!rt)\n        rt = ++tottree;\n    tree[rt].cl = cl;\n    tree[rt].cr = cr;\n    if (cl == cr)\n    {\n        rtnum1[cl] = rt;\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    build1(tree[rt].l, cl, mid);\n    build1(tree[rt].r, mid + 1, cr);\n    add_edge(tree[rt].l, rt, 0);\n    add_edge(tree[rt].r, rt, 0);\n    return;\n}\nvoid build2(int &rt, int cl = 1, int cr = n) // 入树，区间连入\n{\n    if (!rt)\n        rt = ++tottree;\n    tree[rt].cl = cl;\n    tree[rt].cr = cr;\n    if (cl == cr)\n    {\n        rtnum2[cl] = rt;\n        add_edge(rt, rtnum1[cl], 0);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    build2(tree[rt].l, cl, mid);\n    build2(tree[rt].r, mid + 1, cr);\n    add_edge(rt, tree[rt].l, 0);\n    add_edge(rt, tree[rt].r, 0);\n    return;\n}\nvoid update1(int &rt, int u, int vl, int vr, int w, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (vl <= cl && cr <= vr)\n    {\n        add_edge(rtnum1[u], rt, w);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (vl <= mid)\n        update1(tree[rt].l, u, vl, vr, w, cl, mid);\n    if (vr > mid)\n        update1(tree[rt].r, u, vl, vr, w, mid + 1, cr);\n}\nvoid update2(int &rt, int v, int ul, int ur, int w, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (ul <= cl && cr <= ur)\n    {\n        add_edge(rt, rtnum2[v], w);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (ul <= mid)\n        update2(tree[rt].l, v, ul, ur, w, cl, mid);\n    if (ur > mid)\n        update2(tree[rt].r, v, ul, ur, w, mid + 1, cr);\n}\nint dist[maxn << 3LL];\nbool vis[maxn << 3LL];\nvoid updist(int &rt, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (cl == cr)\n        return;\n    int mid = (cl + cr) >> 1LL;\n    dist[tree[rt].l] = min(dist[rt], dist[tree[rt].l]);\n    dist[tree[rt].r] = min(dist[rt], dist[tree[rt].r]);\n    updist(tree[rt].l, cl, mid);\n    updist(tree[rt].r, mid + 1, cr);\n    return;\n}\nvoid dijkstra(int s)\n{\n    // memset(dist, 0x3f3f3f3f, sizeof(int) * (tottree + 10));\n    for (int i = 1; i <= tottree + 10; i++)\n        dist[i] = INF, vis[i] = 0;\n    struct qu\n    {\n        int dis, pos;\n        bool operator<(const qu &x) const\n        {\n            return x.dis < dis;\n        }\n    };\n    priority_queue<qu> q;\n    dist[rtnum1[s]] = 0;\n    q.push({0, rtnum1[s]});\n    while (!q.empty())\n    {\n        auto [disu, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (int i = head[u]; i; i = nxt[i])\n        {\n            int v = to[i];\n            if (dist[v] > dist[u] + w[i])\n            {\n                dist[v] = dist[u] + w[i];\n                q.push({dist[v], v});\n            }\n        }\n    }\n    // updist(root);\n    return;\n}\nvoid clear()\n{\n    memset(head, 0, sizeof(int) * (tottree + 10));\n    cnt = 0, tottree = 0;\n    root1 = 0, root2 = 0;\n    return;\n}\nvoid solve()\n{\n    int q, s;\n    cin >> n >> q >> s;\n    build1(root1);\n    build2(root2);\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        int u, v, w, l, r;\n        switch (op)\n        {\n        case 1:\n            cin >> u >> v >> w;\n            add_edge(rtnum1[u], rtnum2[v], w);\n            break;\n        case 2:\n            cin >> u >> l >> r >> w;\n            update1(root2, u, l, r, w);\n            break;\n        case 3:\n            cin >> v >> l >> r >> w;\n            update2(root1, v, l, r, w);\n            break;\n        }\n    }\n    dijkstra(s);\n    for (int i = 1; i <= n; i++)\n    {\n        if (i == s)\n        {\n            cout << \"0 \";\n            continue;\n        }\n        if (dist[rtnum2[i]] == INF)\n            cout << \"-1 \";\n        else\n            cout << dist[rtnum2[i]] << \" \";\n    }\n    cout << endl;\n    clear();\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *1.21 吉司机线段树\n\n线段树维护区间最值操作与区间历史最值的模板。\n\n给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：\n\n- `1 l r k`：对于所有的 $i\\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。\n- `2 l r v`：对于所有的 $i\\in[l,r]$，将 $A_i$ 变成 $\\min(A_i,v)$。\n- `3 l r`：求 $\\sum_{i=l}^{r}A_i$。\n- `4 l r`：对于所有的 $i\\in[l,r]$，求 $A_i$ 的最大值。\n- `5 l r`：对于所有的 $i\\in[l,r]$，求 $B_i$ 的最大值。\n\n在每一次操作后，我们都进行一次更新，让 $B_i\\gets\\max(B_i,A_i)$。\n\n保证 $1\\leq n,m\\leq 5\\times 10^5$,$-5\\times10^8\\leq A_i\\leq 5\\times10^8$,\n\n$op\\in[1,5]$,$1 \\leq l\\leq r \\leq n$,$-2000\\leq k\\leq 2000$,\n\n$-5\\times10^8\\leq v\\leq 5\\times10^8$​​。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*o=obuf;\n#define g()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ninline int read()\n{\n    int s=0,f=1;char c=g();\n    for(;!isdigit(c);c=g())\n        if(c=='-')f=-1;\n    for(;isdigit(c);c=g())\n        s=s*10+c-'0';\n    return s*f;\n}\ninline void write(ll x)\n{\n    static char buf[20];\n    static int len=-1;\n    if(x<0)putchar('-'),x=-x;\n    do buf[++len]=x%10,x/=10;while(x);\n    while(len>=0)putchar(buf[len--]+'0');\n    putchar('\\n');\n}\nint n,m,op,l,r,k,v;\nstruct segment_tree{\n    ll sum;\n    int l,r,maxa,cnt,se,maxb;\n    int add1,add2,add3,add4;\n}s[2000005];\ninline void push_up(int p)\n{\n    s[p].sum=s[p*2].sum+s[p*2+1].sum;\n    s[p].maxa=max(s[p*2].maxa,s[p*2+1].maxa);\n    s[p].maxb=max(s[p*2].maxb,s[p*2+1].maxb);\n    if(s[p*2].maxa==s[p*2+1].maxa)\n    {\n        s[p].se=max(s[p*2].se,s[p*2+1].se);\n        s[p].cnt=s[p*2].cnt+s[p*2+1].cnt;\n    }\n    else if(s[p*2].maxa>s[p*2+1].maxa)\n    {\n        s[p].se=max(s[p*2].se,s[p*2+1].maxa);\n        s[p].cnt=s[p*2].cnt;\n    }\n    else\n    {\n        s[p].se=max(s[p*2].maxa,s[p*2+1].se);\n        s[p].cnt=s[p*2+1].cnt;\n    }\n}\nvoid build(int l,int r,int p)\n{\n    s[p].l=l,s[p].r=r;\n    if(l==r)\n    {\n        s[p].sum=s[p].maxa=s[p].maxb=read();\n        s[p].cnt=1,s[p].se=-2e9;\n        return;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,p*2);\n    build(mid+1,r,p*2+1);\n    push_up(p);\n}\ninline void change(int k1,int k2,int k3,int k4,int p)\n{\n    s[p].sum+=1ll*k1*s[p].cnt+1ll*k2*(s[p].r-s[p].l+1-s[p].cnt);\n    s[p].maxb=max(s[p].maxb,s[p].maxa+k3);\n    s[p].maxa+=k1;\n    if(s[p].se!=-2e9)s[p].se+=k2;\n    s[p].add3=max(s[p].add3,s[p].add1+k3);\n    s[p].add4=max(s[p].add4,s[p].add2+k4);\n    s[p].add1+=k1,s[p].add2+=k2;\n}\ninline void push_down(int p)\n{\n    int maxn=max(s[p*2].maxa,s[p*2+1].maxa);\n    if(s[p*2].maxa==maxn)\n        change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2);\n    else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2);\n    if(s[p*2+1].maxa==maxn)\n        change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2+1);\n    else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2+1);\n    s[p].add1=s[p].add2=s[p].add3=s[p].add4=0;\n}\nvoid update_add(int p)\n{\n    if(l>s[p].r||r<s[p].l)return;\n    if(l<=s[p].l&&s[p].r<=r)\n    {\t\n        s[p].sum+=1ll*k*s[p].cnt+1ll*k*(s[p].r-s[p].l+1-s[p].cnt);\n        s[p].maxa+=k;\n        s[p].maxb=max(s[p].maxb,s[p].maxa);\n        if(s[p].se!=-2e9)s[p].se+=k;\n        s[p].add1+=k,s[p].add2+=k;\n        s[p].add3=max(s[p].add3,s[p].add1);\n        s[p].add4=max(s[p].add4,s[p].add2);\n        return;\n    }\n    push_down(p);\n    update_add(p*2),update_add(p*2+1);\n    push_up(p);\n}\nvoid update_min(int p)\n{\n    if(l>s[p].r||r<s[p].l||v>=s[p].maxa)return;\n    if(l<=s[p].l&&s[p].r<=r&&s[p].se<v)\n    {\n        int k=s[p].maxa-v;\n        s[p].sum-=1ll*s[p].cnt*k;\n        s[p].maxa=v,s[p].add1-=k;\n        return;\n    }\n    push_down(p);\n    update_min(p*2),update_min(p*2+1);\n    push_up(p);\n}\nll query_sum(int p)\n{\n    if(l>s[p].r||r<s[p].l)return 0;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].sum;\n    push_down(p);\n    return query_sum(p*2)+query_sum(p*2+1);\n}\nint query_maxa(int p)\n{\n    if(l>s[p].r||r<s[p].l)return -2e9;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].maxa;\n    push_down(p);\n    return max(query_maxa(p*2),query_maxa(p*2+1));\n}\nint query_maxb(int p)\n{\n    if(l>s[p].r||r<s[p].l)return -2e9;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].maxb;\n    push_down(p);\n    return max(query_maxb(p*2),query_maxb(p*2+1));\n}\nint main()\n{\n    n=read(),m=read();\n    build(1,n,1);\n    while(m--)\n    {\n        op=read(),l=read(),r=read();\n        if(op==1)k=read(),update_add(1);\n        else if(op==2)v=read(),update_min(1);\n        else if(op==3)write(query_sum(1));\n        else if(op==4)printf(\"%d\\n\",query_maxa(1));\n        else printf(\"%d\\n\",query_maxb(1));\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *1.22 树上数据结构警示（树上线段树）\n\n一般而言，树上数据结构主要是树上权值树以及树上动态开点线段树。这里提及两个**需要注意的点**\n\n1. 主席树/线段树合并写法的$merge$函数在向父节点合并的时候会有拷贝节点（主席树原理），**如果有多个儿子节点，这种行为会导致父节点信息合并完全之后，子节点的主席树信息被污染。**如果要这么做，涉及到子树信息查询，需要合并dfs的同时进行离线处理，保证污染之后不再查询。\n\n   解决方法是树链剖分，尤其是子树信息维护，更是树剖为重中之重。\n\n   树上差分不会因为这个受影响的原因在于，树上差分的信息合并是父节点向子节点合并，子节点继承父节点的信息以记录**从自己直到根**路径上的所有数信息，子节点只有一个父节点可以继承，意味着父节点的信息不会被污染。\n\n   （ABC239E 树上子树第$K$​大因为这个问题导致WA）\n\n2. 树上合并，**一定检查有没有写**`cl==cr`里面的$\\color{red}return$\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.堆(Heap)\n\n关键词：有序序列，只关心最值\n\n### 2.1 可并堆（左偏树）\n\n定义左偏树中左儿子结点的$dist_l$一定大于等于右儿子节点的$dist_r$.\n\n定义某节点$u$的$dist_u$为其到$u$​​所在子树中最近的外节点（没有左儿子或者右儿子）的距离。\n\n一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：\n\n1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在同一个堆内，则无视此操作）。\n\n2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$​ 并无视删除操作）。\n\n***注意，这个题需要查某个数在哪个堆，需要并查集，而且因为路径压缩的不成样子，但凡涉及到弹出堆顶，必须连被删除元素一起调整而不是将删除元素简简单单的 fa 归0就可以。***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct heap\n{\n    int dis, l, r, fa, val;\n};\nconst int maxn = 1e5 + 9;\nheap tr[maxn << 5];\nint n, m;\nint getfather(int x)\n{\n    return tr[x].fa == x ? x : tr[x].fa = getfather(tr[x].fa);\n}\nint merge(int x, int y)\n{\n    if (!x || !y)\n        return x | y;\n    if (tr[x].val > tr[y].val)\n        swap(x, y);\n    tr[x].r = merge(tr[x].r, y);\n    if (tr[tr[x].l].dis < tr[tr[x].r].dis)\n        swap(tr[x].l, tr[x].r);\n    tr[x].dis = tr[tr[x].r].dis + 1;\n    tr[tr[x].l].fa = tr[tr[x].r].fa = tr[x].fa = x;\n    return x;\n}\nint pop(int x)\n{\n    tr[x].val = -1;\n    tr[tr[x].l].fa = tr[x].l;\n    tr[tr[x].r].fa = tr[x].r;\n    tr[x].fa = merge(tr[x].l, tr[x].r);\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i)\n        tr[i].fa = i, cin >> tr[i].val;\n    int t, x, y;\n    for (int i = 1; i <= m; ++i)\n    {\n        cin >> t >> x;\n        if (t == 1)\n        {\n            cin >> y;\n            if (tr[x].val == -1 || tr[y].val == -1)\n                continue;\n            int l = getfather(x), r = getfather(y);\n            if (l != r)\n                tr[l].fa = tr[r].fa = merge(l, r);\n        }\n        else\n        {\n            if (tr[x].val == -1)\n                cout << -1 << endl;\n            else\n                cout << tr[getfather(x)].val << endl, pop(getfather(x));\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 带懒标记左偏树\n\n像动态开点线段树一样，合并时注意标记下传问题\n\n```cpp\nstruct node\n{\n    int dis, val; int ch[2]; int fa; int lazyadd = 0, lazymul = 1;\n    int id; int cnt; int lazyc = 0;\n};\nint &rs(int rt) {return tree[rt].ch[tree[tree[rt].ch[0]].dis > tree[tree[rt].ch[1]].dis];/*注意rs写法*/}\nint &ls(int rt) {return tree[rt].ch[1 ^ (tree[tree[rt].ch[0]].dis > tree[tree[rt].ch[1]].dis)];/*更注意ls写法*/}\nint &dis(int rt) {return tree[rt].dis;}\nint &val(int rt) {return tree[rt].val;}\nint &fa(int rt) {return tree[rt].fa;}\nint &lazyadd(int rt) {return tree[rt].lazyadd;}\nint &lazymul(int rt) {return tree[rt].lazymul;}\nint &lazyc(int rt) {return tree[rt].lazyc;}\nint &vcnt(int rt) {return tree[rt].cnt;}\nint &id(int rt) {return tree[rt].id;}\nvoid pushdown(int rt)\n{\n    if (!rt)\n        return;\n    if (lazyadd(rt) != 0 || lazymul(rt) != 1 || lazyc(rt) != 0)\n    {\n        if (ls(rt))\n        {\n            val(ls(rt)) = val(ls(rt)) * lazymul(rt) + lazyadd(rt);\n            vcnt(ls(rt)) += lazyc(rt);\n            lazymul(ls(rt)) *= lazymul(rt);\n            lazyadd(ls(rt)) = lazyadd(ls(rt)) * lazymul(rt) + lazyadd(rt);\n            lazyc(ls(rt)) += lazyc(rt);\n        }\n        if (rs(rt))\n        {\n            val(rs(rt)) = val(rs(rt)) * lazymul(rt) + lazyadd(rt);\n            vcnt(rs(rt)) += lazyc(rt);\n            lazymul(rs(rt)) *= lazymul(rt);\n            lazyadd(rs(rt)) = lazyadd(rs(rt)) * lazymul(rt) + lazyadd(rt);\n            lazyc(rs(rt)) += lazyc(rt);\n        }\n        lazyadd(rt) = 0;\n        lazymul(rt) = 1;\n        lazyc(rt) = 0;\n    }\n    return;\n}\nint merge(int rt1, int rt2)\n{\n    if (!rt1 || !rt2)\n        return rt1 | rt2;\n    if (val(rt1) > val(rt2))\n        swap(rt1, rt2);\n    pushdown(rt1);\n    int &r = rs(rt1);\n    r = merge(r, rt2);\n    fa(r) = rt1;\n    dis(rt1) = dis(rs(rt1)) + 1; // 严禁使用pushup于此，pushup只用于删除任意非根节点时使用，删除根节点要pop\n    return rt1;\n}\nint pop(int rt1)\n{\n    pushdown(rt1);\n    return merge(ls(rt1), rs(rt1));\n}\nint tot = 0;\nint push(int rt1, int val, int id)\n{\n    tree[++tot].val = val;\n    tree[tot].id = id;\n    return merge(rt1, tot);\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *2.3 支持删除任意节点可并堆\n\n没有专门的题，有涉及到可并堆删对应节点的理论上主席树都可以做，而且复杂度是一样的，优先写自己顺手的。\n\n这里是OI-wiki的\n\n```cpp\nvoid erase(int x) {\n  int y = merge(ls(x), rs(x));\n  fa(y) = fa(x);\n  if (ls(fa(x)) == x)\n    ls(fa(x)) = y;\n  else if (rs(fa(x)) == x)\n    rs(fa(x)) = y;\n  pushup(fa(y));\n}\n```\n\n### *2.4 GNU/GCC pb_ds库\n\n`pb_ds`库提供了五种可并堆，默认大根堆，`greater`标签使用和普通$STL$一致。\n\n```cpp\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n__gnu_pbds::priority_queue<int>q;//因为放置和std重复，故需要带上命名空间\n__gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> q;//最快\n__gnu_pbds::priority_queue<int,greater<int>,binary_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,binomial_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,rc_binomial_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,thin_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int> > q;\n```\n\n`pairing_heap_tag` : `push`和`join`为$O(1)$,其余为均摊$O(logn)$。\n\n`binary_heap_tag`:只支持`push`和`pop`,均为均摊$O(logn)$。\n\n`binomial_heap_tag`:`push`为均摊$O(1)$,其余为$O(logn)$。\n\n`rc_binomial_heap_tag`: `push`为$O(1)$,其余为$O(logn)$。\n\n`thin_heap_tag`: `push`为$O(1)$,不支持`join`,其余为$O(logn)$;但是如果只有`increase_key`,那么`modify`为均摊$O(1)$​。“不支持”不是不能用,而是用起来很慢\n\n操作表：\n\n- `size()`用法同std\n\n- `empty()`用法同std\n\n- `push(const_reference r_val)`注意`push`返回`point_iterator`，被`push`元素入堆后位置\n\n- `top()`没区别…\n\n- `pop()`弹出堆顶\n\n- `point_iterator`对应某元素的迭代器\n\n- `erase(point_iterator it)`删除对应点\n\n- `modify(point_iterator it,const_reference r_new_val)`修改对应点的值\n\n  这是优化$dijkstra$神方法,均摊复杂度$O(1)$​\n\n  优化$dijkstra$的思路就是在前面提到的$std$优先队列优化的基础上,维护一个`point_iterator`数组,`push`的时候存下`push`时返回的迭代器,更新`dis`是判断是否存在此迭代器,若存在$O(1)$`modify`,不存在均摊$O(1)$`push`\n\n- `clear()`基本没什么用,还不如重新定义一个…\n\n- `join(priority_queue &other)`可并堆啊,还是$O(1)$的,注意合并后`other`会被清空\n\n- 其他迭代器同std\n\n使用示例：\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n#define int long long\nusing mergeable_priority_queue = __gnu_pbds::priority_queue<int, less<int>, __gnu_pbds::pairing_heap_tag>;\nconst int maxn = 2e5 + 9;\nint ans = 0;\nvector<int> connects[maxn];\nmergeable_priority_queue qs[maxn];\nint sum[maxn];\nint L[maxn];\nint n, m;\nvoid dfs(int u, int fa)\n{\n    for (auto v : connects[u])\n    {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n        qs[u].join(qs[v]);\n        sum[u] += sum[v];\n    }\n    while (!qs[u].empty() && sum[u] > m)\n    {\n        sum[u] -= qs[u].top();\n        qs[u].pop();\n    }\n    ans = max(ans, (int)(qs[u].size()) * L[u]);\n    return;\n}\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        int fa, c, l;\n        cin >> fa >> c >> l;\n        qs[i].push(c);\n        sum[i] += c, L[i] = l;\n        connects[fa].push_back(i);\n        connects[i].push_back(fa);\n    }\n    dfs(0, 0);\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 3.ST表（Sparse Table）\n\n关键词：静态区间，可重复贡献\n\n稀疏表，倍增，可以解决可重复贡献问题：\n\n代数系统$<S,\\cdot >$满足以下条件：\n\n1. 该代数系统为半群。\n2. 对于$\\forall x\\in S,x\\cdot x=x$​（可重复贡献）\n\n除 RMQ 以外，还有其它的「可重复贡献问题」。例如「区间按位与」、「区间按位或」、「区间 GCD」，ST 表都能高效地解决。\n\n如果碰到恶心的卡内存的，考虑ST表存对应答案在原数组的下标，节省空间。\n\n### 3.1 静态区间最值，一维ST表\n\n```cpp\n// ST表，静态区间最大值\n#include <bits/stdc++.h>\nusing namespace std;\nint getlog(int n)\n{\n    int ans = 0;\n    while (n)\n    {\n        n >>= 1;\n        ans++;\n    }\n    return ans - 1;\n}\nconst int maxn = 5e5 + 10;\nint st[maxn][20];\n#define endl '\\n'\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    int logn = getlog(n);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> st[i][0];\n    }\n    for (int j = 1; j <= logn; j++)\n    {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        {\n            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n    while (q--)\n    {\n        int l, r;\n        cin >> l >> r;\n        int dis = r - l + 1;\n        int k = getlog(dis);\n        cout << max(st[l][k], st[r - (1 << k) + 1][k]) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.2 静态区间最值，二维ST表\n\n类比一维$ST$ 表，我们定义数组$st[i][j][k][p]$表示从$(i,j)$往下$2^k$个元素，往右$2^p$个元素的最值。\n\n建表的话，同样类比一维$ST$表，外层两个循环$k$ 和$p$ , 然后内层取最值就行了。要注意的是，$k$ 和$p$要从$0$​开始循环，因为一行或者一列的情况也要维护。\n\n复杂度$O(n^2log^2n)$\n\n```cpp\nvoid build_st()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            if (i == 0 && j == 0)\n                continue;\n            for (int k = 1; k <= n - (1 << i) + 1; k++)\n            {\n                for (int p = 1; p <= n - (1 << j) + 1; p++)\n                {\n                    if (i == 0)\n                        st[k][p][i][j] = min(st[k][p][i][j - 1], st[k][p + (1 << j - 1)][i][j - 1]);\n                    else\n                        st[k][p][i][j] = min(st[k][p][i - 1][j], st[k + (1 << i - 1)][p][i - 1][j]);\n                }\n            }\n        }\n    }\n}\n\nint query(int r1, int c1, int r2, int c2)\n{\n    int k1 = log2(r2 - r1 + 1);\n    int k2 = log2(c2 - c1 + 1);\n    return min(st[r1][c1][k1][k2], min(st[r2 - (1 << k1) + 1][c1][k1][k2], min(st[r1][c2 - (1 << k2) + 1][k1][k2], st[r2 - (1 << k1) + 1][c2 - (1 << k2) + 1][k1][k2])));\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.3 倍增ST表求解LCA问题\n\n倍增优化求$LCA$，$dfs$预处理祖先信息，然后查询时先跳到同一高度，再一起暴力向上跳。暴力向上跳必须从大向小枚举。预处理$O(nlogn)$，单次查询$O(n)$.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 9;\nvector<int> connects[maxn];\nint fa[maxn][21];\nint dep[maxn];\ninline void dfs(int u, int fas)\n{\n    dep[u] = dep[fas] + 1;\n    fa[u][0] = fas;\n    for (int j = 1; j <= 20; j++)\n    {\n        fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    }\n    for (auto v : connects[u])\n    {\n        if (v == fas)\n            continue;\n        dfs(v, u);\n    }\n    return;\n}\ninline int lca(int u, int v)\n{\n    if (dep[u] < dep[v])\n        swap(u, v);\n    int tmp = dep[u] - dep[v];\n    for (int j = 0; j <= 20; j++)\n    {\n        if ((tmp >> j) & 1)\n            u = fa[u][j];\n    }\n    if (u == v)\n        return u;\n    for (int j = 20; j >= 0; j--)\n    {\t\t\n        if (fa[u][j] != fa[v][j])\n        {\n            u = fa[u][j], v = fa[v][j];\n        }\n    }\n    return fa[u][0];\n}\nint main()\n{\n    int n, m, rt;\n    cin >> n >> m >> rt;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        connects[u].push_back(v);\n        connects[v].push_back(u);\n    }\n    dfs(rt, rt);\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.4 欧拉序ST表求LCA问题\n\n问题转化成$dfs$遍历路径记录下结点的$dfn$序号上$RMQ$问题，两个节点的$lca$一定是欧拉序遍历下序号区间内深度最浅的结点。可以做到$O(nlogn)$预处理，单次询问$O(1)$.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 9;\nvector<int> connects[maxn];\nint st[maxn << 1][25];\nint dep[maxn];\nint pos[maxn];\nint logs[maxn << 1];\nvoid add_edge(int u, int v)\n{\n    connects[u].push_back(v);\n    connects[v].push_back(u);\n}\nint cnt = 0;\nvoid dfs1(int u, int fa)\n{\n    st[++cnt][0] = u;\n    dep[u] = dep[fa] + 1;\n    pos[u] = cnt;\n    for (auto v : connects[u])\n    {\n        if (v == fa)\n            continue;\n        dfs1(v, u);\n        st[++cnt][0] = u;//欧拉序记录\n    }\n    return;\n}\nvoid build_st()\n{\n    for (int j = 1; j < 25; j++)\n        for (int i = 1; i + (1 << j) - 1 <= cnt; i++)\n        {\n            int l = st[i][j - 1], r = st[i + (1 << (j - 1))][j - 1];//st维护结点序号\n            if (dep[l] < dep[r])\n                st[i][j] = l;\n            else\n                st[i][j] = r;\n        }\n    logs[1] = 0;\n    for (int i = 2; i <= cnt; i++)\n    {\n        logs[i] = logs[i / 2] + 1;\n    }\n    return;\n}\nint lcas(int u, int v)\n{\n    int l = pos[u], r = pos[v];\n    if (l > r)\n        swap(l, r);\n    int k = logs[r - l + 1];\n    int ansl = st[l][k];\n    int ansr = st[r - (1 << k) + 1][k];\n    if (dep[ansl] < dep[ansr])\n        return ansl;\n    else\n        return ansr;\n}\nint main()\n{\n    int n, m, rt;\n    cin >> n >> m >> rt;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    dfs1(rt, rt);\n    build_st();\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lcas(u, v) << endl;\n    }\n    return 0;\n}\n```\n\n\n\n<div style=\"page-break-after: always;\"></div>\n\n## 4.并查集(Disjoint Sets)\n\n关键词：同属性分类\n\n### 4.1 带权并查集\n\n维护路径权值信息，常见用路径压缩均摊复杂度。merge时搞不清就画向量图表示，一下就懂。\n\n```cpp\nint getfather(int x)\n{\n    int fa = father[x];\n    if (x != father[x])\n    {\n        father[x] = getfather(father[x]);\n        val[x] += val[fa];\n        return father[x];\n    }\n    return x;\n}\nvoid merge(int x, int y, int value)\n{\n    int fx = getfather(x);\n    int fy = getfather(y);\n    father[fx] = fy;\n    val[fx] = value + val[y] - val[x];\n}\n```\n\n### 4.2 种类并查集\n\n一个点拆成多个点维护对立矛盾等信息。\n\n```cpp\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int maxn = 1e6 + 1;\nint father[maxn];\nint ran[maxn];\nint n;\nint getfather(int x)\n{\n    if (x == father[x])\n        return x;\n    return father[x] = getfather(father[x]);\n}\nvoid merge(int x, int y)\n{\n    int fx = getfather(x);\n    int fy = getfather(y);\n    father[fx]=fy;\n}\nvoid eat(int x, int y)\n{\n    merge(x, n + y);\n    merge(n + x, 2 * n + y);\n    merge(2 * n + x, y);\n}\nvoid same(int x, int y)\n{\n    merge(x, y);\n    merge(n + x, n + y);\n    merge(2 * n + x, 2 * n + y);\n}\nbool checkeat(int x, int y)\n{\n    return getfather(x) == getfather(y + n) || getfather(x) == getfather(y + 2 * n); // 查询捕食和被捕食关系\n}\nbool checksame(int x, int y)\n{\n    return (getfather(x) == getfather(y)) || x == y;\n}\nvoid init(int n)\n{\n    for (int i = 1; i <= 3 * n; i++)\n    {\n        father[i] = i;\n    }\n}\n```\n\n### 4.3 可持久化并查集\n\n见1.14\n\n<div style=\"page-break-after: always;\"></div>\n\n## 5.树状数组(Fenwick Trees)\n\n关键词：二进制枚举，前缀和\n\n树状数组维护类似前缀和的东西。核心操作为lowbit。\n\n### 5.1 二维树状数组（模板，子矩形所有元素和）\n\n一维的树状数组都会写。下面的是二维的。维护矩形前缀和\n\n```cpp\n// 高位树状数组，没啥大区别，开多个\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct Fenwick\n{\nprivate:\n    int n, m;\n    vector<vector<i64>> c;\n    int lowbit(int x) { return x & -x; }\n\npublic:\n    Fenwick(int n, int m) : n(n), m(m), c(n + 1, vector<i64>(m + 1, 0)) {}\n    Fenwick() : n(0), m(0) {}\n    void init(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        c.assign(n + 1, vector<i64>(m + 1, 0));\n    }\n    void add(int x, int y, i64 v)\n    {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = y; j <= m; j += lowbit(j))\n                c[i][j] += v;\n    }\n    i64 query(int x, int y)\n    {\n        i64 res = 0;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = y; j; j -= lowbit(j))\n                res += c[i][j];\n        return res;\n    }\n};\n```\n\n### 5.2 离线二维数点\n\n求$[l,r]$内小于等于$x$的点有多少个。\n\n```cpp\n// 离线二维数点，扫描线离线版本\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct Fenwick\n{\nprivate:\n    int _n;\n    vector<i64> c;\n\npublic:\n    void init(int n)\n    {\n        _n = n;\n        c = vector<i64>(n + 1, 0);\n    }\n    void add(int x, i64 d)\n    {\n        for (; x <= _n; x += (x & -x))\n            c[x] += d;\n    }\n    i64 query(int x)\n    {\n        i64 res = 0;\n        for (; x; x -= (x & -x))\n            res += c[x];\n        return res;\n    }\n};\nFenwick fw;\nconst int maxn = 2e6 + 10;\nvector<pair<int, int>> mp[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 1);\n    int maxs = 0;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], maxs = max(maxs, a[i]);\n    vector<tuple<int, int, int>> query(q + 1);\n    vector<int> ans(q + 1);\n    for (int i = 1; i <= q; i++)\n    {\n        int l, r, x;\n        cin >> l >> r >> x;\n        query[i] = {l, r, x};\n        mp[r].push_back({i, 1});\n        mp[l - 1].push_back({i, -1});\n    }\n    fw.init(maxs + 100);\n    for (int i = 1; i <= n; i++)\n    {\n        fw.add(a[i], 1);\n        for (auto &j : mp[i])\n        {\n            ans[j.first] += j.second * fw.query(get<2>(query[j.first]));\n        }\n    }\n    for (int i = 1; i <= q; i++)\n        cout << ans[i] << '\\n';\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 6.平衡树（Bindary Search AVL Tree）\n\n关键词：有序序列，动态插入与删除。\n\n### 6.1 普通平衡树\n\n说实话，裸平衡树用的真不多，能用$set$、$multiset$等$STL$​​实现的东西为啥要自己写。\n\n更新：需要知道排名就别尼玛想你的multiset了，赶紧给我滚去写$Treap$!\n\n***平衡树可提供以下操作：***\n\n1. 插入一个数 $x$。\n2. 删除一个数 $x$（若有多个相同的数，应只删除一个）。\n3. 定义**排名**为比当前数小的数的个数 $+1$。查询 $x$ 的排名。\n4. 查询数据结构中排名为 $x$ 的数。\n5. 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。\n6. 求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。\n\n对于操作 3,5,6，**不保证**当前数据结构中存在数 $x$，$1\\le n \\le 10^5$.\n\n#### 6.1.1 替罪羊树（ScapeGoat Tree）\n\n替罪羊树是一个很暴力的思想，每次插入一个数动态检查插入后某些节点是否需要暴力进行平衡重构。一般选择平衡因子$\\alpha=0.7-0.8$。如果某个子树的左儿子所管辖子树大小占比例超过平衡因子就重构。重构就是中序遍历暴力重构即可。\n\n复杂度均摊$O(nlogn)$，树高均摊$O(logn)$\n\n下面示例中，重复点算作新开点，点总数不得超过$1e5$级别。平衡树构建时，默认左儿子权值必须严格小于自身，即相同权值结点必定是全部挂载于右儿子上。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (1 << 30);\ntypedef long long ll;\nconst int maxn = 1e6 + 5;\nvector<int> vec;\nstruct node\n{\n    int ls, rs, w; // 左儿子，有儿子，节点权值\n    bool exist;    // 该节点所代表元素是否存在\n    int sizx;      // 该节点下属子树大小\n    int fact;      // 该节点下属子树中尚存在元素个数\n} tr[maxn];\nint cnt, root;\nvoid pushup(int now) // 维护节点信息\n{\n    tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;\n    tr[now].fact = tr[tr[now].ls].fact + tr[tr[now].rs].fact + 1;\n}\nvoid newnode(int &now, int w) // 开新点\n{\n    now = ++cnt;\n    tr[now].w = w, tr[now].sizx = tr[now].fact = 1;\n    tr[now].exist = true;\n}\nbool judge(int now) // 判断是否平衡\n{\n    if (max(tr[tr[now].ls].sizx, tr[tr[now].rs].sizx) > tr[now].sizx * 0.75)\n        return true;\n    if ((tr[now].sizx - tr[now].fact) > tr[now].sizx * 0.3)\n        return true;\n    return false;\n}\nvoid mds(int now) // 中序遍历\n{\n    if (!now)\n        return;\n    mds(tr[now].ls);\n    if (tr[now].exist)\n        vec.push_back(now);\n    mds(tr[now].rs);\n}\nvoid cre(int L, int R, int &now) // 构造标准平衡树\n{\n    if (L == R)\n    {\n        now = vec[L];\n        tr[now].ls = tr[now].rs = 0;\n        tr[now].sizx = tr[now].fact = 1;\n        return;\n    }\n    int mid = (L + R) >> 1;\n    while (L < mid && tr[vec[mid]].w == tr[vec[mid - 1]].w)\n        mid--;\n    now = vec[mid];\n    if (L < mid)\n        cre(L, mid - 1, tr[now].ls);\n    else\n        tr[now].ls = 0;\n    cre(mid + 1, R, tr[now].rs);\n    pushup(now);\n}\nvoid update(int now, int en) // 维护父辈节点\n{\n    if (!now)\n        return;\n    if (tr[now].w > tr[en].w)\n        update(tr[now].ls, en);\n    else\n        update(tr[now].rs, en);\n    tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;\n}\nvoid rebuild(int &now) // 重构树\n{\n    vec.clear();\n    mds(now);\n    if (vec.empty())\n    {\n        now = 0;\n        return;\n    }\n    cre(0, vec.size() - 1, now);\n}\nvoid check(int &now, int en) // 检查，并重构子树\n{\n    if (now == en)\n        return;\n    if (judge(now))\n    {\n        rebuild(now);\n        update(root, now);\n        return;\n    }\n    if (tr[en].w < tr[now].w)\n        check(tr[now].ls, en);\n    else\n        check(tr[now].rs, en);\n}\nvoid inser(int &now, int w) // 插入\n{\n    if (!now)\n    {\n        newnode(now, w);\n        check(root, now);\n        return;\n    }\n    tr[now].sizx++, tr[now].fact++;\n    if (w < tr[now].w)\n        inser(tr[now].ls, w);\n    else\n        inser(tr[now].rs, w);\n}\nvoid del(int now, int w) // 删除\n{\n    if (tr[now].exist && tr[now].w == w)\n    {\n        tr[now].exist = false;\n        tr[now].fact--;\n        check(root, now);\n        return;\n    }\n    tr[now].fact--;\n    if (w < tr[now].w)\n        del(tr[now].ls, w);\n    else\n        del(tr[now].rs, w);\n}\nint getrank(int w) // 求w的排名\n{\n    int now = root, rank = 1;\n    while (now)\n    {\n        if (w <= tr[now].w)\n            now = tr[now].ls;\n        else\n        {\n            rank += tr[now].exist + tr[tr[now].ls].fact, now = tr[now].rs;\n        }\n    }\n    return rank;\n}\nint getnum(int rank) // 求排名为rank的树数\n{\n    int now = root;\n    while (now)\n    {\n        if (tr[now].exist && tr[tr[now].ls].fact + tr[now].exist == rank)\n            break;\n        else if (rank <= tr[tr[now].ls].fact)\n            now = tr[now].ls;\n        else\n        {\n            rank -= tr[now].exist + tr[tr[now].ls].fact, now = tr[now].rs;\n        }\n    }\n    return tr[now].w;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int op, x;\n        cin >> op >> x;\n        switch (op)\n        {\n        case 1:\n            inser(root, x);\n            break;\n        case 2:\n            del(root, x);\n            break;\n        case 3:\n            cout << getrank(x) << endl;\n            break;\n        case 4:\n            cout << getnum(x) << endl;\n            break;\n        case 5:\n            cout << getnum(getrank(x) - 1) << endl;\n            break;\n        case 6:\n\n            cout << getnum(getrank(x + 1)) << endl;\n            break;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.2 树堆（Treap）\n\n$Treap=Tree+Heap$，是一种弱平衡性质的平衡树，***均摊***树深度$O(logn)$。\n\n每一个树节点多赋值一个***随机***权值，使得该树***既满足平衡树性质***（$val_{lson}<val_{rt}< val_{rson}$），***又满足堆的性质***（$w_{lson}<w_{rt},w_{rt}>w_{rson}$​）\n\n复杂度正确性由随机数保证。\n\n关于更多的Treap，详见***6.2 笛卡尔树***\n\n***此处的示例因题目保证前驱后继必定存在故没有特判，如果前驱后继不存在对应函数必定卡死，解决方案参见6.3.1可持久化Treap中的解决方式。***\n\n##### 6.1.2.1 有旋Treap\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nconst int inf = 0x3f3f3f3f;\nunsigned int seed;\nrandom_device rd;\nmt19937 ran;\nstruct Treap\n{\n    struct node\n    {\n        int val, rnd, lc, rc, size, num;\n    };\n    int cnt = 0;\n    node tr[MAXN];\n    void init()\n    {\n        cnt = 0;\n    }\n    int _rand()\n    {\n        ran.seed(rd());\n        return ran();\n    }\n    void pushup(int p)\n    {\n        tr[p].size = tr[tr[p].lc].size + tr[tr[p].rc].size + tr[p].num;\n    }\n    void right(int &k)\n    {\n        int tmp = tr[k].lc;\n        tr[k].lc = tr[tmp].rc;\n        tr[tmp].rc = k;\n        tr[tmp].size = tr[k].size;\n        pushup(k);\n        k = tmp;\n    }\n    void left(int &k)\n    {\n        int tmp = tr[k].rc;\n        tr[k].rc = tr[tmp].lc;\n        tr[tmp].lc = k;\n        tr[tmp].size = tr[k].size;\n        pushup(k);\n        k = tmp;\n    }\n    void insert(int &p, int x)\n    {\n        if (p == 0)\n        {\n            p = ++cnt;\n            tr[p].val = x;\n            tr[p].num = tr[p].size = 1;\n            tr[p].lc = tr[p].rc = 0;\n            tr[p].rnd = _rand();\n            return;\n        }\n        ++tr[p].size;\n        if (x == tr[p].val)\n            ++tr[p].num;\n        else if (x < tr[p].val)\n        {\n            insert(tr[p].lc, x);\n            if (tr[tr[p].lc].rnd < tr[p].rnd)\n                right(p);\n        }\n        else if (x > tr[p].val)\n        {\n            insert(tr[p].rc, x);\n            if (tr[tr[p].rc].rnd < tr[p].rnd)\n                left(p);\n        }\n    }\n    void del(int &p, int x)\n    {\n        if (p == 0)\n            return;\n        if (tr[p].val == x)\n        {\n            if (tr[p].num > 1)\n                --tr[p].num, --tr[p].size;\n            else\n            {\n                if (tr[p].lc == 0 || tr[p].rc == 0)\n                    p = tr[p].lc + tr[p].rc;\n                else if (tr[tr[p].lc].rnd < tr[tr[p].rc].rnd)\n                    right(p), del(p, x);\n                else if (tr[tr[p].lc].rnd > tr[tr[p].rc].rnd)\n                    left(p), del(p, x);\n            }\n        }\n        else if (tr[p].val < x)\n            --tr[p].size, del(tr[p].rc, x);\n        else\n            --tr[p].size, del(tr[p].lc, x);\n    }\n    int queryrnk(int &p, int x)\n    {\n        if (p == 0)\n            return 0;\n        else if (tr[p].val == x)\n            return tr[tr[p].lc].size;\n        else if (tr[p].val < x)\n            return tr[tr[p].lc].size + tr[p].num + queryrnk(tr[p].rc, x);\n        else\n            return queryrnk(tr[p].lc, x);\n    }\n    int querynum(int &p, int rnk)\n    {\n        if (p == 0)\n            return 0;\n        if (tr[tr[p].lc].size >= rnk)\n            return querynum(tr[p].lc, rnk);\n        rnk -= tr[tr[p].lc].size;\n        if (rnk <= tr[p].num)\n            return tr[p].val;\n        rnk -= tr[p].num;\n        return querynum(tr[p].rc, rnk);\n    }\n    int queryfront(int &p, int x)\n    {\n        if (p == 0)\n            return -inf;\n        if (tr[p].val < x)\n            return max(tr[p].val, queryfront(tr[p].rc, x));\n        else if (tr[p].val >= x)\n            return queryfront(tr[p].lc, x);\n    }\n    int queryback(int &p, int x)\n    {\n        if (p == 0)\n            return inf;\n        if (tr[p].val > x)\n            return min(tr[p].val, queryback(tr[p].lc, x));\n        else if (tr[p].val <= x)\n            return queryback(tr[p].rc, x);\n    }\n};\nint pos;\nTreap tr;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int m, k;\n    tr.init();\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d%d\", &m, &k);\n        if (m == 1)\n            tr.insert(pos, k);\n        else if (m == 2)\n            tr.del(pos, k);\n        else if (m == 3)\n            printf(\"%d\\n\", tr.queryrnk(pos, k) + 1);\n        else if (m == 4)\n            printf(\"%d\\n\", tr.querynum(pos, k));\n        else if (m == 5)\n            printf(\"%d\\n\", tr.queryfront(pos, k));\n        else if (m == 6)\n            printf(\"%d\\n\", tr.queryback(pos, k));\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n##### 6.1.2.2 无旋Treap（FHQ-Treap)\n\n无旋转$Treap$​​通过树分裂和合并实现节点的添加以及删除。可以支持固定区间操作，支持可持久化操作。\n\n###### 6.1.2.2.1 单个节点只有一个值，相同值使用多个节点，可支持split_sz\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int w;\n        int val;\n        int sz;\n        node() : l(0), r(0), w(0), val(0), sz(0) {};\n        node(int val) : l(0), r(0), w(ran()), val(val), sz(1) {};\n    };\n    const static int maxn = 5e5 + 9;\n    node tree[maxn];\n    int root;\n    int tot = 0;\n    int newnode(int val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    inline void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n        return;\n    }\n    inline void split_val(const int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[rt].val <= val) // 叶子权值比目标值小，必定属于左侧。\n        {\n            l = rt;\n            split_val(tree[rt].r, tree[rt].r, r, val);\n        }\n        else\n        {\n            r = rt;\n            split_val(tree[rt].l, l, tree[rt].l, val);\n        }\n        pushup(rt);\n    }\n    inline void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            l = rt;\n            split_sz(tree[rt].r, tree[rt].r, r, sz - (tree[tree[rt].l].sz + 1));\n        }\n        else\n        {\n            r = rt;\n            split_sz(tree[rt].l, l, tree[rt].l, sz);\n        }\n        pushup(rt);\n    }\n    inline void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        if (tree[l].w > tree[r].w) // 大根堆形式，小根堆换个号就行\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n    }\n    inline void insert(int x)\n    {\n        int rt1, rt2;\n        split_val(root, rt1, rt2, x - 1);\n        merge(rt1, rt1, newnode(x));\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline void del(int val)\n    {\n        int x, y, z;\n        split_val(root, x, y, val);\n        split_val(x, x, z, val - 1);\n        merge(z, tree[z].l, tree[z].r);\n        merge(x, x, z);\n        merge(root, x, y);\n    }\n    inline int rnk(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        merge(root, x, y);\n        return ans;\n    }\n    inline int kth(int root, int k)\n    {\n        int x = root;\n        while (true)\n        {\n            if (k == tree[tree[x].l].sz + 1)\n                return tree[x].val;\n            if (k <= tree[tree[x].l].sz)\n                x = tree[x].l;\n            else\n                k -= tree[tree[x].l].sz + 1, x = tree[x].r;\n        }\n    }\n    inline int kth(int k)\n    {\n        return kth(root, k);\n    }\n    inline int pre(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = kth(x, tree[x].sz);\n        merge(root, x, y);\n        return ans;\n    }\n    inline int suf(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val);\n        int ans = kth(y, 1);\n        merge(root, x, y);\n        return ans;\n    }\n};\nTreap tr;\nsigned main()\n{\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int op, x;\n        cin >> op >> x;\n        if (op == 1)\n        {\n            tr.insert(x);\n        }\n        else if (op == 2)\n        {\n            tr.del(x);\n        }\n        else if (op == 3)\n        {\n            cout << tr.rnk(x) << endl;\n        }\n        else if (op == 4)\n        {\n            cout << tr.kth(x) << endl;\n        }\n        else if (op == 5)\n        {\n            cout << tr.pre(x) << endl;\n        }\n        else\n            cout << tr.suf(x) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n###### 6.1.2.2.2 单个节点有多个值，相同值使用同一个个节点，不支持split_sz\n\n```cpp\nrandom_device rd;\nmt19937 ran(rd());\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int val;\n        int sz;\n        int cnt;\n        int w;\n        node() : l(0), r(0), val(0), sz(0), cnt(0), w(0) {};\n        node(int val) : l(0), r(0), val(val), sz(1), cnt(1), w(ran()) {};\n    };\n    const static int N = 2e6 + 9;\n    int tot = 0;\n    int root = 0;\n    node tree[N];\n    int newnode(int val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + tree[rt].cnt;\n        return;\n    }\n    void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        if (tree[l].w > tree[r].w)\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n        return;\n    }\n    void split_val(const int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[rt].val <= val)\n        {\n            l = rt;\n            split_val(tree[rt].r, tree[rt].r, r, val);\n        }\n        else\n        {\n            r = rt;\n            split_val(tree[rt].l, l, tree[rt].l, val);\n        }\n        pushup(rt);\n    }\n    inline void insert(int x)\n    {\n        int rt1, rt2, rt3;\n        split_val(root, rt1, rt2, x - 1);\n        split_val(rt2, rt2, rt3, x);\n        if (!rt2)\n            rt2 = newnode(x);\n        else\n            tree[rt2].cnt++, tree[rt2].sz++;\n        merge(rt2, rt2, rt3);\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline void del(int val)\n    {\n        int rt1, rt2, rt3;\n        split_val(root, rt1, rt2, val);\n        split_val(rt1, rt1, rt3, val - 1);\n        assert(rt3 != 0);\n        tree[rt3].cnt--, tree[rt3].sz--;\n        if (!tree[rt3].cnt)\n            merge(rt3, tree[rt3].l, tree[rt3].r);\n        merge(rt1, rt1, rt3);\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline int rnk(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        merge(root, x, y);\n        return ans;\n    }\n    inline int kth(int root, int k)\n    {\n        int x = root;\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int kth(int k)\n    {\n        return kth(root, k);\n    }\n    inline int pre(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = kth(x, tree[x].sz);\n        merge(root, x, y);\n        return ans;\n    }\n    inline int suf(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val);\n        int ans = kth(y, 1);\n        merge(root, x, y);\n        return ans;\n    }\n};\nTreap tr;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.3 伸展树（Splay Tree）\n\n通过 **$Splay$/伸展操作** 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在均摊$O(logN)$​​时间内完成插入，查找和删除操作，并且保持平衡而不至于退化为链。\n\n每次操作之后，被操作数均在根节点。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 100005;\nint rt, tot, fa[N], ch[N][2], val[N], cnt[N], sz[N];\nstruct Splay\n{\n    void maintain(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x]; }\n\n    bool get(int x) { return x == ch[fa[x]][1]; }\n\n    void clear(int x)\n    {\n        ch[x][0] = ch[x][1] = fa[x] = val[x] = sz[x] = cnt[x] = 0;\n    }\n\n    void rotate(int x)\n    {\n        int y = fa[x], z = fa[y], chk = get(x);\n        ch[y][chk] = ch[x][chk ^ 1];\n        if (ch[x][chk ^ 1])\n            fa[ch[x][chk ^ 1]] = y;\n        ch[x][chk ^ 1] = y;\n        fa[y] = x;\n        fa[x] = z;\n        if (z)\n            ch[z][y == ch[z][1]] = x;\n        maintain(y);\n        maintain(x);\n    }\n\n    void splay(int x, int goal = 0)\n    {\n        if (goal == 0)\n            rt = x;\n        while (fa[x] != goal)\n        {\n            int f = fa[x], g = fa[fa[x]];\n            if (g != goal)\n            {\n                if (get(f) == get(x))\n                    rotate(f);\n                else\n                    rotate(x);\n            }\n            rotate(x);\n        }\n    }\n\n    void ins(int k)\n    {\n        if (!rt)\n        {\n            val[++tot] = k;\n            cnt[tot]++;\n            rt = tot;\n            maintain(rt);\n            return;\n        }\n        int cur = rt, f = 0;\n        while (1)\n        {\n            if (val[cur] == k)\n            {\n                cnt[cur]++;\n                maintain(cur);\n                maintain(f);\n                splay(cur);\n                break;\n            }\n            f = cur;\n            cur = ch[cur][val[cur] < k];\n            if (!cur)\n            {\n                val[++tot] = k;\n                cnt[tot]++;\n                fa[tot] = f;\n                ch[f][val[f] < k] = tot;\n                maintain(tot);\n                maintain(f);\n                splay(tot);\n                break;\n            }\n        }\n    }\n\n    int rk(int k)\n    {\n        int res = 0, cur = rt;\n        while (1)\n        {\n            if (k < val[cur])\n            {\n                cur = ch[cur][0];\n            }\n            else\n            {\n                res += sz[ch[cur][0]];\n                if (!cur)\n                    return res + 1;\n                if (k == val[cur])\n                {\n                    splay(cur);\n                    return res + 1;\n                }\n                res += cnt[cur];\n                cur = ch[cur][1];\n            }\n        }\n    }\n\n    int kth(int k)\n    {\n        int cur = rt;\n        while (1)\n        {\n            if (ch[cur][0] && k <= sz[ch[cur][0]])\n            {\n                cur = ch[cur][0];\n            }\n            else\n            {\n                k -= cnt[cur] + sz[ch[cur][0]];\n                if (k <= 0)\n                {\n                    splay(cur);\n                    return val[cur];\n                }\n                cur = ch[cur][1];\n            }\n        }\n    }\n    // 返回前驱结点根编号\n    int pre()\n    {\n        int cur = ch[rt][0];\n        if (!cur)\n            return cur;\n        while (ch[cur][1])\n            cur = ch[cur][1];\n        splay(cur);\n        return cur;\n    }\n    // 返回后继结点根编号\n    int nxt()\n    {\n        int cur = ch[rt][1];\n        if (!cur)\n            return cur;\n        while (ch[cur][0])\n            cur = ch[cur][0];\n        splay(cur);\n        return cur;\n    }\n\n    void del(int k)\n    {\n        rk(k);\n        if (cnt[rt] > 1)\n        {\n            cnt[rt]--;\n            maintain(rt);\n            return;\n        }\n        if (!ch[rt][0] && !ch[rt][1])\n        {\n            clear(rt);\n            rt = 0;\n            return;\n        }\n        if (!ch[rt][0])\n        {\n            int cur = rt;\n            rt = ch[rt][1];\n            fa[rt] = 0;\n            clear(cur);\n            return;\n        }\n        if (!ch[rt][1])\n        {\n            int cur = rt;\n            rt = ch[rt][0];\n            fa[rt] = 0;\n            clear(cur);\n            return;\n        }\n        int cur = rt;\n        int x = pre();\n        fa[ch[cur][1]] = x;\n        ch[x][1] = ch[cur][1];\n        clear(cur);\n        maintain(rt);\n    }\n} tree;\n\nint main()\n{\n    int n, opt, x;\n    for (scanf(\"%d\", &n); n; --n)\n    {\n        scanf(\"%d%d\", &opt, &x);\n        if (opt == 1)\n            tree.ins(x);\n        else if (opt == 2)\n            tree.del(x);\n        else if (opt == 3)\n            printf(\"%d\\n\", tree.rk(x));\n        else if (opt == 4)\n            printf(\"%d\\n\", tree.kth(x));\n        else if (opt == 5)\n            tree.ins(x), printf(\"%d\\n\", val[tree.pre()]), tree.del(x);\n        else\n            tree.ins(x), printf(\"%d\\n\", val[tree.nxt()]), tree.del(x);\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.2 文艺平衡树\n\n文艺平衡树，指借助平衡树中序遍历是从小到大的性质将其略作修改，用于***维护高级区间操作***行为（例如，***维护区间 $[l,r]$​ 翻转***），不支持一切传统平衡树操作。\n\n请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：\n\n| 编号 |     名称     |                             格式                             | 说明                                                         |\n| :--: | :----------: | :----------------------------------------------------------: | :----------------------------------------------------------- |\n|  1   |     插入     | $\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}$ | 在当前数列的第 $posi$ 个数字后插入 $tot$ 个数字：$c_1, c_2 \\cdots c_{tot}$；若在数列首插入，则 $posi$ 为 $0$ |\n|  2   |     删除     |             $\\operatorname{DELETE} \\ posi \\ tot$             | 从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字        |\n|  3   |     修改     |         $\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c$          | 从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字统一修改为 $c$ |\n|  4   |     翻转     |            $\\operatorname{REVERSE} \\ posi \\ tot$             | 取出从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字，翻转后放入原来的位置 |\n|  5   |     求和     |            $\\operatorname{GET-SUM} \\ posi \\ tot$             | 计算从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字的和并输出 |\n|  6   | 求最大子列和 |                   $\\operatorname{MAX-SUM}$                   | 求出当前数列中和最大的一段子列，并输出最大和                 |\n\n- 对于 $100\\%$ 的数据，任何时刻数列中最多含有 $5 \\times 10^5$ 个数，任何时刻数列中任何一个数字均在 $[-10^3, 10^3]$ 内，$1 \\le M \\le 2 \\times 10^4$，插入的数字总数不超过 $4 \\times 10^6$。\n\n#### 6.2.1 无旋Treap实现文艺平衡树\n\n懒标记和线段树的想法一样，这样处理不容易错。\n\n分裂要按`size`，交换是整个子树内的所有节点的$lson,rson$​全部交换，所以需要懒标记。交换儿子并不会影响堆的性质，所以不需要管。\n\n更复杂的懒标记一定要搞清楚。搞不清楚懒标记极其容易错且相当难以调试（因为树结构的随机性）\n\n这个题标记的坑点就在于子段长度非空，全负数就要输出最大的那个负数。所以维护区间中值（区间最大子段）的时候需要额外带一次`tree[rt].val`，详情见懒标记。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\n#define int long long\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int w;\n        int val;\n        int sz;\n        int lazytag;\n        int sum;\n        int maxsum;\n        int maxpresum;\n        int maxsufsum;\n        bool sametag;\n        int sames;\n        node() : l(0), r(0), w(0), val(0),\n                 sz(0), lazytag(0), sum(0), maxpresum(0), maxsufsum(0),\n                 sametag(0), sames(0), maxsum(0) {};\n        node(int val) : l(0), r(0), w(ran()), val(val),\n                        sz(1), lazytag(0), sum(val), maxpresum(max(val, 0ll)),\n                        maxsufsum(max(val, 0ll)), sametag(0), sames(0), maxsum(val) {};\n    };\n    const static int maxn = 5e5 + 9;\n    node tree[maxn];\n    int root;\n    queue<int> q;\n    inline void init()\n    {\n        for (int i = 1; i < maxn; i++)\n        {\n            q.push(i);\n        }\n    }\n    Treap() { init(); }\n    int newnode(int val)\n    {\n        int tot = q.front();\n        q.pop();\n        tree[tot] = node(val);\n        return tot;\n    }\n    void getrub(int rt)\n    {\n        if (!rt)\n            return;\n        getrub(tree[rt].l);\n        getrub(tree[rt].r);\n        q.push(rt);\n        tree[rt] = node();\n        return;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n\n        tree[rt].sum = tree[tree[rt].l].sum + tree[tree[rt].r].sum + tree[rt].val;\n\n        tree[rt].maxpresum = max(tree[tree[rt].l].maxpresum, tree[tree[rt].l].sum + tree[rt].val + tree[tree[rt].r].maxpresum);\n\n        tree[rt].maxsufsum = max(tree[tree[rt].r].maxsufsum, tree[tree[rt].r].sum + tree[rt].val + tree[tree[rt].l].maxsufsum);\n\n        tree[rt].maxsum = max(tree[rt].val, tree[tree[rt].l].maxsufsum + tree[rt].val + tree[tree[rt].r].maxpresum);\n\n        if (tree[rt].l)\n        {\n            tree[rt].maxsum = max(tree[rt].maxsum, tree[tree[rt].l].maxsum);\n        }\n        if (tree[rt].r)\n        {\n            tree[rt].maxsum = max(tree[rt].maxsum, tree[tree[rt].r].maxsum);\n        }\n\n        return;\n    }\n    void Reverse(int x)\n    {\n        if (!x)\n            return;\n        swap(tree[x].l, tree[x].r);\n        swap(tree[x].maxpresum, tree[x].maxsufsum);\n        tree[x].lazytag ^= 1;\n    }\n    void Cover(int rt, int ci)\n    {\n        tree[rt].val = tree[rt].sames = ci;\n        tree[rt].sum = tree[rt].sz * ci;\n        tree[rt].maxpresum = tree[rt].maxsufsum = max(0ll, tree[rt].sum);\n        tree[rt].maxsum = max(ci, tree[rt].sum);\n        tree[rt].sametag = 1;\n    }\n    void pushdown(int rt)\n    {\n        if (!rt)\n            return;\n        if (tree[rt].lazytag)\n        {\n            if (tree[rt].l)\n                Reverse(tree[rt].l);\n            if (tree[rt].r)\n                Reverse(tree[rt].r);\n            tree[rt].lazytag = 0;\n        }\n        if (tree[rt].sametag)\n        {\n            if (tree[rt].l)\n            {\n                Cover(tree[rt].l, tree[rt].sames);\n            }\n            if (tree[rt].r)\n            {\n                Cover(tree[rt].r, tree[rt].sames);\n            }\n            tree[rt].sametag = 0;\n            tree[rt].sames = 0;\n        }\n    }\n    void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        pushdown(rt);\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            l = rt;\n            split_sz(tree[rt].r, tree[rt].r, r, sz - (tree[tree[rt].l].sz + 1));\n        }\n        else\n        {\n            r = rt;\n            split_sz(tree[rt].l, l, tree[rt].l, sz);\n        }\n        pushup(rt);\n    }\n    void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        pushdown(l);\n        pushdown(r);\n        if (tree[l].w > tree[r].w) // 大根堆形式，小根堆换个号就行\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n    }\n    void insert(int pos, vector<int> &a)\n    {\n        int rt1, rt2;\n        split_sz(root, rt1, rt2, pos);\n        for (auto j : a)\n        {\n            merge(rt1, rt1, newnode(j));\n        }\n        merge(root, rt1, rt2);\n    }\n    void del(int pos, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt1, rt3, pos + tot - 1);\n        split_sz(rt1, rt1, rt2, pos - 1);\n        getrub(rt2);\n        merge(root, rt1, rt3);\n    }\n    void reverse(int l, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt2, rt3, l + tot - 1);\n        split_sz(rt2, rt1, rt2, l - 1);\n        Reverse(rt2);\n        merge(rt2, rt1, rt2);\n        merge(root, rt2, rt3);\n    }\n    int getsum(int pos, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt1, rt3, pos + tot - 1);\n        split_sz(rt1, rt1, rt2, pos - 1);\n        int ans = tree[rt2].sum;\n        merge(rt1, rt1, rt2);\n        merge(root, rt1, rt3);\n        return ans;\n    }\n    int getmaxsum()\n    {\n        return tree[root].maxsum;\n    }\n    void make_same(int l, int tot, int c)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt2, rt3, l + tot - 1);\n        split_sz(rt2, rt1, rt2, l - 1);\n        Cover(rt2, c);\n        merge(rt2, rt1, rt2);\n        merge(root, rt2, rt3);\n    }\n    void print(int rt)\n    {\n        if (!rt)\n            return;\n        pushdown(rt);\n        print(tree[rt].l);\n        cout << tree[rt].val << \" \";\n        print(tree[rt].r);\n    }\n    void print()\n    {\n        print(root);\n        cout << endl;\n        return;\n    }\n};\nTreap tr;\nsigned main()\n{\n    // freopen(\"data.in\", \"r\", stdin);\n    // freopen(\"data.out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (auto &i : a)\n        cin >> i;\n    tr.insert(0, a);\n    while (m--)\n    {\n        string s;\n        cin >> s;\n        if (s == \"GET-SUM\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            cout << tr.getsum(pos, cnt) << endl;\n        }\n        else if (s == \"MAX-SUM\")\n        {\n            cout << tr.getmaxsum() << endl;\n        }\n        else if (s == \"INSERT\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            vector<int> b(cnt);\n            for (auto &j : b)\n                cin >> j;\n            tr.insert(pos, b);\n        }\n        else if (s == \"DELETE\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            tr.del(pos, cnt);\n        }\n        else if (s == \"MAKE-SAME\")\n        {\n            int pos, tot, c;\n            cin >> pos >> tot >> c;\n            tr.make_same(pos, tot, c);\n        }\n        else\n        {\n            int pos, tot;\n            cin >> pos >> tot;\n            tr.reverse(pos, tot);\n        }\n        // tr.print();\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.3 可持久化平衡树\n\n如题，可持久化数据结构。\n\n需要注意一点，平衡树可持久化消耗无用内存更大，建议空间倍数`<<6`以上\n\n#### 6.3.1 可持久化无旋Treap\n\n和非可持久化无旋$Treap$​​几乎没有区别，小简单的差异出在`merge`和`split_val`函数上，每次要分裂或者要合并的时候都必须新开结点，将复制一份旧结点，以保证原先版本不被破坏。\n\n用于解决需要提供以下操作的数据结构（ **对于各个以往的历史版本** ）：\n\n\n1、 插入 $x$\n\n2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）\n\n\n3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）\n\n\n4、查询排名为 $x$ 的数\n\n\n5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）\n\n6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）\n\n**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**\n\n每个版本的编号即为操作的序号（版本$0$即为初始状态，空树）\n对于 $100\\%$ 的数据， $ 1 \\leq n \\leq 5 \\times  10^5 $ , $|x_i| \\leq {10}^9$，$0 \\le v_i < i$，$1\\le \\text{opt} \\le 6$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\nstruct Persistant_Treap\n{\n    struct node\n    {\n        int l, r;\n        int val;\n        int sz;\n        int cnt;\n        int w;\n        node() { l = r = val = sz = cnt = w = 0; };\n        node(int val) : l(0), r(0), val(val), sz(1), cnt(1), w(ran()) {}\n    };\n    int tot = 0;\n    const static int maxn = 5e5 + 9;\n    node tree[maxn << 6];\n    int vers[maxn];\n    int ver = 0;\n    int newnode(int val)\n    {\n        ++tot;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[rt].cnt + tree[tree[rt].l].sz + tree[tree[rt].r].sz;\n        return;\n    }\n    int merge(const int l, const int r)\n    {\n        if (!l || !r)\n            return l | r;\n        int newrt;\n        if (tree[l].w > tree[r].w)\n        {\n            newrt = ++tot;\n            tree[newrt] = tree[l];\n            tree[newrt].r = merge(tree[newrt].r, r);\n        }\n        else\n        {\n            newrt = ++tot;\n            tree[newrt] = tree[r];\n            tree[newrt].l = merge(l, tree[newrt].l);\n        }\n        pushup(newrt);\n        return newrt;\n    }\n    void split_val(int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        int newrt;\n        if (tree[rt].val <= val)\n        {\n            l = ++tot;\n            tree[l] = tree[rt];\n            split_val(tree[rt].r, tree[l].r, r, val);\n            pushup(l);\n        }\n        else\n        {\n            r = ++tot;\n            tree[r] = tree[rt];\n            split_val(tree[rt].l, l, tree[r].l, val);\n            pushup(r);\n        }\n    }\n    inline void insert(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_val(vers[ver], rt1, rt2, val - 1);\n        split_val(rt2, rt2, rt3, val);\n        if (!rt2)\n            rt2 = newnode(val);\n        else\n            tree[rt2].cnt++, tree[rt2].sz++;\n        rt2 = merge(rt2, rt3);\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline void del(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_val(vers[ver], rt1, rt2, val);\n        split_val(rt1, rt1, rt3, val - 1);\n        if (!rt3)\n            return;\n        tree[rt3].cnt--, tree[rt3].sz--;\n        if (!tree[rt3].cnt)\n            rt3 = merge(tree[rt3].l, tree[rt3].r);\n        rt1 = merge(rt1, rt3);\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline int rnk(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n    inline int kth(int v, int k) // 版本访问\n    {\n        vers[++ver] = vers[v];\n        int x = vers[ver];\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int _kth(int rt, int k) // 根访问，private\n    {\n        int x = rt;\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int pre(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val - 1);\n\n        int ans = -(INT_MAX);\n        if (x != 0)\n            ans = _kth(x, tree[x].sz);\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n    inline int suf(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val);\n        int ans = (INT_MAX);\n        if (y != 0)\n            ans = _kth(y, 1);\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n};\nPersistant_Treap tr;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int v, op, x;\n        cin >> v >> op >> x;\n        if (op == 1)\n        {\n            tr.insert(v, x);\n        }\n        else if (op == 2)\n        {\n            tr.del(v, x);\n        }\n        else if (op == 3)\n        {\n            cout << tr.rnk(v, x) << endl;\n        }\n        else if (op == 4)\n        {\n            cout << tr.kth(v, x) << endl;\n        }\n        else if (op == 5)\n        {\n            cout << tr.pre(v, x) << endl;\n        }\n        else\n            cout << tr.suf(v, x) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.3.2 可持久化文艺平衡树\n\n理论上，文艺平衡树可以干了线段树所能干的所有活儿，但是常数$SuperBig$。其存活意义主要在于区间翻转。\n\n维护一个序列，其中需要提供以下操作，要求强制在线（**对于各个以往的历史版本**）：\n\n1. 在第 $p$ 个数后插入数 $x$。\n2. 删除第 $p$ 个数。\n3. 翻转区间 $[l,r]$，例如原序列是 $\\{5,4,3,2,1\\}$，翻转区间 $[2,4]$ 后，结果是 $\\{5,2,3,4,1\\}$。\n4. 查询区间 $[l,r]$ 中所有数的和。\n\n**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 $4$ 即保持原版本无变化），新版本即编号为此次操作的序号。**\n\nemm,相当贴内存$(979MB/1GB)$，爆$\\color{red}MLE$​就看着办吧。\n\n注意，pushdown的时候也要新建立拷贝节点，记住，可持久化数据结构上只要涉及到改必须要新建节点。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\n#define i64 long long\nstruct Persistant_literary_Treap\n{\nprivate:\n    struct node\n    {\n        int l, r;\n        int w;\n        i64 sum;\n        i64 val;\n        bool lazy;\n        int sz;\n        node() { l = r = w = sum = val = sz = lazy = 0; };\n        node(i64 val) : l(0), r(0), w(ran()), sum(val), val(val), sz(1), lazy(0) {}\n    };\n    const static int maxn = 2e5 + 9;\n    node tree[maxn << 7];\n    int vers[maxn], ver = 0;\n    int tot = 0;\n    int newnode(i64 val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushdown(int rt)\n    {\n        if (!rt)\n            return;\n        if (!tree[rt].lazy)\n            return;\n        if (tree[rt].l) // 只要动结点那必须全部备份可持久化\n        {\n            int rl = ++tot;\n            tree[rl] = tree[tree[rt].l];\n            tree[rt].l = rl;\n        }\n        if (tree[rt].r)\n        {\n            int rr = ++tot;\n            tree[rr] = tree[tree[rt].r];\n            tree[rt].r = rr;\n        }\n        swap(tree[rt].l, tree[rt].r);\n        if (tree[rt].l)\n            tree[tree[rt].l].lazy ^= 1;\n        if (tree[rt].r)\n            tree[tree[rt].r].lazy ^= 1;\n        tree[rt].lazy = 0;\n        return;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n        tree[rt].sum = tree[tree[rt].l].sum + tree[tree[rt].r].sum + tree[rt].val;\n        return;\n    }\n    int merge(int l, int r)\n    {\n        if (!l || !r)\n            return l | r;\n        int nowrt = 0;\n        pushdown(l);\n        pushdown(r);\n        if (tree[l].w > tree[r].w)\n        {\n            nowrt = ++tot;\n            tree[nowrt] = tree[l];\n            tree[nowrt].r = merge(tree[nowrt].r, r);\n            pushup(nowrt);\n        }\n        else\n        {\n            nowrt = ++tot;\n            tree[nowrt] = tree[r];\n            tree[nowrt].l = merge(l, tree[nowrt].l);\n            pushup(nowrt);\n        }\n        return nowrt;\n    }\n    void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        pushdown(rt);\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            int newrt = ++tot;\n            tree[newrt] = tree[rt];\n            l = newrt;\n            split_sz(tree[rt].r, tree[newrt].r, r, sz - (tree[tree[newrt].l].sz + 1));\n            pushup(l);\n        }\n        else\n        {\n            int newrt = ++tot;\n            tree[newrt] = tree[rt];\n            r = newrt;\n            split_sz(tree[rt].l, l, tree[newrt].l, sz);\n            pushup(r);\n        }\n        return;\n    }\n\npublic:\n    inline void insert(int v, int k, i64 val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2;\n        split_sz(vers[ver], rt1, rt2, k);\n        rt1 = merge(rt1, newnode(val));\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline void del(int v, int k)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, k);\n        split_sz(rt1, rt1, rt2, k - 1);\n        vers[ver] = merge(rt1, rt3);\n        return;\n    }\n    inline i64 query(int v, int l, int r)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, r);\n        split_sz(rt1, rt1, rt2, l - 1);\n        i64 ans = tree[rt2].sum;\n        rt1 = merge(rt1, rt2);\n        vers[ver] = merge(rt1, rt3);\n        return ans;\n    }\n    inline void reverse(int v, int l, int r)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, r);\n        split_sz(rt1, rt1, rt2, l - 1);\n        tree[rt2].lazy ^= 1;\n        rt1 = merge(rt1, rt2);\n        vers[ver] = merge(rt1, rt3);\n        return;\n    }\n};\nPersistant_literary_Treap tr;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    i64 lastans = 0;\n    while (n--)\n    {\n        i64 v, op, p, x, l, r;\n        cin >> v >> op;\n        if (op == 1)\n        {\n            cin >> p >> x;\n            p ^= lastans;\n            x ^= lastans;\n            tr.insert(v, p, x);\n        }\n        else if (op == 2)\n        {\n            cin >> p;\n            p ^= lastans;\n            tr.del(v, p);\n        }\n        else if (op == 3)\n        {\n            cin >> l >> r;\n            l ^= lastans;\n            r ^= lastans;\n            tr.reverse(v, l, r);\n        }\n        else\n        {\n            cin >> l >> r;\n            l ^= lastans;\n            r ^= lastans;\n            lastans = tr.query(v, l, r);\n            cout << lastans << endl;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 7.树套树\n\n### 7.1 线段树套平衡树\n\n关键词：区间大型平衡树操作。\n\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n\n1. 查询 $k$ 在区间内的排名\n\n2. 查询区间内排名为 $k$ 的值\n\n3. 修改某一位置上的数值\n\n4. 查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，**若不存在输出 `-2147483647`**）\n\n5. 查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，**若不存在输出 `2147483647`**）\n\n$1\\le n,m\\le5\\times 10^4$，序列中的值在任何时刻 $\\in[0,10^8]$。\n\n**（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）**\n\n做法：\n\n每个线段树结点维护一个$Treap$平衡树，区间合并直接平衡树$Merge$​拿下。\n\n1. 查询排名：线段树查询，查询每个子区间内$(k-1)$的排名并求和，复杂度$O(logN)$\n2. 查询排名为$k$的数：这个没办法直接加法求，需要二分+操作1判断，复杂度$O(log^2N)$\n3. 修改：无话可说，复杂度$O(logN)$。\n4. 查询前驱：各区间查询前驱后取$max$，复杂度$O(logN)$。\n5. 查询后继：各区间查询后继后取$min$，复杂度$O(logN)$.\n\n复杂度上界$O(Nlog^3N)$。单纯修改+查询第$K$小树状主席树可以$O(Nlog^2N)$实现。\n\n### 7.2 树状数组+线段树\n\n关键词：主席树强化，差分动态开点线段树\n\n树状数组的差分性质使得主席树可以支持快速修改。\n\n见1.12\n\n<div style=\"page-break-after: always;\"></div>\n\n### *7.3 线段树套线段树\n\n关键词：二维区间修改、区间查询。\n\n见$OI-Wiki$手册，过于偏门。\n\n## 8. 静态树（树上差分；HLD/LLD，重链剖分、长链剖分）\n\n关键词：静态树区间操作，静态树序列化操作。\n\n#### 8.1 树上差分——静态树，静态树节点信息\n\n想操作、查询$u$到$v$节点的区间属性，可以通过树上差分到根操作实现，即结点$u$存储$u$到根的信息，$v$存储$v$到根的信息。\n\n查询的时候直接查询$u+v-lca_{u,v}-fa_{lca_{u,v}}$​即可。\n\n```cpp\n#include <bits/stdc++.h>//树上差分，树上一条链的区间和，from：[JLOI2014] 松鼠的新家\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=3*1e5+10;\nint n,u,v,vis[N],a[N],b[N];\nint fa[N][40],dep[N];\nvector<int>edge[N];\nvoid dfs(int x,int f){//lca预处理\n    dep[x]=dep[f]+1;\n    fa[x][0]=f;\n    for(auto i:edge[x])if(i!=f)dfs(i,x); \n}\nvoid sum(int x,int f){//统计点x的值\n    a[x]=b[x];\n    for(auto i:edge[x]){\n        if(i!=f){\n            sum(i,x);//此时已经统计了所有i的值了\n            a[x]+=a[i];\n        }\n    }\n}\nint lca(int x,int y){//lca\n    if(x==y)return x;\n    if(dep[x]<dep[y])swap(x,y);\n    for(int i=30;i>=0;i--)\n        if(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n    if(x==y)return x;\n    for(int i=30;i>=0;i--)\n        if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n    return fa[x][0];\n}\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>vis[i];\n    for(int i=1;i<=n-1;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int j=1;j<=30;j++)\n        for(int i=1;i<=n;i++)\n            fa[i][j]=fa[fa[i][j-1]][j-1];\n    for(int i=1;i<=n-1;i++){//点差分,一个点的差分数组的值就是这个点的值-所有其亲儿子的值\n    //对vis[i],vis[i+1]这两个点之间加一只需要如下步骤（四步），操作的是差分数组\n        b[vis[i]]++;\n        b[vis[i+1]]++;\n        b[lca(vis[i],vis[i+1])]--;\n        b[fa[lca(vis[i],vis[i+1])][0]]--;\n    }\n    sum(1,0);//遍历整棵树，推出原始权值\n    for(int i=2;i<=n;i++)a[vis[i]]--;//本题例外（因为我们把既作为起点又做为终点的点算了两次，现在把这些点的权值减一即可 ）\n    for(int i=1;i<=n;i++)cout<<a[i]<<endl;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n还有一个树上异或差分：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define lowbit(x) (x&-x)\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int N=1e6+10;\nint n,q,u,v,idx,s,w;\nint tree[N],a[N],dfn[N],dep[N],fa[N][21],siz[N];\nvector<int>edge[N];\n/*要求解决这样一个问题，满足以下两个操作：\n1.u到v的路径上所有值异或上k\n2.输出u到v上所有点的值\n解法：\n树上异或差分，1由异或的性质可以转化为四条链的操作，u->1，v->1，k->1，（k-fa）->1，但是可以简化，利用异或差分数组，一个点的值为这个点异或它的所有儿子节点，这样只需要修改u，v，k，k-fa四个点的值即可\n2单点查询，难度在于如何通过异或差分还原这个点的值，方法就是u异或以u为根的子树的所有点的异或差分数组，利用dfs序，子树内的所有点被维护成了一个区间，这样就变成了区间异或，就可以利用树状数组快速维护，对dfs序建立树状数组即可。\n//涉及知识点：异或、树状数组、dfs序、树上差分、异或前缀和、lca*/\nvoid dfs(int x,int f){\n    dep[x]=dep[f]+1;fa[x][0]=f;a[f]^=a[x],dfn[x]=++idx;\n    siz[x]=1;\n    for(auto i:edge[x]){\n        if(i!=f){\n            dfs(i,x);\n            siz[x]+=siz[i];\n        }\n    }\n}\nvoid add(int x,int k){//点x加上k\n    while(x<=n){\n        tree[x]^=k;//依次修改每个覆盖有x的区间的值\n        x+=lowbit(x);\n    }\n}\nint sum(int x){//处理0到x之间的前缀和\n    int cnt=0;\n    while(x>0){\n        cnt^=tree[x];\n        x-=lowbit(x);\n    }\n    return cnt;\n}\nint lca(int x,int y){\n    if(dep[x]>dep[y]) swap(x,y);//y的深度大，dep大\n    for (int i=20;i>=0;i-- ) \n        if(dep[x]<=dep[y]-(1<<i)) y=fa[y][i];\n    if(x==y) return x;\n    for (int i=20;i>=0;i-- ) \n        if(fa[x][i]!=fa[y][i]) \n            x=fa[x][i],y=fa[y][i];\n    return fa[x][0];\n}\nvoid change(int u,int v,int w){\n    int k=lca(u,v);\n    add(dfn[u],w);\n    add(dfn[v],w);\n    add(dfn[k],w);\n    if (fa[k][0]) add(dfn[fa[k][0]], w);\n}\nint get(int u){\n    return sum(dfn[u]+siz[u]-1)^sum(dfn[u]-1);\n}\nint check2(int u,int v){\n    vector<int>e;int flag=0;\n    if(dep[u]<dep[v])swap(u,v);\n    while(dep[u]>dep[v]){\n        e.push_back(get(u));\n        u=fa[u][0];\n    }\n    if(u==v)e.push_back(get(u));\n    else {\n        while(u!=v){\n            e.push_back(get(u));e.push_back(get(v));\n            u=fa[u][0];v=fa[v][0];\n        }\n        e.push_back(get(u));\n    }\n    sort(e.begin(),e.end());\n    for(int i=2;i<e.size();i++){\n        if(e[i-2]+e[i-1]>e[i])return 1;\n    }\n    return 0;\n}\nint find(int u,int v){\n    int k = lca(u, v);\n    if (dep[u] + dep[v] - 2 * dep[k] + 1 > 46) return 1;\n    else return check2(u,v);\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    for(int i=1;i<=n-1;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int j=1;j<=20;j++)\n        for(int i=1;i<=n;i++)\n            fa[i][j]=fa[fa[i][j-1]][j-1];\n    for(int i=1;i<=n;i++)add(dfn[i],a[i]);\n    for(int i=1;i<=q;i++){\n        cin>>s;\n        if(s==1){\n            cin>>u>>v>>w;\n            change(u,v,w);\n        }\n        else {\n            cin>>u>>v;\n            cout<<find(u,v);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 8.2 重链剖分——静态树，动态树节点信息\n\n一种以链节点数划分轻重以实现树节点编号化，将书上问题转移到区间操作实现。\n\n重链剖分保证每一颗子树中所有节点的编号必定是一段连续的序列$dfn$序号。\n\n重链剖分可以将树上的任意一条路径划分成不超过$logN$条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 $LCA$ 为链的一个端点)。\n\n重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。\n\n重链剖分复杂度是$O(n)$的，两次$dfs$实现，跳链求$lca$的实现是单次询问$O(logN)$​的。对于高节点数而低强度询问相当友好。\n\n这里默认是从$1$开始的\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 3e5 + 9;\nint father[maxn], sizes[maxn], hson[maxn], depth[maxn], top[maxn], ranks[maxn], dfn[maxn], cnt;\nint nxt[maxn << 1LL], head[maxn], to[maxn << 1LL], tot;\nvoid add(int u, int v)\n{\n    nxt[++tot] = head[u];\n    head[u] = tot;\n    to[tot] = v;\n}\nvoid add_edge(int u, int v)\n{\n    add(u, v);\n    add(v, u);\n}\nvoid dfs1(int pos)\n{\n    hson[pos] = -1;\n    sizes[pos] = 1;\n    for (int i = head[pos]; i; i = nxt[i])\n    {\n        if (!depth[to[i]])\n        {\n            depth[to[i]] = depth[pos] + 1;\n            father[to[i]] = pos;\n            dfs1(to[i]);\n            sizes[pos] += sizes[to[i]];\n            if (hson[pos] == -1 || sizes[to[i]] > sizes[hson[pos]])\n                hson[pos] = to[i];\n        }\n    }\n}\nvoid dfs2(int u, int tops)\n{\n    top[u] = tops;\n    dfn[u] = ++cnt;\n    ranks[cnt] = u;\n    if (hson[u] != -1)\n    {\n        dfs2(hson[u], tops);\n        for (int i = head[u]; i; i = nxt[i])\n        {\n            if (to[i] == father[u] || to[i] == hson[u])\n                continue;\n            dfs2(to[i], to[i]);\n        }\n    }\n}\nint n, m, r;\nint a[maxn];\nint lca(int u, int v)\n{\n    while (top[u] != top[v])\n    {\n        if (depth[top[u]] < depth[top[v]])\n            swap(u, v);\n        u = father[top[u]]; // 所在重链首低的向上跳\n    }\n    return depth[u] < depth[v] ? u : v;\n}\nvoid init()\n{\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    depth[r] = 1;\n    dfs1(r);\n    dfs2(r, r);\n    // cout << \"finished build\" << endl;\n    // cout << \"root  is\" << dfn[1] << endl;\n    /*for (int i = 1; i <= n; i++)\n        cout << dfn[i] << \" \";\n    cout << endl;\n    for (int i = 1; i <= n; i++)\n        cout << ranks[i] << \" \";\n    cout << endl;\n    for (int i = 1; i <= n; i++)\n        cout << top[i] << \" \";\n        */\n    return;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 8.3长链剖分——仅深度维度线性优化动态规划\n\n长链剖分的实现方式和重链剖分很像，只不过重儿子被定义为了链长度最长的那一个，sz维护的是所属最长链的长度。\n\n长链剖分跳链的时空复杂度最大是$O(N\\sqrt N)$的，这个道理显而易见。\n\n长链剖分可以做到线性时间的优化树上和深度有关的$dp$。长链剖分后，在维护信息的过程中，先 $O(1)$ 继承重儿子的信息，再暴力合并其余轻儿子的信息。\n\n示例：\n\n给定一棵以 $1$ 为根，$n$ 个节点的树。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。\n\n对于每个点，求一个最小的 $k$，使得 $d(u,k)$ 最大。$1≤n≤10^6$\n\n正常分析的话，设$f_{u,i}$表示在$u$子树中距离$u$距离为$i$的节点数，那么这个方程有：\n$$\nf_{u,i}=\\sum f_{v,i-1}\n$$\n纯暴力转移，深度维度是$O(n)$，总复杂度$O(n^2)$​，无法承受。\n\n考虑树链剖分优化，对于$u$，直接继承其重儿子的$dp$数组，并在数组前头插入一个$1$元素表示$dp_{u,0}=1$，指根节点自己。\n\n然后剩下的轻儿子的暴力向重儿子合并就可以了。时间复杂度$O(2n)$​，线性通过，因为每个子树节点的vector最多存放深度多个元素，总元素数虽多$O(n)$，而不是暴力那样所有的全部开，没有的也开了。\n\n关于直接继承重儿子信息，使用`vector`的`swap`函数显然比写指针更简单易懂。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std; \nconst int N=1e6+5;\nint n,x,y,cnt,hd[N],to[N<<1],nxt[N<<1],len[N],son[N],ans[N];\nvector<int>f[N];    //这里的 vector 是倒序存储的，因为要在继承重儿子的信息后，要将当前节点的 DP 数组最前面插入一个元素，而 push_back 的复杂度优于 pop_front，倒序存储就可以直接使用 push_back \nvoid add(int x,int y){\n    to[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;\n}\nint get(int x,int id){    //由于 vector 是倒序存储的，此处将 vector 正序存储的位置转化为倒序存储的位置 \n    return len[x]-id-1;\n}\nvoid dfs1(int x,int fa){\n    for(int i=hd[x];i;i=nxt[i]){\n        int y=to[i];\n        if(y==fa) continue;\n        dfs1(y,x);\n        if(len[y]>len[son[x]]) son[x]=y;\n    }\n    len[x]=len[son[x]]+1;\n}\nvoid dfs2(int x,int fa){\n    if(son[x]) dfs2(son[x],x),swap(f[x],f[son[x]]),ans[x]=ans[son[x]]+1;    //继承重儿子的信息。这里的继承直接用 swap 而不是复制，swap 在时间和空间上都更优（swap 交换 vector 的时间复杂度为 O(1)）。 \n    f[x].push_back(1);    //push_back 的复杂度优于 pop_front\n    for(int i=hd[x];i;i=nxt[i]){\n        int y=to[i];\n        if(y==fa||y==son[x]) continue;\n        dfs2(y,x);\n        for(int j=1;j<=len[y];j++){\n            f[x][get(x,j)]+=f[y][get(y,j-1)];    //暴力合并轻儿子的信息 \n            if(f[x][get(x,j)]>f[x][get(x,ans[x])]||(f[x][get(x,j)]==f[x][get(x,ans[x])]&&j<ans[x])) ans[x]=j;    //更新答案\n        }\n    }\n    if(f[x][get(x,ans[x])]==1) ans[x]=0;    //f[x][0]=1,f[x][ans[x]]=1，0 显然更优\n}\nsigned main(){\n    scanf(\"%lld\",&n);\n    for(int i=1;i<n;i++){\n        scanf(\"%lld%lld\",&x,&y);\n        add(x,y),add(y,x);\n    }\n    dfs1(1,0),dfs2(1,0);\n    for(int i=1;i<=n;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 9. 动态树 （LCT/Link-Cut Tree，实链剖分）\n\n关键词：动态树，修改树结构后树上区间操作、序列化操作。\n\n***注意，序列上的跳跃同样可以视作一棵树来解决问题***\n\n维护一个 **森林**，支持删除某条边，加入某条边，并保证加边，删边之后仍是森林。我们要维护这个森林的一些信息。\n\n一般的操作有两点连通性，两点路径权值和，连接两点和切断某条边、修改信息等。\n\n核心思想是我要谁我就把谁转到实链上面，其他的都是虚链。\n\n$LCT$的辅助树性质：\n\n1. 辅助树由多棵 $Splay$ 组成，每棵 $Splay$ 维护原树中的一条路径，且中序遍历这棵 $Splay$ 得到的点序列，从前到后对应原树「从上到下」的一条路径。\n2. 原树每个节点与辅助树的 $Splay$ 节点一一对应。\n3. 辅助树的各棵 $Splay$ 之间并不是独立的。每棵 $Splay$ 的根节点的父亲节点本应是空，但在 $LCT$ 中每棵 $Splay$ 的根节点的父亲节点指向原树中 **这条链** 的父亲节点（即链最顶端的点的父亲节点）。这类父亲链接与通常 $Splay$ 的父亲链接区别在于儿子认父亲，而父亲不认儿子，对应原树的一条 **虚边**。因此，每个连通块恰好有一个点的父亲节点为空。\n4. 由于辅助树的以上性质，我们维护任何操作都不需要维护原树，辅助树可以在任何情况下拿出一个唯一的原树，我们只需要维护辅助树即可。\n\n示例：\n\n给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  \n\n操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。\n\n\n- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。\n- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。\n- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。\n- `3 x y` 代表将点 $x$ 上的权值变成 $y$。\n\n保证：\n- $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。\n- 对于操作 $0, 1, 2$，保证 $1 \\leq x, y \\leq n$。\n- 对于操作 $3$，保证 $1 \\leq x \\leq n$，$1 \\leq y \\leq 10^9$。\n\n```cpp\n// LCT，动态树、实链剖分\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int ch[2];\n#define l ch[0]\n#define r ch[1]\n    int val = 0;\n    int sum = 0;\n    // int lazytag = 0;\n    // int sz = 1;\n    int revtag = 0;\n    int fa = 0;\n};\nconst int maxn = 5e5 + 9;\nnode tr[maxn];\nvoid reverse(int x)\n{\n    tr[x].revtag ^= 1;\n    return;\n}\nbool get(int x) // 获取x是父亲节点的哪个儿子\n{\n    return tr[tr[x].fa].r == x;\n}\nbool isroot(int x) // 判断x结点是否作为一棵动态Splay的根\n{\n    return tr[tr[x].fa].l != x && tr[tr[x].fa].r != x;\n}\nvoid pushup(int rt) // 更新结点信息\n{\n    // other pushups;\n    // tr[rt].sz = tr[tr[rt].l].sz + tr[tr[rt].r].sz + 1;\n    tr[rt].sum = tr[tr[rt].l].sum ^ tr[tr[rt].r].sum ^ tr[rt].val;\n    return;\n}\nvoid pushdown(int x) // 树上懒标记，文艺平衡树标记是刚需求\n{\n    if (tr[x].revtag)\n    {\n        swap(tr[x].l, tr[x].r);\n        if (tr[x].l)\n            reverse(tr[x].l);\n        if (tr[x].r)\n            reverse(tr[x].r);\n        tr[x].revtag = 0;\n    }\n}\nvoid update(int x) // 动x之前结算x所在根的所有lazytag\n{\n    if (!isroot(x))\n    {\n        update(tr[x].fa);\n    }\n    pushdown(x);\n    return;\n}\nvoid rotate(int x)\n{\n    int y = tr[x].fa, z = tr[y].fa, k = get(x);\n    if (!isroot(y))\n        tr[z].ch[tr[z].r == y] = x;\n    // 上面这句一定要写在前面，普通的 Splay 是不用的，因为 isRoot  (后面会讲)\n    tr[x].fa = z;\n    tr[y].ch[k] = tr[x].ch[!k];\n    tr[tr[x].ch[!k]].fa = y;\n    tr[x].ch[!k] = y;\n    tr[y].fa = x;\n    pushup(y), pushup(x);\n}\nvoid Splay(int x) // 伸展操作，将结点伸展到根。\n{\n    update(x);\n    for (int fa; fa = tr[x].fa, !isroot(x); rotate(x))\n    {\n        if (!isroot(fa))\n            rotate(get(fa) == get(x) ? fa : x);\n    }\n}\nint access(int x) // 拉直从x到当前动态树根节点的实边路径，返回该路径终点的Splay的根（即路径终点）\n{\n    int p;\n    for (p = 0; x; p = x, x = tr[x].fa)\n    {\n        Splay(x);\n        tr[x].r = p;\n        pushup(x);\n    }\n    return p;\n}\nvoid makeroot(int x) // 换根操作，指定x结点成为原树（非辅助树）的总根\n{\n    access(x);  // 拉出x到当前根的路径，x必然是此时所在Splay中中序遍历的最后一个点\n    Splay(x);   // 旋根，根据LCT-Splay定义，这棵Splay必定没有右儿子\n    reverse(x); // 直接翻转Splay，迫使其成为当前Splay中序遍历第一个访问的点，成为深度最浅的根，实现了换跟\n    return;\n}\nint find(int p) // 找结点p在原森林所属树（非辅助Splay森林树）的树根\n{\n    access(p);\n    Splay(p);\n    pushdown(p);\n    while (tr[p].l)\n        p = tr[p].l, pushdown(p);\n    Splay(p);\n    return p;\n}\nbool link(int x, int y) // 连一条x->y的轻边\n{\n    makeroot(x);\n    if (find(y) == x)\n        return 0;\n    tr[x].fa = y;\n    return 1;\n}\nbool cut(int x, int y)\n{\n    makeroot(x);\n    if (find(y) != x || tr[y].fa != x || tr[y].l)\n        return 0;\n    tr[y].fa = tr[x].r = 0; // x在findroot(y)后被转到了根\n    pushup(x);\n    return 1;\n}\nvoid split(int x, int y) // 动态树中拆出来一条x->y指定路径，保证路径上都是实边,保证y在根。\n{\n    makeroot(x);\n    access(y);\n    Splay(y);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        int v;\n        cin >> v;\n        tr[i].val = v;\n        tr[i].sum = v;\n    }\n    while (m--)\n    {\n        int op, x, y;\n        cin >> op >> x >> y;\n        if (op == 0)\n        {\n            split(x, y);\n            cout << tr[y].sum << endl;\n        }\n        else if (op == 1)\n        {\n            link(x, y);\n        }\n        else if (op == 2)\n        {\n            cut(x, y);\n        }\n        else\n        {\n            Splay(x); // 节点修改转到根再改，不会影响其他信息\n            tr[x].val = y;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 10. 01Trie\n\n关于字典树Trie的内容，详见$Part\\ 2$.\n\n### 10.1 01Trie\n\n01字典树。写法参见可持久化，没啥区别。\n\n`tr[rt].cnt`存储的是从当前节点数位出发还有多少个数字，根节点就是数字的总个数。\n\n### 10.2 可持久化01Trie\n\n维护区间异或最大值或者区间第$K$大值。区间第$K$大值类似于主席树树上二分。\n\n示例：（区间最大值）\n\n给定一个非负整数序列 $\\{a\\}$，初始长度为 $N$。  \n\n有 $M$ 个操作，有以下两种操作类型：  \n\n1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  \n2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ 最大，输出最大值。\n\n- 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Present_Trie\n{\nprivate:\n    struct node\n    {\n        int nxt[2];\n        int cnt = 0;\n    };\n    vector<node> tr;\n    int tot = 0;\n    int n;\n\npublic:\n    void init(int n)\n    {\n        this->n = n;\n        tr.resize(n << 5);\n    }\n    int newroot()\n    {\n        return ++tot;\n    }\n    void insert(int rt1, int rt2, int x)\n    {\n        for (int i = 30; i >= 0; i--)\n        {\n            int bit = (x >> i) & 1;\n            if (bit)\n            {\n                if (!tr[rt2].nxt[1])\n                {\n                    tr[rt2].nxt[1] = ++tot;\n                }\n                tr[rt2].nxt[0] = tr[rt1].nxt[0];\n                rt1 = tr[rt1].nxt[1];\n                rt2 = tr[rt2].nxt[1];\n            }\n            else\n            {\n                if (!tr[rt2].nxt[0])\n                {\n                    tr[rt2].nxt[0] = ++tot;\n                }\n                tr[rt2].nxt[1] = tr[rt1].nxt[1];\n                rt1 = tr[rt1].nxt[0];\n                rt2 = tr[rt2].nxt[0];\n            }\n            tr[rt2].cnt = tr[rt1].cnt + 1;\n        }\n    }\n    int query(int rt1, int rt2, int x)\n    {\n        int ret = 0;\n        for (int i = 30; i >= 0; i--)\n        {\n            int bit = (x >> i) & 1;\n            if (tr[tr[rt2].nxt[bit ^ 1]].cnt - tr[tr[rt1].nxt[bit ^ 1]].cnt > 0)\n            {\n                ret |= (1 << i);\n                rt1 = tr[rt1].nxt[bit ^ 1];\n                rt2 = tr[rt2].nxt[bit ^ 1];\n            }\n            else\n            {\n                rt1 = tr[rt1].nxt[bit];\n                rt2 = tr[rt2].nxt[bit];\n            }\n        }\n        return ret;\n    }\n};\nPresent_Trie pt;\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> root(n + 1);\n    pt.init(1e6 + 9);\n    int calc = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        calc ^= x;\n        root[i] = pt.newroot();\n        pt.insert(root[i - 1], root[i], calc);\n    }\n    while (q--)\n    {\n        char c;\n        int l, r, x;\n        cin >> c;\n        if (c == 'Q')\n        {\n            cin >> l >> r >> x;\n            l--, r--;\n            if (l == 0)\n            {\n                cout << max(x ^ calc, pt.query(root[l], root[r], x ^ calc)) << endl;\n            }\n            else\n            {\n                cout << pt.query(root[l - 1], root[r], x ^ calc) << endl;\n            }\n        }\n        else if (c == 'A')\n        {\n            cin >> x;\n            calc ^= x;\n            root.emplace_back(pt.newroot());\n            n++;\n            pt.insert(root[n - 1], root[n], calc);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 11.单调栈\n\n单调栈，可以维护一个单调的序列，使得每一个元素进栈的时候，所有比这个元素小的栈内元素均会被其消除或者融合，比他大的栈内元素不会与其消除或者融合。最典型的例子就是维护某个数最左侧和最右侧第一个比其大的数。但是单调栈并不局限于此：\n\n给定一个长度为 $m$ 的数组 $b$ 。您可以执行以下任意次操作（可能是零次）：\n\n- 选择两个不同的索引 $i$ 和 $j$ ，其中 $\\bf{1\\le i < j\\le m}$ 和 $b_i$ 为偶数，将 $b_i$ 除以 $2$ ，并将 $b_j$ 乘以 $2$ 。\n\n您的任务是在执行任意数量的此类操作后最大化数组的总和。由于它可能很大，请输出此总和模数 $10^9+7$ 。\n\n由于这道题太简单了，给你一个长度为 $n$ 的数组 $a$ ，你需要对 $a$ 的每个前缀进行求解。\n\n换句话说，表示在执行任意数量的 $f(b)$ 等运算后 $b$ 的最大和，你需要分别输出 $f([a_1])$ 、 $f([a_1,a_2])$ 、 $\\ldots$ 、 $f([a_1,a_2,\\ldots,a_n])$ 模数 $10^9+7$ 。\n\n不难考虑到每个数新加进序列的时候，所有比这个数小的底数（除尽2以后的数）所包含2的个数都要加到新数字上。很像一个线段树区间查，但是这会存在一个问题：\n\n样例： 18 2 7\n\n新加入的7显然查不到9底上的一个2，但是14可以查到。线段树最坏复杂度是$nlog^2n$的。（实际上根据运算特性分析，能够卡满$log^2n$单次询问的情况最多只有$logn$次，所以真实实际复杂度为$nlogn+log^3n\\rightarrow nlogn$的复杂度）\n\n所以，比当前数小的均可以合并，比当前数大的均无法合并，符合单调栈定义：\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    mint tmpsum = 0;\n    vector<i64> a(n + 1);\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    stack<pair<i64, i64>> st;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = 0;\n        while (a[i] % 2 == 0)\n        {\n            k++;\n            a[i] >>= 1;\n        }\n        while (!st.empty() && (k >= 30 || (a[i] << k) > st.top().first))\n        {\n            auto [num, cnt] = st.top();\n            st.pop();\n            tmpsum -= power(mint(2), cnt) * num;\n            tmpsum += num;\n            k += cnt;\n        }\n        st.push({a[i], k});\n        tmpsum += mint(a[i]) * power(mint(2), k);\n        cout << tmpsum << \" \";\n    }\n    cout << endl;\n    return;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 2. 数学\n\n### 0. Modint.h\n\n```cpp\n#ifndef __MODINT_H__\n\n#define __MODINT_H__\n\nusing i64 = long long;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nnamespace Modint\n{\n    template <class T>\n    constexpr T power(T a, i64 b)\n    {\n        T res = 1;\n        for (; b; b /= 2, a *= a)\n        {\n            if (b % 2)\n            {\n                res *= a;\n            }\n        }\n        return res;\n    }\n\n    constexpr i64 mul(i64 a, i64 b, i64 p)\n    {\n        i64 res = a * b - (i64)(1.L * a * b / p) * p;\n        res %= p;\n        if (res < 0)\n        {\n            res += p;\n        }\n        return res;\n    }\n    /*\n     * @brief 模运算（i64），jiangly版本，支持动态模数改变\n     * @param P 模数，仅支持质数。如果选择动态定义模数，P=0，且必须调用setMod函数设置模数。默认为1e18+9\n     */\n    template <i64 P>\n    struct MLong\n    {\n        i64 x;\n        constexpr MLong() : x{} {}\n        constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n\n        static i64 Mod;\n        constexpr static i64 getMod()\n        {\n            if (P > 0)\n            {\n                return P;\n            }\n            else\n            {\n                return Mod;\n            }\n        }\n        constexpr static void setMod(i64 Mod_)\n        {\n            Mod = Mod_;\n        }\n        constexpr i64 norm(i64 x) const\n        {\n            if (x < 0)\n            {\n                x += getMod();\n            }\n            if (x >= getMod())\n            {\n                x -= getMod();\n            }\n            return x;\n        }\n        constexpr i64 val() const\n        {\n            return x;\n        }\n        explicit constexpr operator i64() const\n        {\n            return x;\n        }\n        constexpr MLong operator-() const\n        {\n            MLong res;\n            res.x = norm(getMod() - x);\n            return res;\n        }\n        constexpr MLong inv() const\n        {\n            assert(x != 0);\n            return power(*this, getMod() - 2);\n        }\n        constexpr MLong &operator*=(MLong rhs) &\n        {\n            x = mul(x, rhs.x, getMod());\n            return *this;\n        }\n        constexpr MLong &operator+=(MLong rhs) &\n        {\n            x = norm(x + rhs.x);\n            return *this;\n        }\n        constexpr MLong &operator-=(MLong rhs) &\n        {\n            x = norm(x - rhs.x);\n            return *this;\n        }\n        constexpr MLong &operator/=(MLong rhs) &\n        {\n            return *this *= rhs.inv();\n        }\n        friend constexpr MLong operator*(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res *= rhs;\n            return res;\n        }\n        friend constexpr MLong operator+(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res += rhs;\n            return res;\n        }\n        friend constexpr MLong operator-(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res -= rhs;\n            return res;\n        }\n        friend constexpr MLong operator/(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res /= rhs;\n            return res;\n        }\n        friend constexpr std::istream &operator>>(std::istream &is, MLong &a)\n        {\n            i64 v;\n            is >> v;\n            a = MLong(v);\n            return is;\n        }\n        friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a)\n        {\n            return os << a.val();\n        }\n        friend constexpr bool operator==(MLong lhs, MLong rhs)\n        {\n            return lhs.val() == rhs.val();\n        }\n        friend constexpr bool operator!=(MLong lhs, MLong rhs)\n        {\n            return lhs.val() != rhs.val();\n        }\n    };\n\n    template <>\n    i64 MLong<0LL>::Mod = (i64)(1E18) + 9;\n\n    /*template <i64 V, i64 P>\n    constexpr MLong<P> CInv = MLong<P>(V).inv();*/\n\n    /*\n     * @brief 模运算（int），jiangly版本，支持动态模数改变\n     * @param P 模数，仅支持质数。如果选择动态定义模数，P=0，且必须调用setMod函数设置模数。默认为998244353\n     */\n    template <int P>\n    struct MInt\n    {\n        int x;\n        constexpr MInt() : x{} {}\n        constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n\n        static int Mod;\n        constexpr static int getMod()\n        {\n            if (P > 0)\n            {\n                return P;\n            }\n            else\n            {\n                return Mod;\n            }\n        }\n        constexpr static void setMod(int Mod_)\n        {\n            Mod = Mod_;\n        }\n        constexpr int norm(int x) const\n        {\n            if (x < 0)\n            {\n                x += getMod();\n            }\n            if (x >= getMod())\n            {\n                x -= getMod();\n            }\n            return x;\n        }\n        constexpr int val() const\n        {\n            return x;\n        }\n        explicit constexpr operator int() const\n        {\n            return x;\n        }\n        constexpr MInt operator-() const\n        {\n            MInt res;\n            res.x = norm(getMod() - x);\n            return res;\n        }\n        constexpr MInt inv() const\n        {\n            assert(x != 0);\n            return power(*this, getMod() - 2);\n        }\n        constexpr MInt &operator*=(MInt rhs) &\n        {\n            x = 1LL * x * rhs.x % getMod();\n            return *this;\n        }\n        constexpr MInt &operator+=(MInt rhs) &\n        {\n            x = norm(x + rhs.x);\n            return *this;\n        }\n        constexpr MInt &operator-=(MInt rhs) &\n        {\n            x = norm(x - rhs.x);\n            return *this;\n        }\n        constexpr MInt &operator/=(MInt rhs) &\n        {\n            return *this *= rhs.inv();\n        }\n        friend constexpr MInt operator*(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res *= rhs;\n            return res;\n        }\n        friend constexpr MInt operator+(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res += rhs;\n            return res;\n        }\n        friend constexpr MInt operator-(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res -= rhs;\n            return res;\n        }\n        friend constexpr MInt operator/(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res /= rhs;\n            return res;\n        }\n        friend constexpr std::istream &operator>>(std::istream &is, MInt &a)\n        {\n            i64 v;\n            is >> v;\n            a = MInt(v);\n            return is;\n        }\n        friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a)\n        {\n            return os << a.val();\n        }\n        friend constexpr bool operator==(MInt lhs, MInt rhs)\n        {\n            return lhs.val() == rhs.val();\n        }\n        friend constexpr bool operator!=(MInt lhs, MInt rhs)\n        {\n            return lhs.val() != rhs.val();\n        }\n    };\n\n    template <>\n    int MInt<0>::Mod = 998244353;\n\n    // 逆元\n    template <int V, int P>\n    constexpr MInt<P> CInv = MInt<P>(V).inv();\n    /*\n     * @brief 阶乘类(适配Jiangly模板），支持计算组合数，排列数等操作，复杂度O(n),配套jiangly版本的模运算类\n     * @brief 小数据时需要组合数建议使用组合数表（杨辉三角），大数据时需要组合数建议使用Lucas定理\n     * @param MOD 模数，一般取质数，部分合数情况下可能没有逆元。\n     * @note 支持计算组合数，可以使用C(n,k)计算组合数。\n     * @note 支持计算排列数，可以使用A(n,k)计算排列数。\n     */\n    template <class T>\n    struct Fact\n    {\n        std::vector<T> fact, factinv;\n        const int n;\n        Fact(const int &_n) : n(_n), fact(_n + 1, 1), factinv(_n + 1)\n        {\n            for (int i = 1; i <= n; ++i)\n                fact[i] = fact[i - 1] * i;\n            factinv[n] = fact[n].inv();\n            for (int i = n; i; --i)\n                factinv[i - 1] = factinv[i] * i;\n        }\n        T C(const int &n, const int &k)\n        {\n            if (n < 0 || k < 0 || n < k)\n                return 0;\n            return fact[n] * factinv[k] * factinv[n - k];\n        }\n        T A(const int &n, const int &k)\n        {\n            if (n < 0 || k < 0 || n < k)\n                return 0;\n            return fact[n] * factinv[n - k];\n        }\n    };\n};\n\n#endif //__MODINT_H__\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1. 数论相关\n\n#### 1.1 大质数判定（Miller-Rabin素性测试）\n\n以$O(logN)$复杂度，以较高正确性判定质数。\n\n```cpp\n#define i64 long long\n    i64 mul(i64 a, i64 b, i64 m)\n    {\n        return static_cast<__int128>(a) * b % m;\n    }\n    i64 power(i64 a, i64 b, i64 m)\n    {\n        i64 res = 1 % m;\n        for (; b; b >>= 1, a = mul(a, a, m))\n            if (b & 1)\n                res = mul(res, a, m);\n        return res;\n    }\n    /* @brief Miller-Rabin 素性测试,时间复杂度为 O(log n)\n     * @param n 待测试的数，不大于 1e18\n     * @return true 为素数，false 为合数*/\n    bool isprime(i64 n)\n    {\n        if (n < 2)\n            return false;\n        static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n        int s = __builtin_ctzll(n - 1);\n        i64 d = (n - 1) >> s;\n        for (auto a : A)\n        {\n            if (a == n)\n                return true;\n            i64 x = power(a, d, n);\n            if (x == 1 || x == n - 1)\n                continue;\n            bool ok = false;\n            for (int i = 0; i < s - 1; ++i)\n            {\n                x = mul(x, x, n);\n                if (x == n - 1)\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n        return true;\n    }\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.2 质因数分解\n\n##### 1.2.1  小数字质因数分解\n\n以$O(N\\sqrt N)$复杂度分解质因数。\n\n```cpp\nvector<int> breakdown(int N) {\n  vector<int> result;\n  for (int i = 2; i * i <= N; i++) {\n    if (N % i == 0) {  // 如果 i 能够整除 N，说明 i 为 N 的一个质因子。\n      while (N % i == 0) N /= i;\n      result.push_back(i);\n    }\n  }\n  if (N != 1) {  // 说明再经过操作之后 N 留下了一个素数\n    result.push_back(N);\n  }\n  return result;\n}\n```\n\n##### 1.2.2 大质数质因数分解（Pollar-Rho算法）\n\n以期望复杂度$O(N^{\\frac{1}{4}})$复杂度分解质因数。\n\n```cpp\nnamespace Prime\n{\nusing i64=long long;\n    i64 mul(i64 a, i64 b, i64 m)\n    {\n        return static_cast<__int128>(a) * b % m;\n    }\n    i64 power(i64 a, i64 b, i64 m)\n    {\n        i64 res = 1 % m;\n        for (; b; b >>= 1, a = mul(a, a, m))\n            if (b & 1)\n                res = mul(res, a, m);\n        return res;\n    }\n    /* @brief Miller-Rabin 素性测试,时间复杂度为 O(log n)\n     * @param n 待测试的数，不大于 1e18\n     * @return true 为素数，false 为合数\n     */\n    bool isprime(i64 n)\n    {\n        if (n < 2)\n            return false;\n        static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n        int s = __builtin_ctzll(n - 1);\n        i64 d = (n - 1) >> s;\n        for (auto a : A)\n        {\n            if (a == n)\n                return true;\n            i64 x = power(a, d, n);\n            if (x == 1 || x == n - 1)\n                continue;\n            bool ok = false;\n            for (int i = 0; i < s - 1; ++i)\n            {\n                x = mul(x, x, n);\n                if (x == n - 1)\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n        return true;\n    }\n    /* @brief 素因子分解（Pollard-Rho 算法）,时间复杂度期望为 O(n^(1/4))，最坏为 O(n^(1/2))，本函数复杂度带排序，具体复杂度待定，可估算为亚线性\n     * @param n 待分解的数，不大于 1e18\n     * @return 一个 vector，包含了 n 的所有素因子，按照从小到大的顺序排列，包括重复的\n     */\n    std::vector<i64> factorize(i64 n)\n    {\n        std::vector<i64> p;\n        std::function<void(i64)> f = [&](i64 n)\n        {\n            if (n <= 10000)\n            {\n                for (int i = 2; i * i <= n; ++i)\n                    for (; n % i == 0; n /= i)\n                        p.push_back(i);\n                if (n > 1)\n                    p.push_back(n);\n                return;\n            }\n            if (isprime(n))\n            {\n                p.push_back(n);\n                return;\n            }\n            auto g = [&](i64 x)\n            {\n                return (mul(x, x, n) + 1) % n;\n            };\n            i64 x0 = 2;\n            while (true)\n            {\n                i64 x = x0;\n                i64 y = x0;\n                i64 d = 1;\n                i64 power = 1, lam = 0;\n                i64 v = 1;\n                while (d == 1)\n                {\n                    y = g(y);\n                    ++lam;\n                    v = mul(v, std::abs(x - y), n);\n                    if (lam % 127 == 0)\n                    {\n                        d = std::gcd(v, n);\n                        v = 1;\n                    }\n\n                    if (power == lam)\n                    {\n                        x = y;\n                        power *= 2;\n                        lam = 0;\n                        d = std::gcd(v, n);\n                        v = 1;\n                    }\n                }\n                if (d != n)\n                {\n                    f(d);\n                    f(n / d);\n                    return;\n                }\n                ++x0;\n            }\n        };\n        f(n);\n        std::sort(p.begin(), p.end());\n        return p;\n    }\n    /*\n     * @brief 素因子分解（Pollard-Rho 算法）\n     * @param n 待分解的数，不大于 1e18\n     * @return 一个 vector，包含了 n 的所有素因子，按照从小到大的顺序排列，first 为素因子，second 为指数\n     */\n    std::vector<std::pair<i64, i64>> factorize_pairs(i64 n)\n    {\n        std::vector<i64> p = factorize(n);\n        std::vector<std::pair<i64, i64>> res;\n        for (auto i : p)\n        {\n            if (res.empty() || res.back().first != i)\n                res.emplace_back(i, 1);\n            else\n                res.back().second++;\n        }\n        return res;\n    }\n    void dfs(int p, i64 n, std::vector<std::pair<i64, i64>> &ps, std::vector<i64> &ds)\n    {\n        if (p == ps.size())\n        {\n            if (n > 1)\n            {\n                ds.push_back(n);\n            }\n            return;\n        }\n        for (i64 i = 0; i <= ps[p].second; i++)\n        {\n            dfs(p + 1, n, ps, ds);\n            n *= ps[p].first;\n        }\n        return;\n    }\n    /*\n     * @brief 因数集合(不含1,Pollard-Rho 算法质因数分解)\n     * @param n 待考察的数，不大于 1e18\n     * @return 一个 vector，包含了 n 的因子，按照从小到大的顺序排列。不含1。\n     */\n    std::vector<i64> getd(i64 n)\n    {\n        std::vector<std::pair<i64, i64>> p = factorize_pairs(n);\n        std::vector<i64> d;\n        dfs(0, 1, p, d);\n        std::sort(d.begin(), d.end());\n        return d;\n    }\n\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.3 基于值域处理的快速GCD\n\n你需要解决以下问题：\n\n以$O(1)$的单次询问复杂度、$O(n)$的总时间复杂度回答$\\forall x,y\\in[1,n],gcd(x,y)=?$\n\n操作方法：\n\n将任意$x$分解成三个数的乘积$a\\times b\\times c$，则显然$a,b,c\\le \\sqrt n$.\n\n考虑线筛，若 $x$ 为质数，显然 $(1,1,x)$它的一个分解；\n\n若 $x$ 为合数，设 $p$ 是 $x$ 的最小质因子， $(a_0,b_0,c_0)$ 是 $\\frac{x}{p}$ 的一个分解；\n\n则显然有$(a_0p,b_0,c_0)$排序后是一个从小到大的分解。\n\n若求$gcd(x,y)$，设$x=a\\times b\\times c$. 勒令$p_1=y,r_1=gcd(a,p_1)$​.\n\n勒令$p_2=\\frac{p_1}{r_1}$，$r_2=gcd(b,p_2)$；$p_3=\\frac{p_2}{r_2}$，$r_3=gcd(c,p_3)$.\n\n则有$gcd(x,y)=r_1r_2r_3.$\n\n原理为$gcd(x,y)=rgcd(x/r,y/r)\\quad iff\\quad r|x,r|y$\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e6 + 1;\nconst int maxn = 5001;\nvector<array<int, 3>> v(INF + 10);\nbool vis[INF + 10];\nint prime[INF + 10];\nvoid euler()\n{\n    v[1] = {1, 1, 1};\n    for (int i = 2; i <= INF; i++)\n    {\n        if (!vis[i])\n        {\n            vis[i] = 1;\n            prime[++prime[0]] = i;\n            v[i] = {1, 1, i};\n        }\n        for (int j = 1; j <= prime[0] && i * prime[j] <= INF; j++)\n        {\n            int k = i * prime[j];\n            vis[k] = 1;\n            v[k] = {v[i][0] * prime[j], v[i][1], v[i][2]};\n            sort(v[k].begin(), v[k].end());\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nint gcds[1010][1010];\nvoid init()\n{\n    gcds[0][0] = 0;\n    for (int i = 1; i <= 1000; i++)\n    {\n        gcds[i][0] = gcds[0][i] = i;\n        for (int j = 1; j <= i; j++)\n        {\n            gcds[i][j] = gcds[j][i] = gcds[j][i % j];\n        }\n    }\n}\nint Gcd(int a, int b)\n{\n    int ret = 1;\n    for (int i = 0, r; i < 3; i++)\n    {\n        if (v[a][i] > 1e3)\n        {\n            if (b % v[a][i])\n                r = 1;\n            else\n                r = v[a][i];\n        }\n        else\n            r = gcds[v[a][i]][b % v[a][i]];\n        b /= r;\n        ret = ret * r;\n    }\n    return ret;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.4 扩展欧几里得定理\n\n可求出方程$ax+by=gcd(a,b)$的一组特解。该方程通解为：\n$$\n\\left\\{\n\\begin{aligned}\nx=x^{'}+k\\frac{b}{gcd(a,b)}&\\\\\n\\\\&,k\\in Z\\\\\ny=y^{'}-k\\frac{a}{gcd(a,b)}\\\\\n\\end{aligned}\n\\right.\n$$\n取最小的非负解，`x=(x%s+s)%s`。\n\n```cpp\nvoid exgcd(int a, int b, int &x, int &y)\n{\n    if (b == 0)\n    {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.5 积性函数线性筛（欧拉函数筛）\n\n如果一个积性函数能够满足以下三条性质：\n\n1. $f(p)可O(1)查询$\n2. 若$gcd(n,m)=1$，则$\\varphi(nm)=\\varphi(n)\\varphi(m)$\n3. 若$n\\mid m$,则$\\varphi(nm)可积性转移$（即递推公式只含有乘法）\n\n则均可使用线性筛实现线性求解。\n\n***筛法求欧拉函数：***\n\n```cpp\nint prime[maxn];\nbool vis[maxn];//初始0，标记合数\nint phi[maxn];\nvoid euler(int n)\n{\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i])prime[++prime[0]]=i,phi[i]=i-1;\\\\性质1\n        for(int j=1;j<=prime[0]&&i*prime[j]<=n;j++)\n        {\n            vis[i*prime[j]]=true;\\\\筛去合数\n            if(i%prime[j]==0)\n            {\n                phi[i*prime[j]]=prime[j]*phi[i];\\\\性质3\n                break;\n            }\n            phi[i*prime[j]]=phi[prime[j]]*phi[i];\\\\性质2\n        }\n    }\n}\n```\n\n***因数个数筛：***\n\n```cpp\nstruct pre\n{\n    int n;\n    vector<int> d;\n    vector<int> num;\n    vector<bool> vis;\n    vector<int> prime;\n    void init(int _n)\n    {\n        n = _n;\n        d.resize(n + 1);\n        num.resize(n + 1);\n        vis.resize(n + 1);\n    }\n    void did()\n    {\n        d[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            if (!vis[i])\n            {\n                prime.push_back(i);\n                d[i] = 2;\n                num[i] = 1;\n            }\n            for (int j = 0; j < prime.size() && i * prime[j] <= n; j++)\n            {\n                vis[i * prime[j]] = 1;\n                if (i % prime[j] == 0)\n                {\n                    num[i * prime[j]] = num[i] + 1;\n                    d[i * prime[j]] = d[i] / (num[i * prime[j]]) * (num[i * prime[j]] + 1);\n                    break;\n                }\n                num[i * prime[j]] = 1;\n                d[i * prime[j]] = d[i] * 2;\n            }\n        }\n    }\n    int qs(int x)\n    {\n        return d[x];\n    }\n};\n```\n\n若函数$f(n)$满足$f(1)=1$且$\\forall x,y\\in N^*,gcd(x,y)=1$都有$f(xy)=f(x)f(y)$，则$f(n)$​为积性函数。\n\n特别的，若$\\forall x,y\\in N^*$都有$f(xy)=f(x)f(y)$​​​,则称作完全积性函数。\n\n若$f(x)$和$g(x)$均为积性函数，那么下列函数也称作积性函数：\n$$\n\\begin{align}\n&h(x)=f(x^p)\\\\\n&h(x)=f^p(x)\\\\\n&h(x)=f(x)g(x)\\\\\n&h(x)=\\sum_{d\\mid x}f(d)g(\\frac{x}{d})\\\\\n\\end{align}\n$$\n设质因数分解$x=\\prod_{i=1}^{n}p_i^{k_i}$，则\n\n若$F(x)$为积性函数，则$F(x)=\\prod_{i=1}^{n}f(p_i^k)$\n\n若$F(x)$为完全积性函数，则$F(x)=\\prod_{i=1}^{n}f(p_i^k)=\\prod_{i=1}^{n}f^k(p_i)$​\n\n（因为质数和其自己的$gcd$​并不是1而是其本身）\n\n常见积性函数:\n\n1. 欧拉函数$\\varphi(n)=\\sum_{i=1}^{n}[gcd(i,n)=1]$.\n\n2. 除数函数$\\sigma_k(n)=\\sum_{d\\mid n}d^k,k\\in N.$\n\n   （特别的，$\\sigma_0(n)$又记作$d(n)$，表示除数的个数。$\\sigma_1(n)$又记作$\\sigma(n)$​​，表示因数和）\n\n二者均为非完全积性函数。\n\n3. 莫比乌斯函数\n\n$$\n\\begin{align}\\mu(n)=\\left\\{\n\\begin{aligned}\n&\\quad \\ -1\\qquad \\quad \\ \\ iff\\ \\ n\\ is\\ a\\ prime \\\\\n&\\qquad 0\\qquad \\qquad n^{'}\\;mod\\;p1=0\\\\\n&-\\mu(n^{'})\\qquad \\quad otherwise\n\\end{aligned}\n\\right.\n&,n=p_1\\cdot n^{'}\n\\end{align}\n$$\n\n4. 欧拉函数$\\varphi(n)=\\sum_{i=1}^{n}[gcd(i,n)=1]$\n\n   通解公式\n\n$$\n\\varphi(x)=x\\prod_{i=1}^{n}(1-\\frac{1}{p_i})\\,\\,\\,\\,,\\,\\,\\,x=\\prod_{i=1}^{n}p_i^{k_i}\n$$\n   性质\n1. $\\varphi(p)=p-1$\n2. $\\varphi(p^k)=p^{k-1}\\varphi(p)$\n3. 若$gcd(n,m)=1$，则$\\varphi(nm)=\\varphi(n)\\varphi(m)$\n4. 若$n\\mid m$,则$\\varphi(nm)=n\\varphi(m)$​\n\n仔细观察不难发现2是4的子集关系，故性质1、3、4称作欧拉函数三性质，简称欧拉函数性。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.6 裴蜀定理\n\n$$\n\\begin{aligned}\n&设不全为0的整数a,b，对于任意整数x,y有\\\\\n\\\\\n&\\qquad gcd(a,b)|(ax+by)\\\\\n\\\\\n&且一定存在整数解x_0,y_0使得下列方程成立\\\\\n\\\\\n&\\qquad ax_0+by_0=gcd(a,b)\n\\end{aligned}\n$$\n\n\n\n上述情形可以推广到任意多变量。\n\n#### 1.7 扩展欧拉定理\n\n$$\na^b\\equiv \n\\left \\{\n\\begin{aligned}\n&a^{b\\ mod\\ \\varphi(m)}\\qquad \\qquad gcd(a,m)=1\\\\\n&a^b \\qquad\\qquad\\qquad\\quad\\ gcd(a,m)\\neq1,b<\\varphi(m)\\\\\n&a^{(b\\ mod\\ \\varphi(m))+\\varphi(m)} \\quad \\ gcd(a,m)\\neq1,b\\geq\\varphi(m)\n\\end{aligned}\n\\right.\\quad (mod\\ m)\n$$\n\n\n\n#### 1.8 乘法逆元\n\n线性逆元：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod;\nconst int maxn = 6e6 + 9;\nint inv[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a;\n    cin >> a >> mod;\n    inv[1] = 1;\n    cout << 1 << endl;\n    for (int i = 2; i <= a; i++)\n    {\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n        cout << inv[i] << endl;\n    }\n}\n```\n\n快速幂逆元（费马小定理）：\n$$\n对于任意正整数a，\\exists p满足gcd(a,p)=1,则必然有以下同余式成立:\\\\\na^{p-1} \\equiv1\\ (mod \\; n)\n$$\n\n```cpp\nquickpow(a,mod-2);\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.9 中国剩余定理\n\n给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。\n$$\n\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}\n$$\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^5$，$1 \\le b_i,a_i \\le {10}^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。不保证$b$为质数\n\n**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint quickmul(int a, int b, int mod)\n{\n    while (a < 0)\n        a += mod;\n    while (b < 0)\n        b += mod;\n    if (a < b)\n        swap(a, b);\n    int e = 0;\n    while (b)\n    {\n        if (b & 1)\n            (e += a) %= mod;\n        (a <<= 1) %= mod;\n        b >>= 1;\n    }\n    return e;\n}\nvoid exgcd(int a, int b, int &x, int &y)\n{\n    if (b == 0)\n    {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n}\nconst int maxn = 500001;\nint a[maxn], m[maxn]; // 对m取模余数是a\nint n;\nint ExCRT()\n{\n    int mod = m[1], ans = a[1];\n    for (int i = 2; i <= n; i++)\n    {\n        int b1 = mod, b2 = m[i], c = __gcd(b1, b2), minus = (a[i] - ans % b2 + b2) % b2;\n        if (minus % c != 0)\n            return -1;\n        b1 /= c, b2 /= c, minus /= c;\n        int x, y;\n        exgcd(b1, b2, x, y);\n        x = quickmul(x, minus, b2);\n        ans += x * mod;\n        mod *= b2;\n        ans = (ans % mod + mod) % mod;\n    }\n    return ans;\n}\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> m[i] >> a[i];\n    }\n    cout << ExCRT() << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.10 离散对数\n\n##### 1.10.1 原根\n\n满足$a^n\\equiv 1\\ (mod \\ m),gcd(a,m)=1$的最小正整数$n$存在，称$n$为$a$的阶，记作$\\delta_m(a)$。\n\n给定$m$，若$gcd(g,m)=1$且$\\delta_m(g)=\\varphi(m)$，则称$g$为$m$的一个原根（循环群的生成元）。\n\n详细见$OI-Wiki$\n\n##### 1.10.2 离散对数\n\n定义$a^x\\equiv b\\ (mod\\ m)$，$a$为$m$的一个原根时，记$x=ind_ab$，称作$b$关于$m$的离散对数。\n\n##### 1.10.3 ExBSGS算法\n\n给定 $a,p,b$，求满足 $a^x≡b \\pmod p$ 的最小自然数 $x$ 。如果无解，输出 `No Solution`，否则输出最小自然数解。\n\n对于 $100\\%$ 的数据，$1\\le a,p,b≤10^9$ 或 $a=p=b=0$。$\\sum \\sqrt p\\le 5\\times 10^6$​。\n\n原理：搞到和BSGS算法一致，通过$a \\equiv b \\ (mod\\ c) \\iff a\\times d\\equiv b\\times d\\ (mod\\ c\\times d)$\n\n每次在两边除以 $d=gcd(a,p)$，得到$\\frac{a}{d}\\times a^{x-1}\\equiv\\frac{b}{d}\\ (mod\\ \\frac{p}{d})$\n\n重复执行该语段，直到$gcd(a,p)=1$ 为止。\n\n然后上$BSGS$根号暴力分治算，复杂度$O(\\sqrt {\\varphi(p)})$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int BSGS(int a, int n, int p, int ad = 1) // ad*(a^x)=n(mod p)\n{\n    unordered_map<int, int> mp;\n    int m = ceil(sqrt(p));\n    int s = 1;\n    for (int i = 0; i < m; i++, s = 1ll * s * a % p)\n        mp[1ll * s * n % p] = i;\n    for (int i = 0, tmp = s, s = ad; i <= m; i++, s = 1ll * s * tmp % p)\n        if (mp.find(s) != mp.end())\n            if (1ll * i * m - mp[s] >= 0)\n                return 1ll * i * m - mp[s];\n    return -1;\n}\ninline int exBSGS(int a, int n, int p)\n{\n    a %= p;\n    n %= p;\n    if (n == 1 || p == 1)\n        return 0;\n    int cnt = 0;\n    int d, ad = 1;\n    while ((d = gcd(a, p)) ^ 1)\n    {\n        if (n % d)\n            return -1;\n        cnt++;\n        n /= d;\n        p /= d;\n        ad = (1ll * ad * a / d) % p;\n        if (ad == n)\n            return cnt;\n    }\n    int ans = BSGS(a, n, p, ad);\n    if (ans == -1)\n        return -1;\n    return ans + cnt;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, p, n;\n    while (cin >> a >> p >> n)\n    {\n        if (!a && !p && !n)\n            break;\n        int ans = exBSGS(a, n, p);\n        if (~ans)\n            cout << ans << \"\\n\";\n        else\n            cout << \"No Solution\" << \"\\n\";\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.11 二次剩余（奇素数）\n\n给出 $N,p$，求解方程 \n\n$$\nx^2 \\equiv N \\pmod{p}\n$$\n\n多组数据，**且保证 $p$ 是奇素数。**\n\n输出共 $T$ 行。\n\n对于每一行输出，若有解，则按 $\\bmod ~p$ 后递增的顺序输出在 $\\bmod~ p$ 意义下的全部解；若两解相同，只输出其中一个；若无解，则输出 `Hola!` 。\n\n对于 $100\\%$ 的数据，$1\\leq T\\leq 10^4,0\\le N, p\\leq 10^9+9$​。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nrandom_device rd;\nmt19937 ran(rd());\nstruct num\n{\n    ll x; // 实部\n    ll y; // 虚部(即虚数单位√w的系数)\n};\n\nll t, w, n, p;\n\nnum mul(num a, num b, ll p)\n{ // 复数乘法\n    num res;\n    res.x = ((a.x * b.x % p + a.y * b.y % p * w % p) % p + p) % p; // x = a.x*b.x + a.y*b.y*w\n    res.y = ((a.x * b.y % p + a.y * b.x % p) % p + p) % p;         // y = a.x*b.y + a.y*b.x\n    return res;\n}\nll qpow_r(ll a, ll b, ll p)\n{ // 实数快速幂\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = res * a % p;\n        a = a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\nll qpow_i(num a, ll b, ll p)\n{ // 复数快速幂\n    num res = {1, 0};\n    while (b)\n    {\n        if (b & 1)\n            res = mul(res, a, p);\n        a = mul(a, a, p);\n        b >>= 1;\n    }\n    return res.x % p; // 只用返回实数部分，因为虚数部分没了\n}\nll cipolla(ll n, ll p)\n{\n    n %= p;\n    if (qpow_r(n, (p - 1) / 2, p) == -1 + p)\n        return -1; // 据欧拉准则判定是否有解\n    ll a;\n    while (1)\n    { // 找出一个符合条件的a\n        a = ran() % p;\n        w = (((a * a) % p - n) % p + p) % p; // w = a^2 - n，虚数单位的平方\n        if (qpow_r(w, (p - 1) / 2, p) == -1 + p)\n            break;\n    }\n    num x = {a, 1};\n    return qpow_i(x, (p + 1) / 2, p);\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> p;\n        if (!n)\n        {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        ll ans1 = cipolla(n, p), ans2 = -ans1 + p; // 另一个解就是其相反数\n        if (ans1 == -1)\n            cout << \"Hola!\\n\";\n        else\n        {\n            if (ans1 > ans2)\n                swap(ans1, ans2);\n            if (ans1 == ans2)\n                cout << ans1 << \"\\n\";\n            else\n                cout << ans1 << \" \" << ans2 << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.12 数论分块\n\n以期望复杂度$O(\\sqrt x)$的复杂度求解$F(x)=\\sum_{i=1}^ng(\\lfloor\\frac{x}i\\rfloor)$。\n\n分块理论：如果$\\lfloor\\frac{x}{i}\\rfloor=\\lfloor\\frac{x}{j}\\rfloor$，则有该块的分块区间为$\\large [i,\\lfloor\\frac{x}{\\lfloor\\frac{x}{i}\\rfloor}\\rfloor]$​\n\n原理：$\\lfloor\\frac{x}{ab}\\rfloor=\\lfloor\\frac{\\lfloor\\frac{x}{a}\\rfloor}{b}\\rfloor$\n\n```cpp\nlong long H(int n) {\n  long long res = 0;  // 储存结果\n  int l = 1, r;       // 块左端点与右端点\n  while (l <= n) {\n    r = n / (n / l);  // 计算当前块的右端点\n    // 累加这一块的贡献到结果中。乘上 1LL 防止溢出\n    res += 1LL * (r - l + 1) * (n / l);\n    l = r + 1;  // 左端点移到下一块\n  }\n  return res;\n}\n```\n\n如果是向上取整分块$F(x)=\\sum_{i=1}^ng(\\lceil\\frac{x}i\\rceil)$，则有如果$\\lceil\\frac{x}{i}\\rceil=\\lceil\\frac{x}{j}\\rceil$，则有该块的分块区间为$\\large [i,\\lceil\\frac{x}{\\lceil\\frac{x-1}{i}\\rceil}\\rceil]$。注意特殊处理$i\\ge x$的情况，此时分块右端点分母为$0$.注意右边界的写法。\n\n```cpp\nauto calc = [&](auto self, int x) -> i64\n    {\n        if (mp.count(x))\n            return mp[x];\n        i64 res = 0;\n        int i = 2;\n        while (i <= n)\n        {\n            int invr = (x - 1) / i;\n            int r = n;\n            if (invr != 0)                  // 分块防0\n                r = min(r, (x - 1) / invr); // 注意分块值域不要超过你求和式的上界\n            res = (res + (r - i + 1) * self(self, (x + i - 1) / i) % mod) % mod;\n            i = r + 1;\n        }\n        res = (res * inv) % mod;\n        res = (res + n * inv % mod) % mod;\n        return mp[x] = res;\n    };\n```\n\n\n\n\n\n### 2. 线性代数相关\n\n#### 2.1 矩阵快速幂\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nconst int mod = 1e9 + 7;\nusing mint = MInt<mod>;\nvector<vector<mint>> operator*(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n    vector<vector<mint>> c(a.size(), vector<mint>(a.size(), 0));\n    int n = a.size();\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            for (int k = 0; k < n; k++)\n            {\n                c[i][j] += (a[i][k] * b[k][j]);\n            }\n        }\n    }\n    return c;\n}\nvoid solve()\n{\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<vector<mint>> E(n, vector<mint>(n, 0));\n    vector<vector<mint>> A = E;\n    for (int i = 0; i < n; i++)\n        E[i][i] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> A[i][j];\n        }\n    }\n    while (k)\n    {\n        if (k & 1)\n            E = E * A;\n        A = A * A;\n        k >>= 1;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << E[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    // cin >> t;\n    // while (t--)\n    solve();\n}\n```\n\n#### 2.2 矩阵数列递推\n\n对数列递推式子列矩阵方程就行。最著名的就是feibonacci数列：\n$$\n\\pmatrix{f_n\\\\f_{n-1}} =\\pmatrix{1\\ 1\\\\1 \\ 0}\\pmatrix{f_{ n-1}\\\\f_{n-2}}\n$$\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.3 矩阵求逆/高斯消元(仅可求唯一解)\n\n求矩阵的逆矩阵，无解判定矩阵非满秩矩阵，等价于解线性方程组。使用高斯消元法即可。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\n#define endl '\\n'\nconst int P = 1e9 + 7;\nint power(int a, int b, int mod)\n{\n    int res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = (1ll * res * a) % mod;\n        a = (1ll * a * a) % mod;\n        b >>= 1;\n    }\n    return res % mod;\n}\nstd::vector<int> gauss(std::vector<std::vector<int>> a, std::vector<int> b)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (a[r][i] == 0)\n            ++r;\n        std::swap(a[i], a[r]);\n        std::swap(b[i], b[r]);\n        int inv = power(a[i][i], P - 2, P);\n        for (int j = i; j < n; ++j)\n            a[i][j] = 1ll * a[i][j] * inv % P;\n        b[i] = 1ll * b[i] * inv % P;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            int x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] = (a[j][k] + 1ll * (P - x) * a[i][k]) % P;\n            b[j] = (b[j] + 1ll * (P - x) * b[i]) % P;\n        }\n    }\n    return b;\n}\n/**   高斯消元法（gaussian elimination）【久远】\n *    2020-12-02: https://www.codechef.com/viewsolution/39942900\n **/\nstd::vector<double> gauss(std::vector<std::vector<double>> a, std::vector<double> b, int &rank)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (r < n && a[r][i] == 0)\n            ++r;\n        if (r == n)\n            return b;\n        std::swap(a[i], a[r]);\n        std::swap(b[i], b[r]);\n        double x = a[i][i];\n        rank++;\n        for (int j = i; j < n; ++j)\n            a[i][j] /= x;\n        b[i] /= x;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] -= a[i][k] * x;\n            b[j] -= b[i] * x;\n        }\n    }\n    return b;\n}\nvector<vector<int>> invmatrix(vector<vector<int>> a, vector<vector<int>> b, int &rank)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (r < n && a[r][i] == 0)\n            ++r;\n        if (r == n)\n            break;\n        rank++;\n        swap(a[i], a[r]);\n        swap(b[i], b[r]);\n        int inv = power(a[i][i], P - 2, P);\n        for (int j = i; j < n; ++j)\n            a[i][j] = 1ll * a[i][j] * inv % P;\n        for (int k = 0; k < n; k++)\n            b[i][k] = 1ll * b[i][k] * inv % P;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            int x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] = (a[j][k] + 1ll * (P - x) * a[i][k]) % P;\n            for (int k = 0; k < n; k++)\n                b[j][k] = (b[j][k] + 1ll * (P - x) * b[i][k]) % P;\n        }\n    }\n    return b;\n}\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    vector<vector<int>> E(n, vector<int>(n));\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> a[i][j];\n            if (i == j)\n                E[i][j] = 1;\n        }\n    }\n    vector<vector<int>> A;\n    int rk = 0;\n    A = invmatrix(a, E, rk);\n    if (rk != n)\n    {\n        cout << \"No Solution\" << endl;\n        return;\n    }\n\n    for (auto &i : A)\n    {\n        for (auto &j : i)\n        {\n            cout << j << \" \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    // int t;\n    // cin >> t;\n    // while (t--)\n    solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.4 线性基\n\n不难发现，按位Bitwise Xor运算是一个针对MOD2剩余系向量空间加法运算，故存在代数线性基。\n\n线性空间$<Z_2^n,bitwise\\ Xor,bitwise\\ And>$为域空间。\n\n我们可以利用异或线性基实现：\n\n1. 判断一个数能否表示成某数集子集的异或和（已有集合元素是否能够构造出0）；\n\n2. 求一个数表示成某数集子集异或和的方案数；\n\n3. 求某数集子集的最大/最小/第$k$大/第$k$​小异或和；\n\n   如果说，线性基中异或的最大数（的二进制形式）是一串 **连续的，没有带后续$0$** 的$1$，那相信聪明的你一定会求第$k$大，因为第$k$大其实就是$k$。\n\n   现在相当于告诉你在这一串$1$中夹了很多$0$，问你第$k$大是多少。那么你其实可以不用管中间的$0$，把$k$的二进制形式弄出来，然后把中间省略$0$给插回去就好了。（因为最大值位是$0$的地方一辈子不可能出$1$）\n   解释一下就相当于把线性基异或后出来的最大值里的所有$1$都给挤到最后，然后求出第$k$大，再把你弄走的0给丢回去。\n\n   $eg:$异或后最大值为$101100110_2$，问第$20$大\n\n   挤到后面去后成$11111_2$，第$k$大是$10100_2$，把$0$插回去成为$100100000_2$，第20大便是$100100000_2$\n\n4. 求一个数在某数集子集异或和中的排名。\n\n线性基的独立性决定了一组异或为0的数无论以什么顺序插入最终线性基都不会允许这n个数同时插入线性基中，所以和线性基相关的贪心直接对权值排序后按顺序插入线性基就可以了。\n\n注意，线性基的插入是可重复贡献的，所以支持树上倍增$RMQ$，思想参考树上倍增lca查询和序列区间最大值查询。线性基的极大无关性保证任意一组线性基最多是$logn$​级别的，支持暴力合并。可以借助树上倍增实现树上查询问题。\n\n求$x\\rightarrow y$路径上的最大异或和，只需要四段彩色弧线段所代表的倍增线性基合并即可，这是$O(log^2n)$的单次询问。求$lca$方式的倍增跳是$O(log^3n)$的。\n\n![image-20241030231917971](C:\\Users\\栾津\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241030231917971.png)\n\n```cpp\nstruct LineBase\n{\nprivate:\n    const static int MN = 62;\n    i64 a[MN + 1], tmp[MN + 1];\n    bool flag; // 线性基中是否有重复插入的元素\n\npublic:\n    void insert(i64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                {\n                    a[i] = x;\n                    return;\n                }\n                else\n                    x ^= a[i];\n        flag = true;\n    }\n    bool check(i64 x) // 查看当前线性基中能否表示出来这个数(是否已插入)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                    return false;\n                else\n                    x ^= a[i];\n        return true;\n    }\n    i64 qmax(i64 res = 0)\n    {\n        for (int i = MN; ~i; i--)\n            res = max(res, res ^ a[i]);\n        return res;\n    }\n    i64 qmin()\n    {\n        if (flag) // 线性基有试图插入过相同的数，最小值为0\n            return 0;\n        for (int i = 0; i <= MN; i++)\n            if (a[i])\n                return a[i];\n    }\n    i64 query(i64 k) // 线性基下第k小\n    {\n        i64 res = 0;\n        int cnt = 0;\n        k -= flag; // 线性基有试图插入过相同的数，最小值为0\n        if (!k)\n            return 0;\n        for (int i = 0; i <= MN; i++)\n        {\n            for (int j = i - 1; ~j; j--)\n                if (a[i] & (1ll << j))\n                    a[i] ^= a[j];\n            if (a[i])\n                tmp[cnt++] = a[i];\n        } // 线性基重构\n        if (k >= (1ll << cnt))\n            return -1;\n        for (int i = 0; i < cnt; i++)\n            if (k & (1ll << i))\n                res ^= tmp[i];\n        return res;\n    }\n};\nLineBase lb;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n树上倍增查询路径max\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nusing u64 = unsigned long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nstruct LineBase\n{\nprivate:\n    const static int MN = 60;\n    array<u64, MN + 1> a;\n    bool flag;\n    friend LineBase merge(LineBase a, LineBase b);\n\npublic:\n    LineBase()\n    {\n        a.fill(0);\n    }\n    void ins(u64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                {\n                    a[i] = x;\n                    return;\n                }\n                else\n                    x ^= a[i];\n        flag = true;\n    }\n    bool check(u64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                    return false;\n                else\n                    x ^= a[i];\n        return true;\n    }\n    u64 qmax(u64 res = 0)\n    {\n        for (int i = MN; ~i; i--)\n            res = max(res, res ^ a[i]);\n        return res;\n    }\n    u64 qmin()\n    {\n        if (flag)\n            return 0;\n        for (int i = 0; i <= MN; i++)\n            if (a[i])\n                return a[i];\n    }\n\n    void merge(LineBase b)\n    {\n        for (int i = 0; i < b.MN; i++)\n        {\n            this->ins(b.a[i]);\n        }\n    }\n};\nLineBase merge(LineBase a, LineBase b)\n{\n    LineBase c = a;\n    for (int i = 0; i < b.MN; i++)\n    {\n        c.ins(b.a[i]);\n    }\n    return c;\n}\nstruct node\n{\n    int fa;\n    LineBase lb;\n};\nconst int maxn = 2e4 + 9;\nnode st[maxn][16];\nvector<int> con[maxn];\nvector<int> dep;\nvector<u64> num;\nvoid add_edge(int u, int v)\n{\n    con[u].push_back(v);\n    con[v].push_back(u);\n}\nvoid dfs(int u, int fa)\n{\n    st[u][0].fa = fa;\n    dep[u] = dep[fa] + 1;\n    st[u][0].lb.ins(num[u]);\n    st[u][0].lb.ins(num[fa]);\n    for (int j = 1; j <= 15; j++)\n    {\n        st[u][j].fa = st[st[u][j - 1].fa][j - 1].fa;\n        st[u][j].lb = merge(st[u][j - 1].lb, st[st[u][j - 1].fa][j - 1].lb);\n    }\n    for (auto v : con[u])\n    {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n    }\n    return;\n}\npair<int, LineBase> lca(int u, int v)\n{\n    if (dep[u] < dep[v])\n        swap(u, v);\n    int tmp = dep[u] - dep[v];\n    LineBase ans;\n    ans.ins(num[u]), ans.ins(num[v]);\n    for (int j = 0; j <= 15; j++)\n    {\n        if ((tmp >> j) & 1)\n            ans.merge(st[u][j].lb), u = st[u][j].fa;\n    }\n    if (u == v)\n        return {u, ans};\n    for (int j = 15; j >= 0; j--)\n    {\n        if (st[u][j].fa != st[v][j].fa)\n        {\n            ans.merge(st[u][j].lb);\n            ans.merge(st[v][j].lb);\n            u = st[u][j].fa, v = st[v][j].fa;\n        }\n    }\n    ans.merge(st[u][0].lb);\n    ans.merge(st[v][0].lb);\n    return {st[u][0].fa, ans};\n}\n\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    num.assign(n + 1, 0);\n    dep.assign(n + 1, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> num[i];\n    }\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    dfs(1, 1);\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v).second.qmax() << endl;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.5 二进制矩阵类Matrix.h\n\n这段代码定义了一个名为 `matrix_Z2_base` 的模板类，它用于表示和操作$<Z_2^n,xor,and>$线性空间的矩阵。元素只有0和1，运算在$mod2$数域下。\n\n1. **构造函数**：\n   \n   - `matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false)`：创建一个大小为 n×m 的矩阵，其中 `n` 是行数，`m` 是列数。`init_diagonal` 和 `init_off_diagonal` 参数用于初始化对角线和非对角线元素。如果 `init_diagonal` 为 `true`，则对角线元素被初始化为 1，否则为 0。非对角线元素的初始化由 `init_off_diagonal` 控制。\n   \n2. **访问操作符**：\n   - `std::bitset<SZ> &operator[](int i)`：返回第 `i` 行的引用。\n   - `const std::bitset<SZ> &operator[](int i) const`：返回第 `i` 行的常量引用。\n\n3. **切片操作**：\n   - `matrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr)`：在原地修改矩阵，返回左上角为 `(il, jl)`，右下角为 `(ir, jr)` 的子矩阵。\n   - `matrix_Z2_base slice(int il, int ir, int jl, int jr) const`：返回左上角为 `(il, jl)`，右下角为 `(ir, jr)` 的子矩阵的副本。\n\n4. **行切片和列切片**：\n   - `matrix_Z2_base &inplace_row_slice(int il, int ir)`：在原地修改矩阵，返回行切片子矩阵。\n   - `matrix_Z2_base row_slice(int il, int ir) const`：返回行切片子矩阵的副本。\n   - `matrix_Z2_base &inplace_column_slice(int jl, int jr)`：在原地修改矩阵，返回列切片子矩阵。\n   - `matrix_Z2_base column_slice(int jl, int jr) const`：返回列切片子矩阵的副本。\n\n5. **比较操作符**：\n   - `bool operator==(const matrix_Z2_base &a) const`：比较两个矩阵是否相等。\n   - `bool operator!=(const matrix_Z2_base &a) const`：比较两个矩阵是否不相等。\n\n6. **矩阵加法和减法**：\n   - `matrix_Z2_base &operator+=(const matrix_Z2_base &M)`：原地矩阵加法。\n   - `matrix_Z2_base operator+(const matrix_Z2_base &M) const`：返回两个矩阵相加的结果。\n   - `matrix_Z2_base &operator-=(const matrix_Z2_base &M)`：原地矩阵减法。\n   - `matrix_Z2_base operator-(const matrix_Z2_base &M) const`：返回两个矩阵相减的结果。\n\n7. **矩阵乘法**：\n   - `matrix_Z2_base &operator*=(const matrix_Z2_base &a)`：原地矩阵乘法。\n   - `matrix_Z2_base operator*(const matrix_Z2_base &a) const`：返回两个矩阵相乘的结果。\n\n8. **矩阵乘以常数**：\n   - `matrix_Z2_base &operator*=(bool c)`：将矩阵的每个元素乘以布尔常数 `c`。\n   - `matrix_Z2_base operator*(bool c) const`：返回乘以常数后的矩阵。\n\n9. **矩阵乘方**：\n   - `matrix_Z2_base &inplace_power(T e)`：原地计算矩阵的 `e` 次幂。\n   - `matrix_Z2_base power(T e) const`：返回矩阵的 `e` 次幂。\n\n10. **矩阵转置**：\n    - `matrix_Z2_base &inplace_transpose()`：原地转置矩阵。\n    - `matrix_Z2_base transpose() const`：返回矩阵的转置。\n\n11. **矩阵乘以行向量**：\n    - `std::vector<int> operator*(const std::bitset<SZ> &v) const`：将矩阵乘以行向量 `v`。\n\n12. **行阶梯形式和行列式、秩**：\n    - `tuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1)`：原地计算矩阵的行阶梯形式，并返回行列式和秩。\n    - `tuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const`：返回矩阵的行阶梯形式，并返回行列式和秩。\n\n13. **矩阵逆**：\n    - `optional<matrix_Z2_base> inverse() const`：返回矩阵的逆，如果矩阵不可逆，则返回空。\n\n14. **行列式**：\n    - `bool determinant() const`：返回矩阵的行列式是否为 1。\n\n15. **秩**：\n    - `int rank() const`：返回矩阵的秩。\n\n16. **线性方程组的解**：\n    - `optional<std::bitset<SZ>> find_a_solution() const`：返回矩阵所代表的线性方程组的一个解。\n\n      解多解$n$元$n$式线性方程组示例：\n    \n      ```cpp\n      for (auto s = 0; s < n; ++s)\n      {\n          matrix_Z2 M(n + 1, n + 1);//第n行表示主元都有谁，第n列是方程增广列，表示各线性方程结果。\n          for (auto u = 0; u < n; ++u)\n          {\n              for (auto v = 0; v < n; ++v)\n              {\n                  if (adjm[u] >> v & 1)\n                  {\n                      M[v][u] = 1;//原题是个图论，根据边列的矩阵方程\n                  }\n              }\n              M[n][u] = u == s;//标记主元，表示第s个元素的解必须是1，给出来的多组解必定线性无关\n          }\n          M[n][n] = 1;\n          if (auto resptr = M.find_a_solution())\n          {\n              auto pick = *resptr;\n              for (auto u = 0; u < n; ++u)\n              {\n                  if (pick[u])\n                  {\n                      res[u] |= 1LL << s;\n                  }\n              }\n          }\n          else\n          {\n              cout << \"No\\n\";\n              return 0;\n          }\n      }\n      ```\n    \n      \n    \n17. **输出操作符**：\n    \n    - `friend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a)`：输出矩阵到流。\n    \n18. **矩阵乘以常数（外部）**：\n    - `matrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M)`：返回乘以常数后的矩阵。\n\n19. **行向量乘以矩阵**：\n    - `std::bitset<SZ> operator*(const std::vector<int> &v, const matrix_Z2_base<SZ> &a)`：将行向量 `v` 乘以矩阵 `a`。\n\n```cpp\n#ifndef __MATRIX_H__\n#define __MATRIX_H__\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n *@brief 二进制矩阵类\n *@note 该类支持矩阵的加减乘，求逆，求行列式，求秩，求行阶梯形式，求解线性方程组等操作\n *@tparam SZ 矩阵列向量的位数，即矩阵的列数，用于初始化bitset的位数\n */\ntemplate <size_t SZ>\nstruct matrix_Z2_base\n{\n    int n, m;\n    std::vector<std::bitset<SZ>> data;\n    std::bitset<SZ> &operator[](int i)\n    {\n        assert(0 <= i && i < n);\n        return data[i];\n    }\n    const std::bitset<SZ> &operator[](int i) const\n    {\n        assert(0 <= i && i < n);\n        return data[i];\n    }\n    matrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr)\n    {\n        assert(0 <= il && il <= ir && ir <= n);\n        assert(0 <= jl && jl <= jr && jr <= m);\n        n = ir - il, m = jr - jl;\n        if (il > 0)\n            for (auto i = 0; i < n; ++i)\n                swap(data[i], data[il + i]);\n        data.resize(n);\n        for (auto &row : data)\n            row = row << SZ - jr >> jl;\n        return *this;\n    }\n    /*\n     *@brief 返回一个子矩阵\n     *@param il 左上角行坐标\n     *@param ir 右下角行坐标\n     *@param jl 左上角列坐标\n     *@param jr 右下角列坐标\n     *@return 返回一个子矩阵\n     */\n    matrix_Z2_base slice(int il, int ir, int jl, int jr) const\n    {\n        return matrix_Z2_base(*this).inplace_slice(il, ir, jl, jr);\n    }\n    matrix_Z2_base &inplace_row_slice(int il, int ir)\n    {\n        assert(0 <= il && il <= ir && ir <= n);\n        n = ir - il;\n        if (il > 0)\n            for (auto i = 0; i < n; ++i)\n                swap(data[i], data[il + i]);\n        data.resize(n);\n        return *this;\n    }\n    /*\n     *@brief 返回一个行切片子矩阵\n     *@param il 左上角行坐标\n     *@param ir 右下角行坐标\n     *@return 返回一个行切片子矩阵\n     */\n    matrix_Z2_base row_slice(int il, int ir) const\n    {\n        return matrix_Z2_base(*this).inplace_row_slice(il, ir);\n    }\n    matrix_Z2_base &inplace_column_slice(int jl, int jr)\n    {\n        assert(0 <= jl && jl <= jr && jr <= m);\n        m = jr - jl;\n        for (auto &row : data)\n            row = row << SZ - jr >> jl;\n        return *this;\n    }\n    /*\n     *@brief 返回一个列切片子矩阵\n     *@param jl 左上角列坐标\n     *@param jr 右下角列坐标\n     *@return 返回一个列切片子矩阵\n     */\n    matrix_Z2_base column_slice(int jl, int jr) const\n    {\n        return matrix_Z2_base(*this).inplace_column_slice(jl, jr);\n    }\n    // 矩阵相等\n    bool operator==(const matrix_Z2_base &a) const\n    {\n        assert(n == a.n && m == a.m);\n        return data == a.data;\n    }\n    // 矩阵不等\n    bool operator!=(const matrix_Z2_base &a) const\n    {\n        assert(n == a.n && m == a.m);\n        return data != a.data;\n    }\n    // 矩阵相加\n    matrix_Z2_base &operator+=(const matrix_Z2_base &M)\n    {\n        assert(n == M.n && m == M.m);\n        for (auto i = 0; i < n; ++i)\n            data[i] ^= M[i];\n        return *this;\n    }\n    // 矩阵相加\n    matrix_Z2_base operator+(const matrix_Z2_base &M) const\n    {\n        return matrix_Z2_base(*this) += M;\n    }\n    // 矩阵相减\n    matrix_Z2_base &operator-=(const matrix_Z2_base &M)\n    {\n        assert(n == M.n && m == M.m);\n        for (auto i = 0; i < n; ++i)\n            data[i] ^= M[i];\n        return *this;\n    }\n    // 矩阵相减\n    matrix_Z2_base operator-(const matrix_Z2_base &M) const\n    {\n        return matrix_Z2_base(*this) -= M;\n    }\n    // 矩阵相乘\n    matrix_Z2_base &operator*=(const matrix_Z2_base &a)\n    {\n        assert(m == a.n);\n        int l = a.m;\n        matrix_Z2_base res(n, l);\n        std::vector<std::bitset<SZ>> temp(l);\n        for (auto i = 0; i < l; ++i)\n            for (auto j = 0; j < m; ++j)\n                temp[i][j] = a[j][i];\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < l; ++j)\n                res[i][j] = (data[i] & temp[j]).count() & 1;\n        return *this = res;\n    }\n    // 矩阵相乘\n    matrix_Z2_base operator*(const matrix_Z2_base &a) const\n    {\n        return matrix_Z2_base(*this) *= a;\n    }\n    // 矩阵乘以一个常数\n    matrix_Z2_base &operator*=(bool c)\n    {\n        if (!c)\n            for (auto &v : *this)\n                v.reset();\n        return *this;\n    }\n    // 矩阵乘以一个常数\n    matrix_Z2_base operator*(bool c) const\n    {\n        return matrix_Z2_base(*this) *= c;\n    }\n    // 矩阵乘方\n    template <class T, typename enable_if<is_integral<T>::value>::type * = nullptr>\n    matrix_Z2_base &inplace_power(T e)\n    {\n        assert(n == m);\n        matrix_Z2_base res(n, n, true);\n        for (; e; *this *= *this, e >>= 1)\n            if (e & 1)\n                res *= *this;\n        return *this = res;\n    }\n    // 矩阵乘方\n    template <class T>\n    matrix_Z2_base power(T e) const\n    {\n        return matrix_Z2_base(*this).inplace_power(e);\n    }\n    // 矩阵转置\n    matrix_Z2_base &inplace_transpose()\n    {\n        assert(n == m);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = i + 1; j < n; ++j)\n                swap(data[i][j], data[j][i]);\n        return *this;\n    }\n    // 矩阵转置\n    matrix_Z2_base transpose() const\n    {\n        if (n == m)\n            return matrix_Z2_base(*this).inplace_transpose();\n        matrix_Z2_base res(m, n);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < m; ++j)\n                res[j][i] = data[i][j];\n        return res;\n    }\n    /*\n     *@brief 矩阵乘以一个行向量\n     *@param v 行向量\n     *@return 返回一个行向量\n     *@note 行向量必须在矩阵左乘，时间复杂度O(n * m / w)\n     */\n    std::vector<int> operator*(const std::bitset<SZ> &v) const\n    {\n        std::vector<int> res(n);\n        for (auto i = 0; i < n; ++i)\n            res[i] = (data[i] & v).count() & 1;\n        return res;\n    }\n    // O(n * m * up_to / w)\n    // Returns {REF matrix, determinant, rank}\n\n    /*\n     *@brief 矩阵的行阶梯形式\n     *@param up_to 行阶梯形式的行数，带参数的情况下只计算前up_to=m-1列向量的行阶梯形式，用于解线性方程组\n     *@return 返回一个元组，第一个元素是行阶梯形式的矩阵，第二个元素是行列式，第三个元素是秩\n     *@note 时间复杂度O(n * m * up_to / w),如果要解多解线性方程组，如果想固定第k个自由变量，需要对传入矩阵的a_{n,k}置1,同时增广向量的对应位a_{n,n}也必须置1，然后调用该函数。\n     *@note 实际上等价于新添了一组线性方程，即a_{n,k} * x_k = a_{n,n}。\n     */\n    tuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1)\n    {\n        if (n == 0)\n            return {*this, true, 0};\n        if (!~up_to)\n            up_to = m;\n        bool det = true;\n        int rank = 0;\n        for (auto j = 0; j < up_to; ++j)\n        {\n            int pivot = -1;\n            for (auto i = rank; i < n; ++i)\n                if (data[i][j])\n                {\n                    pivot = i;\n                    break;\n                }\n            if (!~pivot)\n            {\n                det = false;\n                continue;\n            }\n            if (rank != pivot)\n                swap(data[rank], data[pivot]);\n            for (auto i = rank + 1; i < n; ++i)\n                if (data[i][j])\n                    data[i] ^= data[rank];\n            ++rank;\n            if (rank == n)\n                break;\n        }\n        return {*this, det, rank};\n    }\n    // O(n * m * up_to / w)\n    // Returns {REF matrix, determinant, rank}\n    /*\n     *@brief 矩阵的行阶梯形式\n     *@param up_to 行阶梯形式的行数\n     *@return 返回一个元组，第一个元素是行阶梯形式的矩阵，第二个元素是行列式，第三个元素是秩\n     *@note 时间复杂度O(n * m * up_to / w)。解多解线性方程组时，如果想固定第k个自由变量，需要对传入矩阵的a_{n,k}置1,同时增广向量的对应位a_{n,n}也必须置1，然后调用该函数。\n     *@note 实际上等价于新添了一组线性方程，即a_{n,k} * x_k = a_{n,n}。\n     */\n    tuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const\n    {\n        return matrix_Z2_base(*this).inplace_REF(up_to);\n    }\n    // O(n * m * min(n, m) / w)\n    /*\n     *@brief 矩阵的逆\n     *@return 返回一个可选的矩阵，表示矩阵的逆\n     */\n    optional<matrix_Z2_base> inverse() const\n    {\n        assert(n == m);\n        std::vector<std::bitset<SZ>> a(data), res(n);\n        for (auto i = 0; i < n; ++i)\n            res[i].set(i);\n        for (auto j = 0; j < n; ++j)\n        {\n            int pivot = -1;\n            for (auto i = j; i < n; ++i)\n                if (a[i][j])\n                {\n                    pivot = i;\n                    break;\n                }\n            if (!~pivot)\n                return {};\n            swap(a[j], a[pivot]), swap(res[j], res[pivot]);\n            for (auto i = 0; i < n; ++i)\n                if (i != j && a[i][j])\n                    a[i] ^= a[j], res[i] ^= res[j];\n        }\n        swap(*this, res);\n        return true;\n    }\n    /*\n     *@brief 矩阵的行列式\n     *@return 返回一个布尔值，表示矩阵的行列式是否为1\n     */\n    bool determinant() const\n    {\n        assert(n == m);\n        matrix_Z2_base a(data);\n        for (auto i = 0; i < n; ++i)\n        {\n            for (auto j = i + 1; j < n; ++j)\n                if (a[j][i])\n                {\n                    if (a[i][i])\n                        a[j] ^= a[i];\n                    else\n                        swap(a[i], a[j]);\n                }\n            if (!a[i][i])\n                return false;\n        }\n        return true;\n    }\n    // O(n^3 / w)\n    /*\n     *@brief 矩阵的秩\n     *@return 返回一个整数，表示矩阵的秩\n     *@note 时间复杂度O(n^3 / w)\n     */\n    int rank() const\n    {\n        return get<2>(REF());\n    }\n    // Regarding the matrix as a system of linear equations by separating first m-1 columns, find a solution of the linear equation.\n    // O(n * m^2 / w)\n    /*\n     *@brief 矩阵所代表的线性方程组的一个解\n     *@return 返回一个可选的位集，表示矩阵的一个解\n     *@note 时间复杂度O(n * m^2 / w),该矩阵所代表的线性方程组系数矩阵为低m-1位，常数项为第m位，表示n*(m-1)的增广矩阵。\n     *@note 时间复杂度O(n * m * up_to / w),如果要解多解线性方程组，如果想固定第k个自由变量，需要对传入矩阵的a_{n,k}置1,同时增广向量的对应位a_{n,n}也必须置1，然后调用该函数。\n     *@note 实际上等价于新添了一组线性方程，即a_{n,k} * x_k = a_{n,n}。\n     */\n    optional<std::bitset<SZ>> find_a_solution() const\n    {\n        assert(m >= 1);\n        auto [ref, _, rank] = REF(m - 1);\n        for (auto i = rank; i < n; ++i)\n            if (ref[i][m - 1])\n                return {};\n        std::bitset<SZ> res;\n        for (auto i = rank - 1; i >= 0; --i)\n        {\n            int pivot = ref[i]._Find_first();\n            assert(pivot < m - 1);\n            res[pivot] = ref[i][m - 1] ^ (ref[i] & res).count() & 1;\n        }\n        return res;\n    }\n    template <class output_stream>\n    friend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a)\n    {\n        out << \"\\n\";\n        for (auto i = 0; i < a.n; ++i)\n        {\n            for (auto j = 0; j < a.m; ++j)\n                out << bool(a[i][j]);\n            out << \"\\n\";\n        }\n        return out;\n    }\n    /*\n     *@brief 构造函数\n     *@param n 行数\n     *@param m 列数\n     *@param init_diagonal 对角线是否初始化\n     *@param init_off_diagonal 非对角线是否初始化\n     */\n    matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false) : n(n), m(m), data(n)\n    {\n        assert(m <= SZ);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < m; ++j)\n                data[i][j] = i == j ? init_diagonal : init_off_diagonal;\n    }\n    /*\n     *@brief 构造函数\n     *@param n 行数\n     *@param m 列数\n     *@param a 矩阵\n     */\n    matrix_Z2_base(int n, int m, const std::vector<std::bitset<SZ>> &a) : n(n), m(m), data(a) {}\n};\n/*\n *@brief 矩阵乘以一个常数\n *@param c 常数\n *@param M 矩阵\n *@return 返回一个矩阵\n */\ntemplate <size_t SZ>\nmatrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M)\n{\n    if (!c)\n        for (auto &v : M)\n            v.reset();\n    return M;\n}\n// Multiply a row std::vector v on the left\n/*\n *@brief 行向量乘以矩阵\n *@param v 行向量\n *@param a 矩阵\n *@return 返回一个行向量\n */\ntemplate <size_t SZ>\nstd::bitset<SZ> operator*(const std::vector<int> &v, const matrix_Z2_base<SZ> &a)\n{\n    assert(a.n == (int)v.size());\n    std::bitset<SZ> res;\n    for (auto i = 0; i < a.n; ++i)\n        if (v[i])\n            res ^= a[i];\n    return res;\n}\n\n#endif\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3. 多项式相关\n\n关键词：卷积优化。动态规划优化。\n\n#### 3.1 快速傅里叶变换（FTT）/多项式乘法\n\n给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。\n\n请求出 $F(x)$ 和 $G(x)$ 的卷积，从低次方项到高次方项给出系数。\n\n保证输入中的系数大于等于 $0$ 且小于等于 $9$。\n\n对于 $100\\%$ 的数据：$1 \\le n, m \\leq {10}^6$​​。\n\n$FTT$等下列一系列快速变换的本质都是选择出来$2^w=n$个多项式点值，用这组点值向量的运算去替代多项式的运算。\n\n```cpp\n#include <bits/stdc++.h>\n#include <math.h>\nusing namespace std;\nusing d32 = double;\n#define endl '\\n'\nconst d32 PI = 3.14159265358979323846;\nvoid fft(vector<complex<d32>> &a)\n{\n    int n = a.size();\n    if (n == 1)\n        return;\n    vector<complex<d32>> a0(n / 2), a1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        a0[i] = a[i * 2];\n        a1[i] = a[i * 2 + 1];\n    }\n    fft(a0);\n    fft(a1);\n    d32 ang = 2 * PI / n;\n    complex<d32> w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; i < n / 2; i++)\n    {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n / 2] = a0[i] - w * a1[i];\n        w *= wn;\n    }\n}\nvector<d32> mul(vector<d32> a, vector<d32> b)\n{\n    int n = 1;\n    while (n < a.size() + b.size())\n        n *= 2;\n    a.resize(n);\n    b.resize(n);\n    vector<complex<d32>> A(a.begin(), a.end()), B(b.begin(), b.end());\n    fft(A);\n    fft(B);\n    for (int i = 0; i < n; i++)\n        A[i] *= B[i];\n    for (int i = 0; i < n; i++)\n        A[i] = conj(A[i]);//逆变换前求倒数。\n    fft(A);\n    vector<d32> res(n);\n    for (int i = 0; i < n; i++)\n        res[i] = round(A[i].real() / n);\n    return res;\n}\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<d32> a(n + 1), b(m + 1);\n    for (int i = 0; i <= n; i++)\n        cin >> a[i];\n    for (int i = 0; i <= m; i++)\n        cin >> b[i];\n    vector<d32> res = mul(a, b);\n    for (int i = 0; i <= n + m; i++)\n        cout << (long long)res[i] << \" \";\n    cout << endl;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n还有一种写法：\n\n```cpp\nusing d32 = double;\n#define endl '\\n'\nconst d32 PI = 3.14159265358979323846;\nvoid fft(vector<complex<double>> &f, int op)\n{\n    int n = f.size();\n    if (n == 1)\n        return;\n    vector<complex<double>> f0(n / 2), f1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        f0[i] = f[i * 2];\n        f1[i] = f[i * 2 + 1];\n    }\n    fft(f0, op);\n    fft(f1, op);\n    complex<double> cur(1, 0), step(cos(2 * PI / n), sin(2 * PI * op / n));\n    for (int k = 0; k < n / 2; ++k)\n    {\n        complex<double> tmp = cur * f1[k];\n        f[k] = f0[k] + tmp;\n        f[k + n / 2] = f0[k] - tmp;\n        cur *= step;\n    }\n    return;\n}\nvector<d32> mul(vector<d32> &a, vector<d32> &b)\n{\n    int n = 1;\n    while (n < a.size() + b.size())\n        n *= 2;\n    a.resize(n);\n    b.resize(n);\n    vector<complex<d32>> A(a.begin(), a.end()), B(b.begin(), b.end());\n    fft(A, 1);\n    fft(B, 1);\n    for (int i = 0; i < n; i++)\n        A[i] *= B[i];\n    fft(A, -1);\n    vector<d32> res(n);\n    for (int i = 0; i < n; i++)\n        res[i] = round(A[i].real() / n);\n    return res;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.2 快速数论变换（NTT）/多项式乘法\n\n```cpp\nconstexpr int P = 998244353;\n\nint power(int a, int b)\n{\n    int res = 1;\n    for (; b; b /= 2, a = 1LL * a * a % P)\n    {\n        if (b % 2)\n        {\n            res = 1LL * res * a % P;\n        }\n    }\n    return res;\n}\n\nstd::vector<int> rev, roots{0, 1};\n\nvoid dft(std::vector<int> &a)\n{\n    int n = a.size();\n    if (int(rev.size()) != n)\n    {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n        {\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (rev[i] < i)\n        {\n            std::swap(a[i], a[rev[i]]);\n        }\n    }\n    if (roots.size() < n)\n    {\n        int k = __builtin_ctz(roots.size());\n        roots.resize(n);\n        while ((1 << k) < n)\n        {\n            int e = power(31, 1 << (__builtin_ctz(P - 1) - k - 1));\n            for (int i = 1 << (k - 1); i < (1 << k); i++)\n            {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = 1LL * roots[i] * e % P;\n            }\n            k++;\n        }\n    }\n\n    for (int k = 1; k < n; k *= 2)\n    {\n        for (int i = 0; i < n; i += 2 * k)\n        {\n            for (int j = 0; j < k; j++)\n            {\n                int u = a[i + j];\n                int v = 1LL * a[i + j + k] * roots[k + j] % P;\n                a[i + j] = (u + v) % P;\n                a[i + j + k] = (u - v + P) % P;\n            }\n        }\n    }\n}\n\nvoid idft(std::vector<int> &a)\n{\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    int inv = power(n, P - 2);\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = 1LL * a[i] * inv % P;\n    }\n}\n\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b)\n{\n    int n = 1, tot = a.size() + b.size() - 1;\n    while (n < tot)\n    {\n        n *= 2;\n    }\n    if (tot < 128)\n    {\n        std::vector<int> c(a.size() + b.size() - 1);\n        for (int i = 0; i < a.size(); i++)\n        {\n            for (int j = 0; j < b.size(); j++)\n            {\n                c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;\n            }\n        }\n        return c;\n    }\n    a.resize(n);\n    b.resize(n);\n    dft(a);\n    dft(b);\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = 1LL * a[i] * b[i] % P;\n    }\n    idft(a);\n    a.resize(tot);\n    return a;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.3 快速莫比乌斯变换/快速沃尔什变换（FMT/FWT）\n\n给定长度为 $2^n$ 两个序列 $A,B$，设 \n\n$$C_i=\\sum_{j\\oplus k = i}A_j \\times B_k$$\n\n分别当 $\\oplus$ 是 $or, and, xor$ 时求出 $C$​​。称作或、与、异或卷积。**请区分他们与对应乘法的区别。**\n\n卷积原理：$FMT$是子集运算，$FWT$是$x\\circ y=popcount(x\\&y)\\%2$​\n\n$FMT_{and}(A)_i=\\sum_{i\\&j=i}a_j$\n\n$FMT_{or}(A)_i=\\sum_{i|j=i}a_j$\n\n$FMT_{xor}(A)_i=\\sum_{i\\circ j=0}a_j-\\sum_{i\\circ j=1}a_j$\n\n注意，针对异或的快速沃尔什变换是线性变换的，即$FWT(c\\cdot A+B)=c\\cdot FWT(A)+FWT(B)$​\n\n对数组$F(x)=x^0$（即只有$a[0]=1$，其余位置全为$0$）的快速$FWT$后所得序列全为$1$。\n\n对数组$F(x)=x^t$（即只有$a[t]=1$，其余位置全为$0$）的快速$FWT$后所得序列全为$1$或者$-1$（显然）\n\n```cpp\nstd::vector<int> fwt_and(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[j + k] = (1ll * a[j + k] + a[i + j + k]) % mod;\n    return a;\n}\nstd::vector<int> ifwt_and(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[j + k] = (1ll * a[j + k] - a[i + j + k] + mod) % mod;\n    return a;\n}\nstd::vector<int> fwt_or(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[i + j + k] = (1ll * a[j + k] + a[i + j + k]) % mod;\n    return a;\n}\nstd::vector<int> ifwt_or(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[i + j + k] = (1ll * a[i + j + k] - a[j + k] + mod) % mod;\n    return a;\n}\nstd::vector<int> fwt_xor(vector<int> a) // 异或\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (1ll * x + y) % mod;\n                a[i + j + k] = (1ll * x - y + mod) % mod;\n            }\n    return a;\n}\nstd::vector<int> ifwt_xor(vector<int> a)\n{\n    int inv_2 = 499122177;\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (1ll * x + y) * inv_2 % mod;\n                a[i + j + k] = (1ll * x - y + mod) % mod * inv_2 % mod;\n            }\n    return a;\n}\n\nstd::vector<int> fwt_not(std::vector<int> a) // 同或\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[i + j + k] = (1ll * x + y) % mod;\n                a[j + k] = (1ll * x - y + mod) % mod;\n            }\n    return a;\n}\nstd::vector<int> ifwt_not(std::vector<int> a)\n{\n    int inv_2 = 499122177;\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[i + j + k] = (1ll * x + y) * inv_2 % mod;\n                a[j + k] = (1ll * x - y + mod) % mod * inv_2 % mod;\n            }\n    return a;\n}\nstd::vector<int> FWT(std::vector<int> a, std::vector<int> b, vector<int> (*f)(vector<int>), vector<int> (*g)(vector<int>))\n{\n    int n = a.size();\n    assert((n & (n - 1)) == 0); // n是2的幂\n    a = f(a);\n    b = f(b);\n    for (int i = 0; i < n; i++)\n        a[i] = 1ll * a[i] * b[i] % mod;\n    return g(a);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.4 分治NTT（NTT+CQD）\n\n给定序列 $g_{1\\dots n - 1}$，求序列 $f_{0\\dots n - 1}$。\n\n其中 $f_i=\\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。\n\n答案对 $998244353$ 取模。\n\n$2\\leq n\\leq 10^5$，$0\\leq g_i<998244353$​。\n\n利用CDQ分治的思想，先解决左半部分，再解决左半部分对右半部分的贡献。\n\n设当前计算区间为$[l,r]$，此时先$CDQ$已经计算出了$f[l,\\ldots,mid]$，考虑其对$f[mid+1,\\ldots,r]$的贡献。\n\n对于$f_k(k\\ge mid+1)$而言，前半部分所造成的贡献为$\\sum_{i+j=k,i\\le mid}f_ig_{k-i}$\n\n也就是说，需要将$f[l,mid]$和$g(0,r-l)$卷积卷起来，对后半部分进行贡献。\n\n所以算出前半部分后，将$f[l,\\ldots,mid]$搞成一个多项式，卷积$NTT$​计算贡献，加在后面，然后递归后半部分。\n\n复杂度$O(nlog^2n)$\n\n（本例题也可利用生成函数操纵序列，多项式求逆解决，复杂度$O(nlogn)$ ）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nconstexpr int P = 998244353;\n\nint power(int a, int b)\n{\n    int res = 1;\n    for (; b; b /= 2, a = 1LL * a * a % P)\n    {\n        if (b % 2)\n        {\n            res = 1LL * res * a % P;\n        }\n    }\n    return res;\n}\n\nstd::vector<int> rev, roots{0, 1};\n\nvoid dft(std::vector<int> &a)\n{\n   //见NTT\n}\n\nvoid idft(std::vector<int> &a)\n{\n    //见NTT\n}\n\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b)\n{\n   //见NTT\n}\nvector<int> f, g;\nvoid cdq(int l, int r)\n{\n    if (l == r)\n    {\n        if (!l)\n            f[l] = 1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    cdq(l, mid);\n    vector<int> a(mid - l + 1), b(r - l + 1);\n    for (int i = l; i <= mid; i++)\n        a[i - l] = f[i];\n    for (int i = 0; i <= r - l; i++)\n        b[i] = g[i];\n    a = mul(a, b);\n    for (int i = mid + 1; i <= r; i++)\n        f[i] = (f[i] + a[i - l]) % P;\n    cdq(mid + 1, r);\n    return;\n}\nvoid solve()\n{\n    int n;\n    cin >> n;\n    f.resize(n);\n    g.resize(n);\n    for (int i = 1; i < n; i++)\n    {\n        cin >> g[i];\n    }\n    g[0] = 0;\n    cdq(0, n - 1);\n    for (int i = 0; i < n; i++)\n    {\n        cout << f[i] << \" \";\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.5 Poly.h, with NTT&Modint.h\n\n```cpp\n/**   多项式相关（Poly, with. MInt & MLong）\n *    2023-09-20: https://atcoder.jp/contests/arc163/submissions/45737810\n *    2024-07-28: https://codeforces.com/contest/1991/submission/273204889\n **/\n#ifndef __POLYS_H__\n#define __POLYS_H__\n#include <bits/stdc++.h>\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\nusing i64 = long long;\nstd::vector<int> rev;\ntemplate <int P>\nstd::vector<MInt<P>> roots{0, 1};\n\ntemplate <int P>\nconstexpr MInt<P> findPrimitiveRoot()\n{\n    MInt<P> i = 2;\n    int k = __builtin_ctz(P - 1);\n    while (true)\n    {\n        if (power(i, (P - 1) / 2) != 1)\n        {\n            break;\n        }\n        i += 1;\n    }\n    return power(i, (P - 1) >> k);\n}\n\ntemplate <int P>\nconstexpr MInt<P> primitiveRoot = findPrimitiveRoot<P>();\n\ntemplate <>\nconstexpr MInt<998244353> primitiveRoot<998244353>{31};\n\ntemplate <int P>\nconstexpr void dft(std::vector<MInt<P>> &a)\n{\n    int n = a.size();\n\n    if (int(rev.size()) != n)\n    {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n        {\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        if (rev[i] < i)\n        {\n            std::swap(a[i], a[rev[i]]);\n        }\n    }\n    if (roots<P>.size() < n)\n    {\n        int k = __builtin_ctz(roots<P>.size());\n        roots<P>.resize(n);\n        while ((1 << k) < n)\n        {\n            auto e = power(primitiveRoot<P>, 1 << (__builtin_ctz(P - 1) - k - 1));\n            for (int i = 1 << (k - 1); i < (1 << k); i++)\n            {\n                roots<P>[2 * i] = roots<P>[i];\n                roots<P>[2 * i + 1] = roots<P>[i] * e;\n            }\n            k++;\n        }\n    }\n    for (int k = 1; k < n; k *= 2)\n    {\n        for (int i = 0; i < n; i += 2 * k)\n        {\n            for (int j = 0; j < k; j++)\n            {\n                MInt<P> u = a[i + j];\n                MInt<P> v = a[i + j + k] * roots<P>[k + j];\n                a[i + j] = u + v;\n                a[i + j + k] = u - v;\n            }\n        }\n    }\n}\n\ntemplate <int P>\nconstexpr void idft(std::vector<MInt<P>> &a)\n{\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    MInt<P> inv = (1 - P) / n;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] *= inv;\n    }\n}\n\ntemplate <int P = 998244353>\nstruct Poly : public std::vector<MInt<P>>\n{\n    using Value = MInt<P>;\n\n    Poly() : std::vector<Value>() {}\n    explicit constexpr Poly(int n) : std::vector<Value>(n) {}\n\n    explicit constexpr Poly(const std::vector<Value> &a) : std::vector<Value>(a) {}\n    constexpr Poly(const std::initializer_list<Value> &a) : std::vector<Value>(a) {}\n\n    template <class InputIt, class = std::_RequireInputIter<InputIt>>\n    explicit constexpr Poly(InputIt first, InputIt last) : std::vector<Value>(first, last) {}\n    /*\n    @brief 通过函数生成多项式\n    @param n 生成的多项式的长度\n    @param f 生成多项式的函数\n    */\n    template <class F>\n    explicit constexpr Poly(int n, F f) : std::vector<Value>(n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            (*this)[i] = f(i);\n        }\n    }\n    /*\n    @brief 多项式位移\n    @param k 位移的距离，正数表示各项乘以 x^k，负数表示各项除以 x^k\n    @return 位移后的多项式\n    */\n    constexpr Poly shift(int k) const\n    {\n        if (k >= 0)\n        {\n            auto b = *this;\n            b.insert(b.begin(), k, 0);\n            return b;\n        }\n        else if (this->size() <= -k)\n        {\n            return Poly();\n        }\n        else\n        {\n            return Poly(this->begin() + (-k), this->end());\n        }\n    }\n    // 多项式重塑，将多项式的长度调整为 k\n    constexpr Poly trunc(int k) const\n    {\n        Poly f = *this;\n        f.resize(k);\n        return f;\n    }\n    // 多项式加法\n    constexpr friend Poly operator+(const Poly &a, const Poly &b)\n    {\n        Poly res(std::max(a.size(), b.size()));\n        for (int i = 0; i < a.size(); i++)\n        {\n            res[i] += a[i];\n        }\n        for (int i = 0; i < b.size(); i++)\n        {\n            res[i] += b[i];\n        }\n        return res;\n    }\n    // 多项式减法\n    constexpr friend Poly operator-(const Poly &a, const Poly &b)\n    {\n        Poly res(std::max(a.size(), b.size()));\n        for (int i = 0; i < a.size(); i++)\n        {\n            res[i] += a[i];\n        }\n        for (int i = 0; i < b.size(); i++)\n        {\n            res[i] -= b[i];\n        }\n        return res;\n    }\n    // 多项式取负\n    constexpr friend Poly operator-(const Poly &a)\n    {\n        std::vector<Value> res(a.size());\n        for (int i = 0; i < int(res.size()); i++)\n        {\n            res[i] = -a[i];\n        }\n        return Poly(res);\n    }\n    // 多项式乘法，NTT快速数论变换\n    constexpr friend Poly operator*(Poly a, Poly b)\n    {\n        if (a.size() == 0 || b.size() == 0)\n        {\n            return Poly();\n        }\n        if (a.size() < b.size())\n        {\n            std::swap(a, b);\n        }\n        int n = 1, tot = a.size() + b.size() - 1;\n        while (n < tot)\n        {\n            n *= 2;\n        }\n        if (((P - 1) & (n - 1)) != 0 || b.size() < 128)\n        {\n            Poly c(a.size() + b.size() - 1);\n            for (int i = 0; i < a.size(); i++)\n            {\n                for (int j = 0; j < b.size(); j++)\n                {\n                    c[i + j] += a[i] * b[j];\n                }\n            }\n            return c;\n        }\n        a.resize(n);\n        b.resize(n);\n        dft(a);\n        dft(b);\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] *= b[i];\n        }\n        idft(a);\n        a.resize(tot);\n        return a;\n    }\n    constexpr friend Poly operator*(Value a, Poly b)\n    {\n        for (int i = 0; i < int(b.size()); i++)\n        {\n            b[i] *= a;\n        }\n        return b;\n    }\n    constexpr friend Poly operator*(Poly a, Value b)\n    {\n        for (int i = 0; i < int(a.size()); i++)\n        {\n            a[i] *= b;\n        }\n        return a;\n    }\n    constexpr friend Poly operator/(Poly a, Value b)\n    {\n        for (int i = 0; i < int(a.size()); i++)\n        {\n            a[i] /= b;\n        }\n        return a;\n    }\n    constexpr Poly &operator+=(Poly b)\n    {\n        return (*this) = (*this) + b;\n    }\n    constexpr Poly &operator-=(Poly b)\n    {\n        return (*this) = (*this) - b;\n    }\n    constexpr Poly &operator*=(Poly b)\n    {\n        return (*this) = (*this) * b;\n    }\n    constexpr Poly &operator*=(Value b)\n    {\n        return (*this) = (*this) * b;\n    }\n    constexpr Poly &operator/=(Value b)\n    {\n        return (*this) = (*this) / b;\n    }\n    // 多项式求导\n    constexpr Poly deriv() const\n    {\n        if (this->empty())\n        {\n            return Poly();\n        }\n        Poly res(this->size() - 1);\n        for (int i = 0; i < this->size() - 1; ++i)\n        {\n            res[i] = (i + 1) * (*this)[i + 1];\n        }\n        return res;\n    }\n    // 多项式积分\n    constexpr Poly integr() const\n    {\n        Poly res(this->size() + 1);\n        for (int i = 0; i < this->size(); ++i)\n        {\n            res[i + 1] = (*this)[i] / (i + 1);\n        }\n        return res;\n    }\n    // 多项式求逆，中间m为模多项式长度，即 mod x^m\n    constexpr Poly inv(int m) const\n    {\n        Poly x{(*this)[0].inv()};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x * (Poly{2} - trunc(k) * x)).trunc(k);\n        }\n        return x.trunc(m);\n    }\n    // 多项式求lnx\n    constexpr Poly log(int m) const\n    {\n        return (deriv() * inv(m)).integr().trunc(m);\n    }\n    // 多项式求e^x\n    constexpr Poly exp(int m) const\n    {\n        Poly x{1};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x * (Poly{1} - x.log(k) + trunc(k))).trunc(k);\n        }\n        return x.trunc(m);\n    }\n    // 多项式快速幂\n    constexpr Poly pow(int k, int m) const\n    {\n        int i = 0;\n        while (i < this->size() && (*this)[i] == 0)\n        {\n            i++;\n        }\n        if (i == this->size() || 1LL * i * k >= m)\n        {\n            return Poly(m);\n        }\n        Value v = (*this)[i];\n        auto f = shift(-i) * v.inv();\n        return (f.log(m - i * k) * k).exp(m - i * k).shift(i * k) * power(v, k);\n    }\n    // 多项式开根\n    constexpr Poly sqrt(int m) const\n    {\n        Poly x{1};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x + (trunc(k) * x.inv(k)).trunc(k)) * CInv<2, P>;\n        }\n        return x.trunc(m);\n    }\n    // 多项式转置乘法，计算F(x)*G(1/x)的结果，抹掉负次方项\n    constexpr Poly mulT(Poly b) const\n    {\n        if (b.size() == 0)\n        {\n            return Poly();\n        }\n        int n = b.size();\n        std::reverse(b.begin(), b.end());\n        return ((*this) * b).shift(-(n - 1));\n    }\n    // 多项式多点求值\n    constexpr std::vector<Value> eval(std::vector<Value> x) const\n    {\n        if (this->size() == 0)\n        {\n            return std::vector<Value>(x.size(), 0);\n        }\n        const int n = std::max(x.size(), this->size());\n        std::vector<Poly> q(4 * n);\n        std::vector<Value> ans(x.size());\n        x.resize(n);\n        std::function<void(int, int, int)> build = [&](int p, int l, int r)\n        {\n            if (r - l == 1)\n            {\n                q[p] = Poly{1, -x[l]};\n            }\n            else\n            {\n                int m = (l + r) / 2;\n                build(2 * p, l, m);\n                build(2 * p + 1, m, r);\n                q[p] = q[2 * p] * q[2 * p + 1];\n            }\n        };\n        build(1, 0, n);\n        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num)\n        {\n            if (r - l == 1)\n            {\n                if (l < int(ans.size()))\n                {\n                    ans[l] = num[0];\n                }\n            }\n            else\n            {\n                int m = (l + r) / 2;\n                work(2 * p, l, m, num.mulT(q[2 * p + 1]).trunc(m - l));\n                work(2 * p + 1, m, r, num.mulT(q[2 * p]).trunc(r - m));\n            }\n        };\n        work(1, 0, n, mulT(q[1].inv(n)));\n        return ans;\n    }\n};\n\ntemplate <int P = 998244353>\nPoly<P> berlekampMassey(const Poly<P> &s)\n{\n    Poly<P> c;\n    Poly<P> oldC;\n    int f = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        auto delta = s[i];\n        for (int j = 1; j <= c.size(); j++)\n        {\n            delta -= c[j - 1] * s[i - j];\n        }\n        if (delta == 0)\n        {\n            continue;\n        }\n        if (f == -1)\n        {\n            c.resize(i + 1);\n            f = i;\n        }\n        else\n        {\n            auto d = oldC;\n            d *= -1;\n            d.insert(d.begin(), 1);\n            MInt<P> df1 = 0;\n            for (int j = 1; j <= d.size(); j++)\n            {\n                df1 += d[j - 1] * s[f + 1 - j];\n            }\n            assert(df1 != 0);\n            auto coef = delta / df1;\n            d *= coef;\n            Poly<P> zeros(i - f - 1);\n            zeros.insert(zeros.end(), d.begin(), d.end());\n            d = zeros;\n            auto temp = c;\n            c += d;\n            if (i - temp.size() > f - oldC.size())\n            {\n                oldC = temp;\n                f = i;\n            }\n        }\n    }\n    c *= -1;\n    c.insert(c.begin(), 1);\n    return c;\n}\n\ntemplate <int P = 998244353>\nMInt<P> linearRecurrence(Poly<P> p, Poly<P> q, i64 n)\n{\n    int m = q.size() - 1;\n    while (n > 0)\n    {\n        auto newq = q;\n        for (int i = 1; i <= m; i += 2)\n        {\n            newq[i] *= -1;\n        }\n        auto newp = p * newq;\n        newq = q * newq;\n        for (int i = 0; i < m; i++)\n        {\n            p[i] = newp[i * 2 + n % 2];\n        }\n        for (int i = 0; i <= m; i++)\n        {\n            q[i] = newq[i * 2];\n        }\n        n /= 2;\n    }\n    return p[0] / q[0];\n}\n\nstruct Comb\n{\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n\n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb()\n    {\n        init(n);\n    }\n\n    void init(int m)\n    {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n)\n            return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n\n        for (int i = n + 1; i <= m; i++)\n        {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--)\n        {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n\n    Z fac(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m)\n    {\n        if (n < m || m < 0)\n            return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nPoly<P> get(int n, int m)\n{\n    if (m == 0)\n    {\n        return Poly(n + 1);\n    }\n    if (m % 2 == 1)\n    {\n        auto f = get(n, m - 1);\n        Z p = 1;\n        for (int i = 0; i <= n; i++)\n        {\n            f[n - i] += comb.binom(n, i) * p;\n            p *= m;\n        }\n        return f;\n    }\n    auto f = get(n, m / 2);\n    auto fm = f;\n    for (int i = 0; i <= n; i++)\n    {\n        fm[i] *= comb.fac(i);\n    }\n    Poly pw(n + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        pw[i] = pw[i - 1] * (m / 2);\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        pw[i] *= comb.invfac(i);\n    }\n    fm = fm.mulT(pw);\n    for (int i = 0; i <= n; i++)\n    {\n        fm[i] *= comb.invfac(i);\n    }\n    return f + fm;\n}\n#endif\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.6 多项式求逆\n\n给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \\equiv 1 \\pmod{x^n}$。系数对 $998244353$ 取模。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$ 0 \\leq a_i \\leq 10^9$​。\n\n工作原理：\n\n我们不妨假设，$n=2^k$,$k\\in N$。\n\n若$n=1$，则$A(x)×B(x)≡a_0×b_0≡1(mod\\  x^1)$,其中$a_0$，$b_0$表示多项式$A$和多项式$B$的常数项。\n\n若需要求出$b_0$，直接用费马小定理求出$a_0$的乘法逆元即可。\n\n当$n>1$时：\n\n我们假设在模$x^{\\frac{n}{2}}$的意义下$A(x)$的逆元$B^′(x)$我们已经求得。\n\n依据定义，则有\n\n$A(x)B^′(x)≡1(mod\\  x^{\\frac{n}{2}})$ (1)\n\n对(1)式进行移项得\n\n$A(x)B^′(x)−1≡0(mod\\ x^{\\frac{n}{2}})$ (2)\n\n然后对(2)式等号两边平方，得\n\n$A^2(x)B^{′2}(x)−2A(x)B^′(x)+1≡0(mod\\  x^n)$ (3)\n\n将常数项移动到等式右侧，得\n\n$A^2(x)B^{′2}(x)−2A(x)B^′(x)≡−1(mod\\  x^n)$ (4)\n\n将等式两边去相反数，得\n\n$2A(x)B^′(x)−A^2(x)B^{′2}(x)≡1(mod\\  x^n)$ (5)\n\n下面考虑回我们需要求的多项式$B(x)$，依据定义，其满足\n\n$A(x)B(x)≡1(mod\\ x^n)$ (6)\n\n将(5)−(6)并移项，得\n\n$A(x)B(x)≡2A(x)B^′(x)−A^2(x)B^{′2}(x)(mod\\  x^n)$ (7)\n\n等式两边约去$A(x)$，得\n\n$B(x)≡2B′(x)−A(x)B^{′2}(x)(mod\\  x^n)$ (8)\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &i : a)\n        cin >> i;\n    Poly<P> A(a);\n    Poly<P> invA = A.inv(n);\n    for (auto &i : invA)\n    {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.7 多项式除法\n\n***严格注意：多项式除法不可以拿来做高精度除法！因为多项式除法做了取余数的操作！相当于扣了项的系数！***\n\n给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：\n\n - $Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$\n - $F(x) = Q(x)  G(x) + R(x)$\n\n所有的运算在模 $998244353$ 意义下进行。   \n\n如果 $R(x)$ 不足 $m-1$ 次，多余的项系数补 $0$。\n\n对于所有数据，$1 \\le m < n \\le 10^5$，给出的系数均属于 $[0, 998244353) \\cap \\mathbb{Z}$。\n\n$N$次多项式$A(x)$的系数$vector$进行一次$reverse$后表示的是$A(\\frac{1}{x})x^N$的系数。\n\n故求多项式除法$A(x)=B(x)C(x)+D(x)$时，考虑$x^NA(\\frac{1}{x})=x^MB(\\frac{1}{x})x^{N-M}C(\\frac{1}{x})+D(\\frac{1}{x})$\n\n多项式对$x^{N-M+1}$求模，$D(x)$消失，有$x^{N-M}C(\\frac{1}{x})\\equiv \\frac{A^{'}(x)}{B^{'}(x)}$\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<Z> a(n + 1), b(k + 1);\n    for (auto &i : a)\n        cin >> i;\n    for (auto &i : b)\n        cin >> i;\n    Poly<P> A(a), B(b);\n    reverse(A.begin(), A.end());\n    reverse(B.begin(), B.end());\n    A.resize(n - k + 1);\n    B.resize(n - k + 1);\n    Poly<P> C = A * (B.inv(n - k + 1));\n    C.resize(n - k + 1);\n    reverse(C.begin(), C.end());\n    for (auto &i : C)\n        cout << i << \" \";\n    cout << endl;\n    Poly<P> D = Poly<P>(a) - Poly<P>(b) * C;\n    D.resize(k);\n    for (auto &i : D)\n        cout << i << \" \";\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.8 多项式对数\n\n求个导再积分就行。\n\n给定多项式$A(x)$，求$B(x)$使得$B(x)\\equiv lnA(x)\\ (mod\\ x^n)$，保证$a_0=1$\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &x : a)\n        cin >> x;\n    Poly<P> p(a);\n    auto b = p.log(n);\n    for (auto x : b)\n        cout << x << ' ';\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.9 多项式自然指数\n\n给定多项式$A(x)$，求$B(x)$使得$B(x)\\equiv e^{A(x)}\\ (mod\\ x^n)$，保证$a_0=0$​\n\n函数求导，牛顿迭代法。\n\n先从牛顿迭代讲起。 \n\n已知多项式函数$G(z)$，求多项式函数$F(x)$满足 $$G(F(x))\\equiv0 \\pmod{x^n}$$ \n\n考虑用迭代求解，假设我们已经求得$F_0(x)$满足 $$G(F_0(x))\\equiv0\\pmod{x^{\\left\\lceil\\frac{n}{2}\\right\\rceil}}$$ \n\n将函数$G$在$z=F_0(x)$处进行泰勒展开 $$G(F(x))=\\sum_{i=1}^{\\infty}\\frac{G^i(F_0(x))}{i!}(F(x)-F_0(x))^i$$ ,其中$G^i$为$G$的$i$阶导函数. \n\n取前两项 $$G(F(x))\\equiv G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))\\pmod{x^n}$$ \n\n考虑到$G(F(x))\\equiv 0\\pmod{x^n}$ $$F(x)\\equiv F_0(x)-\\frac{G(F_0(x))}{G'(F_0(x))}\\pmod{x^n}$$ \n\n边界条件即$f[0]=e^{a_0}$，向上迭代即可. \n\n回到本题，考虑到 $$B(x)\\equiv e^{A(x)}\\pmod{x^n}$$ \n\n即 $$\\ln B(x)-A(x)\\equiv0\\pmod{x^n}$$ \n\n于是令 $$G(B(x))\\equiv\\ln B(x)-A(x)\\pmod{x^n}$$ \n\n由于$A(x)$为常数， $$G'(B(x))=B^{-1}(x)$$ ，套牛顿迭代 $$B(x)\\equiv B_0(x)(1-\\ln B_0(x)+A(x))\\pmod{x^n}$$\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &x : a)\n        cin >> x;\n    Poly<P> p(a);\n    auto b = p.exp(n);\n    for (auto x : b)\n        cout << x << ' ';\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.10 多项式多点求值\n\n原理不会，抄就行。\n\n给定一个 $n$ 次多项式 $f(x)$ ，现在请你对于 $i \\in [1,m]$ ，求出 $f(a_i)$ 。***注意是$n$次，意味着有$n+1$项***。\n\n$n,m \\in [1,64000]$，$a_i,[x^i]f(x) \\in [0,998244352]$ 。\n\n$[x^i]f(x)$ 表示 $f(x)$ 的 $i$​ 次项系数。\n\n```cpp\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    Poly<P> f(n + 1);\n    for (auto &v : f)\n    {\n        cin >> v;\n    }\n    vector<Z> x(m);\n    for (auto &v : x)\n    {\n        cin >> v;\n    }\n    auto fx = f.eval(x);\n    for (auto v : fx)\n    {\n        cout << v << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.11 多项式快速插值/拉格朗日快速插值\n\n以下默认$mid=\\lfloor\\frac{l+r}{2}\\rfloor$\n\n由拉格朗日差值公式$\\large F(x)=\\sum_{i=1}^n y_i\\prod_{j\\neq i}\\frac{x-x_j}{x_i-x_j}$化简得到\n$$\n\\large F(x)=\\sum_{i=1}^n \\frac{y_i}{\\prod_{j\\neq i}(x_i-x_j)}\\prod_{j\\neq i}(x-x_j)\n$$\n设$\\large \\delta(x)=\\prod_{i=1}^n(x-x_i)$，则显然有洛必达法则下，$\\large \\prod_{j\\neq i}(x_i-x_j)=\\lim_{x\\to x_i}\\frac{\\delta(x)}{x-x_i}=\\delta'(x_i)$\n\n对$\\delta(x)$分治$NTT$（类似快速幂那种就行了），求导后多点求值得到$\\delta'(x_i)$.\n\n接下来继续正宗分治$NTT$即可，设$G_{l,r}(x)=\\prod_{i=l}^r(x-x_i)$，$H_{l,r}$为$(x_l,y_l),\\cdots,(x_r,y_r)$插出来的多项式，即$\\sum_{i=l}^r \\frac{y_i}{\\delta'(x_i)}\\prod_{j\\neq i,l\\le j\\le r}(x-x_j)$，则有\n$$\nG_{l,r}=G_{l,mid}\\ \\cdot\\ G_{mid+1,r}\\\\\nH_{l,r}=H_{l,mid}\\ \\cdot G_{mid+1,r}\\ +\\ H_{mid+1,r}\\ \\cdot\\ G_{l,mid}\n$$\n\n\n分治$NTT$即可。复杂度$O(nlog^2n)$\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.12 二维卷积\n\n$$\n\\large s_{i,j}=\\sum_{x_1\\circ x_2=i,y_1*y_2=j}a_{x_1,y_1}\\times b_{x_2,y_2}\n$$\n\n分5步：\n\n1.对$a$和$b$的每一行做普通$DFT$或对应$FWT$\n\n2.对$a$和$b$的每一列做普通$DFT/FWT$\n\n3.新建矩阵$s$，$s_{i,j}=a_{i,j}b_{i,j}$\n\n4.对$s$的每一**列**做普通$IDFT/IFWT$(别忘了做完之后乘上每列长度的逆元)\n\n5.对$s$的每一**行**做普通$IDFT/IFWT$(别忘了做完之后乘上每行长度的逆元)\n\n然后$s$就是要求的结果了。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.13 普通生成函数操作\n\n普通生成函数操作组合数学计数问题。\n\n举一个例子：\n\n一个长度为$n$的数列，从中取出$s$个数，要求异或结果为$k$的方案数。\n\n操纵生成函数：\n$$\nF(x,y)=\\prod_{i=1}^n(1+x^{a_i}y)\n$$\n这里$x$为异或卷积，$y$为正卷积。\n\n则答案为$[x^{k}y^s]F(x,y)$，即对应项系数。一般不会有二维的情况，二维显然无法确定单位根，一般是需要暴力卷积的。本生成函数原题$ABC367G$中$y$是一个长度不超过$100$​的循环卷积，问题只在快速沃尔什变换上。\n\n考虑对$1+x^{a_i}y$进行快速沃尔什点值变换，记变换后的点值序列为$FWT(x^{a_i})=\\{g_{a_i}^{w}\\}$，则由于将$y$于此维度视作常数，由于沃尔什变换线性性有$FWT(1+x^{a_i}y)=\\{1+g_{a_i}^{w}y\\}$​.\n\n由于沃尔什变换特性，幂次函数$x^n$的沃尔什变换序列只有$1$和$-1$两种情况，所以沃尔什序列对应位置点值相乘后有$FWT(F(x,y))_w=[y^0]\\prod_{i=1}^n(1+y)^{c_w}(1-y)^{n-c_w}$，其中$c_w$为$FWT(x_{a_i})_w$为$1$的$i$的数量。关于$c_w$显然有$c_w+(n-c_w)\\times(-1)=\\sum_{i=1}^nh_{a_i}^w$，等式右边可以由$\\sum_{i=1}^nx^{a_i}$快速沃尔什变换得到（$FWT$线性性）\n\n由于$y$​维度很小，暴力卷积卷出来，最后快速沃尔什逆变换后就是结果多项式，直接锁结果就行了。\n\n```cpp\nvector<int> f, a, b, finalans;\nvector<vector<int>> presum, presum2;\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    f.assign(1 << 20, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        f[x]++;\n    }\n    a = fwt_xor(f);\n    for (int i = 0; i < (1 << 20); i++)\n    {\n        a[i] = ((n + a[i]) % mod * (499122177)) % mod;\n    }\n    // 暴力预处理循环卷积(1+y)^a 以及(1-y)^a\n    presum.assign(n + 1, vector<int>(m + 1)), presum2 = presum;\n    presum[0][0] = presum2[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            presum[i][j] = (presum[i][j] + presum[i - 1][j]) % mod;                              //(1+y)\n            presum[i][(j + 1) % m] = (presum[i][(j + 1) % m] + presum[i - 1][j]) % mod;          //(1+y)\n            presum2[i][j] = (presum2[i][j] + presum2[i - 1][j]) % mod;                           //(1-y)\n            presum2[i][(j + 1) % m] = (presum2[i][(j + 1) % m] - presum2[i - 1][j] + mod) % mod; //(1-y)\n        }\n    }\n    finalans.assign(1 << 20, 0);\n    for (int i = 0; i < (1 << 20); i++) // 快速沃尔什变换第i位的值\n    {                                   //(1+y)^(a[i])*(1-y)^(n-a[i])\n                                        // 求y^0，即y^m项\n        for (int j = 0; j < m; j++)\n        {\n            finalans[i] = (finalans[i] + (presum[a[i]][j] * presum2[n - a[i]][(m - j) % m] % mod)) % mod;\n        }\n    }\n    b = ifwt_xor(finalans);\n    i64 ans = 0;\n    for (int i = 0; i < (1 << 20); i++)\n    {\n        ans = (ans + b[i] * power(i, k) % mod) % mod;\n    }\n    cout << ans << endl;\n}\n```\n\n其他见$OI-Wiki$\n\n#### 3.14 指数生成函数操作\n\n操纵排列数学计数问题。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 4. 计算几何相关\n\n#### 4.1 平面几何（with Complex)\n\n```cpp\n/**   平面几何（with. complex）\n *    2023-09-04: https://qoj.ac/submission/164445\n**/\nusing Point = std::complex<long double>;\n\n#define x real\n#define y imag\n\nlong double dot(const Point &a, const Point &b) {\n    return (std::conj(a) * b).x();\n}\n\nlong double cross(const Point &a, const Point &b) {\n    return (std::conj(a) * b).y();\n}\n\nlong double length(const Point &a) {\n    return std::sqrt(dot(a, a));\n}\n\nlong double dist(const Point &a, const Point &b) {\n    return length(a - b);\n}\n\nlong double get(const Point &a, const Point &b, const Point &c, const Point &d) {\n    auto e = a + (b - a) * cross(c - a, d - a) / cross(b - a, d - c);\n    return dist(d, e);\n}\n```\n\n#### 4.2 二维凸包+旋转卡壳（凸包直径）\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// #define DEBUG 1\n#define i64 long long\n#define d32 double\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e6 + 9;\nstruct node\n{\n    i64 x, y;\n    bool operator<(const node &a) const\n    {\n        return x == a.x ? y < a.y : x < a.x;\n    }\n    bool operator==(const node &a) const\n    {\n        return x == a.x && y == a.y;\n    }\n    node operator-(const node &a) const\n    {\n        return {x - a.x, y - a.y};\n    }\n    i64 operator*(const node &a) const\n    {\n        return x * a.y - y * a.x;\n    }\n    i64 operator^(const node &a) const\n    {\n        return x * a.x + y * a.y;\n    }\n    node operator+(const node &a) const\n    {\n        return {x + a.x, y + a.y};\n    }\n    friend d32 dis(node a, node b)\n    {\n        return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    friend i64 dis2(node a, node b)\n    {\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n};\nint stk[N], tp = 0;\nbool used[N];\n\n//返回的vector0位空出，最后一位为第一个点\nvector<node> get_convex(node p[], int n)\n{\n    // stk[] 是整型，存的是下标\n    // p[] 存储向量或点\n    // h[] 存储凸包上的点\n    // used[] 标记是否在凸包上\n    // tp 栈顶指针\n    tp = 0; // 初始化栈\n            // 标记是否在凸包上\n    for (int i = 1; i <= n; i++)\n    {\n        used[i] = 0;\n    }\n    std::sort(p + 1, p + 1 + n); // 对点进行排序\n    stk[++tp] = 1;\n    // 栈内添加第一个元素，且不更新 used，使得 1 在最后封闭凸包时也对单调栈更新\n    for (int i = 2; i <= n; ++i)\n    {\n        while (tp >= 2 // 下一行 * 操作符被重载为叉积\n               && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n            used[stk[tp--]] = 0;\n        used[i] = 1; // used 表示在凸壳上\n        stk[++tp] = i;\n    }\n    int tmp = tp; // tmp 表示下凸壳大小\n    for (int i = n - 1; i > 0; --i)\n        if (!used[i])\n        {\n            // ↓求上凸壳时不影响下凸壳\n            while (tp > tmp && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n                used[stk[tp--]] = 0;\n            used[i] = 1;\n            stk[++tp] = i;\n        }\n    vector<node> h;\n    h.push_back({-INF, -INF});    // 从 1 开始存储凸包上的点\n    for (int i = 1; i <= tp; ++i) // 复制到新数组中去\n        h.push_back(p[stk[i]]);\n    int ans = tp - 1;\n    return h;\n}\nbool is[N];\n// 求凸包直径，返回直径的平方\ni64 get_longest(vector<node> sta)\n{\n#ifdef DEBUG\n    cout << \"-------------------DEBUG-------------------\" << endl;\n    cout << \"points in convex hull:\" << endl;\n    for (auto i : sta)\n    {\n        cout << i.x << \" \" << i.y << endl;\n    }\n    cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n    i64 mx = 0;               // 求凸包直径\n    int top = sta.size() - 1; // 将凸包上的节点编号存在栈里，第一个和最后一个节点编号相同\n    int j = 3;\n    if (top < 4)\n    {\n        mx = dis2(sta[1], sta[2]);\n        return mx;\n    }\n    for (int i = 1; i < top; i++)\n    {\n        while ((sta[i + 1] - sta[i]) * (sta[j] - sta[i + 1]) <= (sta[i + 1] - sta[i]) * (sta[j % top + 1] - sta[i + 1]))\n        {\n#ifdef DEBUG\n            cout << \"-------------------DEBUG-------------------\" << endl;\n            cout << \"i=\" << i << \" j=\" << j << endl;\n            cout << \"sta[i]=\" << sta[i].x << \" \" << sta[i].y << endl;\n            cout << \"sta[i+1]=\" << sta[i + 1].x << \" \" << sta[i + 1].y << endl;\n            cout << \"sta[j]=\" << sta[j].x << \" \" << sta[j].y << endl;\n            cout << \"sta[j%top+1]=\" << sta[j % top + 1].x << \" \" << sta[j % top + 1].y << endl;\n            cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n            j = j % top + 1;\n        }\n#ifdef DEBUG\n        cout << \"-------------------DEBUG-------------------\" << endl;\n        cout << \"mx=\" << mx << endl;\n        cout << \"dis2(sta[\" << i << \"],sta[\" << j << \"])=\" << dis2(sta[i], sta[j]) << endl;\n        cout << \"dis2(sta[\" << i + 1 << \"],sta[\" << j << \"])=\" << dis2(sta[i + 1], sta[j]) << endl;\n        cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n        mx = max(mx, max(dis2(sta[i], sta[j]), dis2(sta[i + 1], sta[j])));\n    }\n    return mx;\n}\nnode a[N + 1], b[N + 1];\nvoid solve()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i].x >> a[i].y;\n    }\n    vector<node> h = get_convex(a, n);\n    int cnt = h.size() - 2;\n    d32 C = 0;\n    for (int i = 1; i <= cnt; i++)\n    {\n        C += dis(h[i], h[i + 1]);\n    }\n\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> b[i].x >> b[i].y;\n    }\n    h.clear();\n    h = get_convex(b, n);\n    d32 D = sqrtl(get_longest(h));\n    // cout << C << endl;\n    cout << fixed << setprecision(10) << C + 2 * M_PI * D << endl;\n    return;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5. 组合数学相关\n\n#### 5.1 组合数杨辉三角+线性递推逆元\n\n```cpp\n#include<iostream>\n\nusing namespace std;\nint n,m;\nint f[1005][1005];\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n    {\n        f[i][i]=1;\n        f[i][0]=1;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            f[i][j]=f[i-1][j]+f[i-1][j-1];\n    cout<<f[n][m];\n    return 0;\n}\n\n```\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod;\nconst int maxn = 6e6 + 9;\nint inv[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a;\n    cin >> a >> mod;\n    inv[1] = 1;\n    cout << 1 << endl;\n    for (int i = 2; i <= a; i++)\n    {\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n        cout << inv[i] << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 5.2 卢卡斯定理/扩展卢卡斯定理\n\n$$\nC_n^{m}\\ mod\\ p=C_{\\lfloor \\frac{n}{p}\\rfloor}^{\\lfloor \\frac{m}{p}\\rfloor}\\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p}\\ mod \\ p\n$$\n\n强制要求$p$为质数。复杂度$O(p+Tlogn)$\n\n```cpp\nlong long C(long long n,long long m,long long mod)\n{\n    if(m>n&&n==0)return 0;\n    if(m==0)return 1;\n    return ((frac[n]*invq[m]%mod)*invq[n-m])%mod;\n}\n//阶乘的值和逆元预处理是线性的递推\nlong long Lucas(long long n, long long m, long long p)\n{\n    if (m == 0)\n        return 1;\n    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;\n}\n```\n\n对于扩展卢卡斯定理，不再要求$p$必须是质数，原理见$OI-Wiki$。注意，单次询问$O(plogp)$复杂度，基本不可能支持大量次数询问。模板也是仅支持查询一次的。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <climits>\n#include <cmath>\nusing namespace std;\nnamespace ExLucas\n{\n    const int N = 1e6;\n    typedef long long ll;\n    ll n, m, p;\n    inline ll power(ll a, ll b, const ll p = LLONG_MAX)\n    {\n        ll ans = 1;\n        while (b)\n        {\n            if (b & 1)\n                ans = ans * a % p;\n            a = a * a % p;\n            b >>= 1;\n        }\n        return ans;\n    }\n    ll fac(const ll n, const ll p, const ll pk)\n    {\n        if (!n)\n            return 1;\n        ll ans = 1;\n        for (int i = 1; i < pk; i++)\n            if (i % p)\n                ans = ans * i % pk;\n        ans = power(ans, n / pk, pk);\n        for (int i = 1; i <= n % pk; i++)\n            if (i % p)\n                ans = ans * i % pk;\n        return ans * fac(n / p, p, pk) % pk;\n    }\n    ll exgcd(const ll a, const ll b, ll &x, ll &y)\n    {\n        if (!b)\n        {\n            x = 1, y = 0;\n            return a;\n        }\n        ll xx, yy, g = exgcd(b, a % b, xx, yy);\n        x = yy;\n        y = xx - a / b * yy;\n        return g;\n    }\n    ll inv(const ll a, const ll p)\n    {\n        ll x, y;\n        exgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n    ll C(const ll n, const ll m, const ll p, const ll pk)\n    {\n        if (n < m)\n            return 0;\n        ll f1 = fac(n, p, pk), f2 = fac(m, p, pk), f3 = fac(n - m, p, pk), cnt = 0;\n        for (ll i = n; i; i /= p)\n            cnt += i / p;\n        for (ll i = m; i; i /= p)\n            cnt -= i / p;\n        for (ll i = n - m; i; i /= p)\n            cnt -= i / p;\n        return f1 * inv(f2, pk) % pk * inv(f3, pk) % pk * power(p, cnt, pk) % pk;\n    }\n    ll a[N], c[N];\n    int cnt;\n    inline ll CRT()\n    {\n        ll M = 1, ans = 0;\n        for (int i = 0; i < cnt; i++)\n            M *= c[i];\n        for (int i = 0; i < cnt; i++)\n            ans = (ans + a[i] * (M / c[i]) % M * inv(M / c[i], c[i]) % M) % M;\n        return ans;\n    }\n    ll exlucas(const ll n, const ll m, ll p)\n    {\n        ll tmp = sqrt(p);\n        for (int i = 2; p > 1 && i <= tmp; i++)\n        {\n            ll tmp = 1;\n            while (p % i == 0)\n                p /= i, tmp *= i;\n            if (tmp > 1)\n                a[cnt] = C(n, m, i, tmp), c[cnt++] = tmp;\n        }\n        if (p > 1)\n            a[cnt] = C(n, m, p, p), c[cnt++] = p;\n        return CRT();\n    }\n    int work()\n    {\n        ios::sync_with_stdio(false);\n        cin >> n >> m >> p;\n        cout << exlucas(n, m, p);\n        return 0;\n    }\n}\nint main()\n{\n    return zyt::work();\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 5.3 $Catlan$数与$Fibonacci$数列\n\n$H_n=\\frac{2n!}{n+1},n\\ge 2$，维护一种绝对大于等于的关系，比如固定入栈顺序，有多少种出栈顺序（保证栈内元素数量一定大于等于总出栈元素数量）​\n\n数列皮亚诺周期不超过$6k$，$k$​为模数。强行解周期可以考虑矩阵原根计算，因为矩阵$mod$$p$最小周期是皮亚诺周期，所以根号开$\\sqrt {6k+1}$.\n\n```cpp\n#include <bits/stdc++.h>\n#define umap unordered_map\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstring S;\nll MOD;\n\nconst int L = 2;\nconst ull BASE = 13331;\nstruct Matrix {\n    ll M[L+1][L+1];\n    ll *operator[](int p) {\n        return M[p];\n    }\n    void clear() {\n        memset(M, 0, sizeof M);\n    }\n    void reset() {\n        clear();\n        for (int i = 1; i <= L; i++)\n            M[i][i] = 1;\n    }\n    Matrix friend operator*(Matrix A, Matrix B) {\n        Matrix C; C.clear();\n        for (int i = 1; i <= L; i++)\n            for (int k = 1; k <= L; k++)\n                for (int j = 1; j <= L; j++)\n                    (C[i][j] += A[i][k] * B[k][j] % MOD) %= MOD;\n        return C;\n    }\n    ull hs() { // hash\n        ull ret = 0;\n        for (int i = 1; i <= L; i++)\n            for (int j = 1; j <= L; j++)\n                ret = ret * BASE + M[i][j];\n        return ret;\n    }\n\n};\nMatrix qpow(Matrix A, ll b) {\n    Matrix Ret; Ret.reset();\n    while (b) {\n        if (b & 1)\n            Ret = Ret * A;\n        A = A * A;\n        b >>= 1;\n    }\n    return Ret;\n}\n\nll BSGS(Matrix A, Matrix B) {\n    umap<ull, ll> mp;\n    ll t = sqrt(MOD * 6) + 1;\n    Matrix Cur; Cur.reset();\n    for (ll i = 1; i <= t; i++) {\n        mp[(Cur * B).hs()] = i-1;\n        Cur = A * Cur;\n    }\n    Matrix Cur2 = Cur;\n    for (ll i = 1; i <= t; i++) {\n        if (mp.find(Cur2.hs()) != mp.end())\n            return i * t - mp[Cur2.hs()];\n        Cur2 = Cur * Cur2;\n    }\n    return -1;\n}\n\nMatrix A, I;\nvoid init() {\n    A[1][1] = 1; A[1][2] = 1;\n    A[2][1] = 1; A[2][2] = 0;\n\n    I[1][1] = 1; I[1][2] = 0;\n    I[2][1] = 0; I[2][2] = 1;\n}\n\nll fib(ll n) {\n    if (n == 0)\n        return 0;\n    return qpow(A, n-1)[1][1];\n}\n\nint main() { ios::sync_with_stdio(0); cin.tie(0);\n    cin >> S >> MOD;\n    if (MOD == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    init();\n    ll pi = BSGS(A, I);\n    ll n = 0;\n    for (auto c : S)\n        n = (n * 10 + (c - '0')) % pi;\n    cout << fib(n) << endl;\n    return 0;\n}\n```\n\n\n\n查$OI-Wiki$​\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6. 位运算相关技巧杂谈\n\n1. 异或是特殊的矩阵加法，在$<Z_2^n,xor,and>$下。\n2. 连续从$1$到$n$的异或和是有规律的，对于模$4$剩余下有余$1$得$1$，余$2$得$n+1$，余$3$得$0$，余$0$得$n$​.\n3. 区间异或和可表示两个前缀异或的异或和。\n4. 带递归形式的$f(x)=f(\\frac{x}{3})$等之类的关注位运算进制表示规律。\n5. $a+b=2(a\\&b)+(a\\oplus b)$\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 3. 杂项技巧\n\n### 3.1 普通莫队\n\n假设$n=m$,那么对于序列上的区间询问问题,如果从$[l,r]$的答案能够$O(1)$扩展到$[l-1,r],[l+1,r],[l,r+1],[l,r-1]$（即与$[l,r]$相邻的区间）的答案,那么可以在$O(n\\sqrt n)$​的复杂度内求出所有询问的答案。\n\n莫队需要相当牛逼的卡常，基本上禁用一切$mapSTL$，实在必要需要手搓哈希表。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nint block; // 莫队分块大小\nstruct node\n{\n    int l, r, id;\n    bool operator<(const node &x) const\n    {\n        if (l / block != x.l / block)\n            return l < x.l;\n        // 注意下面两行不能写小于（大于）等于，否则会出错（详见下面的小细节）\n        if ((l / block) & 1)\n            return r < x.r;\n        return r > x.r;\n    }\n};\nint sum = 0;\nconst int maxn = 2e5 + 9;\nconst int inf = 1e6 + 9;\nint mp[inf];\nint a[maxn];\nvoid add(int pos)\n{\n    if (mp[a[pos]])\n        sum--;\n    else\n        sum++;\n    mp[a[pos]] ^= 1;\n}\nvoid del(int pos)\n{\n    if (mp[a[pos]])\n        sum--;\n    else\n        sum++;\n    mp[a[pos]] ^= 1;\n}\nint n;\nvoid solve()\n{\n    sum = 0;\n    int n, q;\n    cin >> n >> q;\n    block = sqrt(n);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        mp[a[i]] = 0;\n    }\n    vector<node> qs;\n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        qs.push_back({l, r, i});\n    }\n    vector<int> ans(q);\n    sort(qs.begin(), qs.end());\n    int l = 1, r = 0;\n    for (int i = 0; i < q; i++)//莫队算法灵魂\n    {\n        while (l > qs[i].l)\n            add(--l);\n        while (r < qs[i].r)\n            add(++r);\n        while (l < qs[i].l)\n            del(l++);\n        while (r > qs[i].r)\n            del(r--);\n        ans[qs[i].id] = sum;\n    }\n    for (int i = 0; i < q; i++)\n    {\n        if (ans[i])\n        {\n            cout << \"NO\" << endl;\n        }\n        else\n            cout << \"YES\" << endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.2 带修改莫队\n\n普通莫队算法不支持修改，需要带修改的莫队。带修改莫队唯一的区别就是加上了一个时间戳维度，变成了多维莫队。\n\n然后跳时间戳就行了，改少了就多改，改多了就改回去。\n\n注意，带修改莫队常数较大，分块$n^{\\frac{2}{3}}$，时间复杂度$O(n^{\\frac{5}{3}})$，不要带奇偶排序​\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nint block;\nstruct qnode\n{\n    int l, r, id, t;\n    bool operator<(const qnode &x) const\n    {\n        if (l / block != x.l / block)\n            return l < x.l;\n        if (r / block != x.r / block)\n            return r < x.r;\n        return t < x.t;\n    };\n};\nvector<array<int, 2>> upd(1);\nvector<int> mp(1e7);\nint sum = 0;\nvoid add(int x)\n{\n    mp[x]++;\n    if (mp[x] == 1)\n        sum++;\n}\nvoid del(int x)\n{\n    mp[x]--;\n    if (mp[x] == 0)\n        sum--;\n}\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    block = pow(n, 2.0 / 3);\n    vector<qnode> query;\n    for (int i = 0, cnt = 0; i < q; i++)\n    {\n        char op;\n        cin >> op;\n        if (op == 'Q')\n        {\n            int l, r;\n            cin >> l >> r;\n            query.emplace_back((qnode){l - 1, r - 1, cnt, upd.size() - 1});\n            cnt++;\n        }\n        else\n        {\n            int x, y;\n            cin >> x >> y;\n            upd.push_back({x - 1, y});\n        }\n    }\n    vector<int> ans(query.size());\n    sort(query.begin(), query.end());\n    int l = 0, r = -1, t = 0;\n    stack<array<int, 2>> stk;\n    for (auto &i : query)\n    {\n        while (l > i.l)\n            add(a[--l]);\n        while (r < i.r)\n            add(a[++r]);\n        while (l < i.l)\n            del(a[l++]);\n        while (r > i.r)\n            del(a[r--]);\n        while (t < i.t)\n        {\n            t++;\n            if (l <= upd[t][0] && upd[t][0] <= r)\n            {\n                del(a[upd[t][0]]);\n                add(upd[t][1]);\n            }\n            stk.push({upd[t][0], a[upd[t][0]]});\n            a[upd[t][0]] = upd[t][1];\n        }\n        while (t > i.t)\n        {\n            if (l <= upd[t][0] && upd[t][0] <= r)\n            {\n                del(a[upd[t][0]]);\n                add(stk.top()[1]);\n            }\n            a[upd[t][0]] = stk.top()[1];\n            stk.pop();\n            t--;\n        }\n        ans[i.id] = sum;\n    }\n    for (auto i : ans)\n        cout << i << endl;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.3 树上莫队\n\n给定一个$n$个节点的树，每个节点表示一个整数，问$u$到$v$的路径上有多少个不同的整数。\n\n转成欧拉序区间问题。\n\n具体做法：设每个点的编号$a$首次出现的位置$first[a]$，最后出现的位置为$last[a]$，那么对于路径$x→y$，设$first[x]\\le first[y]$（不满足则`swap`，这个操作的意义在于，如果$x$、$y$在一条链上，则$x$一定是$y$的祖先或等于$y$），如果$lca(x,y)=x$，则直接把$[first[x],first[y]]$的区间扯过来用，反之使用$[last[x],first[y]]$区间，但这个区间内不包含$x$和$y$的最近公共祖先，查询的时候加上即可。\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 4. 图论\n\n## 1. 最短路\n\n最短路，图上问题，分层图最短路，最短路形式优化$dp$​.\n\n最短路具有类似$dp$的最优子结构性质，判定一条边$(u,v)$属于最短路$i\\to j$的一条边，当且仅当$dis_{i,u}+w+dis_{v,j}=dis_{i,j}$\n\n### 1.1 Dijkstra\n\n稀疏图堆优化，复杂度$O((n+m)logn)$，只能处理完全正边权图。如果有负边权需要参考费用流中对偶$Dijkstra$，使用势能函数进行评估。\n\n```cpp\n//mlogn\n#include<bits/stdc++.h>//处理完全正权有向图，可以有环\n//将结点分为两类，不断松弛，但注意确定一个节点后我们便不再进行更新这个节点了（所以这是dij的短视性），所以无法处理负权，因为负权可能会更新我们已加入的节点。\nusing namespace std;\nconst int N=1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,s,u,v,sum;\nstruct node{\n    int to,val;\n};\nvector<vector<node> >edge;\nint dis[N],vis[N];\nvoid dijkstra(){\n    memset(dis,inf,sizeof(dis));//初始化\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;//小根堆启动\n    q.push({0,s});//距离在前，点在后，因为pair默认先排前面的\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second]){\n            if(dis[j.to]>dis[k.second]+j.val){\n                dis[j.to]=min(dis[j.to],dis[k.second]+j.val);\n                q.push({dis[j.to],j.to});\n            }\n        } \n        //对所有相邻顶点进行松弛，dis是到源点的距离\n    }\n}\nint main(){\n    cin>>n>>m>>s;\n    edge.resize(n+1);\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        edge[u].push_back({v,sum});\n    }\n    dijkstra();\n    for(int i=1;i<=n;i++){\n        if(!vis[i])cout<<(1<<31)-1<<\" \";//说明不相连\n        else cout<<dis[i]<<\" \";\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.2  Floyed\n\n以$O(n^3)$的方式暴力预处理所有的最短路，本质是连通矩阵的传递闭包。适合数据范围极小的大量的最短路询问操作。曾经在$Atcoder$​出现过。\n\n暴力枚举顺序千万别反了。\n\n```cpp\ncin>>n>>m>>s;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(i!=j)a[i][j]=inf;//初始化\n            else a[i][j]=0;\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        a[u][v]=min(a[u][v],sum);//应付重边\n    }\n    for(int k=1;k<=n;k++)//先枚举每个中间点，来更新i，j，必须先这么做\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);//核心过程：借助每个中间点进行松弛操作\n    for(int i=1;i<=n;i++){\n        if(a[s][i]==inf)cout<<(1<<31)-1<<\" \";//说明不相连\n        else cout<<a[s][i]<<\" \";\n}\n```\n\n### 1.3  SPFA/Bellman-Ford\n\n关于$SPFA$——他死了。\n\n极端条件下会被菊花图卡成$O(nm)$的算法。可以用于普适性的带负边权的图，可以检测负环。\n\n```cpp\nbool spfa()\n{\n    memset(dis, inf, sizeof(dis)); // 初始化\n    memset(cnt, 0, sizeof(cnt));   // 负环计数器\n    dis[s] = 0;\n    vis[s] = 1; // 注意 vis数组代表在不在队列中，在这里点是可以重复入队的\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0; // 取出队列中的元素，故vis为0\n        for (auto i : edge[u])\n        {\n            if (dis[i.to] > dis[u] + i.val)\n            {\n                cnt[i.to]++;\n                if (cnt[i.to] > n)\n                    return 0;\n                dis[i.to] = dis[u] + i.val;\n                if (vis[i.to] == 0)\n                {\n                    vis[i.to] = 1;\n                    q.push(i.to);\n                }\n            }\n        }\n    }\n    return 1;\n}\n```\n\n判断负环方式：当一个点被松弛了超过$n$次，意味着其中一定有经过它的负环。\n<div style=\"page-break-after: always;\"></div>\n\n### 1.4 差分约束\n\n$x_r-x_l\\le c\\iff addEdge(l,r,c)$，$x_r-x_l\\ge c\\iff addEdge(r,l,-c)$\n\n跑最短路求可行解即可，使用$Spfa$跑最短路。有负环则无解。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<vector<array<int, 2>>> con;\nvoid addedge(int x, int y, int z)\n{\n    con[x].push_back({y, z});\n}\nvector<int> dist, vis, tot;\nint n, m;\nbool spfa(vector<int> &dist, int st)\n{\n    dist.assign(n + 1, LONG_LONG_MIN / 2);\n    vis.assign(n + 1, 0);\n    tot.assign(n + 1, 0);\n    queue<int> q;\n    dist[0] = 0;\n    vis[0] = 1;\n    q.push(0);\n    while (!q.empty())\n    { // 判负环，看上面的\n        int cur = q.front();\n        q.pop();\n        vis[cur] = 0;\n        for (auto [v, w] : con[cur])\n            if (dist[cur] + w > dist[v])\n            {\n                dist[v] = dist[cur] + w;\n                if (!vis[v])\n                {\n                    vis[v] = 1;\n                    q.push(v);\n                    tot[v]++;\n                    if (tot[v] >= n)\n                    {\n                        return 0;\n                    }\n                }\n            }\n    }\n    return 1;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> m;\n    con.assign(n + 1, vector<array<int, 2>>());\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        addedge(u, v, w);\n        addedge(v, u, -w);\n    }\n    for (int i = 1; i <= n; i++)\n        addedge(0, i, 0);\n    spfa(dist, 0);\n    for (int i = 1; i <= n; i++)\n        cout << dist[i] << ' ';\n    cout << '\\n';\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.5 分层图最短路\n\n对于特定的一些限制条件，可以通过拆分分层图，用不同图层表示不同的状态。\n\n#### 示例1：$k$次机会不消耗花费通过某条边的最短路\n\n```cpp\n#include<bits/stdc++.h>//解决问题：我们有k次机会0代价的通过某条路下的最短路\n//分层图：当我们使用一次机会时，相当于我们进入下一张图\nusing namespace std;\nconst int N=2*1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> P;\nint n,m,k,s,t,u,v,sum;\nvector<P>edge[N];\nint dis[N],vis[N];\nvoid dijkstra(){//常规不必再说\n    memset(dis,inf,sizeof(dis));\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;\n    q.push({0,s});\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second])dis[j.first]=min(dis[j.first],dis[k.second]+j.second),q.push({dis[j.first],j.first});\n    }\n}\nint main(){\n    cin>>n>>m>>k>>s>>t;\n    s++;t++;\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        u++;v++;\n        edge[u].push_back({v,sum});//原始层\n        edge[v].push_back({u,sum});\n        for(int j=1;j<=k;j++){//一共有k+1层，某个点在每个层s，s+n,s+2n,...,s+kn\n            edge[u+j*n].push_back({v+j*n,sum});//每个层都是一样的\n            edge[v+j*n].push_back({u+j*n,sum});\n            edge[v+(j-1)*n].push_back({u+j*n,0});//使用特权：即换层\n            edge[u+(j-1)*n].push_back({v+j*n,0});\n        }\n    }\n    for(int i=1;i<=k;i++)edge[t+(i-1)*n].push_back({t+i*n,0});//把终点从上到小连起来，这样即使没有用完n次机会我们也是从t+nk中读答案\n    dijkstra();//正常跑最短路\n    printf(\"%d\",dis[t+k*n]);\n}\n\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 示例2：地铁换乘问题\n\n```cpp\n//坐地铁问题：一共m条线路，n个地铁站，有换乘等问题，那就建m+1*n个点，在5e5左右，因为每层图之间的边权不同所以要把站点拆开成m个，再建立虚层连接不同层代表模拟换乘的过程\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N = 510000,INF = 0x3f3f3f3f;  //注意数据范围\ntypedef pair<int,int> P;\nint n,m,s,t;\nstruct node{\n    int to,val;\n};\nvector<node>edge[N];\nint dis[N],vis[N];\nvoid add(int u,int v,int w) //加边函数\n{\n    //cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    edge[u].push_back({v,w});\n}\n\nvoid dijkstra(int s){\n    memset(dis,INF,sizeof(dis));//初始化\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;//小根堆启动\n    q.push({0,s});//距离在前，点在后，因为pair默认先排前面的\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second]){\n            if(dis[j.to]>dis[k.second]+j.val){\n                //if(j.to==8)cout<<k.second<<\" \"<<dis[k.second]<<endl;\n                dis[j.to]=min(dis[j.to],dis[k.second]+j.val);\n                q.push({dis[j.to],j.to});\n            }\n        } \n    }\n}\nint main()\n{\n    int price,ad,num,pre,cur;\n    cin >> n >> m >> s >> t;\n    for(int i = 1;i <= m;i++)\n    {\n        cin >> price >> ad >> num;\n        for(int j = 0;j <num;j++)\n        {\n            cin >> cur;\n            if(j){\n                add((i-1)*n+pre,(i-1)*n+cur,ad);    \n                add((i-1)*n+cur,(i-1)*n+pre,ad);\n            }\n            add((i-1)*n+cur,n*m+cur,0);\n            add(n*m+cur,(i-1)*n+cur,price); \n            pre = cur;  \n        }\n    }\n    dijkstra(n*m+s);    \n    if(dis[n*m+t] == INF)   \n        cout << -1 << endl;\n    else\n        cout << dis[n*m+t] << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 示例3：一些相类似的移动方式集合到一起（2023澳门区域赛）\n\n题意概括：\n\n有一个$n$个节点的环，编号$0\\to n-1$. 你初始在$i$号节点。给一个长度为$n$的数组$a$。你每一次可以进行以下操作：\n\n1. 从$i$立即传送：$i\\to (a_i+i)\\pmod{n}$\n2. 修改当前$a_i$：$a_i\\to a_i+1$\n\n给定一个$x$，询问最少经过多少次操作能够从$0$到达$x$.\n\n这里要看你怎么看待这个修改。在$i$对$a_i$加$1$等价于直接跳到$a_i+i$后又花费一次机会向后走。因为你永远不可能走回头路，就是第二次经过$i$这个点，所以这个抽象是合理的。而我们又不可能直接在原图上把所有的点全部直接串起来。\n\n所以开一个分层图，额外新建立一个有向环模拟后跳跃这个操作，然后一次操作$1$就从原图的$i$向环上的$i+a_i$连边。环上的点向原图的自己连一条代价为0的单向有向边。\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2. 网络流\n\n解决网络流模型问题。\n\n### 2.1 MaxFlow.h\n\nJiangly最新最大流模板，点编号从0开始。费用流同理。\n\n```cpp\ntemplate <class T>\nstruct MaxFlow\n{\n    struct _Edge\n    {\n        int to;\n        T cap;\n        _Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n\n    int n;\n    std::vector<_Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n\n    MaxFlow() {}\n    MaxFlow(int n)\n    {\n        init(n);\n    }\n\n    void init(int n)\n    {\n        this->n = n;\n        e.clear();\n        g.assign(n, {});\n        cur.resize(n);\n        h.resize(n);\n    }\n\n    bool bfs(int s, int t)\n    {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty())\n        {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u])\n            {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1)\n                {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                    {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n\n    T dfs(int u, int t, T f)\n    {\n        if (u == t)\n        {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i)\n        {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1)\n            {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0)\n                {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c)\n    {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T flow(int s, int t)\n    {\n        T ans = 0;\n        while (bfs(s, t))\n        {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n\n    std::vector<bool> minCut()\n    {\n        std::vector<bool> c(n);\n        for (int i = 0; i < n; i++)\n        {\n            c[i] = (h[i] != -1);\n        }\n        return c;\n    }\n\n    struct Edge\n    {\n        int from;\n        int to;\n        T cap;\n        T flow;\n    };\n    std::vector<Edge> edges()\n    {\n        std::vector<Edge> a;\n        for (int i = 0; i < e.size(); i += 2)\n        {\n            Edge x;\n            x.from = e[i + 1].to;\n            x.to = e[i].to;\n            x.cap = e[i].cap + e[i + 1].cap;\n            x.flow = e[i + 1].cap;\n            a.push_back(x);\n        }\n        return a;\n    }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 MinCostFlow.h\n\n支持负数费用，不支持负数流量。\n\n```cpp\n/*\n *@brief 费用流（Jiangly）\n *@note 时间复杂度O(F(n+m)log(n+m)),F(n+m)表示流量和，n表示点数，m表示边数\n *@note 空间复杂度O(n+m)\n *@tparam Cap 流量数据类型\n *@tparam Cost 费用数据类型\n *@note  复杂度估算可同最大流，点数不超过2000，最坏上界估算O(n^3)到O(n^4)，基本不会TLE\n */\ntemplate <class T>\nstruct MinCostFlow\n{\n    struct _Edge\n    {\n        int to;\n        T cap;\n        T cost;\n        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}\n    };\n    int n;\n    std::vector<_Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<T> h, dis;\n    std::vector<int> pre;\n    bool dijkstra(int s, int t)\n    {\n        dis.assign(n, std::numeric_limits<T>::max());\n        pre.assign(n, -1);\n        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> que;\n        dis[s] = 0;\n        que.emplace(0, s);\n        while (!que.empty())\n        {\n            T d = que.top().first;\n            int u = que.top().second;\n            que.pop();\n            if (dis[u] != d)\n            {\n                continue;\n            }\n            for (int i : g[u])\n            {\n                int v = e[i].to;\n                T cap = e[i].cap;\n                T cost = e[i].cost;\n                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost)\n                {\n                    dis[v] = d + h[u] - h[v] + cost;\n                    pre[v] = i;\n                    que.emplace(dis[v], v);\n                }\n            }\n        }\n        return dis[t] != std::numeric_limits<T>::max();\n    }\n    MinCostFlow() {}\n    MinCostFlow(int n_)\n    {\n        init(n_);\n    }\n    void init(int n_)\n    {\n        n = n_;\n        e.clear();\n        g.assign(n, {});\n    }\n    void addEdge(int u, int v, T cap, T cost)\n    {\n        g[u].push_back(e.size());\n        e.emplace_back(v, cap, cost);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0, -cost);\n    }\n    std::pair<T, T> flow(int s, int t)\n    {\n        T flow = 0;\n        T cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t))\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                h[i] += dis[i];\n            }\n            T aug = std::numeric_limits<int>::max();\n            for (int i = t; i != s; i = e[pre[i] ^ 1].to)\n            {\n                aug = std::min(aug, e[pre[i]].cap);\n            }\n            for (int i = t; i != s; i = e[pre[i] ^ 1].to)\n            {\n                e[pre[i]].cap -= aug;\n                e[pre[i] ^ 1].cap += aug;\n            }\n            flow += aug;\n            cost += aug * h[t];\n        }\n        return std::make_pair(flow, cost);\n    }\n    struct Edge\n    {\n        int from;\n        int to;\n        T cap;\n        T cost;\n        T flow;\n    };\n    std::vector<Edge> edges()\n    {\n        std::vector<Edge> a;\n        for (int i = 0; i < e.size(); i += 2)\n        {\n            Edge x;\n            x.from = e[i + 1].to;\n            x.to = e[i].to;\n            x.cap = e[i].cap + e[i + 1].cap;\n            x.cost = e[i].cost;\n            x.flow = e[i + 1].cap;\n            a.push_back(x);\n        }\n        return a;\n    }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.3 Dinic (朱)\n\n```cpp\n// 理论上界为n2m，处理1e4-1e5的数据\n// 三个优化：多路增广，当前弧，炸点\n// 少做几次bfs，一次dfs进行多次增广\n// 建图时不用考虑点的变化，过程中没有用到点数这个信息，只需把边建出来就能跑\n// 多测的时候记得清空e[0]\n// 检查这条边是不是满流：是的话这条边的len变成0（没有剩余流量）\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], cur[N];\nbool bfs() // bfs分层\n{\n    memset(dep, -1, sizeof dep);\n    queue<int> q;\n    q.push(S);\n    dep[S] = 0;\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i = i + 1)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1 && e[t][i].len) // 如果这个点没有被定义层次，且还有剩余流量\n            {\n                dep[ed] = dep[t] + 1;\n                q.push(ed);\n            }\n        }\n    }\n    memset(cur, 0, sizeof(cur));\n    if (dep[T] == -1)\n        return 0;\n    else\n        return 1;\n}\nint dfs(int st, int limit) // limit最大可增加的流量\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // 定义当前节点的流量,多路增广优化，找满当前能找的limit流量上界\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // 当前弧优化，如果一个点有很多出边，有些出边可能无法再推流了，我们就记录第一条可以推流的边\n    {\n        cur[st] = i; // 当前弧优化\n        int ed = e[st][i].ed;\n        if (dep[ed] == dep[st] + 1 && e[st][i].len) // 这条边能推且，深度为更深一层（为了找最短的增广路）\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // 是为了限制后面点的流量不能大于limit-nowflow\n            if (t)                                               // 走下去能推流\n            {\n                e[st][i].len -= t;           // 减去相应的\n                e[ed][e[st][i].id].len += t; // 反边+相应的\n                nowflow += t;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    }\n    if (!nowflow)\n        dep[st] = -1; // 如果这个点不能延申，那就删掉这个点（炸点优化）\n    return nowflow;   // 会返回本次bfs（）后所有增广路能加的最多流量\n}\nint dinic()\n{\n    int r = 0;\n    while (bfs())\n        r += dfs(S, INF);\n    return r;\n}\nvoid add(int u, int v, int w)\n{ // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // 建边\n    e[v].push_back((edge){u, 0, sti});\n}\nsigned main()\n{\n    cin >> n >> m >> S >> T;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        add(u, v, w);\n    }\n    cout << dinic();\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.4 ISAP (朱)\n\n```cpp\n// 理论上界为n2m，处理1e4-1e5的数据\n// 只做一次bfs\n// 建图时注意n的改变，运行过程中有跟点数相关\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], gap[N], cur[N];\nvoid bfs() // bfs分层\n{\n    memset(dep, -1, sizeof dep);\n    memset(gap, 0, sizeof(gap));\n    queue<int> q;\n    q.push(T);\n    dep[T] = 0; // T为层数为0的点\n    gap[0] = 1; // 层数为0的点有一个\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i++)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1) // 如果这个点没有被定义层次就考虑（在这里不在乎这条边的流量是否为0！只负责分层)\n            {\n                dep[ed] = dep[t] + 1;\n                gap[dep[ed]]++;\n                q.push(ed);\n            }\n        }\n    }\n    return;\n}\nint dfs(int st, int limit) // limit最大可增加的流量\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // 定义当前节点的流量,多路增广优化，找满当前能找的limit流量上界\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // 当前弧优化，如果一个点有很多出边，有些出边可能无法再推流了，我们就记录第一条可以推流的边\n    {\n        cur[st] = i; // 当前弧优化\n        int ed = e[st][i].ed;\n        if (dep[ed] + 1 == dep[st] && e[st][i].len) // 这条边能推且，深度为更深一层（为了找最短的增广路）\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // 是为了限制后面点的流量不能大于limit-nowflow\n            if (t)                                               // 走下去能推流\n            {\n                e[st][i].len -= t;           // 减去相应的\n                e[ed][e[st][i].id].len += t; // 反边+相应的\n                nowflow += t;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    } // 到这说明这个点还有剩余流量，层数就+1\n    --gap[dep[st]];\n    if (gap[dep[st]] == 0)\n        dep[S] = n + 1; // 出现断层，无法到达t了，直接结束\n    dep[st]++;          // 层++\n    gap[dep[st]]++;\n    return nowflow; // 会返回本次bfs（）后所有增广路能加的最多流量\n}\nint ISAP()\n{\n    int flow = 0;\n    bfs();\n    while (dep[S] < n)\n    {\n        memset(cur, 0, sizeof(cur)); // 每一次开始dfs前都要注意cur数组的清空！与dinic不同，因为这里只需要一次bfs\n        flow += dfs(S, INF);         // 初始流量为无穷大\n    }\n    return flow;\n}\nvoid add(int u, int v, int w)\n{ // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // 建边\n    e[v].push_back((edge){u, 0, sti});\n}\nsigned main()\n{\n    cin >> n >> m >> S >> T;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        int sti = e[u].size();\n        int edi = e[v].size();\n        e[u].push_back((edge){v, w, edi}); // 建边\n        e[v].push_back((edge){u, 0, sti});\n    }\n    cout << ISAP();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.5 预流推进（AmiyaCast）\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define pii make_pair\nconst ll inf = 1145141919810;\nusing namespace std;\nint n, m, s, t;\nstruct Dinic\n{\n    int tp, s, t, n, m;\n    struct Edge\n    {\n        int u, v;\n        ll cap;\n    };\n    vector<ll> dis;\n    vector<int> cur, que;\n    vector<vector<int>> v;\n    vector<Edge> e, _e;\n    Dinic(int _n, int _s, int _t)\n    {\n        n = _n, s = _s, t = _t;\n        dis.resize(_n + 1), cur.resize(_n + 1), que.resize(_n + 1),\n            v.resize(n + 1);\n    }\n    void add(int x, int y, ll w) { _e.push_back({x, y, w}); }\n    void Add(int x, int y, int flw)\n    {\n        e.push_back(Edge{x, y, flw}), e.push_back(Edge{y, x, 0});\n        v[x].push_back(e.size() - 2);\n    }\n    int bfs()\n    {\n        dis.assign(n + 1, inf);\n        int l = 1, r = 1;\n        que[1] = s, dis[s] = 0;\n        while (l <= r)\n        {\n            int p = que[l++], to;\n            for (int i : v[p])\n                if (e[i].cap && dis[to = e[i].v] >= inf)\n                    dis[to] = dis[p] + 1, que[++r] = to;\n        }\n        return dis[t] < inf;\n    }\n    int dfs(int p, ll a)\n    {\n        if (p == t || !a)\n            return a;\n        int sf = 0, flw;\n        for (int &i = cur[p], to; i < (int)v[p].size(); ++i)\n        {\n            Edge &E = e[v[p][i]];\n            if (dis[to = E.v] == dis[p] + 1 && (flw = dfs(to, min(a,\n                                                                  E.cap))))\n            {\n                E.cap -= flw;\n                e[v[p][i] ^ 1].cap += flw;\n                a -= flw;\n                sf += flw;\n                if (!a)\n                    break;\n            }\n        }\n        return sf;\n    }\n    ll dinic(int tp = 1)\n    {\n        this->tp = tp;\n        int flw = 0;\n        while (bfs())\n            cur.assign(n + 1, 0), flw += dfs(s, inf);\n        return flw;\n    }\n    ll get_ans()\n    {\n        ll ans = 0;\n        m = _e.size();\n        sort(_e.begin(), _e.end(), [](Edge a, Edge b)\n             { return a.cap >\n                      b.cap; });\n        for (int rp = 0; rp <= 1; ++rp)\n            for (int p = 1 << 30, i = 0; p; p /=\n                                            2)\n            {\n                for (; i < m && _e[i].cap >= p; ++i)\n                    if (rp)\n                        v[_e[i].v].push_back(i * 2 + 1);\n                    else\n                        Add(_e[i].u, _e[i].v, _e[i].cap);\n                ans += dinic(rp);\n            }\n        return ans;\n    }\n};\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m >> s >> t;\n    Dinic d(n, s, t);\n    for (int i = 0; i < m; i++)\n    {\n        int x, y;\n        ll w;\n        cin >> x >> y >> w;\n        d.add(x, y, w);\n    }\n    cout << d.get_ans() << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.6 最小费用最大流（朱）\n\n```cpp\n//理论上界为n2m，处理1e4-1e5的数据\n//每条边流过去多了一个成本\n//bfs换成了spfa跑最短路即可,0号点得空出来\n//最大费用最大流：建边时把c反着建，照样跑板子，最后答案也反过来就行，类似最长路\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n    int cost;\n};\nvector <edge> e[N];\nint n, m, S, T;\nint dep[N], dis[N], vis[N],ans ,res;\nbool spfa(){\n    memset(dis,0x3f,sizeof(dis));//初始化\n    memset(vis,0,sizeof(vis));\n    dis[T]=0;\n    vis[T]=1;//vis数组代表在不在队列中\n    deque<int>q;q.push_back(T);\n    while(!q.empty()){\n        int u=q.front();q.pop_front();\n        vis[u]=0;//取出队列中的元素，故vis为0\n        for (int i = 0; i < e[u].size(); i++){\n            int ed = e[u][i].ed;\n            if (e[ed][e[u][i].id].len && dis[ed]>dis[u]-e[u][i].cost){//取反向边是因为我们要保证正流，但是SPFA是倒着跑的，所以说我们要求e[u][i]的对应反向边是正的，\n                dis[ed]=dis[u]-e[u][i].cost;\n                if (!vis[ed]){\n                    vis[ed]=true;\n                    if (q.empty() || dis[ed]>=dis[q.front()])q.push_back(ed);//一个lis优化spfa的\n                        else q.push_front(ed);\n                }\n            }\n        }\n    }\n    return dis[S]<dis[0];\n}\nint dfs(int st, int limit){\n    vis[st]=1;\n    if (st == T||limit==0)\n        return limit;\n    int nowflow=0;//定义当前节点的流量\n    for (int i = 0; i < e[st].size(); i = i + 1){\n        int ed = e[st][i].ed;\n        if (dis[ed] == dis[st] - e[st][i].cost && e[st][i].len&&!vis[ed])//这条边能推且，深度为更深一层，且没走过\n        {\n            int t = dfs(ed, min(e[st][i].len, limit-nowflow));//是为了限制后面点的流量不能大于limit-nowflow\n            if (t)//走下去能推流\n            {\n                res+=t*e[st][i].cost;//统计答案，经过这一条边\n                e[st][i].len -= t;\n                e[ed][e[st][i].id].len += t;\n                nowflow+=t;\n                if(nowflow==limit)return nowflow;\n            }\n\n        }\n    }\n    if(!nowflow)dep[st]=-1;//如果这个点不能延申，那就删掉这个点（炸点优化）\n    return nowflow;//会返回本次bfs（）后所有增广路能加的最多流量\n}\nvoid dinic(){\n    while(spfa()){\n        vis[T]=1;\n        while(vis[T]){//如果dfs完已经走不到t了那说明这一轮结束\n            memset(vis,0,sizeof vis);\n            ans+=dfs(S,INF);\n        }\n    }\n}\nvoid add(int u,int v,int w,int c){\n    //cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi, c});//建边\n    e[v].push_back((edge){u, 0, sti, -c});\n}\nsigned main(){\n    cin>>n>>m>>S>>T;\n    for (int i = 1; i <= m; i++){\n        int u,v,w,c;\n        cin >> u >> v >> w >> c;\n        int sti = e[u].size();\n        int edi = e[v].size();\n        e[u].push_back((edge){v, w, edi, c});//建边\n        e[v].push_back((edge){u, 0, sti, -c});\n    }\n    dinic();\n    cout<<ans<<\" \"<<res;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.7 网络流结论\n\n#### 2.7.1 二分图博弈\n\n二分图博弈，给出一张二分图和起始点 H，A 和 B轮流操作，每次只能选与上个被选择的点（第一回合则是点 H）相邻的点，且不能选择已选择过的点，无法选点的人输掉。\n\n具体来说，就是所有的状态可以被分为两类，每次操作必定是从一个状态到另一类状态，不能操作的人输\n\n做法，如果二分图的所有最大匹配都经过H，那么先手必胜，否则必败\n\n建图后判断H是不是必须点即可（跑两次，第一次不带H点，跑一次，再带上H点，看看能不能有新增流量，若有则是必须点，先手必胜，否则必败）\n\n```cpp\nvoid solve(){\n    cin>>m>>n>>s;\n    for (int i = 0; i < N; i++)e[i].clear();\n    memset(sp,0,sizeof(sp));\n    int M=a[m];S=M+1;T=M+2;\n    for (int i = 1; i <= n; i++) {\n        int x ;cin>>x; sp[x] = 1;//禁止访问的状态\n    }\n    for(int i = 0; i < M; i++) {//每个状态\n        if(sp[i]) continue;\n        if(odd[i] == odd[s]) {\n            calc(i);//i的后继状态连边\n            if (i != s) add(S, i, 1);//起点先不连\n        }\n        else {\n            add(i, T, 1);   \n        }\n    }\n    dinic();//如何判断这个点是不是最大匹配的必须点？先不加这个点跑一次，再加上跑一次，看能不能有新流即可\n    add(S, s, 1);\n    if(dinic())\n        cout<<\"Alice\"<<endl;\n    else \n        cout<<\"Bob\"<<endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.2 最小路径覆盖与偏序集合Dilworth定理\n\n##### 2.7.2.1 最小路径覆盖\n\n最小路径覆盖问题是指用最少的**不相交**路径，使得路径覆盖整个有向图的所有点。\n\n本质是二分图的最大匹配。\n\n目标是覆盖所有的点，这些路径不要求非得共用起点和终点。初始考虑每个点都被一条自环唯一覆盖，那么一条边连通两个点就意味着这条边同时覆盖了这两个点，同时因为不相交路径的属性确保了如果点$A$连向了点$B$，那么一定不会再有点$A$连向任何一个点。确保一个点只连接一条出边，就是二分图的最大匹配问题。建图跑最大匹配后找出最大可化简数量，结果就是$n-$最大流。\n\n**示例1：（模板题)**\n\n给定有向图 $G=(V,E)$ 。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个定点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个定点开始，长度也是任意的，特别地，可以为 $0$。$G$ 的最小路径覆盖是 $G$ 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图）$G$ 的最小路径覆盖。\n\n**输入格式**\n\n第一行有两个正整数 $n$ 和 $m$。$n$ 是给定 DAG（有向无环图）$G$ 的顶点数，$m$ 是 $G$ 的边数。接下来的 $m$ 行，每行有两个正整数 $i$ 和 $j$ 表示一条有向边 $(i,j)$。\n\n**输出格式**\n\n从第一行开始，每行输出一条路径。文件的最后一行是最少路径数。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 150$，$1\\leq m\\leq 6000$​​。\n\n记录路径在dfs中维护一个nxt数组表示这个点的下一个。\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], cur[N], p[N], net[N], d[N];\nbool bfs() // bfs分层\n{\n    memset(dep, -1, sizeof dep);\n    queue<int> q;\n    q.push(S);\n    dep[S] = 0;\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i = i + 1)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1 && e[t][i].len) // 如果这个点没有被定义层次，且还有剩余流量\n            {\n                dep[ed] = dep[t] + 1;\n                q.push(ed);\n            }\n        }\n    }\n    memset(cur, 0, sizeof(cur));\n    if (dep[T] == -1)\n        return 0;\n    else\n        return 1;\n}\nint dfs(int st, int limit) // limit最大可增加的流量\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // 定义当前节点的流量,多路增广优化，找满当前能找的limit流量上界\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // 当前弧优化，如果一个点有很多出边，有些出边可能无法再推流了，我们就记录第一条可以推流的边\n    {\n        cur[st] = i; // 当前弧优化\n        int ed = e[st][i].ed;\n        if (dep[ed] == dep[st] + 1 && e[st][i].len) // 这条边能推且，深度为更深一层（为了找最短的增广路）\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // 是为了限制后面点的流量不能大于limit-nowflow\n            if (t)                                               // 走下去能推流\n            {\n                e[st][i].len -= t;           // 减去相应的\n                e[ed][e[st][i].id].len += t; // 反边+相应的\n                nowflow += t;\n                if (t)\n                    net[st] = ed - n;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    }\n    if (!nowflow)\n        dep[st] = -1; // 如果这个点不能延申，那就删掉这个点（炸点优化）\n    return nowflow;   // 会返回本次bfs（）后所有增广路能加的最多流量\n}\nint dinic()\n{\n    int r = 0;\n    while (bfs())\n        r += dfs(S, INF);\n    return r;\n}\nvoid add(int u, int v, int w)\n{\n    // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // 建边\n    e[v].push_back((edge){u, 0, sti});\n}\nvoid print(int x)\n{\n    printf(\"%d \", x);\n    if (net[x] > 0)\n        print(net[x]);\n}\nsigned main()\n{\n    cin >> n >> m;\n    S = 0;\n    T = 2 * n + 1;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add(u, v + n, 1);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        add(S, i, 1);\n        add(i + n, T, 1);\n    }\n    int maxflow = dinic();\n    for (int i = 1; i <= n; i++)\n        if (net[i])\n            d[net[i]]++;\n    for (int i = 1; i <= n; i++)\n        if (!d[i])\n            print(i), cout << endl;\n    cout << n - maxflow;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n##### 2.7.2.2 Dilworth定理\n\n根据$Dilworth$定理，偏序集合的**最长链长度**等于其**最小的反链覆盖**。\n\n**链**：一条链是一些**点的集合**，点集中任意两个点$u$和$v$，满足$u$能到达$v$或是$v$能到达$u$（存在偏序关系），则称该点集为一条链。\n\n**反链**：一条反链是一些**点的集合**，点集中任意两个点$u$和$v$，满足$u$不能到达$v$并且$v$不能到达$u$​，则称该点集为一条反链。\n\n**最小链覆盖**是指在有向图中用**可以相交**的若干条路径覆盖整个图且路径数最少。\n\n**求出有向图的传递闭包之后即可按照示例一不相交路径求解，二分图最大匹配即可。**\n\n如果有向图是一个**完备**的**偏序集合哈斯图**（即其传递闭包等于自身），则**最小链覆盖等价于最小路径覆盖**。此时，$Dilworth$定理可重新表述为**最大链长度等于最小的反链划分**。\n\n**示例1：ABC237Ex Hakata**\n\n我们有一个由小写英文字母组成的字符串 $S$ 。Bob 每天都在思考回文。他决定从 $S$ 中选择一些回文子串并告诉 Anna。\n\n如果 Bob 告诉的回文之一是另一个回文的子串，Anna 会生气。Bob 可以选择最多多少个回文而不会让 Anna 生气？\n\n$N\\le 300$\n\n显然，包含是一个偏序关系。我们要求解的是**最长的互相不包含的回文串序列长度**，实际上就是**最长的反链长度**。\n\n$Dilworth$定理转**最小的反链覆盖**。由于我们能够建立出完备的偏序哈斯图（实际上都可以），又转**最小反链划分**，即**最小路径覆盖**。\n\n求二分图最大匹配，参考示例1，作差即可。\n\n```cpp\nvoid solve()\n{\n    string s;\n    cin >> s;\n    vector<string> pali;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 1; i + j <= s.size(); j++)\n        {\n            string t = s.substr(i, j);\n            string r = t;\n            reverse(r.begin(), r.end());\n            if (t == r)\n            {\n                pali.push_back(t);\n            }\n        }\n    }\n    sort(pali.begin(), pali.end());\n    pali.erase(unique(pali.begin(), pali.end()), pali.end());\n    int sz = pali.size();\n    MaxFlow<int> mf(2 * sz + 10);\n    const int S = 2 * sz, T = 2 * sz + 1;\n    for (int i = 0; i < sz; i++)\n    {\n        mf.addEdge(S, i, 1);\n        mf.addEdge(sz + i, T, 1);\n    }\n    for (int i = 0; i < sz; i++)\n    {\n        for (int j = 0; j < sz; j++)\n        {\n            if (i == j)\n                continue;\n            if (pali[i].find(pali[j]) != string::npos)\n            {\n                mf.addEdge(i, sz + j, 1);\n            }\n        }\n    }\n    cout << sz - mf.flow(S, T) << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.3 最大流最小割定理\n\n最大流=最小割。\n\n割集好比是一个恐怖分子 把你家和自来水厂之间的水管网络砍断了一些 然后自来水厂无论怎么放水 水都只能从水管断口哗哗流走了 你家就停水了 割的大小应该是恐怖分子应该关心的事 毕竟细管子好割一些 而最小割花的力气最小\n\n网络的最大流等于最小割 \n\n具体的证明分三部分 \n\n1. 任意一个流都小于等于任意一个割。\n\n这个很好理解，自来水公司随便给你家通点水构成一个流，恐怖分子随便砍几刀，砍出一个割，由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量，每一根被砍的水管的水本来都要到你家的，现在流到外面，加起来得到的流量还是等于原来的流。管子的容量加起来就是割，所以流小于等于割。由于上面的流和割都是任意构造的，所以任意一个流小于任意一个割。\n\n2. 构造出一个流等于一个割。\n\n当达到最大流时，根据增广路定理，残留网络中$s$到$t$已经没有通路了，否则还能继续增广。我们把$s$能到的的点集设为$S$，不能到的点集为$T$，构造出一个割集$C[S,T]$，$S$到$T$的边必然满流，否则就能继续增广，这些满流边的流量和就是当前的流即最大流。把这些满流边作为割，就构造出了一个和最大流相等的割。\n\n3. 最大流等于最小割。\n\n\n设相等的流和割分别为$F_m$和$C_m$，则因为任意一个流小于等于任意一个割，任意$F≤Fm=Cm≤$任意$C$ 。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.4 最大权闭合子图\n\n最大权闭合子图：给定一个有向图, 顶点带权值. 你可以选中一些顶点, 要求当选中一个点 $u$ 的时候, 若存在边 $u\\rightarrow v$ 则 $v$​ 也必须选中. 最大化选中的点的总权值.\n\n建模：负点权点向重点连边，源点向正点权点连边，图中原先的点连无穷大边，跑最小割即可，最终结果就是所有正点权之和$-$最小割。\n\n示例：**CFedu171 Best Subsequence**\n\n给定一个整数数组 $$a$$ ，大小为 $n$ 。\n\n我们将数组的值定义为其大小减去数组所有元素按位或中的设置位数。\n\n例如，对于数组 $[1, 0, 1, 2]$ ，按位或为 $3$ (包含 $2$ 个设置位)，数组的值为 $$4-2=2$$ 。\n\n您的任务是计算给定数组的某个子序列的最大可能值。\n\n显然是最大权闭合子图问题，或者可以理解为二者选其一问题。该点要被选择，这些位置都要被扣1.\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<i64> a(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    MaxFlow<i64> f;\n    int sz = n + 60 + 2;\n    f.init(sz);\n    const int s = n + 60, t = n + 60 + 1;\n    for (int i = 0; i < n; i++)\n    {\n        f.addEdge(s, i, 1);\n        for (int j = 59; j >= 0; j--)\n        {\n            if ((a[i] >> j) & 1)\n            {\n                f.addEdge(i, n + j, 1);\n            }\n        }\n    }\n    for (int j = 59; j >= 0; j--)\n    {\n        f.addEdge(n + j, t, 1);\n    }\n    i64 ans = f.flow(s, t);\n    cout << n - ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.5  二者选其一问题\n\n将若干元素$e_1,e_2,…,e_n$划分到两个集合$A,B$中。对于元素$e_i$,它被划分到$A$或$B$中分别能获得一个$a_{e_i}$或$b_{e_i}$的分值。除此之外,还给出若干个组合$C_i\\in E$,当组合中的元素被同时划分到$A$或$B$时,可以获得额外的分值$a'$或$b'$。求最大的分值。\n\n基本模型是设立两个超级源点，每个物品分别连，最大收益就是收益总和-最小割\n\n对于同属于一遍的额外组合，则新建节点，超级源点（以$A$示例）向该新节点流额外收益$a'$，为保证后续节点必定在$A$部，该新节点向该组合的中间点连无穷大边，迫使最小割如果保留了$a'$边，就必须隔断所有和$B$的边，以达成正确性。\n\n<img src=\"https://pic4.zhimg.com/v2-3f06c22d87598fc1b5c1774376d303c3_r.jpg\" alt=\"img\" style=\"zoom:25%;\" />\n\n示例：**2024杭电多校（5）猫咪们狂欢**\n\n猫咪们生活在树上。\n\n具体来说，有 $n$ 只猫咪和两棵大小为$n$的树。猫咪编号为 $1∼n$ ，每棵树上的节点编号也为 $1∼n$（编号各不相同） 。\n\n今晚，每只猫咪要分别选择一棵树，并待在与其编号相同的节点。\n\n在这 $n$ 只猫咪之中，有 $k$ 只猫咪是狂欢猫。狂欢猫晚上不会睡觉，而是会选择开party。其他猫咪则会选择睡觉。\n\n每条树边都有一个狂欢值，如果这条边连接的两个节点在晚上都有狂欢猫待着，这个狂欢值就会被累加到总狂欢值上。\n\n最大化今晚的总狂欢值，并输出这个值。\n\n\n\n显然是二者选其一问题，每只猫咪有选择左还是选择右的问题，有最多$n-1$组组合会有额外收益。狂欢猫只有$k$只，涉及到的狂欢猫才形成组队节点。\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<int> cat(k + 1);\n    map<int, int> mp;\n    for (int i = 1; i <= k; i++)\n    {\n        cin >> cat[i];\n        mp[cat[i]] = 1;\n    }\n    const int s = 0, t = n + 1;\n    MaxFlow<i64> flow(4 * n + 10);\n    int virp = n + 2;\n    i64 ans = 0;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        if (mp[u] && mp[v])\n        {\n            flow.addEdge(s, virp, w);\n            flow.addEdge(virp, u, INT_MAX / 2);\n            flow.addEdge(virp, v, INT_MAX / 2);\n            ans += w;\n            virp++;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        if (mp[u] && mp[v])\n        {\n            flow.addEdge(virp, t, w);\n            flow.addEdge(u, virp, INT_MAX / 2);\n            flow.addEdge(v, virp, INT_MAX / 2);\n            ans += w;\n            virp++;\n        }\n    }\n    cout << ans - flow.flow(s, t) << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.6 二分图最大边权匹配\n\n二分图的最大权匹配是指二分图中边权和最大的匹配。数据保证有解。\n\n考虑费用流。\n\n与 **二分图最大匹配**类似，二分图的最大权匹配也可以转化为网络流问题来求解。\n\n首先，在图中新增一个源点和一个汇点。\n\n从源点向二分图的每个左部点连一条流量为 $1$ ，费用为 $0$ 的边，从二分图的每个右部点向汇点连一条流量为 $1$ ，费用为 $0$ 的边。\n\n接下来对于二分图中每一条连接左部点 $u$ 和右部点 $v$ ，边权为 $w$ 的边，则连一条从 $u$ 到 $v$，流量为 $1$ ，费用为 $w$ 的边。\n\n另外，考虑到***最大权匹配下***，***匹配边的数量不一定与最大匹配的匹配边数量相等（不一定最大流）***，因此对于每个左部点，还需向汇点连一条流量为$1$ ，费用为 $0$ 的边。\n\n求这个网络的 **最大费用最大流**即可得到答案。此时，该网络的最大流量一定为左部点的数量，而最大流量下的最大费用即对应一个最大权匹配方案。最大费用最大流可以直接负费用的最小费，Jiangly模板支持。\n\n#### 2.7.7 二分图最小边权点覆盖\n\n二分图的最小边权点覆盖指找到一个边权和最小的顶点覆盖。数据保证有解。\n\n考虑最小覆盖的一种构造方式：\n\n选择一个匹配边集合$E_1$，所有不属于$E_1$包含的点集$V_1$的点选择一条与自己相邻的点中边权最小的那一个点，添加对应边（**允许重边**）。可以证明最优解一定可以被这种构造方式构造，且是否是最优解一定取决于$E_1$的选择。\n\n设点$u$为端点的边的最小边权为$wm_u$，则有一个非常简单的化简：\n$$\nCost=\\sum_{e\\in E_1}c(e)+\\sum_{v\\in V\\backslash V_1}wm_v=\\sum_{v\\in V}wm_v+\\sum_{e\\in E_1}(c(e_{u,v})-wm_u-wm_v)\n$$\n最小化第二项成本即可。构建以下网络流二分图跑最小费用流：\n\n- 从 $S$ 向每个 $X_i$ 添加一条边，容量为 $1$ ，成本为 $0$\n- 对于每个 $(X_i,Y_j)$ ，从 $X_i$ 向 $Y_j$ 添加一条边，容量为 $1$ ，成本为 $(c(e_{X_i,Y_i})-wm_{X_i}-wm_{Y_i})$\n- 从每个 $Y_i$ 向 $T$ 添加一条边，容量为 $1$ ，成本为 $0$.\n- 另外，考虑到***最小费匹配下***，***匹配边的数量不一定与最大匹配的匹配边数量相等（不一定最大流，这个带有负成本的更为明显）***，因此对于每个左部点，还需向汇点连一条流量为 $1$ ，费用为 $0$ 的边。\n\n直接跑$MincostFlow.h$就行，Jiangly模板支持负数费用。\n\n示例1：**ABC231H - Minimum Coloring**\n\n我们有一个网格，有 $H$ 行和 $W$ 列。令 $(i,j)$ 表示从顶部算起第 $i$ 行和从左侧算起第 $j$ 列的方格。\n\n在这个网格上，有 $N$ 个白色棋子，编号为 $1$ 至 $N$ 。棋子 $i$ 位于 $(A_i,B_i)$ 上。\n\n您可以支付 $C_i$ 的费用来将棋子 $i$ 改为黑色棋子。\n\n找出在每一行和每一列中至少有一个黑色棋子所需的最小总费用。\n\n裸的板子。\n\n```cpp\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    const int s = n + m, t = n + m + 1;\n    MinCostFlow<i64> mcf(n + m + 10);\n    vector<int> a(n + m + 10, INT_MAX / 2);\n    vector<array<int, 3>> e(k);\n    for (int i = 0; i < k; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--;\n        v--;\n        e[i] = {u, v, w};\n        a[u] = min(a[u], w);\n        a[n + v] = min(a[n + v], w);\n    }\n    i64 ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        mcf.addEdge(s, i, 1, 0);\n        mcf.addEdge(i, t, 1, 0);\n        ans += a[i];\n    }\n    for (int j = 0; j < m; j++)\n    {\n        mcf.addEdge(n + j, t, 1, 0);\n        ans += a[n + j];\n    }\n    for (int i = 0; i < k; i++)\n    {\n        auto [u, v, w] = e[i];\n        mcf.addEdge(u, n + v, 1, w - a[u] - a[n + v]);\n    }\n    auto [flow, cost] = mcf.flow(s, t);\n    cout << ans + cost << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.8 剩余物品互不相同问题\n\n操作后剩余互不相同，可以通过列举出所有剩余物品种类之后每个只向超级汇点连一条容量为$1$的边，以确保每种物品只会出现一次。\n\n剩余数量限制为$x$​的时候同理，限制容量大小即可。\n\n**示例1：（2024成都站K)**\n\n您有一个神奇的集合，最初包含 $n$ 个不同的整数。您发现这些数字可以通过除以它们的因数来产生能量。在每个步骤中，您可以从集合中选择任何大于 $1$ 的数字，将其删除，然后插入它的一个因数。您插入的因数不得等于原始数字。此外，由于神奇集合的不稳定性，您的操作必须确保集合中的数字保持不同。\n\n每个操作都会产生一个能量单位，您的目标是通过执行尽可能多的操作来最大化产生的总能量。给定集合中的初始数字，确定可以产生的最大能量，即可执行的最大操作数。\n\n显然每个数都会尽可能的按步数分解，最大的操作数一定取决于随后剩余的因数组合问题。规约到二分图最大权匹配即可。\n\n分解因数，超级源点向初始数连一条容量为$1$、费用为$0$的边；初始数字向对应因数连容量为$1$、对应消耗次数的费用$w$；对应因数向超级终点连容量为$1$、费用为$0$的边。跑最大费用流即可。\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.9 其他记录\n\n1.小M的作物(最小割) 巧妙将问题转化为最小割\n\n2.奶牛的电信Telecowmunication 最小割边转化为最小割点，方法是拆点把一个点拆成两个点，用1的边长连起来，两个不同点之间的连线用INF连起来，这样的最小割就只能割1的点，相当于割点了 \n\n3.教辅的组成 也是拆点，我们限制一个点通过的流量，就是把这个点拆成两个点，中间连一条我们要限制的流量的大小的边\n\n4.狼捉兔子 可以直接网络流 也可以最小割转平面图最短路（平面图最小割=对偶图的最短路）\n\n5.方格取数问题，有条件的最值。二分图点权最大独立集\n\n把方格根据i+j的奇偶性分为两类点，发现保留一个点的代价是取走周围的另一类的点，转化为最小割。\n\nS连白点，容量为点权，黑点连T同理，同时一个点向周围四个点连边，边权为inf，这样跑出来的最小割，舍弃一个点为断开他与一个源点的连接，意思就是不要这个点，保留下来的点就是最大的，sum-dinic()即可\n\n套路：方格中的点看看能不能分为两类，即分为一个二分图，同类的点是可以共存的，然后不能共存的一定是两类之间，中间连inf边跑最大流，答案就是总和减去最小割。\n\n<div style=\"page-break-after: always;\"></div>\n\n## 3. 生成树\n\n#### 3.1 两种最小生成树\n\n##### 3.1.1 Prim\n\n```cpp\nvoid prim(){\n    memset(dis,0x3f3f3f3f,sizeof(dis));\n    priority_queue<node>q;//所以这里其实是小根堆，存的是边（每次抉择时待选的边）\n    node t;t.to=1,t.val=0;dis[1]=0;\n    q.push(t);//（最开始选择起点）\n    while(q.size()!=0){\n        node now=q.top();q.pop();\n        if(vis[now.to]==1)continue;\n        vis[now.to]=1;\n        ans+=now.val;\n        for(auto i:edge[now.to]){\n            if(!vis[i.to]&&dis[i.to]>i.val){\n                //有更新的边，都是可能要被选的边，加入队列中，这里的判断只有边权，因为dis是到当前集合的距离\n                dis[i.to]=i.val;\n                q.push(i);\n            }\n        }\n    }\n}\n```\n\n##### 3.1.2 Kruskal\n\n```cpp\ncin>>n>>m;\n    for(int i=1;i<=n;i++)fa[i]=i;//并查集维护是否在生成树里\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        a[i].x=u,a[i].y=v,a[i].val=sum;\n    }\n    sort(a+1,a+1+m);\n    for(int i=1;i<=m;i++){\n        if(fa[find(a[i].x)]==fa[find(a[i].y)])continue;//已经加入了那就不要了\n        else{\n            unions(a[i].x,a[i].y);//加边\n            k++;\n            ans+=a[i].val;\n        }\n        if(k==n-1)break;\n    }\n    if(k<n-1)cout<<\"orz\";\nelse cout<<ans;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *3.2 Kruskal重构树\n\nKruskal 重构树就是基于 Kruskal 的最小生成树算法在无向图中得出的树所构造而成的树。\n\n**性质**\n\n- 是一棵二叉树。\n- 如果是按最小生成树建立的话是一个大根堆。\n- **强大性质**：原图中两个点间所有路径上的边最大权值的最小值 == 最小生成树上两点简单路径的边最大权值 == $Kruskal$ 重构树上两点 $LCA$ 的点权。\n\n利用这个性质，我们可以找到到点 $x$ 的简单路径上的边最大权值的最小值$≤ val$的所有点 $y$。可以发现都在 $Kruskal$ 重构树上的某一棵子树内，且恰好为该子树的所有叶节点。\n\n**具体细节**\n\n我们在 $Kruskal$ 重构树上找到 $x$ 到根的路径上权值 $≤val$ 的最浅的节点,这就是那棵子树的根节点。这个到时候类似求$LCA$由高到低倍增跳就行了，一般这种情况下还有树上线段树合并或者书上主席树之类的。\n\n- 如果题目要求最小权值最大值，可以建最大生成树的重构树从而达到一样的效果。\n\n```cpp\nvoid Ex_Kruskal()\n{\n    int cnt=n;\n    sort(e+1,e+m+1,cmp);//对边排序\n    for (int i=1;i<2*n;++i) f[i]=i;//预处理并查集\n    for (int i=1;i<=m;++i)\n    {\n        int u=get(e[i].x),v=get(e[i].y);\n        if (u!=v)\n        {\n            ++cnt;//新点\n            f[u]=f[v]=cnt;//初始化\n            val[cnt]=e[i].z;//新点权为这个边权\n            add(cnt,u);add(cnt,v);//连边\n            if (cnt==2*n-1) break;//一共2*n-1个点，建好退出\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 4.  二分图最大匹配/二分图最小点覆盖\n\n匈牙利算法，或者网络流。\n\n匈牙利算法,判断二分图：并查集/dfs（即染色法/并查集）\n\n二分图是什么？节点由两个集合组成，且两个集合内部没有边的图。这张图上的所有边的两个端点，都分属不同的部分，无向图\n\n最大匹配：要求选出一些边，使得这些边没有公共顶点，且边的数量最大。\n\n二分图中，最小点覆盖 = 最大匹配  最小点覆盖：指的是在一个图中：一个点覆盖与之连接的边，求用最少的点可以覆盖图。\n\n二分图中，最大独立集 = $n- $最小点覆盖 \n\n最大独立集：一个点集，里面的点两两不相邻 \n\n算法步骤：如果后来的和以前的发生矛盾，则以前的被绿优先退让。\n\n如果以前的退让之后没有cp可处，则以前的拒绝退让，新来的去寻找下一个匹配。\n\n如果新来的谁也匹配不上了，那就这么单着吧。\n\n```cpp\n//O(nm),但是Dinic可以sqrt(n)*m\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2*1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> P;\nint n,m,e,u,v,ans;\nvector<int>edge[505];\nint vis[505],match[505];//match：为右部点建立的数组，存的是与它匹配的左部点\nbool check(int x){\n    for(auto i:edge[x]){//枚举每一个右部点\n        if(!vis[i]){//没访问过\n            vis[i]=1;\n            if(!match[i]||check(match[i])){//可以直接匹配or原先的i可以换人\n                match[i]=x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    cin>>n>>m>>e;\n    for(int i=1;i<=e;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n    }\n    for(int i=1;i<=n;i++){\n        memset(vis,0,sizeof(vis));//对于每一个u的研究，对另一外一半只能访问一次，故每次都要清空\n        if(check(i))ans++;\n    }\n    cout<<ans;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 5.树上问题\n\n### 5.1  树上LCA\n\n关于倍增法以及欧拉序$ST$表在线做法参见数据结构部分。这里只给出离线$Tarjan$算法，实现$O(n+m)$​复杂度。\n\n```cpp\n#include<bits/stdc++.h>//Tarjan离线算法\nusing namespace std;\nconst int N=5*1e5+2;\ntypedef long long ll;\nstruct point{\n    int x,i;\n};\nvector<vector<int> >edge;\nvector<vector<point> >q;\nint dep[N],fa[N],vis[N],ans[N];\nint find(int x){//路径压缩\n    if(fa[x]!=x){\n        fa[x]=find(fa[x]);\n    }\n    return fa[x];\n}\nvoid unions(int x,int y){//x合并到y上\n    fa[find(x)]=fa[find(y)];\n}\nvoid dfs(int x,int f){/***1.**以s为根节点，从根节点开始。\n**2.**遍历该点u所有子节点v，并标记这些子节点v已被访问过。\n**3.**若是v还有子节点，返回2，否则下一步。\n**4.**合并v到u上。\n**5.**寻找与当前点u有询问关系的点v。\n**6.**若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。*/\n    vis[x]=1;\n    for(auto i:edge[x]){\n        if(i!=f){\n            dfs(i,x);\n            unions(i,x);\n        }\n    }\n    for(auto t:q[x]){\n        if(vis[t.x])ans[t.i]=find(t.x);\n    }\n}\nint main(){\n    int n,m,s;int x,y;\n    cin>>n>>m>>s;\n    edge.resize(n+1);\n    q.resize(n+1);\n    for(int i=1;i<=n;i++)fa[i]=i;\n    for(int i=1;i<n;i++){\n        cin>>x>>y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    for(int i=1;i<=m;i++){\n        cin>>x>>y;\n        q[x].push_back({y,i});//另一个相关点和组数\n        q[y].push_back({x,i});\n    }\n    dfs(s,0);\n    for(int i=1;i<=m;i++)cout<<ans[i]<<endl;\n    return 0;\n}\n\n/*一个熊孩子Link从一棵有根树的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。\n岩浆会不断的注入，直到注满整个树…\n如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。\n岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。\n机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置*/\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.2 树链剖分\n\n参见数据结构部分静态树章节，对于长链、重链都有。\n\n这里贴出重链剖分头文件$HLD.h$。这个是从$0$开始的。\n\n```cpp\n/*\n     *@brief 重链剖分(jiangly)版本\n     *@brief 时间复杂度O(n)\n     *@brief 空间复杂度O(n)\n     */\n    struct HLD\n    {\n        int n;\n        std::vector<int> siz, top, dep, parent, dfn, enddfn, rk;\n        std::vector<std::vector<int>> adj;\n        int cur;\n        HLD() {}\n        HLD(int n)\n        {\n            init(n);\n        }\n        void init(int n)\n        {\n            this->n = n;\n            siz.resize(n);\n            top.resize(n);\n            dep.resize(n);\n            parent.resize(n);\n            dfn.resize(n);\n            enddfn.resize(n);\n            rk.resize(n);\n            cur = 0;\n            adj.assign(n, {});\n        }\n        void add_edges(int u, int v)\n        {\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        /*\n         * @brief 重链剖分（jiangly），只能剖一次，不支持动态树，节点编号和树剖编号都是从0开始。\n         * @param root 根节点\n         * @note 重链剖分前需要先调用init函数,调用重链剖分后，邻接表vector中存储的是重链剖分后的树，没有指向父节点的边\n         * @note 重链剖分后，dfn数组中存储的是节点的dfs序，rk数组中存储的是dfs序对应的节点，enddfn数组中存储的是节点所对应子树的dfs序的结束位置的后一个（左闭右开）。\n         */\n        void work(int root = 0)\n        {\n            top[root] = root;\n            dep[root] = 0;\n            parent[root] = -1;\n            dfs1(root);\n            dfs2(root);\n        }\n        void dfs1(int u)\n        {\n            if (parent[u] != -1)\n            {\n                adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));\n            }\n            siz[u] = 1;\n            for (auto &v : adj[u])\n            {\n                parent[v] = u;\n                dep[v] = dep[u] + 1;\n                dfs1(v);\n                siz[u] += siz[v];\n                if (siz[v] > siz[adj[u][0]])\n                {\n                    std::swap(v, adj[u][0]);\n                }\n            }\n        }\n        void dfs2(int u)\n        {\n            dfn[u] = cur++;\n            rk[dfn[u]] = u;\n            for (auto v : adj[u])\n            {\n                top[v] = v == adj[u][0] ? top[u] : v;\n                dfs2(v);\n            }\n            enddfn[u] = cur;\n        }\n        /*\n         * @brief 返回u到v的最近公共祖先\n         * @param u 起点\n         * @param v 终点\n         * @return 返回u到v的最近公共祖先节点\n         */\n        int lca(int u, int v)\n        {\n            while (top[u] != top[v])\n            {\n                if (dep[top[u]] > dep[top[v]])\n                {\n                    u = parent[top[u]];\n                }\n                else\n                {\n                    v = parent[top[v]];\n                }\n            }\n            return dep[u] < dep[v] ? u : v;\n        }\n        /*\n         * @brief 返回u到v的距离\n         * @param u 起点\n         * @param v 终点\n         * @return 返回u到v的距离\n         */\n        int dist(int u, int v)\n        {\n            return dep[u] + dep[v] - 2 * dep[lca(u, v)];\n        }\n        /*\n         * @brief 跳跃\n         * @param u 起点\n         * @param k 跳跃距离\n         * @return 返回跳跃后的节点\n         */\n        int jump(int u, int k)\n        {\n            if (dep[u] < k)\n            {\n                return -1;\n            }\n\n            int d = dep[u] - k;\n\n            while (dep[top[u]] > d)\n            {\n                u = parent[top[u]];\n            }\n\n            return rk[dfn[u] - dep[u] + d];\n        }\n        /*\n         * @brief 判断u是否是v的祖先\n         * @param u 起点\n         * @param v 终点\n         * @return 返回u是否是v的祖先\n         */\n        bool isAncester(int u, int v)\n        {\n            return dfn[u] <= dfn[v] && dfn[v] < enddfn[u];\n        }\n        /*\n        int rootedParent(int u, int v)\n        {\n            std::swap(u, v);\n            if (u == v)\n            {\n                return u;\n            }\n            if (!isAncester(u, v))\n            {\n                return parent[u];\n            }\n            auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y)\n                                       { return dfn[x] < dfn[y]; }) -\n                      1;\n            return *it;\n        }\n        int rootedSize(int u, int v)\n        {\n            if (u == v)\n            {\n                return n;\n            }\n            if (!isAncester(v, u))\n            {\n                return siz[v];\n            }\n            return n - siz[rootedParent(u, v)];\n        }\n\n        int rootedLca(int a, int b, int c)\n        {\n            return lca(a, b) ^ lca(b, c) ^ lca(c, a);\n        }*/\n    };\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.3 树的直径\n\n树形$dp$，求出每个点的最长路和次长路。\n\n```cpp\nvoid dfs(int u,int fa){\n    int sum1=0,sum2=0;\n    f[u]=1;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            dfs(i,u);\n            if(f[i]>sum1)sum2=sum1,sum1=f[i];\n            else if(f[i]>sum2)sum2=f[i];\n        }\n    }\n    if(f[u]+sum1+sum2>ans)ans=f[u]+sum1+sum2;\n    f[u]+=sum1;\n}\n```\n\n### 5.4 树的重心\n\n无根树的重心点定义为树种的点$u$，使得$u$相邻的所有子树的子树大小均不大于树大小的一半。显然一棵树最多只有两个重心（当树节点为奇数时），且两个重心必定相邻。根据这个可以进行一定的二分（2024南京站G）\n\n**性质1**\n\n某个点是树的**重心**等价于它最大子树大小**不大于**整棵树大小的**一半**。\n\n**性质2**\n\n树**至多有两个**重心。如果树有两个重心，那么它们**相邻**。此时树一定有**偶数**个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。\n\n**性质3**\n\n树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。\n\n**性质4**\n\n往树上增加或减少一个叶子，如果原节点数是奇数，那么重心可能增加一个，原重心仍是重心；如果原节点数是偶数，重心可能减少一个，另一个重心仍是重心\n\n**性质5**\n\n把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。\n\n```cpp\nint n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小\nvector<int> ctr; // 重心\nvoid dfs(int p, int fa = 0) // 找重心\n{\n    sz[p] = 1, mss[p] = 0;\n    for (auto [to, w] : edges[p])\n        if (to != fa)\n        {\n            dfs(to, p);\n            mss[p] = max(mss[p], sz[to]);\n            sz[p] += sz[to];\n        }\n    mss[p] = max(mss[p], n - sz[p]);\n    if (mss[p] <= n / 2) ctr.push_back(p);\n}\n```\n\n### 5.5 树上差分\n\n见数据结构静态树部分。\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.6 树上启发式合并\n\n树上启发式合并是一种暴力的$Trick$，通过小子树信息向大子树合并，实现和并查集按秩合并一样的亚线性复杂度。估算按照$nlogn$​算就行，也是一种乱搞做法。\n\n示例1: **2024杭电多校1 树**\n\n给一棵根为 $1$ 的有根树，点 $i$ 具有一个权值 $A_i$ 。\n\n定义一个点对的值 $f(u,v)=max(A_u,A_v)×|A_u−A_v|$ 。\n\n你需要对于每个节点 $i$ ，计算 $ans_i=∑_{u∈subtree(i),v∈subtree(i)}f(u,v) $，其中 $subtree(i)$ 表示 $i$ 的子树。\n\n请你输出 $⊕(ans_i\\ mod\\ 2^{64})$ ，其中 ⊕ 表示 $XOR$​​.\n\n显然硬按着结点不好想。\n\n考虑两个子树合并，$ans_i$的信息是一定要继承$ans_{u},u\\in son(i)$的。考虑不同属于两个子树的点如何处理。\n\n权值树合并，权值树区间合并的时候，一定是左部分的区间点权小于右部分的区间点权。所以两部分合并的时候右半区间的每一个点会额外产生\n$$\n\\large\\sum -sum_{lsons}\\times val_{r_i}+cnt_{lson}\\times val_{r_i}^2\n$$\n线段树结点维护区间$sum$、区间数个数、区间$sum^2$即可。然后$nlogn$​线段树树上启发式合并即可。\n\n<div style=\"page-break-after: always;\"></div>\n\n示例2：**2024杭电多校3 旅行**\n\n有一棵$n$ 个结点的无根树，每个结点都有对应的类型 $c_i$ 和权重 $w_i$ ，你需要在这棵树上规划若干次旅行。\n\n对于一次旅行，你将从一个树上的一个结点出发，沿着树上的边进行旅行，最终到达另一个和起点类型相同的结点。\n\n你会进行很多次旅行，但你希望对于每个结点，在所有旅行路线中最多只会经过一次。\n\n一次旅行的价值是起始点和终止点的权重和，你需要规划旅行的方案使得旅行的总权重和最大。\n\n$\\sum n\\le 2e5,c_i\\le n,w_i \\le 1e6$​\n\n和子树有关，考虑子树合并。\n\n一个子树内最优解为$dp_u$，那么其和另一个子树$dp_v$进行合并更新。那么有两种更新方式：\n\n$\\large dp_u=max(dp_u+dp_v,\\{f_{u,c}+f_{v,c}\\})$\n\n其中$f_{u,c}$表示$u$子树上传一个颜色为$c$的路径接口所能提供的最大权值和。显然$dp_u$是不提供上传路径的。\n\n对$f_{u,c}$​的更新有下列式子，出于启发式合并，如果$v$上传路径穿过$u$，则不能使用$dp_u$\n\n$f_{u,c}=max(f_{u,c}+dp_v,f_{v,c}+\\sum_{t\\in son(u)} dp_t)$​\n\n启发式线段树合并即可。\n\n```cpp\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\n#define int long long\nstruct node\n{\n    int l, r;\n    i64 f;\n    i64 lz = 0;\n};\nconst int maxn = 3e5 + 9;\nnode tree[maxn << 5];\nint tot = 0;\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0, 0};\n    return tot;\n}\nvoid pushup(int rt)\n{\n    tree[rt].f = max(tree[tree[rt].l].f, tree[tree[rt].r].f);\n    return;\n}\nvoid pushd(int rt)\n{\n    if (tree[rt].lz)\n    {\n        if (tree[rt].l)\n        {\n            tree[tree[rt].l].f += tree[rt].lz;\n            tree[tree[rt].l].lz += tree[rt].lz;\n        }\n        if (tree[rt].r)\n        {\n            tree[tree[rt].r].f += tree[rt].lz;\n            tree[tree[rt].r].lz += tree[rt].lz;\n        }\n        tree[rt].lz = 0;\n    }\n    return;\n}\nvoid upd(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n        rt = newnode();\n    if (cl == cr)\n    {\n        tree[rt].f = val;\n        return;\n    }\n    pushd(rt);\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        upd(tree[rt].l, pos, val, cl, mid);\n    else\n        upd(tree[rt].r, pos, val, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nvector<i64> dp, dpson, w, c;\nint n;\nvector<vector<int>> con;\nvector<int> root;\nvoid merges(int &rt1, int &rt2, int cl, int cr, i64 &ans, i64 dpv, i64 dpson)\n{\n    if (!rt1 || !rt2)\n    {\n        if (rt1)\n        {\n            tree[rt1].f += dpv;\n            tree[rt1].lz += dpv;\n        }\n        else\n        {\n            tree[rt2].f += dpson;\n            tree[rt2].lz += dpson;\n        }\n        rt1 |= rt2;\n        return;\n    }\n    if (cl == cr)\n    {\n        ans = max(ans, tree[rt1].f + tree[rt2].f);\n        tree[rt1].f = max(tree[rt1].f + dpv, tree[rt2].f + dpson);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    pushd(rt1), pushd(rt2);\n    merges(tree[rt1].l, tree[rt2].l, cl, mid, ans, dpv, dpson);\n    merges(tree[rt1].r, tree[rt2].r, mid + 1, cr, ans, dpv, dpson);\n    pushup(rt1);\n    return;\n}\nvoid dfs(int u, int f)\n{\n    upd(root[u], c[u], w[u], 1, n);\n    dp[u] = 0, dpson[u] = 0;\n    for (auto &v : con[u])\n    {\n        if (v == f)\n            continue;\n        dfs(v, u);\n        i64 tmp = 0;\n        merges(root[u], root[v], 1, n, tmp, dp[v], dpson[u]);\n        dp[u] = max(dp[u] + dp[v], tmp);\n        dpson[u] += dp[v];\n    }\n}\nvoid solve()\n{\n    tot = 0;\n    cin >> n;\n    dp.assign(n + 1, 0);\n    dpson.assign(n + 1, 0);\n    w.assign(n + 1, 0);\n    c.assign(n + 1, 0);\n    root.assign(n + 1, 0);\n    for (int i = 1; i <= n; i++)\n        cin >> c[i];\n    for (int i = 1; i <= n; i++)\n        cin >> w[i];\n    con.assign(n + 1, vector<int>());\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        con[u].push_back(v);\n        con[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout << dp[1] << endl;\n}\n\nsigned main()\n{\n    // freopen(\"1002.in\", \"r\", stdin);\n    // freopen(\"1.out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n示例3：（未知来源，朱的例题）\n\n```cpp\n//处理子树相关的问题，不支持修改，nlogn的复杂度，离线算法\n#include<bits/stdc++.h>\n#define LL long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint N, col[MAXN], son[MAXN], siz[MAXN], cnt[MAXN], Mx, Son;\nLL sum = 0, ans[MAXN];\nvector<int> v[MAXN];\nvoid dfs(int x, int fa) {\n    siz[x] = 1;\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa) continue;\n        dfs(to, x);\n        siz[x] += siz[to];\n        if(siz[to] > siz[son[x]]) son[x] = to;//轻重链剖分\n    }\n}\nvoid add(int x, int fa,int c) {//暴力计算x的子树颜色和，不考虑重边，\n    cnt[col[x]] +=c;//这里可能会因题目而异\n    if(cnt[col[x]] > Mx) Mx = cnt[col[x]], sum = col[x];\n    else if(cnt[col[x]] == Mx) sum += (LL)col[x];\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa || to == Son) continue;\n        add(to, x,c);\n    }\n}\nvoid dfs2(int x, int fa, int opt) {//处理当前节点的答案\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa) continue;\n        if(to != son[x]) dfs2(to, x, 0);//简单的往轻边走算轻边的答案，opt = 0表示递归完成后消除对该点的影响\n    }\n    if(son[x]) dfs2(son[x], x, 1), Son = son[x];//统计重儿子的贡献，不消除影响\n    //这时候的sum和Mx都是只考虑重儿子计算出来的\n    add(x, fa,1); Son = 0;\n    //暴力统计所有轻儿子的贡献，会递归所有轻儿子，除了当前节点的重儿子，而不是son[x]，因为轻儿子的重儿子是需要计算的，这里只是不需要计算x的重儿子\n    ans[x] = sum;//更新答案\n    if(!opt) add(x,fa,-1), sum = 0, Mx = 0;//如果需要删除贡献的话就删掉\n}\nint main() {\n    N = read();\n    for(int i = 1; i <= N; i++) col[i] = read();\n    for(int i = 1; i <= N - 1; i++) {\n        int x = read(), y = read();\n        v[x].push_back(y); v[y].push_back(x);\n    }\n    dfs(1, 0);\n    dfs2(1, 0, 1);\n    for(int i = 1; i <= N; i++) printf(\"%I64d \", ans[i]);\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 6.图的连通性\n\n### 6.1 无向图连通性\n\n无向图的连通性主要关于点双联通分量和边双联通分量，用于操作缩点以及缩边，从而把无向图中的环删掉。\n\n#### 6.1.1 割点\n\n对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。\n\n```cpp\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=2e4+1e3;\nint n,m,ans;\nvector<int> g[N];\nbool cut[N];\nint dfn[N],low[N],cnt;\nvoid tarjan(int u,int root){\n    dfn[u]=low[u]=++cnt;\n    int child=0;\n    for(auto v:g[u]){\n        if(!dfn[v]){\n            tarjan(v,root),low[u]=min(low[u],low[v]);\n            if(low[v]>=dfn[u]&&u!=root) cut[u]=true;//如果儿子的low值大于等于dfn，则代表其为儿子与其他非子树点相连的唯一途径\n            if(u==root) child++;\n        }\n        else low[u]=min(low[u],dfn[v]);//注意这里是dfn[v]\n    //因为割点判定法则是小于等于号，所以在求割点时，不必考虑父节点和重边的问题，从x出发能访问到的所有点的时间戳都可以用来更新 lowx\n    }\n    if(child>=2&&u==root)cut[u]=true;//对根的处理,大于两个子树\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        g[u].pb(v);g[v].pb(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(!dfn[i]) tarjan(i,i);\n    for(int i=1;i<=n;i++)\n        if(cut[i]) ans++;\n    cout<<ans<<endl;\n    for(int i=1;i<=n;i++)\n        if(cut[i]) cout<<i<<\" \";\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.2 割边\n\n对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。严谨来说，就是：假设有连通图 $G=(V,E)$​，$e$​是其中一条边（即 $e\\in E$​)，如果$G-e$​ 是不连通的，则边 $e$​是图$G$​的一条割边（桥)。\n\n```cpp\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=200;\nint n,m,sum;\nint a[200][200];\nbool cut[N];\nint dfn[N],low[N],cnt,fa[N];\nstruct Edge {\n    int x,y;\n} edge[5001];\nbool cmp(struct Edge a,struct Edge b) {\n    if(a.x==b.x)return a.y<b.y;\n    return a.x<b.x;\n}\nvoid tarjan(int u){\n    dfn[u]=low[u]=++cnt;\n    for(int v=1; v<=n; v++) {\n        if(!a[u][v])continue;\n        if(!dfn[v]){\n            fa[v]=u,tarjan(v),low[u]=min(low[u],low[v]);\n            if(low[v]>dfn[u]) edge[++sum].x=u, edge[sum].y=v;//儿子回不到父亲以上的位置\n        }\n        else if(v!=fa[u])low[u]=min(low[u],dfn[v]);//注意这里不能是fa[u],不然上面的if那里一定取不了大于号！\n        //low的意思这里是不经过父亲能回到的最早的点\n    }\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        a[u][v]=a[v][u]=1;\n    }\n    for(int i=1; i<=n; i++) \n        if(!dfn[i])tarjan(i);//tarjan\n    sort(edge+1,edge+sum+1,cmp);\n    for(int i=1;i<=sum; i++) {\n        cout<<min(edge[i].x,edge[i].y)<<' '<<max(edge[i].x,edge[i].y)<<endl;//输出\n    }\n    return 0;\n}\n\n```\n\n封装风格：\n\n```cpp\nmap<array<int, 3>, int> mp;\n    vector<int> dfn(n), low(n), fa(n);\n    int cnt = 0;\n    function<void(int)> tarjan = [&](int u)\n    {\n        dfn[u] = low[u] = ++cnt;\n        for (auto [v, w] : newcon[u])\n        {\n            if (!dfn[v])\n            {\n                fa[v] = u, tarjan(v), low[u] = min(low[u], low[v]);\n                if (low[v] > dfn[u])\n                    mp[{u, v, w}] = mp[{v, u, w}] = 1; // 割边\n            }\n            else if (v != fa[u])\n                low[u] = min(low[u], dfn[v]);\n        }\n    };\n    for (int i = 0; i < n; i++)\n        if (!dfn[i])\n            tarjan(i);\n```\n\n\n\n\n\n#### 6.1.3 点双\n\n若一个无向图中的去掉任意一个点都不会改变此图的连通性，即不存在割点，则称作点双连通图。一个无向图中的每一个极大点双连通子图称作此无向图的点双连通分量。\n\n对于两个点$u,v$，如果删除除他们自己外哪一个点都不能使其不联通，则称两点之间双联通。点双联通不具有传递性。\n\n```cpp\n/*点双连通：若对于一个无向图，其任意一个节点对于这个图本身而言都不是割点，则称其点双连通。也就是说，删除任意点及其相关边后，整个图仍然属于一个连通分量。\n\n点双连通分量：无向图中，极大的点双连通子图。与连通分量类似，抽离出一些点及它们之间的边，使得抽离出的图是一个点双连通图，在这个前提下，使得抽离出的图越大越好。*/\n\n/*桥（割边）不属于任何 e-DCC（边双连通分量），但是割点可能属于多个 v-DCC*/\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int N = 1000010, M = 5000010;\nint dfn[N], low[N], stack[N],cut[N];\nint n, m, tot = 1, num, root, top, sum, cnt;\nvector<int> dcc[N * 2];//dcc[i] 存储编号为 i 的 v-DCC 中的所有节点\nvector<int> edge[N];\nvoid tarjan(int u,int root) {\n    //不用特别根节点是不是割点，它一定属于它儿子的点双中，无论是不是割点\n    dfn[u] = low[u] = ++cnt;\n    stack[++top] = u;\n    if (u == root && edge[u].size() == 0) { //孤立点直接处理\n        dcc[++sum].push_back(u);\n        return;\n    }\n    for (auto v:edge[u]) {\n        if (!dfn[v]) {\n            tarjan(v,root);low[u] = min(low[u], low[v]);\n            if (low[v] >= dfn[u]) {//u为割点，把栈里u前的都要出去\n                sum++;\n                int z;\n                do {//弹栈\n                    z = stack[top--];\n                    dcc[sum].push_back(z);\n                } while (z != v);//把v弹走后目前栈顶为u(u为割点)，u不能弹走因为它属于多个点双（至少2）\n                dcc[sum].push_back(u);//单独加入u\n            }\n        } \n        else low[u] = min(low[u], dfn[v]);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        if(u!=v)edge[u].push_back(v),edge[v].push_back(u);//判自环\n    }\n    for (int i=1;i<=n;i++)\n        if (!dfn[i])tarjan(i,i);\n    //for (int i=1;i<=n;i++)cout<<low[i]<<endl;\n    cout<<sum<<endl;\n    for (int i=1;i<=sum;i++) { \n        cout<<dcc[i].size();\n        for (auto j:dcc[i])\n            cout << ' ' << j;\n        cout<<endl;\n    }\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.4 边双\n\n若一个无向图中的去掉任意一条边都不会改变此图的连通性，即不存在割桥，则称作边双连通图。一个无向图中的每一个极大边双连通子图称作此无向图的边双连通分量。\n\n在一张连通的无向图中，对于两个点$u$和$v$，如果无论删去哪条边（只能删去一条）都不能使它们不连通，我们就说$u$和$v$ **边双连通**。边双联通具有传递性\n\n```cpp\n//边双连通分量，很显然，边双连通分量中没有割边，所以只需要去掉所有桥边剩下的就是边双，跑dfs即可\n//注意这里可能有重边，所以我们存图的时候额外存一下每边的数量（map），找桥的时候正常找，如果非桥边有多个不影响，桥边有多个就说明额外连起来了两个v-ecc，所以我们找到桥边就数量-1，dfs的时候正常dfs，如果桥边还有那就走，没有的话就说明是一个v-ecc\n//用于无向图的缩点\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=5e5+10;\nint n,m,sum;\nint dfn[N],low[N],cnt,fa[N],vis[N];\nunordered_map<int,int>mp[N];\nvector<int>edge[N],ans[N];//ans即是bcc\nvoid tarjan(int u){\n    dfn[u]=low[u]=++cnt;\n    for(auto v:edge[u]) {\n        if(!dfn[v]){\n            fa[v]=u,tarjan(v),low[u]=min(low[u],low[v]);\n            if(low[v]>dfn[u]) mp[u][v]--,mp[v][u]--;//儿子回不到父亲以上的位置\n        }\n        else if(v!=fa[u])low[u]=min(low[u],dfn[v]);//注意这里不能是fa[u],不然上面的if那里一定取不了大于号！\n        //low的意思这里是不经过父亲能回到的最早的点\n    }\n}\nvoid dfs(int u,int k){\n    ans[k].emplace_back(u);\n    vis[u]=1;\n    for(auto v:edge[u]){\n        if(!vis[v]&&mp[u][v]){\n            dfs(v,k);\n        }\n    }\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        if(u==v)continue;\n        if(mp[u].find(v)==mp[u].end()||mp[v].find(u)==mp[v].end()){\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n            mp[u][v]=1;\n            mp[v][u]=1;\n        }\n        else  mp[u][v]++,mp[v][u]++;\n    }\n    for(int i=1; i<=n; i++) \n        if(!dfn[i])tarjan(i);//tarjan\n    for(int i=1; i<=n; i++) {\n        if(!vis[i]){\n            sum++;\n            dfs(i,sum);\n        }\n    }\n    cout<<sum<<endl;\n    for(int i=1;i<=sum;i++){\n        cout<<ans[i].size()<<\" \";\n        for(auto j:ans[i])cout<<j<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *6.1.5 圆方树\n\n```cpp\n//点双的关键性质:对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双。\n//即同一个点双中的两不同点 u,v 之间一定存在一条简单路径经过给定的在同一个点双内的另一点 w。所以看到简单路径的时候，可以考虑圆方树\n//圆方树：点双当作一个点，这个点和所有点连边形成的树，这样不同点双会靠割点联系起来形成一棵树\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int N = 100005;\nint n,m, cnt;\nint dfn[N], low[N], dfc;\nint stk[N], tp;\nvector<int> G[N], T[N * 2];//相关数组开两倍！！！\nvoid tarjan(int u) {\n    low[u] = dfn[u] = ++dfc; //dfs序\n    stk[++tp] = u; \n    for (auto v : G[u]) { // 遍历 u 的相邻节点\n        if (!dfn[v]) { \n            tarjan(v); low[u] = min(low[u], low[v]); \n            if (low[v] == dfn[u]) { // 找到一个以 u 为根的点双连通分量\n                ++cnt; // 增加方点个数\n                for (int x = 0; x != v; --tp) {// 将点双中除了 u 的点退栈，并在圆方树中连边\n                    x = stk[tp];\n                    T[cnt].push_back(x);\n                    T[x].push_back(cnt);\n                }\n                T[cnt].push_back(u);\n                T[u].push_back(cnt);\n            }\n        }\n        else low[u] = min(low[u], dfn[v]); // 已访问的和 dfn 取 min\n    }\n}\nsigned main() {\n    cin>>n>>m;\n    cnt = n; \n    for (int i = 1; i <= m; ++i) {\n        int u, v;cin>>u>>v;\n        G[u].push_back(v); \n        G[v].push_back(u);\n    }\n    // 处理非连通图\n    for (int u = 1; u <= n; ++u)\n        if (!dfn[u]) tarjan(u), --tp;\n        // 注意到退出 Tarjan 时栈中还有一个元素即根，将其退栈\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.2 有向图连通性\n\n#### 6.2.1 强连通分量\n\n强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。\n\n强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图\n\n```cpp\n#include <bits/stdc++.h> //O(n+m)\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\nconst int M = 1e6 + 10;\nint n, m, u, v, cnt, sum;\nint dfn[N], low[N], vis[N], belong[N], flag[N]; // belong的含义是这个点是否属于一个强连通分量，low[x] x能通过有向边能回溯到的最早时间段\nvector<int> edge[N];\nvector<int> q[N];\nstack<int> s;\nvoid tarjan(int x)\n{ // tarjan算法，处理x所在的连通块的强连通分量\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (!belong[i])\n            low[x] = min(dfn[i], low[x]);\n        // 如果这个点不属于任何一个强连通分量，说明在栈中，即需要考虑更新low值\n        // 不在栈里说明不可能存在于一个强连通分量(访问过了又不在栈里，说明已经是一个强连通分量出去了)\n    }\n    if (low[x] == dfn[x])\n    { // 回溯时把（x到栈顶的点）全归为一个强连通分量\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0; // 退栈\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> u >> v;\n        edge[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        if (!dfn[i])\n            tarjan(i);\n    cout << sum << endl;\n    for (int i = 1; i <= n; i++)\n    {\n        if (!flag[i])\n        {\n            sort(q[belong[i]].begin(), q[belong[i]].end());\n            for (auto j : q[belong[i]])\n            {\n                flag[j] = 1;\n                cout << j << \" \";\n            }\n            cout << endl;\n        }\n    }\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.2.2 缩点\n\n缩点的本质就是一个环可以等效处理成一个点时，我们把旧图的每一个强连通分量当作一个点建立一个新图，并把一个环的信息全部统计到一个新点上。\n\n给定一个 $n$个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。\n\n允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。\n\n```cpp\n#include <bits/stdc++.h> //缩点的本质就是一个环可以等效处理成一个点时，我们把旧图的每一个强连通分量当作一个点建立一个新图，并把一个环的信息全部统计到一个新点上\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\nconst int M = 1e6 + 10;\nint n, m, u, v, cnt, sum, k;\nint dfn[N], low[N], vis[N], belong[N], a[N], b[N], in[N], c[N], f[N];\nvector<int> edge[N];\nvector<int> out[N];\nvector<int> inn[N];\nvector<int> q[N];\nstack<int> s;\nvoid topo()\n{\n    queue<int> q;\n    for (int i = 1; i <= sum; i++)\n        if (!in[i])\n            q.push(i);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        c[++k] = u;\n        for (auto j : out[u])\n        {\n            in[j]--;\n            if (!in[j])\n                q.push(j);\n        }\n    }\n}\nvoid tarjan(int x)\n{ // tarjan算法\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (vis[i])\n            low[x] = min(low[i], low[x]);\n    }\n    if (low[x] == dfn[x])\n    {\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0;\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> u >> v;\n        edge[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        if (!dfn[i])\n            tarjan(i);\n    // 现在有sum个强连通分量，接下来将每个强连通分量的信息统计到一个点上\n    for (int i = 1; i <= sum; i++)\n    {\n        for (auto j : q[i])\n        {\n            b[i] += a[j];\n        }\n    }\n    // b数组储存了每个强连通分量的权值和，统计完毕后建立新图\n    // 建图时注意考虑，两个强连通分量之间可能会有多重边！！搜索时注意vis数组\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto j : edge[i])\n        {\n            if (belong[i] == belong[j])\n                continue;\n            out[belong[i]].push_back(belong[j]);\n            inn[belong[j]].push_back(belong[i]);\n            in[belong[j]]++;\n        }\n    }\n    topo();\n    // 拓扑排序来决定dp转移顺序，因为一个点的最优解是从它的所有来边转移过来的，拓扑排序决定了在处理当前点时，它的来边已经全部处理好了\n    for (int i = 1; i <= k; i++)\n    {\n        int u = c[i];\n        f[u] = b[u];\n        for (auto j : inn[u])\n        { // 直接转移就可以\n            f[u] = max(f[u], f[j] + b[u]);\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= k; i++)\n        ans = max(ans, f[i]);\n    cout << ans;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *6.2.3 2-SAT适定性问题\n\n有 $n$ 个布尔变量 $x_1$$\\sim$$x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。\n\n2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。\n\n**输入格式**\n\n第一行两个整数 $n$ 和 $m$，意义如题面所述。\n\n接下来 $m$ 行每行 $4$ 个整数 $i$, $a$, $j$, $b$，表示 「$x_i$ 为 $a$ 或 $x_j$ 为 $b$」($a, b\\in \\{0,1\\}$)\n\n**输出格式**\n\n如无解，输出 `IMPOSSIBLE`；否则输出 `POSSIBLE`。\n\n下一行 $n$ 个整数 $x_1\\sim x_n$（$x_i\\in\\{0,1\\}$），表示构造出的解。\n\n$1\\leq n, m\\leq 10^6$ \n\n```cpp\n/*实际的问题里往往是给出一个更细致的情景，而且题干信息中\n会有二选一的标志，此时可以考虑往2-sat模型上考虑。考虑过程，即\n去寻找题目中的限制，把二选一等信息，转化为一个蕴含关系，即\na ⇒ b 这样的式子*/\n// 其中一个不成立则另一个一定成立\n#include <bits/stdc++.h> //O(n+m)\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 2e6 + 10;\nconst int M = 2e6 + 10;\nint n, m, u, v, cnt, sum;\nint dfn[N], low[N], vis[N], belong[N], flag[N]; // belong的含义是这个点是否属于一个强连通分量，low[x] x能通过有向边能回溯到的最早时间段\nvector<int> edge[N];\nvector<int> q[N];\nstack<int> s;\nvoid tarjan(int x)\n{ // tarjan算法，处理x所在的连通块的强连通分量\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (!belong[i])\n            low[x] = min(dfn[i], low[x]);\n        // 如果这个点不属于任何一个强连通分量，说明在栈中，即需要考虑更新low值\n        // 不在栈里说明不可能存在于一个强连通分量(访问过了又不在栈里，说明已经是一个强连通分量出去了)\n    }\n    if (low[x] == dfn[x])\n    { // 回溯时把（x到栈顶的点）全归为一个强连通分量\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0; // 退栈\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nvoid add(int a, int b)\n{\n    edge[a].push_back(b);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int a, b, x, y;\n        cin >> a >> x; // 第a个数为x或第b个数为y\n        cin >> b >> y;\n        if (x == 0 && y == 0) //\"如果第a个数为0或第b个数为0\"至少满足其一\n        {\n            add(a + n, b); // a=1则b=0\n            add(b + n, a); // b=1则a=0\n        }\n        if (x == 0 && y == 1) //\"如果第a个数为0或第b个数为1\"至少满足其一\n        {\n            add(a + n, b + n); // a=1则b=1\n            add(b, a);         // b=0则a=0\n        }\n        if (x == 1 && y == 0) //\"如果第a个数为1或第b个数为0\"至少满足其一\n        {\n            add(a, b);         // a=0则b=0\n            add(b + n, a + n); // b=1则a=1\n        }\n        if (x == 1 && y == 1) //\"如果第a个数为1或第b个数为1\"至少满足其一\n        {\n            add(a, b + n); // a=0则b=1\n            add(b, a + n); // b=0则a=1\n        }\n    }\n    for (int i = 1; i <= 2 * n; i++)\n        if (!dfn[i])\n            tarjan(i); // 两倍\n    for (int i = 1; i <= n; i++)\n    {\n        if (belong[i] == belong[i + n]) // 同一变量的两种取值在同一强联通分量里,说明无解\n        {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    cout << \"POSSIBLE\" << endl; // 否则就是有解\n    for (int i = 1; i <= n; i++)\n    {\n        if (belong[i] > belong[i + n])\n            cout << 1 << \" \"; // 两种取值中选择拓扑序较大的那个值，而强联通分量编号越小 -> 拓扑序越大 -> 越优\n        else\n            cout << 0 << \" \";\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## *7. 基环树\n\n基环树，只有一个环的树，边数为$n$.\n\n```cpp\n//1. 暴力删边\n//每次断开环上的一条边跑一遍答案，然后取最大值  适用于:数据较小，且环不会影响答案的题目\n//eg：旅行，每次的旅行一定是走n-1条边，直接暴力枚举删掉某一条边，跑一次答案 ，n^2过\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//交互题就删\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=2e5+10;\nint n,m,x[N],y[N],ans[N],cnt,tx,ty,sum[N],vis[N];\nvector<int>edge[N];\nvoid dfs(int u,int fa){\n    ans[++cnt]=u;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            dfs(i,u);\n        }\n    }\n}\nvoid dfs2(int u,int fa){\n    vis[u]=1;\n    sum[++cnt]=u;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            if((i==tx&&u==ty)||(i==ty&&u==tx)||vis[i])continue;\n            dfs2(i,u);\n        }\n    }\n}\nbool check(){\n    for(int i=1;i<=n;i++){\n        if(sum[i]==ans[i])continue;\n        else if(sum[i]>ans[i])return 0;\n        else return 1;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>m;\n    for(int u,v,i=1;i<=m;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n        x[i]=u;y[i]=v;\n    }\n    for(int i=1;i<=n;i++)\n        sort(edge[i].begin(),edge[i].end());\n    if(m==n-1){\n        dfs(1,0);\n        for(int i=1;i<=n;i++)\n            cout<<ans[i]<<\" \";\n        return 0;\n    }\n    for(int i=1;i<=m;i++){\n        memset(vis,0,sizeof(vis));\n        tx=x[i],ty=y[i];cnt=0;\n        dfs2(1,0);\n        if(cnt<n)continue;\n        if(ans[1]==0)\n            for(int j=1;j<=n;j++)ans[j]=sum[j];\n        else if(check())\n            for(int j=1;j<=n;j++)ans[j]=sum[j];\n    }\n    for(int i=1;i<=n;i++)\n        cout<<ans[i]<<\" \";\n    return 0;\n}\n//2. 断边跑两次\n//骑士，每个人有个讨厌的人，那么就是n个点n条边，形成了基环树，注意到环上的某一条边，意味着u和v不能同时选，我们计算两种情况，选u和选v\n//等价于强制隔开这两个人各自选一次\n//正确性：每个人只有一个讨厌的人，那么最终情况一定是，要么有他，要么有他讨厌的人，不可能都没有，所以跑两次是正确的\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define N 1000010\nconst int inf=0x3f3f3f3f;\nusing namespace std;\nint w[N],d[N],n,vis[N],flag,f[N][2],ans;\nvector<int>edge[N];\nvoid dp(int u){\n    vis[u]=1;\n    f[u][0]=0;f[u][1]=w[u];\n    for(auto i:edge[u]){\n        if(i!=flag){//不能dp回根\n            dp(i);\n            f[u][0]+=max(f[i][0],f[i][1]);\n            f[u][1]+=f[i][0];\n        }\n    }\n}\nvoid dfs(int u){\n    vis[u]=1;\n    if(vis[d[u]])flag=u;\n    else dfs(d[u]);\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n;\n    for(int u,v,i=1;i<=n;i++){\n        cin>>w[i]>>d[i];\n        edge[d[i]].push_back(i);//存的是仇恨他的人有哪些\n    }\n    for(int i=1;i<=n;i++){\n        if(vis[i])continue;\n        dfs(i);\n        //现在已经找到了一个环上的一条边:flag 和 d[flag]\n        //我们强制其中一个点不选\n        dp(flag);\n        int ans1=f[flag][0];//不选flag\n        flag=d[flag];\n        dp(flag);\n        int ans2=f[flag][0];//不选d[flag]\n        ans+=max(ans1,ans2);\n    }\n    cout<<ans<<endl;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n\n\n# Part 5. 字符串\n\n***强制规定：所有与字符串相关的数组下标或者函数接口如果未特殊说明，都是从$0$开始。***\n\n## 1.字符串哈希（双哈希）\n\n```cpp\ntemplate <int m1, int mod1, int m2, int mod2>\nstruct Stringhashs\n{\n    int n;\n    vector<i64> h1, h2, mi1, mi2;\n    string s;\n    void init(int n)\n    {\n        this->n = n;\n        h1.resize(n + 10);  // h1[i]表示前i个字符的哈希值，注意哈希数组是从1开始的\n        h2.resize(n + 10);  // h2[i]表示前i个字符的哈希值\n        mi1.resize(n + 10); // mi1[i]表示m1^i,哈希模数\n        mi2.resize(n + 10); // mi2[i]表示m2^i,哈希模数\n        mi1[0] = mi2[0] = 1;\n        s.clear();\n        for (int i = 1; i <= n; i++)\n        {\n            mi1[i] = (i64)mi1[i - 1] * m1 % mod1;\n            mi2[i] = (i64)mi2[i - 1] * m2 % mod2;\n            h1[i] = ((i64)h1[i - 1] * m1 + s[i - 1]) % mod1;\n            h2[i] = ((i64)h2[i - 1] * m2 + s[i - 1]) % mod2;\n        }\n    }\n    void insert(string s)\n    {\n        assert(s.size() <= n);\n        this->s = s;\n        for (int i = 0; i < s.size(); i++)\n        {\n            h1[i + 1] = ((i64)h1[i] * m1 % mod1 + s[i]) % mod1;\n            h2[i + 1] = ((i64)h2[i] * m2 % mod2 + s[i]) % mod2;\n        }\n    }\n    array<int, 2> queryfullhash(string s)\n    {\n        int h1 = 0, h2 = 0;\n        for (int i = 0; i < s.size(); i++)\n        {\n            h1 = ((i64)h1 * m1 % mod1 + s[i]) % mod1;\n            h2 = ((i64)h2 * m2 % mod2 + s[i]) % mod2;\n        }\n        return {h1, h2};\n    }\n    array<int, 2> query(int l, int r)\n    {\n        assert(n);\n        assert(l >= 0 && r < n && l <= r);\n        l++, r++;\n        int h1 = ((this->h1[r] - (i64)this->h1[l - 1] * mi1[r - l + 1] % mod1) % mod1 + mod1) % mod1;\n        int h2 = ((this->h2[r] - (i64)this->h2[l - 1] * mi2[r - l + 1] % mod2) % mod2 + mod2) % mod2;\n        return {h1, h2};\n    }\n};\nconst int mod1 = 1e9 + 7, mod2 = 998244353;\nusing hashs = Stringhashs<131, mod1, 13331, mod2>;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.KMP字符串匹配\n\n适配：文本串固定$T$，多个主串$S$，询问$T$在$S$中出现的次数。时间复杂度$O(|T|+\\sum |S|)$\n\n### 2.1 前缀函数与nxt数组\n\n前缀函数定义：$\\pi[i]$表示$s.substr(0,i+1)$中公共前后缀的长度。即有$s[0,\\cdots,\\pi[i]-1]=s[i-\\pi[i]+1,\\cdots,i]$。\n\n规定长度为$1$的字符串前缀函数为$0$。\n\n```cpp\nvector<int> prefix_function(string s) {\n  int n = (int)s.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\n```\n\n基于此维护的$KMP\\ nxt$数组就是方便寻找失配之后下一个配对的位置：\n\n```cpp\nnxt[0] = 0;\n        for (int i = 1, j = 0; i < T.size(); i++)\n        {\n            while (j && T[i] != T[j])\n                j = nxt[j - 1];\n            if (T[i] == T[j])\n                j++;\n            nxt[i] = j;\n        }\n```\n\n\n\n### 2.2 KMP字符串模式匹配算法\n\n$KMP$算法的精髓在于当前匹配失配之后模式串$T$的指针跳到哪里开始重新匹配的问题。因为已匹配部分保证了两段相同，那么只需要跳到公共前后缀的前缀后一位继续匹配就行了。前缀函数是对模式串$T$求解的。\n\n$KMP$匹配思想不只局限于字符串匹配，与匹配有关的$dp$题也会利用到$nxt$数组的思想来优化$dp$。\n\n```cpp\nstruct KMP\n{\n    string T;\n    vector<int> nxt;\n    KMP(string T) : T(T)\n    {\n        nxt.resize(T.size());\n        nxt[0] = 0;\n        for (int i = 1, j = 0; i < T.size(); i++)\n        {\n            while (j && T[i] != T[j])\n                j = nxt[j - 1];\n            if (T[i] == T[j])\n                j++;\n            nxt[i] = j;\n        }\n    }\n    vector<int> match(string S)\n    {\n        vector<int> res;\n        for (int i = 0, j = 0; i < S.size(); i++)\n        {\n            while (j && S[i] != T[j])\n                j = nxt[j - 1];\n            if (S[i] == T[j])\n                j++;\n            if (j == T.size())\n            {\n                res.push_back(i - j + 1);\n                j = nxt[j - 1];\n            }\n        }\n        return res;\n    }\n};\n```\n\n示例1:**2024湖南省赛 经文**\n\n题目大意：有一个长度为$n\\le 1000$的空串和长度为$t\\le 100$的模式串$T$，询问有多少用小写英文字母填充空串的方案数，使得$T$于其中不相交的出现精准$k$次。\n\n设$dp_{i,j,l}$表示前$i$个字符已经匹配了$j$个完整文本串，现在正在匹配$l$位置的方案数。枚举$26$个小写字母，初始匹配指针$pre=l$\n\n如果$s[pre]==char$，则直接有$dp[i][j][pre+1]+=dp[i][j][l]$，满一个则$j$进位。\n\n如果该字符导致了$fail$匹配，则类似$KMP$跳转$pre=nxt[pre-1]$，继续下一个位置的匹配，直到$pre=0$。如果$pre=0$都未能匹配，则说明下一个位置只能从头开始。\n\n```cpp\nbool flag = 0;\nfor (int pre = l; 1; pre = nxt[pre - 1])\n{\n    if (s[pre] == 'a' + m)\n    {\n        if (pre == sz - 1)\n        {\n            if (j + 1 <= k)\n            {\n                dp[i + 1][j + 1][0] += dp[i][j][l];\n                dp[i + 1][j + 1][0] %= mod;\n            }\n        }\n        else\n        {\n            dp[i + 1][j][pre + 1] += dp[i][j][l];\n            dp[i + 1][j][pre + 1] %= mod;\n        }\n        flag = 1;\n        break;\n    }\n    if (!pre)\n        break;\n}\n```\n\n完整代码：\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int sz = s.size();\n    vector<int> nxt(sz);\n    nxt[0] = 0;\n    for (int i = 1, j = 0; i < sz; i++)\n    {\n        while (j && s[i] != s[j])\n            j = nxt[j - 1];\n        if (s[i] == s[j])\n            j++;\n        nxt[i] = j;\n    }\n    vector<vector<vector<i64>>> dp(n + 1, vector<vector<i64>>(k + 1, vector<i64>(sz + 1)));\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; i++)              // 前i个字符\n        for (int j = 0; j <= k; j++)         // 已经匹配了j个\n            for (int l = 0; l < sz; l++)     // 正在匹配第l个\n                for (int m = 0; m < 26; m++) // 枚举字符\n                {\n                    bool flag = 0;\n                    for (int pre = l; 1; pre = nxt[pre - 1])\n                    {\n                        if (s[pre] == 'a' + m)\n                        {\n                            if (pre == sz - 1)\n                            {\n                                if (j + 1 <= k)\n                                {\n                                    dp[i + 1][j + 1][0] += dp[i][j][l];\n                                    dp[i + 1][j + 1][0] %= mod;\n                                }\n                            }\n                            else\n                            {\n                                dp[i + 1][j][pre + 1] += dp[i][j][l];\n                                dp[i + 1][j][pre + 1] %= mod;\n                            }\n                            flag = 1;\n                            break;\n                        }\n                        if (!pre)\n                            break;\n                    }\n                    if (!flag)\n                    {\n                        dp[i + 1][j][0] += dp[i][j][l];\n                        dp[i + 1][j][0] %= mod;\n                    }\n                }\n\n    i64 ans = 0;\n    for (int i = 0; i < sz; i++)\n    {\n        ans += dp[n][k][i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3. 字典树Trie\n\n写法见数据结构部分$01$Trie,没有本质区别。\n\n### 4. Manacher马拉车算法\n\n一种非常优秀的以线性时间复杂度求解字符串中最长回文子串的算法。\n\n```cpp\nint manacher(string t)\n{\n    string s;\n    int tot = 0;\n    s.push_back('$');\n    for (int i = 0; i < t.size(); i++)\n    {\n        s.push_back('#');\n        s.push_back(t[i]);\n    }\n    s.push_back('#');\n    int ans = 0;\n    vector<int> d(s.size() + 10);\n    d[0] = 1; // d[i]代表i为中心的最大半径-1,也表示原回文串长度\n    for (int i = 1, l = 0, r = 0; i < s.size(); ++i)\n    {\n        if (i <= r)\n            d[i] = min(d[l + r - i], r - i + 1);\n        while (s[i + d[i]] == s[i - d[i]])\n            d[i]++;\n        if (d[i] + i - 1 > r)\n            r = d[i] + i - 1, l = i - d[i] + 1;\n        ans = max(ans, d[i]);\n    }\n    return ans - 1;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5. AC自动机\n\n与$KMP$互补，本质依旧是$KMP$，实现的是多模式串$T_1\\to T_n$匹配唯一主串$S$​.复杂度$O(2\\sum|T_i|+|S|)$\n\n字典树上构建$Fail$指针的思路与$nxt$数组极其相似。考虑本模板中如果有$s[i]\\neq s[j]$，则$j=nxt[j-1]$含义为$i$匹配失败后所跳跃的位置。**第$i$个失配了，肯定要跳跃$i-1$的下一个适配点，也就是$nxt[j-1]$**\n\n考虑字典树中，如果结点$u$失配，意味着结点$u$的所有儿子都不适配下一个字符，但是结点$u$的父亲是适配上一个字符的，所以我们要去跳转下一个对应上一个字符的结点，这个就是$u$结点父亲所指向的$Fail$​结点。\n\n```cpp\nint Fail = trie[u].fail;\nfor (int i = 0; i < 26; i++)\n{\n    int v = trie[u].son[i];\n    if (!v)\n    {\n        trie[u].son[i] = trie[Fail].son[i];\n        continue;\n    }\n    trie[v].fail = trie[Fail].son[i];\n    in[trie[v].fail]++;\n    q.push(v);\n}\n```\n\n下面是模板，每重新一次新主串$S$都要重新跳一遍$Fail$指针。\n\n版本1：（只求有多少个文本串$T$于主串$S$中出现过）\n\n```cpp\n// 构建字典图实现自动跳转，构建失配指针实现多模式匹配。\n// 本题AC自动机解决求有多少个不同的模式串在文本串里出现过，且两个模式串不同当且仅当他们编号不同；\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct AC\n{\n    const static int N = 1 * 1e6 + 4;\n    int t[N][30], idx, q; // t[i][j]:表示一个节点，父节点的编号为I,自己的字符是j，idx是节点总数\n    int cnt[N];           // 记录以这个点为结尾有几个单词\n    int fail[N];          // 失配指针，从i跳到j就说明，word(j)是i的最长后缀！！\n    int getnum(char ch)\n    { // 字符转为数字\n        if (ch >= 'a' && ch <= 'z')\n            return ch - 'a' + 1;\n    }\n    void insert(string s)\n    {                              // 插入\n        int p = 0, len = s.size(); // 从0节点开始\n        for (int i = 0; i < len; i++)\n        {\n            int c = getnum(s[i]);\n            if (!t[p][c])\n                t[p][c] = ++idx; // 创建节点\n            p = t[p][c];         // 把父节点更改为上个节点\n        }\n        cnt[p]++; // 以该点为结尾的单词数量，因为不保证模式串一致\n    }\n    void build()\n    {\n        queue<int> q;\n        memset(fail, 0, sizeof(fail));\n        for (int i = 1; i <= 26; i++)\n            if (t[0][i])\n                q.push(t[0][i]);\n        // 根节点的首字符入队\n        // 不直接将0入队是为了避免指向自己\n        while (!q.empty())\n        {\n            int k = q.front();\n            q.pop(); // 当前结点\n            for (int i = 1; i <= 26; i++)\n            {\n                if (t[k][i])\n                {                                  // 如果子节点存在\n                    fail[t[k][i]] = t[fail[k]][i]; // 构建当前的fail指针\n                    // 原理，上一层的fail已经求出，例如上一层为her，自己是s，r的fail指向了er，若r有这个子节点s，由于er是her的最长后缀，那么ers必然是hers的最长后缀。\n                    // 另外结合else的代码 ，原本按道理如果没有s这个节点应不断跳fail，但这里为什么不用呢？因为如果跳完fail的话能换到一条链，则else的代码能够帮助一步跳过去所以可以一步，如果不能，则赋值为0，同样也是根节点，完美\n                    q.push(t[k][i]); // 入队\n                }\n                else\n                    t[k][i] = t[fail[k]][i];\n                // 匹配到空字符，则索引到父节点fail指针对应的字符，以供后续指针的构建\n                // 类似并差集的路径压缩，把不存在的tr[k][i]全部指向tr[fail[k]][i]\n                // 这句话在后面匹配主串的时候也能帮助跳转\n            }\n        }\n    }\n    int queryy(string S)\n    {\n        int len = S.size(), p = 0, ans = 0;\n        for (int i = 0; i < len; i++)\n        {\n            p = t[p][getnum(S[i])];\n            for (int j = p; j && ~cnt[j]; j = fail[j])\n                ans += cnt[j], cnt[j] = -1; // 答案加上结尾，cnt[j]=-1就是以后别在统计这里相关的了，防止重复\n            // 这个点开始跳fail数组，求得与之相关的后缀的单词有没有\n            // 分析j&&~cnt[j]:只有=-1时取反才是0，所以结束条件为跳到根节点（j=0）或者到达了求过的点\n            // 因为本题要求有多少个模式串出现过，所以不能重复贡献\n        }\n        return ans;\n    }\n};\nAC ac;\nint main()\n{\n    int n;\n    cin >> n;\n    string s;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> s;\n        ac.insert(s);\n    }\n    ac.build();\n    cin >> s;\n    cout << ac.queryy(s) << endl;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n版本2：返回每一个$T_i$​的出现次数\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nstruct AC\n{\n    const static int maxn = 2e5 + 9;\n    int n, cnt = 1, vis[maxn], ans, in[maxn << 5], Map[maxn];\n    struct Trie\n    {\n        int son[26], fail, flag, ans;\n        void clear() { memset(son, 0, sizeof(son)), fail = flag = ans = 0; }\n    } trie[maxn << 5];\n    queue<int> q;\n    void init(int _n)\n    {\n        for (int i = 0; i <= cnt; i++)\n            trie[i].clear();\n        for (int i = 1; i <= n; i++)\n            vis[i] = 0;\n        cnt = 1;\n        n = _n;\n    }\n    void insert(string t, int num)\n    {\n        int u = 1, len = t.size();\n        for (int i = 0; i < len; i++)\n        {\n            int v = t[i] - 'a';\n            if (!trie[u].son[v])\n                trie[u].son[v] = ++cnt;\n            u = trie[u].son[v];\n        }\n        if (!trie[u].flag)\n            trie[u].flag = num;\n        Map[num] = trie[u].flag;\n    }\n    void getFail()\n    {\n        for (int i = 0; i < 26; i++)\n            trie[0].son[i] = 1;\n        q.push(1);\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            int Fail = trie[u].fail;\n            for (int i = 0; i < 26; i++)\n            {\n                int v = trie[u].son[i];\n                if (!v)\n                {\n                    trie[u].son[i] = trie[Fail].son[i];\n                    continue;\n                }\n                trie[v].fail = trie[Fail].son[i];\n                in[trie[v].fail]++;\n                q.push(v);\n            }\n        }\n    }\n    void topu()\n    {\n        for (int i = 1; i <= cnt; i++)\n            if (in[i] == 0)\n                q.push(i);\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            vis[trie[u].flag] = trie[u].ans;\n            int v = trie[u].fail;\n            in[v]--;\n            trie[v].ans += trie[u].ans;\n            if (in[v] == 0)\n                q.push(v);\n        }\n    }\n    void query(string s)\n    {\n        int u = 1, len = s.size();\n        for (int i = 0; i < len; i++)\n            u = trie[u].son[s[i] - 'a'], trie[u].ans++;\n    }\n    vector<int> querys(string s)\n    {\n        vector<int> res;\n        query(s);\n        topu();\n        for (int i = 1; i <= n; i++)\n            res.push_back(vis[Map[i]]);\n        return res;\n    }\n};\nAC ac;\nint main()\n{\n    int n;\n    cin >> n;\n    ac.init(n);\n    for (int i = 1; i <= n; i++)\n    {\n        string t;\n        cin >> t;\n        ac.insert(t, i);\n    }\n    ac.getFail();\n    string s;\n    cin >> s;\n    auto res = ac.querys(s);\n    for (auto i : res)\n        cout << i << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6. 后缀数组SA\n\n***Warning: 此处SA数组的字符串下标定义是从1开始的！***\n\n后缀数组$sa[i]$表示的是字典序排名第$i$小的后缀是原来字符串中哪一个后缀。\n\n排名数组$rk[i]$表示原来字符串的后缀中第$i$个后缀是多少字典序。\n\n第$i$个后缀的定义：$s[i\\cdots n]$\n\n$O(nlogn)$求法：\n\n```cpp\nstruct SufArray\n{\n    const static int maxn = 1e6 + 9;\n    // rk[i] i 的排名  sa[i] 第i名\n    // 字符串的序号  +k 就是往后走k个\n    int rk[maxn + 10], sa[maxn + 10], n, lstrk[maxn + 10], lstsa[maxn], w,\n        m = 127, cnt[maxn], h[maxn], f[maxn][20];\n    string s;\n\n#define siz n * sizeof(int)\n    void init(string _s)\n    {\n        s = _s;\n        m = 127;\n        n = s.length();\n        memset(cnt, 0, sizeof cnt);\n        memset(sa, 0, sizeof sa);\n        memset(rk, 0, sizeof rk);\n        memset(h, 0, sizeof h);\n        for (int i = 1; i <= n; ++i)\n            ++cnt[rk[i] = s[i - 1]];\n        for (int i = 1; i <= m; ++i)\n            cnt[i] += cnt[i - 1];\n        for (int i = n; i >= 1; --i)\n            sa[cnt[rk[i]]--] = i;\n        memcpy(lstrk + 1, rk + 1, siz);\n        for (int p = 0, i = 1; i <= n; ++i)\n            if (lstrk[sa[i]] == lstrk[sa[i - 1]])\n                rk[sa[i]] = p;\n            else\n                rk[sa[i]] = ++p;\n        for (w = 1; w < n; w <<= 1, m = n)\n        {\n            for (int p = 0, i = n; i >= n - w + 1; --i)\n                lstsa[++p] = i;\n            for (int p = w, i = 1; i <= n; ++i)\n                if (sa[i] > w)\n                    lstsa[++p] = sa[i] - w;\n            memset(cnt, 0, sizeof cnt);\n            for (int i = 1; i <= n; ++i)\n                ++cnt[rk[lstsa[i]]];\n            for (int i = 1; i <= m; ++i)\n                cnt[i] += cnt[i - 1];\n            for (int i = n; i >= 1; --i)\n                sa[cnt[rk[lstsa[i]]]--] = lstsa[i];\n            memcpy(lstrk + 1, rk + 1, siz);\n            for (int p = 0, i = 1; i <= n; ++i)\n                if (lstrk[sa[i]] == lstrk[sa[i - 1]] && lstrk[sa[i] + w] == lstrk[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n        }\n        for (int i = 1, k = 0; i <= n; ++i)\n        {\n            if (rk[i] == 0)\n                continue;\n            if (k)\n                --k;\n            while (s[i + k - 1] == s[sa[rk[i] - 1] + k - 1])\n                ++k;\n            h[rk[i]] = k;\n        }\n\n        memset(f, 0x3f, sizeof f);\n        for (int i = 1; i <= n; ++i)\n            f[i][0] = h[i];\n        for (int j = 1; (1 << j) <= n; ++j)\n            for (int i = 1; i <= n - (1 << j) + 1; ++i)\n                f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n    }\n    int lcp(int x, int y)\n    { // 后缀x和后缀y的最长公共前缀\n        if (x == y)\n            return n - y + 1;\n        x = rk[x], y = rk[y];\n        if (x >= y)\n            swap(x, y);\n        int k = log2(y - (x + 1) + 1);\n        return min(f[x + 1][k], f[y - (1 << k) + 1][k]);\n    }\n} SA;\nvoid solve()\n{\n    string s;\n    cin >> s;\n    SA.init(s);\n    for (int i = 1; i <= SA.n; i++)\n        cout << SA.sa[i] << ' ';\n    cout << endl;\n    // for (int i = 1; i <= SA.n; i++)\n    //     cout << SA.h[i] << ' ';\n    // cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 7. SA数组(线性SA-IS)\n\n**Warning：此处SA数组以及height数组是从0开始的**\n\n```cpp\nstruct SA\n{\n    int n;\n    vector<int> sa, rk;\n    vector<i64> h;\n    SA(string s)\n    {\n        n = s.size();\n        s.push_back(0);\n        sa.resize(n);\n        h.resize(n - 1);\n        rk.resize(n);\n        iota(sa.begin(), sa.end(), 0);\n        sort(sa.begin(), sa.end(), [&](int a, int b)\n             { return s[a] < s[b]; });\n        rk[sa[0]] = 0;\n        for (int i = 1; i < n; ++i)\n        {\n            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);\n        }\n        int k = 1;\n        vector<int> tmp, cnt(n);\n        tmp.reserve(n);\n        while (rk[sa[n - 1]] < n - 1)\n        {\n            tmp.clear();\n            for (int i = 0; i < k; ++i)\n            {\n                tmp.push_back(n - k + i);\n            }\n            for (auto i : sa)\n            {\n                if (i >= k)\n                {\n                    tmp.push_back(i - k);\n                }\n            }\n            fill(cnt.begin(), cnt.end(), 0);\n            for (int i = 0; i < n; ++i)\n            {\n                ++cnt[rk[i]];\n            }\n            for (int i = 1; i < n; ++i)\n            {\n                cnt[i] += cnt[i - 1];\n            }\n            for (int i = n - 1; i >= 0; --i)\n            {\n                sa[--cnt[rk[tmp[i]]]] = tmp[i];\n            }\n            swap(rk, tmp);\n            rk[sa[0]] = 0;\n            for (int i = 1; i < n; ++i)\n            {\n                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);\n            }\n            k *= 2;\n        }\n        for (int i = 0, j = 0; i < n; ++i)\n        {\n            if (rk[i] == 0)\n            {\n                j = 0;\n                continue;\n            }\n            for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j];)\n                ++j;\n            h[rk[i] - 1] = j;\n        }\n    }\n};\n\nvoid solve()\n{\n    string s;\n    cin >> s;\n    SA sa(s);\n    for (int i = 0; i < s.size(); i++)\n        cout << sa.sa[i] + 1 << \" \";\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 8. 后缀自动机SAM\n\n$SAM$自动机是一种压缩子串信息的自动机，可以在线性时间内解决以下问题：\n\n- 在另一个字符串中搜索一个字符串的所有出现位置。\n- 计算给定的字符串中有多少个不同的子串。\n\n```cpp\nstruct SAM {\n    //root是1\n    int size, last, len[N << 1], fa[N << 1], tr[N << 1][31];\n    int nxt[N << 1], head[N << 1], to[N << 1], ecnt = 1;\n    int cnt[N << 1], first_pos[N << 1], is_clone[N << 1];\n\n#define sfor(x, i) for(int i = 0; i <= 30; ++i) if(tr[x][i])\n    SAM() {\n        size = last = ecnt = 1;\n    }\n    int extend(int x) {\n        int cur = ++ size,u;\n        cnt[cur] = 1, first_pos[cur] = len[cur] = len[last] + 1;\n        for(u = last; u && !tr[u][x]; u = fa[u]) tr[u][x] = cur;\n        if(!u) fa[cur] = 1;\n        else {\n            int v = tr[u][x];\n            if(len[v] == len[u] + 1) fa[cur] = v;\n            else {\n                int clone = ++ size;\n                len[clone] = len[u] + 1, fa[clone] = fa[v], first_pos[clone] = first_pos[v], is_clone[clone] = 1;\n                memcpy(tr[clone], tr[v], sizeof(tr[v]));//时间复杂度在这个地方\n                for(; u && tr[u][x] == v; u = fa[u]) tr[u][x] = clone;\n                fa[cur] = fa[v] = clone;\n            }\n        }\n        return last = cur;\n    }\n    //cnt数组表示endpos的大小，默认是真实大小\n    //d数组表示下面可以走多少路径，默认和endpos集合大小有关\n    //每个结点的endpos集合起始就是终点结点的endpos的集合\n//=========================================建树=========================================\n    void add(int x, int y) {\n        nxt[++ecnt] = head[x], to[ecnt] = y, head[x] = ecnt;\n    }\n    void build_tree() {\n        for(int i = 2; i <= size; ++i) add(fa[i], i);\n    }\n\n//===========================================求occ=========================================\n    int pos[N << 1], f[N << 1][20];//pos代表s[1...r]对应的结点\n    //调用的时候pos[r] = extend(s[r] - 'a' + 1);\n    //调用时先建树 并求得cnt\n    void get_f(int x = 1){//遍历后缀链接树\n        f[x][0] = fa[x];\n        for(int i = 1; i <= 19; ++i) f[x][i] = f[f[x][i - 1]][i - 1];\n        for(int i = head[x]; i; i = nxt[i]) if(fa[x] != to[i]) {\n            get_f(to[i]);\n        }\n    }\n    int node(int l, int r){\n        int now = pos[r];\n        for(int i = 19; i >= 0; --i) if(len[f[now][i]] >= r-l+1) now = f[now][i];\n        return now;//找到l...r所在的结点\n    }\n    int occ(int l, int r){\n        return cnt[node(l, r)];\n    }\n//==========================================求结点的cnt=======================================\n    void Get_cnt(int x) {\n        for(int i = head[x]; i; i = nxt[i]) Get_cnt(to[i]), cnt[x] += cnt[to[i]];\n    }\n    //调用时先建树\n    void get_cnt(int type = 1) {\n        if(type == 0) for(int i = 1; i <= size; ++i) cnt[i] = 1;    //不同位置的子串算作一个 强制每个子串只出现一次\n        else Get_cnt(1);\n    }\n    vector<int> endpos(int x) {\n        queue<int> q;\n        vector<int> ep;\n        q.push(x);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            if(!is_clone[now])  //是终点结点\n                ep.push_back(first_pos[now]);\n            for(int i = head[now]; i; i = nxt[i])\n                q.push(to[i]);\n        }\n        return ep;\n    }\n    //遍历后缀树：用图那一套 从1开始 //遍历后缀自动机：从1开始用tr转移\n    ll d[N], ans[N];//d记录了从x开始往下有几条路径 ans记录了从x开始，往下所有路径上不同子串的总长度。\n    void get_d(int x = 1) {\n        if(d[x]) return ;\n        d[x] = cnt[x];\n        sfor(x, i) get_d(tr[x][i]), d[x] += d[tr[x][i]];\n    }\n    void debug() {\n        puts(\"--------Debug_SAM--------\");\n        for(int i = 1; i <= size; ++i)\n            cout << \"i = \" << i << \", endpos_size = \" << cnt[i] << \", fa = \" << fa[i] << \", len = \" << len[i] << \", d = \" << d[i] << endl;\n        for(int i = 1; i <= size; ++i) {\n            cout << \"i = \" << i << \" can trans to \" << endl;\n            sfor(i, j)  cout << tr[i][j] << \" by \" << char(j + 'a' - 1) << endl;\n        }\n        puts(\"--------End_Debug--------\");\n    }\n} sam;\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 6. 动态规划\n\n## 1. sosdp（高维前缀和dp)\n\n对于所有的$i$,$0≤i≤2^n−1$,求解$∑_{j⊂i}a_j$。\n\n以$O(n2^n)$的复杂度管理子集前缀和$dp$​。\n\n子集：$i$对应是$0$的位置，$j$必须对应为$0$\n\n```cpp\nfor(int j = 0; j < n; j++) \n    for(int i = 0; i < 1 << n; i++)\n        if(i >> j & 1) f[i] += f[i ^ (1 << j)];\n\n```\n\n超集：$i$对应是$1$的位置，$j$必须对应$1$\n\n```cpp\nfor(int j = 0; j < n; j++) \n    for(int i = 0; i < 1 << n; i++)\n        if(!(i >> j & 1)) f[i] += f[i ^ (1 << j)];\n\n```\n\n示例1：（2024湖南省赛）\n\n给出一个长度为$n$的正整数串 。现在可以把两个没有重叠的连续子串前后拼接起来，但是要求拼接之后的数串中每个正整数不能出现超过$1$次。请问能拼接出来的符合要求的数字串的最大长度是多少。保证$a_i\\le18$.\n\n数据范围一眼状压$dp$，考虑维护出现不超过一次。显然两个串的$mask$位的交集为$0$，考虑串$A$的$mask$位$K$，则显然串$B$的$mask$必定有$mask_B\\subset(2^{18}\\oplus mask_A)$\n\n串长度不超过$18$，暴力枚举所有合法串初始化$dp$数组，然后跑$sosdp$维护子集$max$，最后暴力检查一圈就行了。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int B = (1 << 18) - 1;\nint mp[2 * B];\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], a[i]--;\n    int i = 1, j = 1;\n    int bit = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        bit = 0;\n        for (int j = 0; j < 18 && j + i <= n; j++)\n        {\n            if ((bit >> a[i + j]) & 1)\n            {\n                break;\n            }\n            bit ^= (1 << a[i + j]);\n            mp[bit] = max(mp[bit], j + 1);\n        }\n    }\n    int ans = 0;\n    for (int j = 0; j < 18; j++)\n    {\n        for (int i = 0; i <= B; i++)\n        {\n            if (i >> j & 1)\n                mp[i] = max(mp[i], mp[i ^ (1 << j)]);\n        }\n    }\n    for (int i = 0; i <= B; i++)\n    {\n        ans = max(ans, mp[i] + mp[B ^ i]);\n    }\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.线性dp\n\n### 2.1 LIS ($O(nlogn)$​)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint a[N], dp[N], dp2[N];\nint main()\n{\n    int n, ans = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        dp[i] = 1;\n    }\n    // O(nlogn)做法\n    int maxx = 0;\n    memset(dp2, inf, sizeof(dp2));\n    for (int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(dp2, dp2 + n, a[i]) - dp2;\n        if (j + 1 > maxx)\n            maxx = j + 1;\n        dp2[j] = a[i];\n    }\n    cout << maxx << endl;\n}\n```\n\n单调栈优化：\n\n```cpp\nint arr[maxn], sta[maxn];\nsigned main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> arr[i];\n    int len = 1;\n    sta[len] = arr[1];\n    for (int i = 2; i <= n; i++)\n    {\n        if (arr[i] > sta[len])\n        {\n            sta[++len] = arr[i];\n        }\n        else\n        {\n            int tem = lower_bound(sta + 1, sta + 1 + len, arr[i]) - sta;\n            sta[tem] = arr[i];\n        }\n    }\n    cout << len << endl;\n    // system(\"pause\");\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 背包\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 2;\n// 物品容积与权重\nint c[N], w[N], dp[N];\nint main()\n{\n    // 01背包\n    // 物品数目与背包体积\n    int n, v;\n    for (int i = 1; i <= n; i++)        // 枚举所有物品\n        for (int j = v; j >= c[i]; j--) // 枚举背包体积\n            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);\n    // 分组背包\n    // t[k][i]表示第k组的第i件物品的编号是多少\n    int ts, m, cnt[N], t[N][N];\n    for (int k = 1; k <= ts; k++)                                        // 循环每一组\n        for (int i = m; i >= 0; i--)                                     // 循环背包容量\n            for (int j = 1; j <= cnt[k]; j++)                            // 循环该组的每一个物品\n                if (i >= w[t[k][j]])                                     // 背包容量充足\n                    dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]); // 像0 - 1背包一样状态转移\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.3 整数划分\n\n```cpp\nll dp[maxn][maxn];\nll f[maxn][maxn], g[maxn][maxn];\nint n, k;\nvoid div1()\n{\n    // dp[i][j] 代表将i划分为不大于j的划分数(允许重复数字)\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (j == 1)\n                dp[i][j] = 1;\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        }\n    }\n}\nvoid div2()\n{\n    // dp[i][j] 代表将i划分为不大于j的划分数(没有重复数字)\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (j == 1)\n            {\n                if (i == 1)\n                    dp[i][j] = 1;\n                else\n                    dp[i][j] = 0; // 初始化不同即可, 转移方程依旧相同.\n            }\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1];\n        }\n    }\n}\nvoid div3()\n{\n    // dp[i][j]为将i恰好划分为j个整数的划分数\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i == j)\n                dp[i][j] = 1;\n            else if (i < j)\n                dp[i][j] = 0;\n            else\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];\n        }\n    }\n}\nvoid div4()\n{\n    // 设f[i][j]为将i恰好划分为j个奇数之和的划分数\n    //  g[i][j]为将i恰好划分为j个偶数之和的划分数。\n    f[0][0] = g[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i < j)\n                f[i][j] = g[i][j] = 0;\n            else\n            {\n                f[i][j] = f[i - 1][j - 1] + g[i - j][j];\n                g[i][j] = f[i - j][j];\n            }\n        }\n    }\n}\nvoid div5()\n{\n    // dp[i][j] 代表i划分为不多于j个正整数的划分数\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i == 1 || j == 1)\n                dp[i][j] = 1;\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.4 数位dp\n\n```cpp\nint a[maxn], f[maxn][maxn][2];\n// f[len][state],状压的state记录状态\nint dfs(int pos, int pre, bool limit, bool lead0, int cnt) {\n    if (!pos)\n        return 1;  // 看情况return 1还是cnt\n    auto& now = f[pos][pre][limit];\n    if (!lead0 && ~now)\n        return now;\n    int up = limit ? a[pos] : 9;\n    int res = 0;\n    for (int i = 0; i <= up; i++) {\n        if (!lead0 && abs(i - pre) < 2)\n            continue;  // 保证枚举的要合法\n        res += dfs(pos - 1, i, limit && i == up, lead0 && i == 0, cnt);\n    }\n    if (!lead0)\n        now = res;\n    return res;\n}\nint solve(int x) {\n    int len = 0;\n    while (x > 0) {\n        a[++len] = x % 10;\n        x /= 10;\n    }\n    return dfs(len, 0, true, true, 0);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.5 四边形不等式优化dp\n\n```cpp\nint m[maxn][maxn],dp[maxn][maxn],sum[maxn],arr[maxn];\n//m是区间分割点\nsigned main(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>arr[i];\n        sum[i]=sum[i-1]+arr[i];\n        m[i][i]=i;\n    }\n    for(int len=2;len<=n;len++){//枚举区间长度，也是对角线条数\n        for(int i=1,j=len;j<=n;i++,j++){\n            dp[i][j]=inf;\n            for(int k=m[i][j-1];k<=m[i+1][j];k++){\n                if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]<dp[i][j]){\n                    dp[i][j]=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1];\n                    m[i][j]=k;\n                }\n            }\n        }\n    }\n    cout<<dp[1][n]<<endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.6 状态压缩dp\n\n```cpp\nusing namespace std;\nconst int maxn = 1 << 16;\ndb f[17][1 << 17]; // 当前到第i个奶酪，并且已经经过的状态为j\ndb d[17][17];\ndb x[17] = {0}, y[17] = {0};\ndb dis(int i, int j)\n{\n    return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n}\nint main()\n{\n    int n = read();\n    memset(f, 127, sizeof(f));\n    db ans = f[0][0];\n    for (int i = 1; i <= n; i++)\n        cin >> x[i] >> y[i];\n    for (int i = 0; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            d[i][j] = d[j][i] = dis(i, j); // 初始化任意两个奶酪之间的距离\n    for (int i = 1; i <= n; i++)\n        f[i][1 << (i - 1)] = d[0][i];\n    for (int j = 0; j < (1 << n); j++)\n    { // 枚举当前已经走过的状态\n        for (int i = 1; i <= n; i++)\n        {\t\t\t\t\t\t\t\t   // 枚举当前已经到第i个奶酪\n            if ((j & (1 << (i - 1))) == 0) // 本应已经到了i个奶酪，但是还没走过i不合题意\n                continue;\n            for (int k = 1; k <= n; k++)\n            { // 枚举上一个走到的奶酪\n                if (i == k)\n                    continue;\t\t\t\t   // 重复了跳过\n                if ((j & (1 << (k - 1))) == 0) // 目前走过的j没走过k\n                    continue;\n                f[i][j] = min(f[i][j], f[k][j - (1 << (i - 1))] + d[i][k]);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        ans = min(ans, f[i][(1 << n) - 1]);\n    cout << fixed << setprecision(2) << ans << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.7 最短路优化dp\n\n最短路$dp$后效性问题会被最短路优化掉。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\n#define int long long\nconst int maxn = 2e5 + 9;\nvector<pair<int, int>> connects[maxn];\nint a[maxn];\nvoid add_edge(int u, int v, int w)\n{\n    connects[u].push_back({v, w});\n    connects[v].push_back({u, w});\n    return;\n}\nvector<int> dist, dist1;\nvoid Dijkstra_queue0()\n{\n    using pi = pair<int, int>;\n    vector<bool> vis(n + 1, 0);\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    for (int i = 1; i <= n; i++)\n    {\n        q.push({dist[i], i});\n    }\n    while (!q.empty())\n    {\n        auto [dis, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto [v, w] : connects[u])\n        {\n            if (vis[v])\n                continue;\n            if (dist[v] > dist[u] + w)\n            {\n                dist[v] = dist[u] + w;\n                q.push({dist[v], v});\n            }\n        }\n    }\n    return;\n}\nvoid Dijkstra_queue1()\n{\n    using pi = pair<int, int>;\n    vector<bool> vis(n + 1, 0);\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    for (int i = 1; i <= n; i++)\n    {\n        q.push({dist1[i], i});\n    }\n    while (!q.empty())\n    {\n        auto [dis, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto [v, w] : connects[u])\n        {\n            int now = min(dist[u], dist1[u] + w);\n            if (now < dist1[v])\n            {\n                dist1[v] = now;\n                q.push({dist1[v], v});\n            }\n        }\n    }\n    return;\n}\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        add_edge(u, v, w);\n    }\n    dist.resize(n + 10), dist1.resize(n + 10);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        dist[i] = dist1[i] = a[i];\n    }\n    Dijkstra_queue0();\n    Dijkstra_queue1();\n    cout << *max_element(dist1.begin() + 1, dist1.end()) << endl;\n}\n```\n\n","tags":["ACM","ICPC","算法模版"]},{"title":"我的21岁","url":"/post/bba48da1.html","content":"恍恍惚惚已经来到这个世界上20个年头，这段时期里有高光也有低谷，无论怎样，一切都已随风而去。对于过去，唯有感恩。正如涛涛的祝福一样，希望自己在今后心态和能力都要提升，更加成熟一点。新的一岁，要做到**言必信，行必果**。涛涛的祝福语还有一句“无事绊心弦，随缘皆所念”。好奇为什么不是“所愿皆所念”，可是发现“随缘”比“所愿”更好......真正在意你的人，又怎么会让你伤心呢，“送给自己一朵小红花，开在我新长的枝桠”，拥抱未来，珍惜爱我的人。\n\n<center>\n\n<img src=\"https://s2.loli.net/2024/11/29/Fh43SXJnB8y1Y5C.jpg\" width=\"100%\" />\n\nFigure 1\n</center>\n\n和室友聚餐庆祝一下。\n\n<center>\n\n<img src=\"https://s2.loli.net/2024/11/29/mn7x5To8t9VAEwY.jpg\" width=\"100%\" />\n\nFigure 2\n</center>","tags":["生日"]},{"title":"上海","url":"/post/ff9c3d7d.html"},{"title":"沈阳","url":"/post/7ef69597.html"},{"title":"Mini App","url":"/post/c1183a76.html","content":"## 作业要求\n**作业说明：**\n个人作业。不限主题，不限功能，做出一款Mini App\n\n**具体要求：**\n1.功能要求：可使用任意界面框架完成至少一个的功能点\n2.技术要求：需要使用到网络、存储等技术点中至少一条\n3.性能要求：不卡顿、无明显资源泄露\n\n**提交要求：**\n1.产品报告：不限于ppt/word/pdf格式，内容需至少包括 ①产品功能介绍；②程序概要设计；③软件架构图；④技术亮点及其实现原理（非必选）\n2.源代码：要求提交到GitHub/gitee repo仓库，将仓库地址粘贴到txt提交即可\n3.演示录屏：mkv, mp4, avi, rm, rmvb格式优先\n4.提交时间：11月30日晚12点前\n\n**提交格式：**\n请将以上三个内容合并到一个文件夹并压缩，命名：学校+姓名+Android/iOS+App名称\n上传至：\n腾讯客户端菁英班课程大作业提交\n\n**样例参考：**\n例1：《表情图库》\n1.功能要求：使用网格/列表，展示表情图库\n2.技术要求：使用 DB 存储图片文件信息，使用文件存储表情图片\n3.性能要求：快速打开超过1000张图片的图库，显示图片流畅滑动不卡顿，内存资源不泄露\n\n例2：《微信文本/图片聊天》\n1.功能要求：仿照微信做一个可以文本/图片聊天的界面\n2.技术要求：能够进行两人以上的聊天，能够发送文本/图片\n3.性能要求：聊天列表上下滑动不卡顿，没有资源泄露\n\n注：以上仅为样例参考，同学们可以任意选择自己想做的 Mini App。\n\n## 《表情图库》Web开发流程\n### 技术架构\n我们将使用以下技术：\n- **HTML**：负责网页结构。\n- **CSS**：负责页面布局和样式。\n- **JavaScript**：控制页面逻辑，操作 IndexedDB 数据库。\n- **IndexedDB**：用于存储图片的文件信息（包括路径、标题和分类）。\n图片文件存储在文件系统（`assets` 文件夹）中，数据库只存储图片的元数据。\n### 开发环境准备\n1.工具：\n- 下载并安装 [`VS Code`](https://code.visualstudio.com/) 作为代码编辑器。\n- 安装浏览器插件 `Live Server`，用于运行本地网页。\n2.文件夹结构： 创建一个名为 表情图库 的文件夹，内部文件组织如下：\n### 项目实现流程\n\n### 运行项目\n","tags":["Mini App","腾讯"]},{"title":"《软件工程》复习","url":"/post/c5fb3a3a.html","content":"\n声明：此文档针对天津大学24251学期《软件工程》课程重点知识整理，仅供个人参考。\n\n## 1.2 软件及其特点\n### ★软件的组成\n**程序**\n**数据：** 程序的加工处理对象和结果。\n**文档：** 记录软件开发活动和阶段性成果、软件配置及变更的阐述性资料。\n\n### ★软件的生命周期\n软件从提出开发开始到最终灭亡所经历的时期。\n**需求分析、软件设计、编码实现、软件测试、部署运行、使用维护。**\n\n### ★软件的分类\n**应用软件**\n**系统软件**\n**支撑软件**\n\n### ★开源软件的优势\n**1. 开源软件的好处**\n源代码可自由传播\n激发创作者的热情\n免费使用降低成本\n**2. 开源软件的优势**\n**采购和开发的成本更低**：开源软件通常是免费的，即使要付费，其费用也非常低廉\n**软件质量更高、更安全**：核心代码都在公众的视野之中，代码问题（如缺陷、安全漏洞等）很容易被人发现\n**软件研制和交付的更快**：基于开源软件的项目开发可以更为快速地给用户交付软件产品\n**软件功能更为强大**：大量的软件开发者不仅参与软件开发，贡献他们的代码，而且还参与软件的创新，提出和构思软件需求，不断完善软件功能\n\n### ★软件质量要素\n正确性、可靠性、健壮性、有效性、安全性、可维护性、可移植性、可重用性、可理解性、可信性、持续性、可用性、互操作性。\n\n## 2 软件工程概述\n### ★软件危机的表现\n<font color=red>**1. 软件危机的表现：**</font>\n**开发成本高**\n**进度难以控制**\n**质量难以保证**\n**软件维护困难**\n**失败风险很大**\n<font color=red>**2. 软件危机的产生根源：**</font>\n**① 对软件这样一类复杂和特殊系统的认识不清**\n**② 没有找到支持软件系统开发的有效方法**\n**③ 缺乏成功软件开发实践以及相应的开发经验**\n<font color=red>**3. 如何来解决软件危机?**</font>\n**策略：采用敏捷项目管理，强化风险控制。**\n**方法：实施敏捷开发和持续集成/部署。**\n**理论：深化软件工程理论，推广系统思维。**\n**技术：利用自动化测试和代码审查工具。**\n\n### ★软件工程的要素\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-0.png\" width=\"50%\" />\n\n### ★软件工程的原则\n抽象和建模、模块化、软件重用、信息隐藏、关注点分离、分而治之、双向追踪原则、工具辅助。\n<font color=red>**信息隐藏?**</font>\n模块内部信息（如内部的语句、变量等）对外**不可见或不可访问**，模块间仅仅交换那些为完成系统功能所必需交换的信息（如接口）\n模块设计时**只对外提供可见的接口**，不提供内部实现细节。信息隐藏原则可提升模块的独立性，减少错误向外传播，支持模块的并行开发\n\n\n\n## 3.1 软件过程模型\n### ★典型软件过程模型\n**瀑布模型**\n**增量模型**\n**迭代模型**\n**原型模型**\n**螺旋模型**\n基于构件的过程模型\nUP模型\n<font color=red> **瀑布模型** </font>\n**过程：** 需求分析->概要设计->详细设计->编码实现->集成测试->确认测试\n**特点:**\n与软件生命周期相互一致\n每个活动结束后需要评审\n相邻活动间存在因果关系\n**优点:** 简单，一目了然，易理解、掌握、应用和管理\n**不足：** 需求确定，过于理想化、缺乏变通，难应对变化\n**改进的瀑布模型：带反馈和回溯**\n**优点:** 后期活动发现有问题后，可返回到前面活动加以解决、提高了过程模型的灵活性\n**不足：** 软件开发处于动荡之中、需等到所有功能实现后，才能得到可运行软件\n\n\n\n## 3.2 敏捷软件开发方法 - Agile\n### ★敏捷开发的概念和观点\n**概念**：\n一种**轻量级**软件开发方法\n主张软件开发要**以代码为中心，快速、轻巧和主动应对需求变化，持续、及时交付可运行的软件系统**\n提供了一组思想和策略，指导快速响应用户需求的变化，快速交付可运行的软件制品\n**观点**：\n较之于过程和工具，应更加重视**人和交互**的价值\n较之于面面俱到文档，应更加重视**可运行软件系统**的价值\n较之于合同谈判，应更加重视**客户合作**的价值\n较之于遵循计划，应更加重视**响应用户需求变化**的价值\n### ★敏捷准则\n**尽早和持续地交付**有价值的软件，以使用户满意\n即使到了软件开发后期，也**欢迎用户需求的变化**\n**不断交付**可运行的软件系统，**交付周期**可以从几周到几个月\n在整个软件项目开发期间，用户和开发人员最好能每天**一起工作**\n由**积极主动**的人来承担项目开发，给他们提供所需环境和支持，信任他们的能力\n团队内部最有效的信息传递方式是**面对面的交谈**\n将**可运行软件**作为衡量软件开发进度的首要标准\n可持续性的开发，出资方、开发方和用户方应当保持**长期、恒定的开发速度**\n关注**优秀的技能和良好的设计**会增强敏捷性\n**简单**化\n最好的架构、需求和设计出自于**自组织的团队**\n软件开发团队应定期就如何提高工作效率的问题进行**反思**，并进行相应的**调整**\n### ★敏捷开发代表方法\n**极限编程**\n**测试驱动开发方法**\n**Scrum方法**\n\n\n\n## 4 软件需求分析基础\n### ★利益相关方\n**用户**\n**客户**\n**系统**\n**开发者**\n\n### ★软件需求的类别\n**软件功能性需求**\n**软件质量方面的需求(外部质量属性、内部质量属性)**\n**软件开发约束性需求**\n### ★面向对象的需求分析方法\n**1.对象、类、继承、多态、覆盖、重载、消息、聚合和组合等概念需要记忆**\n**2.面向对象需求分析步骤**\n明确问题边界，获取软件需求，建立用例模型\n开展用例分析，精化软件需求，建立分析模型\n汇总需求模型，撰写需求文档，评审软件需求\n**3.面向对象需求分析方法的优势和特色**\n自然建模\n统一的概念和抽象\n\n\n\n## 5 获取软件需求\n### ★获取软件需求的方法\n**访谈和会议**\n**调查问卷**\n**现场观摩**\n**分析业务资料**\n**软件原型**\n**群体化方法**\n**成立需求分析的联合工作小组**\n\n### ★用例图\n**用例间的关系**\n包含(Include)\n扩展(Extend)\n继承(Inherit)\n\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-1.png\" width=\"50%\" />\n\n## 6 分析软件需求\n### ★顺序图\n描述对象间的消息交互序列\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-2.png\" width=\"50%\" />\n\n### ★类图\n描述系统的类构成，刻画系统的静态组成结构\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-3.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-4.png\" width=\"50%\" />\n\n### ★状态图\n描述实体（对象、系统）在事件刺激下的反应式动态行为及其导致的状态变化\n刻画了实体的可能状态、每个状态下可响应事件、响应动作、状态迁移\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-5.png\" width=\"50%\" />\n### ★分析软件需求过程\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-6.png\" width=\"50%\" />\n\n### ★软件需求文档\n**撰写软件需求文档的注意事项**\n遵循规范\n图文并茂\n完整表述\n共同参与\n语言简练\n前后一致\n\n\n\n## 7 软件设计基础\n### ★软件设计的质量要求\n**正确性**：正确实现所有的软件需求项；设计元素间无逻辑冲突；在技术平台和软件项目的可用资源约束条件下，采用程序设计语言可完整地实现设计模型\n**充分性**：所有的设计元素已充分细化，模型易于理解，编程人员勿需再面对影响软件功能和质量的技术抉择或权衡\n**优化性**：以合理的、充分优化的方式实现软件需求模型，目标软件产品能够表现出良好的软件质量属性，尤其是正确性、有效性、可靠性和可修改性\n**简单性**：模型中的模块的功能或职责尽可能简明易懂，模块间的关系简单直观，模型的结构尽可能自然地反映待解软件问题的结构\n\n### ★软件设计原则\n**①抽象与逐步求精**\n**②模块化，高内聚度、低耦合度**\n**③信息隐藏**\n**④多视点和关注点分离**\n**⑤软件重用**\n**⑥迭代设计**\n**⑦可追踪性**\n<font color=red>**高内聚度：**</font>**指该模块内各成分间彼此结合的紧密程度，越高越好，高内聚**\n<font color=red>**信息隐藏：**</font>**模块应该设计得使其所含的信息对那些不需要这些信息的模块不可访问；模块间仅仅交换那些为完成系统功能所必需交换的信息**\n\n\n\n## 8 软件体系结构设计\n### ★常用软件体系结构风格\n**分层风格**\n**管道与过滤器风格**\n**黑板风格**\n**MVC风格**\n**SOA风格**\n**总线风格**\n\n\n\n\n## 10 软件详细设计\n### ★详细设计过程\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-7.png\" width=\"50%\" />\n\n### ★活动图\n描述实体为完成某项功能而执行的操作序列，其中某些操作或其子序列存在并发和同步\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-8.png\" width=\"50%\" />\n\n### ★用例设计\n\n### ★类设计\n\n### ★数据设计\n\n\n## 13 软件测试\n### ★软件测试过程\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-9.png\" width=\"50%\" />\n\n### ★软件测试原则\n<font color=red>**软件测试原则**</font>\n测试应该有计划\n所有的测试都应该追溯到用户需求\n将Pareto原则应用于软件测试\n测试应该从“微观”开始，逐步转向“宏观”\n穷举测试是不可能的\n每个测试用例都必须定义预期的输出或结果\n尽量避免程序的开发人员来测试他自己编写的代码\n尽量避免程序开发组织测试其自己开发的程序\n应详细检查每次测试的结果。\n测试用例中不仅要说明合法有效的输入条件，还应该描述那些不期望的、非法的输入条件。\n检查一个程序没有完成希望它做的事情只是测试的一半任务，还应检查程序是否执行了不希望它做的事情。\n避免随意舍弃任何测试用例，即使非常简单的测试用例。\n不应在事先假设不会发现错误的情况下来制定测试计划。\n一个程序模块存在更多错误的可能性与该模块已经发现的错误数量成正比。\n测试是一个具有相当创新性和智力挑战的活动。\n\n### ★软件测试技术\n<font color=red>**白盒测试技术：**</font>**基于程序内部的执行流程来设计测试用例**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-10.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-11.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-12.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-13.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-14.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-15.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-16.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-17.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-18.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-19.png\" width=\"50%\" />\n\n<font color=red>**黑盒测试技术：**</font>**基于程序的外在功能和接口来设计测试用例**\n**等价分类法**\n**边界值分析法**\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-20.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-21.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-22.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-23.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-24.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-25.png\" width=\"50%\" />\n<img src=\"https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/《软件工程》复习/software-26.png\" width=\"50%\" />\n\n## 15 软件维护和演化\n### ★软件维护的形式\n**1. 纠正性维护：** 纠正软件中的缺陷和错误。\n**2. 完善性维护：** 对软件进行改造以增加新的功能、修改已有的功能。\n**3. 适应性维护：** 对软件进行改造以便适应新的运行环境和平台。\n**4. 预防性维护：** 对软件结构进行改造以便提高软件的可靠性和可维护性等。\n\n### ★软件维护技术\n**1. 代码重组**\n**2. 逆向工程**\n**3. 设计重构**\n**4. 再工程**\n\n<font color=red>**影响软件可维护性的因素：**</font>\n**1. 软件开发方法(结构化、OO)**\n**2. 软件文档是否齐全**\n**3. 文档结构是否标准化**\n**4. 软件是否易于扩展**\n**5. 软件结构是否清晰易于理解**\n**6. 是否采用标准的程序设计语言**\n**7. 程序代码是否易于理解**","tags":["复习","软件工程"]},{"title":"Hackathon决赛","url":"/post/5cfdd183.html","content":"本次所选工程题目对于我们来说难度还是太大了。所以决定先去观光一下华为欧洲小镇吧~\n<center>\n<img src=\"https://s2.loli.net/2024/10/26/dDNqeRghP17isKX.jpg\" width=\"100%\" />\n\nFigure 1\n</center>\n\n意料之外获得“安慰奖”。\n<center>\n<img src=\"https://s2.loli.net/2024/10/29/xtLy9h3d5SHAeuZ.jpg\" width=\"100%\" />\n\nFigure 2\n</center>\n\n返程飞机上的体验感还不错。\n<center>\n<img src=\"https://s2.loli.net/2024/10/29/UOLH8Fyaf7lPsI6.jpg\" width=\"100%\" />\n\nFigure 3\n</center>","tags":["Hackathon","华为","比赛","体验"]},{"title":"C/C++ 读取EXCEL数据","url":"/post/undefined.html","content":"- 打开Excel文件，点击文件-另存为\n- 在保存类型这里设置保存为csv格式\n- 选择好想保存的目录后，点击保存\n- 回到工作界面后，会弹出窗口，选择确定就可以了\n\n**按行读取。**\n```C++\n#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    ifstream file(\"01.csv\"); // 打开CSV文件\n    if (!file.is_open()) {\n        cout << \"无法打开文件！\" << endl;\n        return 1;\n    }\n\n    string line;\n    while (getline(file, line)) { // 逐行读取文件\n        cout << line << endl; // 打印每一行内容\n    }\n\n    file.close(); // 关闭文件\n    return 0;\n}\n```","tags":["c++"]},{"title":"基于VirtualBox虚拟机安装Ubuntu教程","url":"/post/4381ab4e.html","content":"## 一. 下载安装VirtualBox\n\n1. [官网下载VirtualBox安装程序](https://www.virtualbox.org/wiki/Downloads)，我的版本（released January 21 2025）：VirtualBox 7.1.6 for Windows hosts x86/amd64\n\n2. 下载好了安装VirtualBox，一路`Next`就可以了,这个比较简单。\n\n3. 运行VirtulBox程序, 如下图：\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/wV8GSWjOA7szHuf.png\" width=\"80%\" />\n</center>\n\n4. 配置VirtualBox。按 `CTRL+G`打开全局设定，根据需要可以设定虚拟脑位置和界面语言：\n\\\n修改`默认虚拟脑位置`比如`D:\\VirtualBox VMs`可以让自己更方便的查找，备份安装好的虚拟机。\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/c6gMmE9kOTUKePa.png\" width=\"80%\" />\n</center>\n\n&emsp;&emsp;&emsp;如果界面是英文，可以改成中文：\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Ui6OyNV37F9pfZ8.png\" width=\"80%\" />\n</center>\n   \n5. 安装VirtualBox Extension Pack（新手可以不做）\n\\\n[下载](https://download.virtualbox.org/virtualbox/6.1.4/Oracle_VM_VirtualBox_Extension_Pack-6.1.4.vbox-extpack), 双击安装，支持USB 2.0 和USB 3.0 设备, VirtualBox RDP, 磁盘加密，虚拟机快照等功能。\n\n## 二、安装Ubuntu\n\n### 创建虚拟机\n\n1. 运行VirtulBox程序，点击“新建”按钮，新建一个虚拟机。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/BUaJM38DxXOEISC.png\" width=\"80%\" />\n</center>\n\n2. 虚拟机名称可以随意输入，示例：`zhy`。操作系统选择Linux，版本选择ubuntu(64-bit)。点击“下一步”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Ov6DCRIuglzAwrP.png\" width=\"80%\" />\n</center>\n\n3. 设定虚拟机的内存，此内存即为虚拟机所占用的系统内存，可随意修改，建议不要超过系统内存的1/2。\\\n   首先了解自己的笔记本电脑系统内存大小，“我的电脑”->“属性”。样机为16G。\\\n   为了方便以后编程学习使用，这里将虚拟内存设为4G。点击“下一步”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/PI3uBHkc1NQ4DhJ.png\" width=\"80%\" />\n</center>\n\n4. 为虚拟机创建一块虚拟硬盘。选择“现在创建虚拟硬盘”，并单击“创建”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/uxgviweoWYF7AmR.png\" width=\"80%\" />\n</center>\n   如果你安装有问题，可以在`默认虚拟脑位置`比如`D:\\VirtualBox VMs`处拷贝别人安装好的XXX.vdi文件，在此选择“使用已有的虚拟硬盘文件”，然后选中拷贝过来的vdi文件就可以了，下面的安装就不用做了。\n\n**在此强烈建议把教程走完，出错了也会有不一样的收获**\n\n5. 选择虚拟硬盘文件类型。选择默认的VDI（VirtualBox磁盘映像），并单击“下一步”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/aXFf74RUsb5B1DW.png\" width=\"80%\" />\n</center>\n\n6. 选择“动态扩展”，并单击“下一步”。\\\n   因为分配给虚拟机的内存空间较大，使用时逐渐占用磁盘空间，闲置时自动缩减比较合理，所以选择动态扩展类型。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/6Todt8VHPwBabZX.png\" width=\"80%\" />\n</center>\n\n7. 输入虚拟硬盘文件的名称，并选择保存位置。\\\n   选择虚拟硬盘大小时一定先确定保存所在位置磁盘的可用大小。可用空间为500G，虚拟硬盘大小设置为10G。单击“创建”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Y1TEbI2jc4Fkis9.png\" width=\"80%\" />\n</center>\n\n8. 虚拟机创建完成。也就是说Ubuntu所需的硬件资源准备好了，相当于买了一个没有安装操作系统的电脑主机。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/6mFDeJh9cHsoCbQ.png\" width=\"80%\" />\n</center>\n\n### 安装Ubuntu 系统软件\n\n&emsp;在虚拟机上安装Ubuntu和在真实机器上安装没有大的差别。\n\n&emsp;**官网下载（不推荐）**\n&emsp;可以直接访问[Ubuntu官网](https://cn.ubuntu.com/)进行下载，但由于服务器在国外，下载速度会非常非常慢，推荐使用国内的一些镜像站下载。\n&emsp;**镜像下载**\n&emsp;个人推荐[清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/)。\n1. 进入之后搜索Ubuntu，选择“ubuntu-releases”。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/8DxnGiw1QrjhVR9.png\" width=\"80%\" />\n</center>\n\n2. 根据个人体验，强烈推荐选择20.04版本（截至发文时间）。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/EmOAqMUvDk6JH2N.png\" width=\"80%\" />\n</center>\n\n3. 选择“ubuntu-20.04.6-desktop-amd64.iso”进行下载\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/YkesCc46KwqvIub.png\" width=\"80%\" />\n</center>\n\n4. 双击启动创建好的虚拟机\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/DJfizcujNO7oSRe.png\" width=\"80%\" />\n</center>\n弹出下图对话框，选择启动盘。单击右侧文件夹小图标。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/QpPLAmoDwtslZEN.png\" width=\"80%\" />\n</center>\n\n选择虚拟光盘文件ubuntu-20.04.6.-desktop-amd64.iso，单击“启动”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/Co1ONqVjIac7DnK.png\" width=\"80%\" />\n</center>\n\n5. 进入安装界面。 选择“中文简体”，选择“安装Ubuntu”\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/fN83Bec7irMAdWo.png\" width=\"80%\" />\n</center>\n\n6. 选择“继续”。 网络状况不好可以不选择“安装Ubuntu时下载更新”\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/QcKatrVeqIpmw7J.png\" width=\"80%\" />\n</center>\n\n7. 选择“清除整个磁盘并安装Ubuntu”单击“现在安装”\n\\\n弹出警告框，选择“继续”。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/doFsbU7IuhjYy9L.png\" width=\"80%\" />\n</center>\n\n8. 安装过程中时区，用鼠标单击地图中的“中国”，就会选择“上海”，单击“继续”，语言选“汉语”。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/vF5qPY2yWjN8dOp.png\" width=\"80%\" />\n</center>\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/vw3OeZxm2Mt1HRS.png\" width=\"80%\" />\n</center>\n\n9. 输入个人信息：用户名，口令等。单击“继续”，安装过程可能需要几十分钟，请耐心等待。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/C4OJgIzNfKsvy2d.png\" width=\"80%\" />\n</center>\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/LviOMRdTNaprWj9.png\" width=\"80%\" />\n</center>\n\n10. 安装完毕，重启一下Ubuntu。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/X4JRekfNnozGrHQ.png\" width=\"80%\" />\n</center>\n\n## 安装VirtualBox虚拟机增强功能\n\n注意：以下需要输入命令代码时请注意之间的空格！以及文件名相互对应！\n\n1. 进入虚拟机Ubuntu系统，安装VirtualBox增强功能，这可以极大的提高虚拟机效率。首先点击VBox菜单栏的“设备”项，选择最下面的“安装增强功能”。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/X4JRekfNnozGrHQ.png\" width=\"80%\" />\n</center>\n\n3. 这时可以看到桌面多出一个光盘图标，如果没有，则重试本步。\n\n4. 按`CTRL+ALT+T`打开“终端”。输入以下命令（**注意空格！注意路径、文件名相互对应。**）\n\n输入命令时要根据自己的情况修改，文件名用`Tab`补全，减少录入错误。\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/X4JRekfNnozGrHQ.png\" width=\"80%\" />\n</center>\n\n等待几分钟就安装好了！\n\n### 分配共享数据空间(易出错，新手可以不做)\n\n为了方便虚拟机和宿主机之间的数据传输，我们可以为虚拟机设置一个和主机共享的“数据空间”。VBox为我们提供了这个功能。\n\n1. 在VBox主界面左侧选择刚刚创建好的虚拟机，点击上方的“设置”按钮，进入虚拟机配置界面。点击左侧“共享文件夹”按钮，在新窗口中任意选择一个本地文件夹作为共享文件夹。示例选择文件夹位置为C:\\rocshare，不要勾选“只读分配”。单击“确定”，并关闭设置窗口。\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030093638484-754721120.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030094135281-471357754.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030093648984-2094658791.png>)\n\n2. 启动Ubuntu，打开终端窗口。（注意空格！）\\\n   一个要点是：命令，文件名要通过`Tab`补全，这样就会减少录入错误。\n\n* 输入命令“sudo mkdir /mnt/shared”。回车后键入密码。\n* 继续输入命令“sudo mount –t vboxsf rocshare /mnt/shared\" //注意rocshare /mnt/shared 要跟据自己的情况修改\n* 输入命令“sudo gedit /etc/fstab”\n\n3. 在弹出的文本末尾添加一行下面的内容：\n\n* “rocshare /mnt/shared vboxsf rw,gid=100,uid=1000,auto 0 0”\n\n4. 现在打开/mnt/shared文件夹，就可以看到主机对应共享文件夹rocshare中的内容了。这就是宿主机和虚拟机之间的桥梁。\n\n比如我们在Ubuntu中用touch命令新建一个testtest的文件，到宿主机的c://rocshare中就能看到这个文件。\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030095516359-1565360436.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030095524640-2011954975.png>)\n\n5. 至此，虚拟机安装配置完成。\n\n## 配置Ubuntu\n\nUbuntu的使用可以参考[别出心裁的Linux命令学习法](http://www.cnblogs.com/rocedu/p/4902411.html).\n\n1. 通过`sudo apt-get update;sudo apt-get upgrade` 更新一下系统。\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030110713000-318570997.png>)\n\n2. 安装软件。Ubuntu中安装软件比较简单，使用`sudo apt-get install XXX`就可以安装XXX软件，比如我们常用的Vim,就可以用`sudo apt-get install Vim`来安装。\n\n![install vim](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030110919031-429532360.png>)\n\n注意：Ubuntu中使用到某个没有安装的软件时，会有贴心的提示，如上图。\n\n我们可以通过`apt-cache search XXXX`来查找软件库中有没有我们想要安装的软件。比如我们想看看有没有常用的调试工具cgdb,就可以使用`apt-cache search cgdb`来查找：\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030112106046-695358617.png>)\n\n找到后就可以通过`sudo apt-get install cgdb`来安装了。\n\n我们可以一次安装多个软件，比如`sudo apt-get install git ddd`就会安装分布式版本控制工具git和图形化调试工具ddd：\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030112525687-2083766394.png>)\n\n这提醒我们可以写个脚本简化软件的安装，你可以源源不断的把自己用的软件添加到这个脚本中，方便日后自己安装新系统：\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030113309812-1973136131.png>)\n\n![](<./基于VirtualBox安装(Ubuntu,openEuler)图文教程 - 娄老师 - 博客园_files/741560-20161030113321468-101934690.png>)\n\n我的安装脚本供大家能参考：\n\n```bash\n#!/bin/sh\n\n# update system\n\nsudo apt-get update\nsudo apt-get grade \nsudo apt-get autoremove\n\n# utilities\nsudo apt-get install krusader unace unrar zip unzip p7zip-full p7zip-rar sharutils rar uudeview mpack  arj cabextract file-roller\nsudo apt-get install apvlv biff bsdgames byobu calcurse curl dia dia2code dtach dump fbset filezilla  freemind gimp  htop iotop jhead ksnapshot multitail moreutils pandoc planner powertop putty python-pip retext rpm screen sniffit socat stardict tmux tpp tree  vlc vnc4server xvnc4viewer wireshark xchm xpdf tweak\n\n# cheat \nsudo pip install docopt pygments\ngit clone https://github.com/chrisallenlane/cheat.git\ncd cheat\nsudo python setup.py install  \n\n#vi \ncd ~/.vim/bundle\nwget http://www.vim.org/scripts/download_script.php?src_id=9679\n\n#java\nsudo apt-get install eclipse  eclipse-wtp eclipse-emf eclipse-gef netbeans  gaphor umbrello umlet\n\n#programming\nsudo apt-get install ascii automake bison bison-doc bluefish  cgdb clang cmake codeblocks codeblocks-dbg codeblocks-dev cscope cvs dia ddd doxygen doxygen-doc doxygen-gui dstat eclipse eclipse-cdt eclipse-cdt-qt  eclipse-cdt-valgrind eclipse-eclox eclipse-egit  eclipse-egit-mylyn eclipse-mylyn  exuberant-ctags flex fossil fp-compiler fp-ide  g++ gcc gdb  git gitk git-gui git-doc git-cvs git-svn git-sh gnustep groovy ifstat indent jedit jython  libncurses5-dev ncurses-doc libasound2-dev libasound2-doc manpages-posix manpages-posix-dev  nasm python-django python-django-doc qtcreator splint sqlite3 libsqlite3-dev sqlitebrowser sqliteman swig2.0 sysstat tcl8.5 tcl8.5-doc tk8.5 tk8.5-doc txt2tags python-pip qtcreator ruby1.9.3  qt4-qmake qtcreator jruby subversion tidy valgrind vim scala \n\n#security\nsudo apt-get install lib32z1 libc6-dev-i386     //64->32\nsudo apt-get install lib32readline-gplv2-dev\n```\n\n## 安装过程中遇到的问题\n### 界面显示不全\n      我们可以通过设置分辨率，所以未安装好之前我们可以通过终端修改分辨率来解决。\n1. `Ctrl+Alt+t`打开终端面板\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/V7dy4rNz5FXgsLC.png\" width=\"80%\" />\n</center>\n\n2. 输入`xrandr`然后回车，查看支持的所有分辨率。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/egZc47lbwQ1KmvE.png\" width=\"80%\" />\n</center>\n\n3. 选择其中一个比较大的分辨率，比如输入：`xrandr -s 1920x1080`，然后回车。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/dav6WrY2VbGHUu7.png\" width=\"80%\" />\n</center>\n\n4. 就可以解决问题了。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/Mn7kD9vlrHS4Z6E.png\" width=\"80%\" />\n</center>\n\n### 安装增强功能时【未能加载虚拟光盘】\n1. 进入系统在侧边找到如图加载的虚拟光驱，右击，点击弹出，然后就可正常安装增强功能了。\n<center>\n<img src=\"https://s2.loli.net/2024/12/07/tfUlRFo97yDsOjI.png\" width=\"80%\" />\n</center>\n\n\n1. 终端依次输入。\n```BASH\nsudo apt-get update\nsudo apt-get install build-essential gcc make perl dkms\nreboot\n```","tags":["教程","VirtualBox","Ubuntu"]},{"title":"MiniMIPS32","url":"/post/dc2fe057.html","content":"## 指令集仿真器 -- TEMU\n### 实验简介\n采用高级语言（C/C++、Java或Python等）设计面向32位MIPS或LoongArch指令集子集的指令集仿真器 -- TEMU，用于实现对程序执行过程的模拟和调试。该指令集仿真器可模拟常见指令，支持单步执行、断点、显示寄存器信息、显示特定存储单元信息等功能，为后续的处理器设计实验提供仿真测试工具。","tags":["MiniMIPS32"]},{"title":"数值计算方法","url":"/post/298117e1.html","content":"## 插值法\n**实现范德蒙德多项式插值、拉格朗日插值、牛顿插值、分段线性、分段三次 Hermite 插值，并完成各方法之间的对比。**\n<font color=red>输入</font>：插值区间 $[a, b]$，参数 $c, d, e, f$ 作为标准函数 $f(x) = c \\cdot \\sin dx + e \\cdot \\cos fx$ 的值，参数 $n+1$ 作为采样点的个数，参数 $m$ 作为实验点的个数。\n<font color=red>要求</font>：在区间 $[a, b]$ 上均匀采集个采集点，利用这 $n+1$ 个采集点，分别使用范德蒙德多项式插值、拉格朗日插值、牛顿插值、分段线性、分段三次 Hermite 插值进行插值，求出 $L(x)$，之后再选取 $m$ 个点作为实验点，计算在这 $m$ 个实验点上插值函数 $L(x)$ 与目标函数 $f(x)$ 的平均误差。同时对比各插值方法之间的精度差异。\n<font color=red>输出</font>：对比函数曲线，平均误差。\n```Python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 范德蒙德多项式插值\ndef vandermonde_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    c = []\n    for i in range(n):\n        coeff = []\n        for j in range(n):\n            coeff.append(x[i]**j)\n        coefficients.append(coeff)\n        c.append(y[i])\n    A = np.array(coefficients)\n    inv_A = np.linalg.inv(A)\n    a = inv_A.dot(c)\n    sum = 0\n    for i in range(n):\n        sum += a[i] * x_values ** i\n    return sum\n\n# 拉格朗日插值\ndef lagrange_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n):\n        p = y[i]\n        for j in range(n):\n            if j != i:\n                p *= (x_values - x[j]) / (x[i] - x[j])\n        result += p\n    return result\n\n# 牛顿插值\ndef newton_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    for i in range(n-1, 0, -1):\n        divided_diff = (y[i] - y[i-1]) / (x[i] - x[i-1])\n        coefficients.append(divided_diff)\n        for j in range(n-i-1, 0, -1):\n            divided_diff = (-divided_diff + coefficients[j-1]) / (x[n-j] - x[i-1])\n            coefficients[j-1] = divided_diff\n    coefficients.append(y[0])\n    result = coefficients[0]\n    for i in range(n-2, -1, -1):\n        result = result * (x_values - x[i]) + coefficients[n-1-i]\n    return result\n\n# 分段线性插值\ndef piecewise_linear_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        mask = (x[i] <= x_values) & (x_values < x[i+1])\n        slope = (y[i+1] - y[i]) / (x[i+1] - x[i])\n        result += ((y[i] + slope * (x_values - x[i]))*mask)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# 分段三次Hermite插值\ndef piecewise_cubic_hermite_interpolation(x, y, yy, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        if ((x[i] <= x_values) & (x_values < x[i+1])):\n            ai = (1+2*(x_values-x[i])/(x[i+1]-x[i]))*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            bi = (x_values - x[i])*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            ai1 = (1+2*(x_values-x[i+1])/(x[i]-x[i+1]))*((x_values-x[i])/(x[i+1]-x[i]))**2\n            bi1 = (x_values - x[i+1])*((x_values-x[i])/(x[i+1]-x[i]))**2\n            result += (y[i] * ai +yy[i] * bi +y[i+1] * ai1 +yy[i+1] * bi1)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# 目标函数\ndef target_function(c,d,e,f,x):\n    return [(c*np.sin(d*val)+e*np.cos(f*val)) for val in x] \n\n# 目标函数导函数\ndef derivative_function(c,d,e,f,x):\n    return [(c*d*np.cos(d*val)-e*f*np.sin(f*val)) for val in x]\n\n# 计算平均误差\ndef compute_average_error(f, g, x_values):\n    return sum([abs(f[i] - g[i]) for i in range(len(x_values))]) / len(x_values)\n\n# 设置插值区间和参数\na = float(input())\nb = float(input())\nc = float(input())\nd = float(input())\ne = float(input())\nf = float(input())\nnum_samples = int(input())\nnum_experiments = int(input())\nx_values = [a + (b - a) * i / (num_samples - 1) for i in range(num_samples)]\nys = target_function(c,d,e,f,x_values)\nyy = derivative_function(c,d,e,f,x_values)\n\n# 计算实验点\nexperiment_points = [a + (b - a) * i / (num_experiments - 1) for i in range(num_experiments)]\n\n# 计算各插值方法的插值结果和平均误差\nvandermonde_interpolated = [vandermonde_interpolation(x_values, ys, val) for val in experiment_points]\nvandermonde_error = compute_average_error(target_function(c,d,e,f,experiment_points), vandermonde_interpolated, experiment_points)\n\nlagrange_interpolated = [lagrange_interpolation(x_values, ys, val) for val in experiment_points]\nlagrange_error = compute_average_error(target_function(c,d,e,f,experiment_points), lagrange_interpolated, experiment_points)\n\nnewton_interpolated = [newton_interpolation(x_values, ys, val) for val in experiment_points]\nnewton_error = compute_average_error(target_function(c,d,e,f,experiment_points), newton_interpolated, experiment_points)\n\npiecewise_linear_interpolated = [piecewise_linear_interpolation(x_values, ys, val) for val in experiment_points]\npiecewise_linear_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_linear_interpolated, experiment_points)\n\npiecewise_cubic_hermite_interpolated = [piecewise_cubic_hermite_interpolation(x_values, ys, yy, val) for val in experiment_points]\npiecewise_cubic_hermite_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_cubic_hermite_interpolated, experiment_points)\n\nfig = plt.figure(num = 1,dpi = 120)\nax = plt.subplot(1,1,1)\n # 坐标轴\nax = plt.gca()  # get current axis 获得坐标轴对象\nax.spines['right'].set_color('none')  # 将右边 边沿线颜色设置为空 其实就相当于抹掉这条边\nax.spines['top'].set_color('none')\nax.xaxis.set_ticks_position('bottom')\nax.yaxis.set_ticks_position('left')\n# 设置中心的为（0，0）的坐标轴\nax.spines['bottom'].set_position(('data', 0))  # 指定 data 设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上\nax.spines['left'].set_position(('data', 0))\n\nx=list(np.arange(a,b,0.01))#此处可调整自变量取值范围，以便选择合适的观察尺度\ny=[]\ny1=[]\ny2=[]\ny3=[]\ny4=[]\ny5=[]\nfor i in range(len(x)):\n    y = target_function(c,d,e,f,x)\n    y1.append(vandermonde_interpolation(x_values, ys, x[i]))\n    y2.append(lagrange_interpolation(x_values, ys, x[i]))\n    y3.append(newton_interpolation(x_values, ys, x[i]))\n    y4.append(piecewise_linear_interpolation(x_values, ys, x[i]))\n    y5.append(piecewise_cubic_hermite_interpolation(x_values, ys, yy, x[i]))\n    \n\nax.plot(x,y,label = \"Target Function\",color =\"blueviolet\")\nax.plot(x_values,ys, marker = \"*\",linestyle = \"\", color = \"blueviolet\")\nax.plot(x,y1,label = \"vandermonde interpolation\\n average error=%f\"%vandermonde_error,color =\"red\")\nax.plot(experiment_points, vandermonde_interpolated, marker = \"o\",linestyle = \"\", color = \"red\")\nax.plot(x,y2,label = \"lagrange interpolation\\n average error=%f\"%lagrange_error,color =\"yellow\")\nax.plot(experiment_points, lagrange_interpolated, marker = \"o\",linestyle = \"\", color = \"yellow\")\nax.plot(x,y3,label = \"newton interpolation\\n average error=%f\"%newton_error,color =\"green\")\nax.plot(experiment_points, newton_interpolated, marker = \"o\",linestyle = \"\", color = \"green\")\nax.plot(x,y4,label = \"piecewise linear interpolation\\n average error=%f\"%piecewise_linear_error,color =\"blue\")\nax.plot(experiment_points, piecewise_linear_interpolated, marker = \"o\",linestyle = \"\", color = \"blue\")\nax.plot(x,y5,label = \"piecewise cubic hermite interpolation\\n average error=%f\"%piecewise_cubic_hermite_error,color =\"purple\")\nax.plot(experiment_points, piecewise_cubic_hermite_interpolated, marker = \"o\",linestyle = \"\", color = \"purple\")\n#ax.set_xlim(0,2)\n#plt.draw()\nplt.legend()\nplt.show()\n```\n\n## 函数逼近\n**实现最佳平方逼近与最小二乘拟合，并完成两种方法之间的对比。**\n<font color=red>输入</font>：函数区间 $[a, b]$，参数 $c$ 作为标准函数$f(x)=\\frac{1}{1+cx^2}$的值，参数 $k$ 作为所构造的逼近多项式的次数 $(k=1,2,3)$ 。参数 $n+1$ 作为采样点的个数，参数 $m$ 作为实验点的个数。\n<font color=red>要求</font>：要求选用勒让德正交多项式作最佳平方逼近；在区间 $[a, b]$ 上均匀采集 $n$ 个采集点，利用这 $n+1$ 个采集点，计算采集点上的函数值，构造最小二乘拟合多项式函数。之后再选取 $m$ 个点作为实验点，计算在这 $m$ 个实验点上所构造的逼近函数与给定的目标函数 $f(x)$ 的平均误差。同时对比两种逼近方法之间的精度差异。\n<font color=red>输出</font>：对比函数曲线，平均误差。\n```Python\nfrom sympy import *\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.rcParams['font.sans-serif']=['SimHei']\nplt.rcParams['axes.unicode_minus'] = False\ndef qpow(a,n):\n    ans=1\n    while n!=0:\n        if n&1:\n            ans*=a\n        a*=a\n        n>>=1\n    return ans\ndef F(x):\n    res = 1/(1+c*x*x)\n    return res\ndef cntpf():\n    t = symbols('t')\n    # (b-a)*t/2+(b+a)/2\n    fp[0] = integrate(1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2)),(t, -1, 1)).evalf()\n    fp[1] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (t),(t, -1, 1)).evalf()\n    fp[2] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (3 * t * t / 2 - 1 / 2),(t, -1, 1)).evalf()\n    fp[3] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (5 * t * t * t / 2 - 3 * t / 2),(t, -1, 1)).evalf()\ndef bsa(inp):\n    res=0\n    inp =(2 * inp -a - b) / (b - a)\n    for i in range(0,k):\n        res+=(2*i+1)*fp[i]*qpow(inp,i)/2\n    return res\ndef setup():\n    for i in range(0,100):\n        vispa[i]=0\n        vispb[i]=0\ndef initx():\n    d=(b-a)/n\n    x[0]=a\n    for i in range(1,n):\n        x[i]=x[i-1]+d\ndef compa(i):\n    if vispa[i]==1:\n        return  pa[i]\n    up=0\n    down=0\n    for j in range(0,n):\n        up+=comP(i-1,x[j])*comP(i-1,x[j])*x[j]\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispa[i] = 1\n    pa[i] = res\n    return res\ndef compb(i):\n    if vispb[i]==1:\n        return pb[i]\n    up = 0\n    down = 0\n    for j in range(0, n):\n        up += comP(i, x[j]) * comP(i, x[j])\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispb[i] = 1\n    pb[i] = res\n    return res\ndef comP(i,inp):\n    res=0\n    if i==0:\n        res=1\n    elif i==1:\n        res = (inp -compa(1))*comP(0, inp)\n    else:\n        res = (inp -compa(i))*comP(i - 1, inp)-compb(i - 1) * comP(i - 2, inp)\n\n    return res\ndef lsf(inp):\n    initx()\n    res=0\n    for i in range(0,k):\n        up=0\n        down=0\n        for j in range(0,n):\n            up += F(x[j]) * comP(i, x[j])\n            down += comP(i, x[j]) * comP(i, x[j])\n        res += comP(i, inp)*up / down\n    return res\ndef bsaerror(inp):\n    return abs(bsa(inp)-F(inp))\ndef lsferror(inp):\n    return abs(lsf(inp)-F(inp))\n\n#全局变量\nx=[None]*200\nfp=[None]*50\nvispa=[0]*100\nvispb=[0]*100\npa=[None]*200\npb=[None]*200\n\n#主函数段\na, b, c = map(int, input(\"输入a,b,c: \").split())\nn , k = map(int, input(\"输入n,k: \").split())\nm=input(\"请输入测试组数：\")\ntst = input(\"请输入测试用例：\").split()\n\nsetup() #初始化fp数组\ncntpf() #初始化fp数组\n\nbsax=range(int(a),int(b))\nbsay=[]\nbsae=0\nfor i in bsax:\n    bsay.append(bsa(i))\n    \nlsfx=range(int(a),int(b))\nlsfy=[]\nlsfe=0\nfor i in lsfx:\n    lsfy.append(lsf(i))\n    \nnx=range(int(a),int(b))\nny=[]\nfor i in nx:\n    ny.append(F(i))\n    \nfor i in tst:\n    bsae+=bsaerror(float(i))\n    lsfe+=lsferror(float(i))\nbsae/=float(m)\nlsfe/=float(m)\nprint('最佳平方逼近的平均误差为%f'%bsae)\nprint('最小二乘拟合的平均误差为%f'%lsfe)\nplt.plot(bsax, bsay, label='最佳平方逼近', color='red')\nplt.plot(lsfx, lsfy, label='最小二乘拟合', color='blue')\nplt.plot(nx, ny, label='原函数', color='orange')\nplt.legend()\nplt.title('函数逼近对比函数')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n```\n\n## 数值积分\n**实现复化梯形公式和龙贝格算法计算积分，并完成两种方法之间的精度对比。**\n<font color=red>输入</font>：函数区间 $[a, b]$，被积函数为 $f(x) =\\sqrt{x}lnx$，参数 $h$ 作为步长。参数 $ε$ 作为要求满足的精度条件。\n<font color=red>要求</font>：取不同的步长 $h$，要求用复化梯形公式和龙贝格算法分别计算积分值计算当精度达到 $ε$ 时，所需要等分积分区间的次数（假设每次都是二等分）及 $h$ 的大小。当达到精度要求时，对比两种方法需要划分次数及步长 $h$ 的大小。\n<font color=red>输出</font>：数值积分计算结果，划分次数，步长 $h$ 的大小。\n```Python\nimport math\n#初始化变量\nvis = [[0 for i in range(1000)] for j in range(1000)]\nT = [[0 for i in range(1000)] for j in range(1000)]\n\ndef f(x):\n    res=math.sqrt(x)*math.log(x,math.e)\n    return res\n\ndef F(x):\n    x3=x*x*x\n    res=2*math.log(x,math.e)*math.sqrt(x3)/3-4*math.sqrt(x3)/9\n    return res\n\n#使用牛顿莱布尼茨公式直接积分\ndef Fitg(a,b):\n    res=F(b)-F(a)\n    return  res\n\n#使用复合梯形求积公式直接积分\ndef ctqf(n):\n    h=(b-a)/n\n    res=0\n    for k in range(n):\n        res+=f(a+k*h)+f(a+(k+1)*h)\n    res=res*h/2\n    return res\n\n#计算T的值\ndef cntT(m,k):\n    if(vis[m][k]==1):\n        return T[m][k]\n    else:\n        vis[m][k] == 1\n        if(m==0 and k==0):\n            T[m][k]=(b-a)*(f(a)+f(b))/2\n        elif(m==0):\n            n=1<<(k-1)\n            h=(b-a)/n\n            sm=0\n            for i in range(n):\n                sm+=f(a+(2*i+1)*h/2)\n            sm=sm*h/2\n            T[m][k]=cntT(m,k-1)/2+sm\n        else:\n            fourm=math.pow(4,m)\n            T[m][k]=fourm*cntT(m-1,k+1)/(fourm-1)-cntT(m-1,k)/(fourm-1)\n    return T[m][k]\n\n#使用龙贝格积分求积\ndef Romberg(m):\n    return cntT(m,0)\n\na,b =map(float,input(\"请输入积分区间a,b: \").split())\ne=float(input(\"请输入精度条件e: \"))\n\nfor k in range(1000):\n    n=1<<k\n    eps=abs(ctqf(n)-Fitg(a,b))\n    if(eps<e):\n        h=(b-a)/n\n        print('复合梯形求积公式的计算结果为：%f'%(ctqf(n)))\n        print('划分次数为：%d'%(k))\n        print('步长为：%f' % (h))\n        break\n\nfor k in range(1,1000):\n    n=1<<k\n    eps=abs(Romberg(k)-Romberg(k-1))\n    if(eps<e):\n        h=(b-a)/n\n        print('龙贝格求积公式的计算结果为：%f'%(Romberg(k)))\n        print('划分次数为：%d'%(k))\n        print('步长为：%f' % (h))\n        break\n```\n\n## 线性方程组的直接解法\n**1. 编写列主元消元法的通用程序。**\n<font color=red>输入</font>：矩阵 $A$ 和向量 $b$。\n<font color=red>输出</font>：消元后的增广矩阵及方程 $Ax=b$ 的根值 $x^*$。\n<font color=red>要求1</font>：选取进行测试，打印出上述程序的输出。\n<font color=red>要求2</font>：随机生成 $n$ 阶（$n$>=20，具体值自定）方阵 $A$，$n*1$ 维非零向量 $b$，求解 $x$。\n\n**2. 编写使用LU分解法求解线性方程组的通用程序。**\n<font color=red>输入</font>：矩阵 $A$ 和向量 $b$。\n<font color=red>输出</font>：对矩阵 $A$ 进行 $LU$ 分解后的 $L$ 和 $U$，以及方程组的根值 $x^*$。  \n<font color=red>要求1</font>：选取进行测试，打印输出结果。\n<font color=red>要求2</font>：随机生成 $n$ 阶（$n$>=20，具体值自定）方阵 $A$，$n*1$ 维非零向量 $b$，求解 $x$。\n```C++\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include <random>\n\nusing namespace std;\nint n;\nconst int maxn=200;\ndouble inA[maxn][maxn];\ndouble A[maxn][maxn];\ndouble L[maxn][maxn];\ndouble U[maxn][maxn];\ndouble ans[maxn];\ndouble ansy[maxn];\nvoid Pivot();//列主元消元法\nvoid copyA();//将输入矩阵复制给A\nvoid printA();//打印矩阵A\nvoid printb();//打印向量b\nvoid exc(int i,int j);//交换行\nvoid Minus(int i,int j,double mult);//第j行减第i行\nvoid printans();//打印答案\nvoid LU();//LU分解法\nvoid iscorrect();//回代判断答案是否正确\ndouble gerandom(double a,double b);//生成a到bdouble类型的随机数\nint main(){\n    int T;\n     cout<<\"please input T :\";\n     cin>>T;\n     while (T--)\n     {\n         cout << \"please input n :\";\n         cin >> n;\n         cout << \"enter 1 if you want to use your own input or 2 if you want your input to be random\"<<endl;\n         int cho;\n         cin>>cho;\n         if (cho == 1)\n         {\n             cout << \"please input matrix A :\" << endl;\n             for (int i = 1; i <= n; i++)\n             {\n                 for (int j = 1; j <= n; j++)\n                 {\n                     cin >> inA[i][j];\n                 }\n             }\n             cout << \"please input vector b :\" << endl;\n             for (int i = 1; i <= n; i++)\n             {\n                 cin >> inA[i][n + 1];\n             }\n         }\n         else{\n            double a,b;\n            cout << \"please input the range of the random number :\" << endl;\n            cin>>a>>b;\n            for (int i = 1; i <= n; i++)\n             {\n                 for (int j = 1; j <= n; j++)\n                 {\n                    inA[i][j]=gerandom(a,b);\n                 }\n             }\n             for (int i = 1; i <= n; i++)\n             {\n                inA[i][n + 1]=gerandom(a,b);\n             }\n         }\n         cout << \"enter 1-Pivot or 2-LU:\" << endl;\n         cin>>cho;\n         if(cho==1){\n            Pivot();\n         }\n         else{\n            LU();\n         }\n         printans();\n         iscorrect();\n     }\n    return 0;\n}\nvoid printA(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cout<<inA[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n}\nvoid copyA(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n+1;j++){\n            A[i][j]=inA[i][j];\n        }\n    }\n}\nvoid exc(int i,int j){\n    for(int k=1;k<=n+1;k++){\n        swap(A[i][k],A[j][k]);\n    }\n}\nvoid Minus(int i,int j,double mult){\n    for(int k=1;k<=n+1;k++){\n        A[j][k]-=A[i][k]*mult;\n    }\n}\nvoid printans(){\n    for(int i=1;i<=n;i++){\n        cout<<ans[i]<<\" \";\n    }\n    cout<<endl;\n}\nvoid Pivot(){\n    copyA();\n    for(int t=1;t<=n-1;t++){\n        double nman=0;\n        int maxi=0;\n        for(int i=t;i<=n;i++){\n            double tp=abs(A[i][t]);\n            if(tp>=nman){\n                maxi=i;\n                nman=tp;\n            }\n        }\n        exc(t,maxi);\n        for(int i=t+1;i<=n;i++){\n            double multi=A[i][t]/A[t][t];\n            Minus(t,i,multi);\n        }\n    }\n    for(int t=n;t>=1;t--){\n        double right=A[t][n+1];\n        for(int j=n;j>t;j--){\n            right-=A[t][j]*ans[j];\n        }\n        ans[t]=right/A[t][t];\n    }\n}\nvoid iscorrect(){\n    int tag=1;\n    for(int i=1;i<=n;i++){\n        double myans=0;\n        for(int j=1;j<=n;j++){\n            myans+=inA[i][j]*ans[j];\n        }\n        if(abs(myans-inA[i][n+1])>=1e-4){\n            tag=0;\n        }\n    }\n    if(tag){\n        cout<<\"answer is correct!\"<<endl;\n    }\n    else{\n        cout<<\"answer is wrong!\"<<endl;\n    }\n}\nvoid LU(){\n    copyA();\n    for(int i=1;i<=n;i++){\n        U[1][i]=A[1][i];\n        L[i][i]=1;\n    }\n    for(int i=2;i<=n;i++){\n        L[i][1]=A[i][1]/U[1][1];\n    }\n    for(int r=2;r<=n;r++){\n        for(int i=r;i<=n;i++){\n            double tplu=0;\n            for(int k=1;k<=r-1;k++){\n                tplu+=L[r][k]*U[k][i];\n            }\n            U[r][i]=A[r][i]-tplu;\n        }\n        if(r!=n){\n            for(int i=r+1;i<=n;i++){\n                double tplu=0;\n                for(int k=1;k<=r-1;k++){\n                    tplu+=L[i][k]*U[k][r];\n                }\n                L[i][r]=(A[i][r]-tplu)/U[r][r];\n            }\n        }\n    }\n    ansy[1]=A[1][n+1];\n    for(int i=2;i<=n;i++){\n        double tply=0;\n        for(int k=1;k<=i-1;k++){\n            tply+=L[i][k]*ansy[k];\n        }\n        ansy[i]=A[i][n+1]-tply;\n    }\n    ans[n]=ansy[n]/U[n][n];\n    for(int i=n-1;i>=1;i--){\n        double tpux=0;\n        for(int k=i+1;k<=n;k++){\n            tpux+=U[i][k]*ans[k];\n        }\n        ans[i]=(ansy[i]-tpux)/U[i][i];\n    }\n}\ndouble gerandom(double a,double b){\n    static random_device rd;\n    static mt19937 gen(rd());\n    uniform_real_distribution<double> dis(a, b);\n    return dis(gen);\n}\n```\n\n## 线性方程组的迭代解法\n**1. 编写高斯-塞德尔迭代和SOR迭代的通用程序。**\n<font color=red>输入</font>：矩阵A和向量b，迭代初值x0，迭代最大步数K，误差控制。对于超松弛迭代，还需输入松弛因子。\n<font color=red>输出</font>：迭代步数及方程 $Ax=b$ 的根值 $x^*$。\n<font color=red>要求</font>：\n(1)选取进行测试，取初值x<sup>(0)</sup>=0，误差控制=10<sup>-8</sup>，打印出两种迭代方法的输出。\n(2)取松弛因子 $=\\frac{i}{50}$，$i$=1,2,...99,打印迭代步数，并给出一个最佳值。\n```C++\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int maxn = 1000;\ndouble a[maxn][maxn];\ndouble b[maxn];\ndouble xk[maxn];\ndouble xk1[maxn];\nint n;\nint K;\ndouble w;\ndouble eps;\ndouble mf;\ndouble nstep;\nvoid setxk0();//初始化xk0\nvoid movk();//将xk1赋值给xk\ndouble cntloss();//计算detx\nvoid SOR(double w);//超松弛迭代法\nvoid printx();//打印x\nvoid iscorrect();//回代验证答案是否正确\nint main(){\n    cout<<\"input max step K : \";\n    cin>>K;\n    cout<<\"input eps  : \";\n    cin>>eps;\n    cout<<\"input the size of A  : \";\n    cin>>n;\n    cout<<\"matrix A :\"<<endl;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>a[i][j];\n        }\n    }\n    cout<<\"vector b :\"<<endl;\n    for(int i=1;i<=n;i++){\n        cin>>b[i];\n    }\n    cout<<\"enter 1 if you want to test one w\"<<endl;\n    cout<<\"or 2 if you want to find the best w\"<<endl;\n    cout<<\"enter : \";\n    cin>>mf;\n    if(mf==1){\n        cout<<\"input Relaxation factor w  : \";\n        cin>>w;\n        SOR(w);\n        printx();\n        iscorrect();\n    }\n    else{\n        int bst=K+1;\n        double bsw=0;\n        for(int i=1;i<=99;i++){\n            double ii = (double)i;\n            double nw=ii/(double)50;\n            cout<<\"now i is \"<<i<<endl;\n            SOR(nw);\n            if(nstep<bst){\n                bst = nstep;\n                bsw=nw;\n            }\n        }\n        cout<<\"the best w is \"<<bsw<<endl;\n    }\n    \n    return 0;\n}\nvoid setxk0(){\n    for(int i=1;i<=n;i++){\n        xk[i]=0;\n    }\n}\nvoid movk(){\n    for(int i=1;i<=n;i++){\n        xk[i]=xk1[i];\n    }\n}\ndouble cntloss(){\n    double res = 0;\n    for(int i=1;i<=n;i++){\n        double tp = abs(xk1[i]-xk[i]);\n        if(tp>res){\n            res = tp;\n        }\n    }\n    return res;\n}\nvoid printx(){\n    for(int i=1;i<=n;i++){\n        cout<<xk1[i]<<\" \";\n    }\n    cout<<endl;\n}\nvoid iscorrect(){\n    int flag = 1;\n    for(int i=1;i<=n;i++){\n        double s=0;\n        for(int j=1;j<=n;j++){\n            s+=a[i][j]*xk1[j];\n        }\n        if(abs(s-b[i])>1e-3){\n            flag=0;\n        }\n    }\n    if(flag){\n        cout<<\"answer is correct!\"<<endl;\n    }\n    else{\n        cout<<\"answer is wrong!\"<<endl;\n    }\n}\nvoid SOR(double w){\n    setxk0();\n    for(int step=1;step<=K;step++){\n        for(int i=1;i<=n;i++){\n            double s1 = 0;\n            double s2 = 0;\n            for(int j=1;j<=i-1;j++){\n                s1+=a[i][j]*xk1[j];\n            }\n            for(int j=i;j<=n;j++){\n                s2+=a[i][j]*xk[j];\n            }\n            xk1[i]=xk[i]+w*(b[i]-s1-s2)/a[i][i];\n        }\n        if(cntloss()<eps){\n            if(mf==2){\n                nstep = step;\n                cout<<\"the step is \"<<step<<endl;\n            }\n            break;\n        }\n        else{\n            movk();\n        }\n    }\n}\n```\n\n## 非线性方程（组）的数值解法\n**1. 编写不动点迭代、斯特芬森加速迭代和牛顿迭代的通用程序。**\n<font color=red>要求</font>：\n(1)设计一种不动点迭代格式，求解函数 $f(x)=x^2-3x+2-e^x$ 和 $g(x)=x^3+2x^2+10x-20$ 的根，要求该迭代格式收敛。然后再使用斯特芬森加速迭代，计算到 |x<sub>k</sub>-x<sub>k-1</sub>|<10<sup>-8</sup> 为止。\n(2)用牛顿迭代，同样计算到 |x<sub>k</sub>-x<sub>k-1</sub>|<10<sup>-8</sup> 。输出迭代初值、迭代次数及各次迭代值，比较方法优劣。\n```Python\n\n```\n**2. 本章计算实习题3。**\n```Python\n\n```","tags":["Python","数值计算方法","实验记录"]},{"title":"图论算法做题总结","url":"/post/ebf888f5.html"},{"title":"单调栈做题总结","url":"/post/ae5bbdb8.html","content":"# 基础\n## 每日温度\n```C++\n/***** 找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n=temperatures.size();\n        vector<int> ans(n);\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&temperatures[s.top()]<temperatures[i]){ //栈中维护下标写法\n                ans[s.top()]=i-s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        return ans;\n    }\n};\n```\n## 商品折扣后的最终价格\n```C++\n/***** 找后面第一个小于等于 *****/\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n=prices.size();\n        vector<int> ans(n);\n \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&prices[s.top()]>=prices[i]){\n                ans[s.top()]=prices[s.top()]-prices[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n        \n        while(!s.empty()){\n            ans[s.top()]=prices[s.top()];\n            s.pop();\n        }\n        return ans;\n    }\n};\n```\n## 下一个更大元素 I\n```C++\n/***** 找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        unordered_map<int,int> hashmap;\n        \n        //处理nums2\n        stack<int> s;\n        for(int i=0;i<nums2.size();i++){\n            while(!s.empty()&&nums2[s.top()]<nums2[i]){\n                int temp=nums2[s.top()];\n                hashmap[temp]=nums2[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        for(int i=0;i<nums1.size();i++){\n            int temp=nums1[i];\n            if(hashmap[temp]) ans[i]=hashmap[temp];\n            else ans[i]=-1;\n        }\n        return ans;\n    }\n};\n```\n## 下一个更大元素 II\n```C++\n/***** 循环找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> ans(n,-1);\n \n        stack<int> s;\n        for(int i=0;i<2*n-1;i++){\n            while(!s.empty()&&nums[s.top()]<nums[i%n]){\n                ans[s.top()]=nums[i%n];\n                s.pop();\n            }\n            s.push(i%n);\n        }\n        \n        return ans;\n    }\n};\n```\n## 最大宽度坡\n```C++\n/*单调递减栈*/\nclass Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        stack<int> s;\n        int n = nums.size();\n        for (int i = 0;i < n;i++) {\n            if (s.empty() || nums[s.top()] > nums[i]) {//要把第一个数据push\n                s.push(i);\n            }\n        }\n        int ans = 0;\n        for (int i = n - 1;i >= 0;i--) {\n            while (!s.empty() && nums[s.top()]<=nums[i]) {\n                ans = max(ans,i - s.top());\n                s.pop();\n            }\n        }\n        return ans;\n    }\n};\n```\n## 车队\n```C++\n/***** 排序+单调栈 *****/\n/***** 根据位置由小到大排序，位置大的左侧（位置小）的时间不应更小等->（严格）单调递减栈 *****/\nclass Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        map<int,int> ps; //自动排序\n        for(int i=0;i<position.size();i++){\n            ps[position[i]]=speed[i];\n        }\n\n        stack<double> s;\n        for(auto& [pos,spd]:ps){\n            double time=double(target-pos)/spd;\n            while(!s.empty()&&s.top()<=time){\n                s.pop();\n            }\n            s.push(time);\n        }\n        return s.size();\n    }\n};\n```\n# 矩形面积（完结）\n## 柱状图中最大的矩形\n```C++\n/***** 单调栈的其中一种写法---处理栈中元素 *****/\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> left(n,-1), right(n,n); //左边第一个小的位置、右边第一个小的位置\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){ //处理右边\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tright[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n \n        s = stack<int> (); //清空栈\n        for(int i=n-1;i>=0;i--){ //处理左边\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tleft[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);\n        }\n        return ans;\n    }\n};\n```\n## 好子数组的最大分数\n```C++\n/***** 单调栈的另一种写法---处理当前元素 *****/\nclass Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> left(n,-1),right(n,n); //左边第一小的编号、右边第一小的编号\n \n        stack<int> s;\n        for(int i=0;i<n;i++){ //处理左边\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) left[i]=s.top();\n            s.push(i);\n        }\n \n        s=stack<int> ();\n        for(int i=n-1;i>=0;i--){ //处理右边\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) right[i]=s.top();\n            s.push(i);\n        }\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            int h=nums[i],l=left[i],r=right[i];\n            if(l<k&&r>k){ //多了一个区间判断\n                ans=max(ans,h*(r-l-1));\n            }\n        }\n        return ans;\n    }   \n};\n```\n## 最大矩形\n```C++\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int n=matrix.size(); //行数\n        int m=matrix[0].size(); //列数\n        vector<vector<int>> left(n,vector<int>(m,0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(matrix[i][j]=='1'){\n                    left[i][j]=(j==0?1:left[i][j-1]+1); //往左能够延申的最大长度\n                }\n            }\n        }\n        int ret=0;\n \n        //对于每一列，使用基于柱状图求最大矩形的方法\n        for(int j=0;j<m;j++){\n            vector<int> up(n,0),down(n,0);\n \n            stack<int> s;\n            for(int i=0;i<n;i++){ \n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                up[i]=s.empty()?-1:s.top(); //上边第一个小于的编号\n                s.push(i);\n            }\n            s=stack<int>();//清空栈\n            for(int i=n-1;i>=0;i--){\n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                down[i]=s.empty()?n:s.top(); //下边第一个小于的编号\n                s.push(i);\n            }\n            \n            for(int i=0;i<n;i++){\n                int width=down[i]-up[i]-1;\n                int area=width*left[i][j];\n                ret=max(ret,area);\n            }\n        }\n \n        return ret;\n    }\n};\n```\n## 统计全 1 子矩形\n```C++\nclass Solution {\npublic:\n    int numSubmat(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<int> height(m);\n \n        /*单调栈求左右更小值(同时处理)*/\n        auto calc=[&]()->int{\n            vector<int> left(m,-1),right(m,m);\n \n            stack<int> s;\n            for(int i=0;i<m;i++){\n                while(!s.empty()&&height[s.top()]>height[i]){\n                    right[s.top()]=i;\n                    s.pop();\n                }\n                if(!s.empty()){\n                    left[i]=s.top();\n                }\n                s.push(i);\n            }\n \n            int ans=0;\n            /* 计算结果时, 乘法原理 * 矩阵高度 */\n            for(int i=0;i<m;i++){\n                ans+=(right[i]-i)*(i-left[i])*height[i];\n            }\n            return ans;\n        };\n \n        int ans=0;\n        for(int i=0;i<n;i++){ /* 遍历每一行的高度, 更新改行的高度值使用单调栈计算左侧更小值和右侧更小值,再计算每个小矩阵出现的次数*/\n            for(int j=0;j<m;j++){\n                if(mat[i][j]==0){\n                    height[j]=0;\n                }\n                else{\n                    height[j]++;\n                }\n            }\n            ans+=calc();\n        }\n        return ans;\n    }\n};\n```\n## 接雨水\n```C++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans=0;\n        int n=height.size();\n\n        stack<int> s;\n        for (int i=0;i<n;i++) {\n            while (!s.empty() && height[s.top()]<height[i]) {\n                int top = s.top();\n                s.pop();\n                if (s.empty()) {\n                    break;\n                }\n                int left = s.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            s.push(i);\n        }\n        \n        return ans;\n    }\n};\n/***** 不能单纯找左边第一个大、右边第一个大 *****/\n/*这种情况会多算\n*   *\n** **\n** **\n*****\n*/\n```\n# 最小字典序\n## 移掉 K 位数字\n","tags":["编程","单调栈","c++"]},{"title":"动态规划做题总结","url":"/post/35c38ce3.html","content":"# 入门 DP\n## 爬楼梯\n### 爬楼梯\n```C\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> f(n+1);     \n        f[0]=1,f[1]=1;\n        for(int i=2;i<=n;i++){\n            f[i]=f[i-1]+f[i-2];\n        }\n        return f[n];\n    }\n};\n/*由于这里的 f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)*/\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; i++) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n```\n### 使用最小花费爬楼梯\n```C\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n + 1);\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[n];\n    }\n};\n```\n### 组合总和 Ⅳ\n```C\n/*本质是爬楼梯，相当于每次往上爬 nums[i] 步*/\nclass Solution {\npublic:\n    long long combinationSum4(vector<int>& nums, int target) {\n        vector<long long> dp(target + 1);\n        dp[0] = 1; //只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。\n        for (int i = 1; i <= target; i++) {\n            for (int& num : nums) {\n                if (num <= i&& dp[i - num] < INT_MAX - dp[i]) {\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n        return dp[target];\n    }\n};\n/*另一种写法*/\nclass Solution {\npublic:\n    int combinationSum4(vector<int> &nums, int target) {\n        // 使用 unsigned 可以让溢出不报错\n        // 对于溢出的数据，不会影响答案的正确性（题目保证）\n        vector<unsigned> f(target + 1);\n        f[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int x : nums) {\n                if (x <= i) {\n                    f[i] += f[i - x];\n                }\n            }\n        }\n        return f[target];\n    }\n};\n```\n### 统计构造好字符串的方案数\n```C\nclass Solution {\npublic:\n    int countGoodStrings(int low, int high, int zero, int one) {\n        const int MOD = 1'000'000'007;\n        int ans = 0;\n        vector<int> f(high + 1); // f[i] 表示构造长为 i 的字符串的方案数\n        f[0] = 1; // 构造空串的方案数为 1\n        for (int i = 1; i <= high; i++) {\n            if (i >= zero) f[i] = f[i - zero];\n            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;\n            if (i >= low)  ans = (ans + f[i]) % MOD;\n        }\n        return ans;\n    }\n};\n```\n### 统计打字方案数\n```C\nclass Solution {\npublic:\n    int countTexts(string pressedKeys) {\n        int m = 1000000007;\n        vector<long long> dp3 = {1, 1, 2, 4};   // 连续按多次 3 个字母按键对应的方案数\n        vector<long long> dp4 = {1, 1, 2, 4};   // 连续按多次 4 个字母按键对应的方案数\n        int n = pressedKeys.size();\n        for (int i = 4; i < n + 1; ++i) {\n            dp3.push_back((dp3[i-1] + dp3[i-2] + dp3[i-3]) % m);\n            dp4.push_back((dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % m);\n        }\n        long long res = 1;   // 总方案数\n        int cnt = 1;   // 当前字符连续出现的次数\n        for (int i = 1; i < n; ++i) {\n            if (pressedKeys[i] == pressedKeys[i-1]) {\n                ++cnt;\n            } else {\n                // 对按键对应字符数量讨论并更新总方案数\n                if (pressedKeys[i-1] == '7' || pressedKeys[i-1] == '9') {\n                    res *= dp4[cnt];\n                } else {\n                    res *= dp3[cnt];\n                }\n                res %= m;\n                cnt = 1;\n            }\n        }\n        // 更新最后一段连续字符子串对应的方案数\n        if (pressedKeys[n-1] == '7' || pressedKeys[n-1] == '9') {\n            res *= dp4[cnt];\n        } else {\n            res *= dp3[cnt];\n        }\n        res %= m;\n        return res;\n    }\n};\n```\n## 打家劫舍\n### 打家劫舍\n```C\n/*题意转化为：从序列中选择子序列使得它们的和最大，数不能有相邻*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        vector<int> dp(n,0); //用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n        }  \n        return dp[n-1];\n    }\n};\n/*上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\n};\n```\n### 删除并获得点数\n```C\nclass Solution {\nprivate:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxval=0;\n        for(int val:nums){\n            maxval=max(maxval,val);\n        }\n        vector<int>sum(maxval+1,0);\n        for(int val:nums){\n            sum[val]+=val;\n        }\n        return rob(sum);\n    }\n};\n```\n### 统计放置房子的方式数\n```C\n/*单独考虑一侧的房子，定义 f[i] 表示前 i 个地块的放置方案数，其中第 i 个地块可以放房子，也可以不放房子。*/\nconst int mod=1e9+7;\nclass Solution {\npublic:\n    int countHousePlacements(int n) {\n        vector<long long> f(n+1,0);\n        f[0]=1;\n        f[1]=2;\n        for(int i=2;i<=n;i++){\n            f[i]=(f[i-1]+f[i-2])%mod;\n        }\n        return f[n]*f[n]%mod;\n    }\n};\n```\n### 打家劫舍 II\n```C\n/*第一间房屋和最后一间房屋不同时偷窃*/\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        int first = nums[start], second = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n\n    int rob(vector<int>& nums) {\n        int length = nums.size();\n        if (length == 1) {\n            return nums[0];\n        } \n        else if (length == 2) {\n            return max(nums[0], nums[1]);\n        }\n        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n};\n```\n### 施咒的最大总伤害\n## 最大子数组和\n>*定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是f[i]=a[i]，和 i 左边拼起来就是f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)。这个做法也叫做 Kadane 算法。*\n### 最大子数组和\n```C\n/*模板题*/\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n        }\n        return ranges::max(dp);\n    }\n};\n```\n### 找到最大开销的子字符串\n```C\n/*一点转化+模板题*/\nclass Solution {\npublic:\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\n        vector<int> m(26+1);\n        iota(m.begin(),m.end(),0);\n        for(int i=0;i<chars.size();i++){\n            m[chars[i]-'a'+1]=vals[i];\n        }\n \n        vector<int> dp(s.size());\n        dp[0]=m[s[0]-'a'+1];\n        int ans=max(0,dp[0]);\n        for(int i=1;i<s.size();i++){\n            dp[i]=max(dp[i-1],0)+m[s[i]-'a'+1];\n            ans=max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n```\n### 任意子数组和的绝对值的最大值\n```C\n/*题目转化为max(最大子数组和，-最小子数组和，0)*/\nclass Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        int ans1=dp[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n            ans1=max(ans1,dp[i]);\n        }\n \n        vector<int> dp1(nums.size());\n        dp1[0]=nums[0];\n        int ans2=dp1[0];\n        for(int i=1;i<nums.size();i++){\n            dp1[i]=min(dp1[i-1],0)+nums[i];\n            ans2=min(ans2,dp1[i]);\n        }\n        int ans=max(0,ans1);\n        ans=max(ans,-ans2);\n        return ans;\n    }\n};\n```\n### K 次串联后最大子数组之和\n```C\n/*\n考虑两种情况：\n\n1.如果k=1，那就是正常DP。\n\n2.k>1时也考虑两种情况：数组所有元素和大于0，数组所有元素和小于等于0。\n首先计算两个相接的DP也就是k=2的情况，如果数组元素和大于0，那可以看成再第一段结尾第二段开头插入k-2个正数，如果数组所有元素和为负，那k=2的情况就是最大的情况。\n*/\nclass Solution {\npublic:\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        const int mod=1e9+7;\n        int n=arr.size();\n        long long sum=0,presum=0,result=0;\n        for(int i=0;i<n*(k>1?2:1);i++){\n            long long num=arr[i%n];\n            presum=max(presum,0ll)+num;\n            result=max(result,presum);\n            if(i<n) sum+=num;\n        }\n        if(sum>0&&k>1){\n            result=(result+sum*(k-2)%mod)%mod;\n        }\n        return result;\n    }\n};\n/*\n1.sum>0、k=2时，最大子数组和如果没有跨过两个数组，那岂不是不能在中间插入k-2个sum吗？\n反证法，反设sum>0时，如果最大子数组和没有跨过两个数组。从L到R的子数组的和最大（0<=L<=R<n-1），考虑R向右n个数(R+1到R+n)，这n个数一定是和arr的数是一样的（循环了），那么这n个数的和是sum，大于0。所以从L到R+n的子数组的和要更大，而这个子数组跨过了两个数组，与反设矛盾。所以这样做是对的。\n2.sum<=0时，为什么可以化归到k=2的情况？\n还是反证法，假设最大子数组的长度>2n，那一定包括一个完整的arr数组，那么因为sum<=0，所以拿掉这一部分，把前后拼接在一起（这样做显然是合法的），这样做结果只会更优，如此操作下去，就可以划归到k=2的情况了。\n*/\n```\n### 环形子数组的最大和\n```C\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> qianmax(n); //前缀最大值\n        int presum=nums[0];\n        qianmax[0]=nums[0];\n\n        int pre=nums[0];\n        int ans=pre;\n\n        for(int i=1;i<n;i++){\n            pre=max(pre,0)+nums[i];\n            ans=max(ans,pre);\n\n            presum+=nums[i];\n            qianmax[i]=max(qianmax[i-1],presum);\n        }\n\n        int housum=0;\n        for(int i=n-1;i>0;i--){ //枚举后缀和\n            housum+=nums[i];\n            ans=max(ans,housum+qianmax[i-1]);\n        }\n        return ans;\n    }\n};\n```\n### 拼接数组的最大分数\n```C\n/*转换成最大子数组和*/\nclass Solution {\n    int solve(vector<int> &nums1, vector<int> &nums2) {\n        int sum = 0, maxSum = 0;\n        for (int i = 0, s = 0; i < nums1.size(); i++) {\n            sum += nums1[i];\n            s = max(s,0)+(nums2[i] - nums1[i]);\n            maxSum = max(maxSum, s);\n        }\n        return sum + maxSum;\n    }\n\npublic:\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2) {\n        return max(solve(nums1, nums2), solve(nums2, nums1));\n    }\n};\n```\n### (扩展）乘积最大子数组\n```C\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector <long> maxF(nums.begin(),nums.end()), minF(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            maxF[i] = max(maxF[i - 1] * nums[i], max((long)nums[i], minF[i - 1] * nums[i]));\n            minF[i] = min(minF[i - 1] * nums[i], min((long)nums[i], maxF[i - 1] * nums[i]));\n            if(minF[i]<INT_MIN) {\n                minF[i]=nums[i];\n            }\n        }\n        return *max_element(maxF.begin(), maxF.end());\n    }\n};\n/*优化空间*/\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        long maxF = nums[0], minF = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            long mx = maxF, mn = minF;\n            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));\n            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));\n            if(minF<INT_MIN) {\n                minF=nums[i];\n            }\n            ans = max(maxF, ans);\n        }\n        return ans;\n    }\n};\n```\n# 网格图 DP\n## 基础\n### 珠宝的最高价值\n```C\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(n,vector<int>(m));\n        f[0][0]=frame[0][0];\n        for(int i=1;i<n;i++){ //处理第一列\n            f[i][0]=f[i-1][0]+frame[i][0];\n        }\n        for(int j=1;j<m;j++){ //处理第一行\n            f[0][j]=f[0][j-1]+frame[0][j];\n        }\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                f[i][j]=max(f[i-1][j],f[i][j-1])+frame[i][j];\n            }\n        }\n        return f[n-1][m-1];\n    }\n};\n \n/*注意到状态转移方程中，f(i,j) 只会从 f(i−1,j) 和 f(i,j−1) 转移而来，而与 f(i−2,⋯) 以及更早的状态无关，因此我们同一时刻只需要存储最后两行的状态，即使用两个长度为 n 的一位数组代替 n×m 的二维数组 f，交替地进行状态转移，减少空间复杂度。*/\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(2,vector<int>(m));\n        for(int i=0;i<n;i++){\n            int pos=i%2;\n            for(int j=0;j<m;j++){\n                f[pos][j]=0;\n                if(i>0) f[pos][j]=max(f[pos][j],f[1-pos][j]);\n                if(j>0) f[pos][j]=max(f[pos][j],f[pos][j-1]);\n                f[pos][j]+=frame[i][j];\n            }\n        }\n        return f[(n-1)%2][m-1];\n    }\n};\n```\n### 不同路径\n```C\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++) f[i][0]=1;\n        for(int j=0;j<n;j++) f[0][j]=1;\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n/*此外，由于 f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。*/\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> f(n,1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                f[j]+=f[j-1];\n            }\n        }\n        return f[n - 1];\n    }\n};\n```\n### 不同路径 II\n```C\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++){ //处理第一列\n            if(obstacleGrid[i][0]==1){ //有障碍 \n                f[i][0]=0; \n                break; //后面都到达不了\n            }\n            else f[i][0]=1;\n        }\n        for(int j=0;j<n;j++){  //处理第一行\n            if(obstacleGrid[0][j]==1){ //有障碍\n                f[0][j]=0; \n                break; //后面都到达不了\n            }\n            else f[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(obstacleGrid[i][j]==1) f[i][j]=0;\n                else f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n```\n### 最小路径和\n```C\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m));\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<n;i++) dp[i][0]=dp[i-1][0]+grid[i][0];\n        for(int j=1;j<m;j++) dp[0][j]=dp[0][j-1]+grid[0][j];\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};\n```\n### 三角形最小路径和\n```C\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            dp[i][0]=dp[i-1][0]+triangle[i][0]; //第一列只能从上面转移\n            for(int j=1;j<i;j++){\n                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n            }\n            dp[i][i]=dp[i-1][i-1]+triangle[i][i];//最后一列只能从左上转移\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n/*可以发现，dp[i][j] 只与 dp[i−1][..] 有关，而与 dp[i−2][..] 及之前的状态无关，因此我们不必存储这些无关的状态。具体地，我们使用两个长度为 n 的一维数组进行转移，将 i 根据奇偶性映射到其中一个一维数组，那么 i−1 就映射到了另一个一维数组。这样我们使用这两个一维数组，交替地进行状态转移。*/\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            dp[cur][0]=dp[pre][0]+triangle[i][0]; //第一列只能从上面转移\n            for(int j=1;j<i;j++){\n                dp[cur][j]=min(dp[pre][j-1],dp[pre][j])+triangle[i][j];\n            }\n            dp[cur][i]=dp[pre][i-1]+triangle[i][i];//最后一列只能从左上转移\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n### 下降路径最小和\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        copy(matrix[0].begin(),matrix[0].end(),dp[0].begin());\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++){\n                int minn=dp[i-1][j]; //都能从正上方转移\n                if(j>0){ //可以从左上方转移\n                    minn=min(minn,dp[i-1][j-1]);\n                }\n                if(j<n-1){ //可以从右上方转移\n                    minn=min(minn,dp[i-1][j+1]);\n                }\n                dp[i][j]=minn+matrix[i][j];\n            }\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n```\n### 矩阵中移动的最大次数\n```C\nclass Solution {\npublic:\n    int maxMoves(vector<vector<int>>& grid) {\n        int ans=0; bool flag=1;\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m)); //dp[i][j]==1表示(i,j)位置可到达\n        for(int i=0;i<n;i++) dp[i][0]=1; \n        for(int j=1;j<m;j++){\n            if(!flag) return ans;\n            flag=0;\n            for(int i=0;i<n;i++){\n                if(grid[i][j-1]<grid[i][j]&&dp[i][j-1]){\n                    dp[i][j]=1;\n                }\n                if(i>0){\n                    if(grid[i-1][j-1]<grid[i][j]&&dp[i-1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(i<n-1){\n                    if(grid[i+1][j-1]<grid[i][j]&&dp[i+1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(dp[i][j]){\n                    flag=1;\n                    ans=j;\n                }\n            }\n        }\n        //ans+=1;\n        return ans;\n    }\n};\n```\n### 网格中的最小路径代价\n```C\nclass Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0]=grid[0];\n        for(int i=1;i<m;i++){\n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            for(int j=0;j<n;j++){ //当前行每一列\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<n;k++){ //上一行每一列\n                    dp[cur][j]=min(dp[cur][j],dp[pre][k]+moveCost[grid[i-1][k]][j]+grid[i][j]);\n                }\n            }\n        }\n        return *min_element(dp[(m-1)%2].begin(),dp[(m-1)%2].end());\n    }\n};\n```\n### 下降路径最小和 II\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(m));\n        dp[0]=grid[0];\n        for(int i=1;i<n;i++){ \n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            for(int j=0;j<m;j++){ //当前行每一列\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<m;k++){ //上一行每一列\n                    if(j!=k){\n                        dp[cur][j]=min(dp[cur][j],dp[pre][k]+grid[i][j]);\n                    }\n                }\n            }\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n## 进阶\n### 矩阵的最大非负积\n```C\nclass Solution {\npublic:\n    int maxProductPath(vector<vector<int>>& grid) {\n        const int mod=1e9+7;\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<long long>> maxgt(m,vector<long long>(n));\n        vector<vector<long long>> minlt(m,vector<long long>(n));\n        maxgt[0][0]=minlt[0][0]=grid[0][0];\n        for(int j=1;j<n;j++){ //处理第一行\n            maxgt[0][j]=minlt[0][j]=maxgt[0][j-1]*grid[0][j];\n        }\n        for(int i=1;i<m;i++){ //处理第一列\n            maxgt[i][0]=minlt[i][0]=maxgt[i-1][0]*grid[i][0];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(grid[i][j]>=0){\n                    maxgt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                    minlt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                }\n                else{\n                    maxgt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                    minlt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                }\n            }\n        }\n        if(maxgt[m-1][n-1]<0) return -1;\n        else{\n            return maxgt[m-1][n-1]%mod;\n        }\n    }\n};\n```\n### 最大得分的路径数目\n```C\nusing PII = pair<int, int>;\n\nclass Solution {\nprivate:\n    static constexpr int mod = (int)1e9 + 7;\n\npublic:\n    void update(vector<vector<PII>>& dp, int n, int x, int y, int u, int v) {\n        if (u >= n || v >= n || dp[u][v].first == -1) {\n            return;\n        }\n        if (dp[u][v].first > dp[x][y].first) {\n            dp[x][y] = dp[u][v];\n        }\n        else if (dp[u][v].first == dp[x][y].first) {\n            dp[x][y].second += dp[u][v].second;\n            if (dp[x][y].second >= mod) {\n                dp[x][y].second -= mod;\n            }\n        }\n    }\n\n    vector<int> pathsWithMaxScore(vector<string>& board) {\n        int n = board.size();\n        vector<vector<PII>> dp(n, vector<PII>(n, {-1, 0}));\n        dp[n - 1][n - 1] = {0, 1};\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (!(i == n - 1 && j == n - 1) && board[i][j] != 'X') {\n                    update(dp, n, i, j, i + 1, j);\n                    update(dp, n, i, j, i, j + 1);\n                    update(dp, n, i, j, i + 1, j + 1);\n                    if (dp[i][j].first != -1) {\n                        dp[i][j].first += (board[i][j] == 'E' ? 0 : board[i][j] - '0');\n                    }\n                }\n            }\n        }\n        return dp[0][0].first == -1 ? vector<int>{0, 0} : vector<int>{dp[0][0].first, dp[0][0].second};\n    }\n};\n```\n### 矩阵中和能被 K 整除的路径\n```C\n/*把路径和模 k 的结果当成一个扩展维度*/\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>> &grid, int k) {\n        const int mod = 1e9 + 7;\n        int m = grid.size(), n = grid[0].size(), f[m + 1][n + 1][k];\n        memset(f, 0, sizeof(f)); // f[i][j][v] 表示从左上走到 (i,j)，且路径和模 k 的结果为 v 时的路径数\n        f[0][1][0] = 1;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                for (int v = 0; v < k; ++v)\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\n        return f[m][n][0];\n    }\n};\n/*代码实现时，为了避免判断是否越界，可以把下标都加一。此时可以设初始值 f[0][1][0]=1（或者 f[1][0][0]=1）简化一点点代码。*/\n```\n### 地下城游戏\n```C\n\n```\n# 背包\n## 0-1 背包\n>*每个物品只能选一次*\n### 和为目标值的最长子序列的长度\n```C\n\n```\n## 完全背包\n## 多重背包\n## 分组背包\n# 经典线性 DP\n## 最长公共子序列（LCS）\n>*一般定义f[i][j]表示对(s[:i],t[:j])的求解结果。*\n### 最长公共子序列\n```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.size(),n=text2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1)); \n        for(int i=1;i<=m;i++){\n            char c1=text1[i-1];\n            for(int j=1;j<=n;j++){\n                char c2=text2[j-1];\n                if(c1==c2){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                else{\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n### 两个字符串的删除操作\n```C++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; i++) {\n            char c1 = word1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = word2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        int lcs = dp[m][n];\n        return m - lcs + n - lcs;\n    }\n};\n```\n### 两个字符串的最小ASCII删除和\n```C++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int m = s1.size();\n        int n = s2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; ++i) {\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\n        }\n        for (int j = 1; j <= n; ++j) {\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\n        }\n        for (int i = 1; i <= m; i++) {\n            char c1 = s1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = s2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n```\n### 编辑距离\n```C++\n\n```\n## 最长递增子序列（LIS）\n","tags":["动态规划","编程"]},{"title":"软件工程综合实践","url":"/post/7f61ed21.html","content":"## 故事场景\n>你们是几名到某软件开发公司（以下简称T软）实习的学生。上班第一天，老板告诉你们，公司现在有个紧急项目，要求三周后上线，但是……上周末，这个项目唯一的程序员，小东，因不满公司的薪水待遇过低而离职了，现在留下了一个半成品的烂摊子，重担落在了你们几个毫无开发经验的实习生身上……\n## JDBC 项目\n**主要目标：解决“使用 JDBC 封装数据层，并实现增删改查”的问题。**\n## 前端项目\n**主要目标：解决“使用 HTML5+CSS3+JavaScript 开发企业级前端静态页面”的问题。**\n## JavaWeb 项目\n**主要目标：解决“使用 Vue（前端）+Servlet（服务端）开发基于前后端分离架构应用程序”的问题。**\n## SpringBoot 项目\n**主要目标：解决“使用 Vue（前端）+SpringBoot（服务端）开发基于前后端分离架构应用程序”的问题。**\n## SpringCloud 项目\n**主要目标：解决“使用 Vue（前端）+SpringCloud（服务端）开发基于微服务的互联网应用程序”的问题。**","tags":["软件工程","实践","开发"]},{"title":"计算机网络实践记录","url":"/post/3f763db6.html","content":"---\n- 天津大学 2024 计算机网络 TCP 课程实践\n- Lab Member：海棠未雨，梨花先雪\n- 最终成绩 93 分捏 😋\n---\n# 文件结构说明\n```markdown\ntju_tcp ----------------- 项目根目录 \n├─ build ---------------- 存放所有编译的中间文件\n│  ├─ kernel.o\n│  ├─ tju_packet.o  \n│  └─ tju_tcp.o\n├─ inc ------------------ 存放所有头文件\n│  ├─ global.h ---------- 定义一些全局都会用到的变量和结构\n│  ├─ kernel.h ---------- 模拟一部分linux内核行为 比如如何发送数据到下一层 根据五元组查找socket等\n│  ├─ tju_packet.h ------ 定义TCP所用到的数据包格式 提供各种数据包的操作(创建 获得字段等)\n│  └─ tju_tcp.h --------- 需要实现的TCP的各种结构和功能的定义\n├─ src ------------------ 存放所有源代码文件\n│  ├─ client.c ---------- 客户端主函数实现\n│  ├─ server.c ---------- 服务端主函数实现\n│  ├─ kernel.c ---------- 虚拟内核实现\n│  ├─ tju_packet.c ------ 可靠层包封装实现\n│  └─ tju_tcp.c --------- 可靠层实现\n├─ Makefile ------------- 生成脚本\n├─ README.md ------------ 文件说明\n└─ bin\n   ├─ client\n   └─ server\n```\n---\n# 系统环境信息\n```SHELL\nneofetch\n--------------\nOS: Ubuntu 20.04.2 LTS x86_64\nHost: Oracle Corporation VirtualBox\nKernel: 5.4.0-80-generic\nUptime: 3 mins\nPackages: 676 (dpkg), 4 (snap)\nShell: bash 5.0.17\nResolution: 800x600\nTerminal: /dev/pts/0\nCPU: 11th Gen Intel i7-11800H (2) @ 2.304GHz\nGPU: VirtualBox Graphics Adapter\nMemory: 294MiB / 981MiB\n```\n---\n# 具体实验记录\n## 连接管理\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/t2LOxSBZgRkiblj.png\" width=\"60%\" />\n</center>\n\n### 三次握手建立连接\n**1. tju_connect( )**\n`tju_connect( )`函数是三次握手的开端。在该函数中，客户端的sock绑定好本地的ip和port后向服务器端发送SYN包，同时把当前的状态变化为SYN_SENT。成功建立连接后将sock放入ESTABLISHED的hash表中。\n```C\nint tju_connect(tju_tcp_t* sock, tju_sock_addr target_addr){\n    sock->established_remote_addr = target_addr;\n\n    tju_sock_addr local_addr;\n    local_addr.ip = inet_network(CLIENT_IP);\n    local_addr.port = 5678; // 连接方进行connect连接的时候 内核中是随机分配一个可用的端口\n    sock->established_local_addr = local_addr;\n\n    // 这里也不能直接建立连接 需要经过三次握手\n    // 实际在linux中 connect调用后 会进入一个while循环\n    // 循环跳出的条件是socket的状态变为ESTABLISHED 表面看上去就是 正在连接中 阻塞\n    // 而状态的改变在别的地方进行 在我们这就是tju_handle_packet\n    uint32_t seq = 0;  // 序列号\n    uint32_t ack = 0;  // 确认号\n    uint8_t flag=SYN_FLAG_MASK; //flag标记为：连接状态进行到哪一步\n    char *SYN = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n    sendToLayer3(SYN, DEFAULT_HEADER_LEN); //客户端向服务器端发送同步报文--第一次握手\n    change_sock_state(sock, SYN_SENT);\n    // printf(\"client发送SYN\\n\");\n    \n    Timeout_retransmission(sock, ESTABLISHED, SYN, DEFAULT_HEADER_LEN); //阻塞等待，直到sock被建立\n    int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n    established_socks[hashval] = sock;\n    return 0;\n}\n```\n**2. Timeout_retransmission( )**\n```C\nvoid Timeout_retransmission(tju_tcp_t* sock, int exp_state, char* pkt, int pktlen) { //超时重传发包函数\n    //printf(\"bg1\\n\");\n    long timeout = 100000L;\n    struct timeval start_time, end_time;\n    gettimeofday(&start_time, NULL);\n    while (sock->state != exp_state){\n        gettimeofday(&end_time, NULL);\n        long Time = 1000000L * (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_usec - start_time.tv_usec);\n        if (Time >= timeout) { //超时重传\n            gettimeofday(&start_time, NULL);\n            sendToLayer3(pkt, pktlen);\n        }\n    }\n    //printf(\"ed1\\n\");\n}\n```\n**3. change_sock_state( )**\n```C\nvoid change_sock_state(tju_tcp_t* sock, int state) {  //添加：sock状态改变\n    while (pthread_mutex_lock(&(sock->state_lock)) != 0) ; //改变sock状态前先加锁\n    sock->state = state;  \n    pthread_mutex_unlock(&(sock->state_lock)); //解锁\n}\n```\n**4. tju_accept()**\n`tju_accept( )`函数中添加了一个阻塞，使得只有当全连接hash表中存在这一个sock，服务器端才算连接完成，才能把新的sock加入到ESTABLISHED的hash表中。\n```C\ntju_tcp_t *tju_accept(tju_tcp_t *listen_sock){\n    while (listen_sock->received_len < DEFAULT_HEADER_LEN);\n    char *header = malloc(DEFAULT_HEADER_LEN);\n    memcpy(header, listen_sock->received_buf, DEFAULT_HEADER_LEN);\n    memset(listen_sock->received_buf, 0, DEFAULT_HEADER_LEN);\n    listen_sock->received_buf = NULL;\n    listen_sock->received_len = listen_sock->received_len - DEFAULT_HEADER_LEN;\n\n    tju_tcp_t* new_conn = (tju_tcp_t*)malloc(sizeof(tju_tcp_t));\n    pthread_mutex_init(&(new_conn->state_lock), NULL);\n    memcpy(new_conn, listen_sock, sizeof(tju_tcp_t));\n\n    tju_sock_addr local_addr, remote_addr;\n    /*\n     这里涉及到TCP连接的建立\n     正常来说应该是收到客户端发来的SYN报文\n     从中拿到对端的IP和PORT\n     换句话说 下面的处理流程其实不应该放在这里 应该在tju_handle_packet中\n    */\n    remote_addr.ip = inet_network(CLIENT_IP);  //具体的IP地址\n    remote_addr.port = 5678;  //端口\n\n    local_addr.ip = listen_sock->bind_addr.ip;  //具体的IP地址\n    local_addr.port = listen_sock->bind_addr.port;  //端口\n\n    new_conn->established_local_addr = local_addr;\n    new_conn->established_remote_addr = remote_addr;\n\n    while (listen_sock->state != ESTABLISHED) ;\n    change_sock_state(new_conn, ESTABLISHED);\n\n    // 将新的conn放到内核建立连接的socket哈希表中\n    int hashval = cal_hash(local_addr.ip, local_addr.port, remote_addr.ip, remote_addr.port);\n    established_socks[hashval] = new_conn;\n    return new_conn;\n}\n```\n**5. tju_handle_packet( )**\n`tju_handle_packet( )`函数中需要解决对各种报文的解析。`onTCPPocket( )`函数如果从established_hash或listen_hash中找到了对应的socket，就会调用 `tju_handle_packet( )`函数对收到的数据包进行处理。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    if (sock->state == LISTEN && get_flags(pkt) == SYN_FLAG_MASK){ //第二次握手\n        while (pthread_mutex_lock(&(sock->recv_lock)) != 0);\n        if (sock->received_buf == NULL) sock->received_buf = malloc(DEFAULT_HEADER_LEN);\n        else sock->received_buf = realloc(sock->received_buf, sock->received_len + DEFAULT_HEADER_LEN);\n        memcpy(sock->received_buf + sock->received_len, pkt, DEFAULT_HEADER_LEN);\n        sock->received_len += DEFAULT_HEADER_LEN;\n        pthread_mutex_unlock(&(sock->recv_lock));\n\n        tju_sock_addr remote;\n        remote.ip = inet_network(CLIENT_IP);\n        remote.port = get_src(pkt);\n\n        sock->established_local_addr = sock->bind_addr;\n        sock->established_remote_addr = remote;\n\n        int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, remote.ip, remote.port);\n        half_connection[hashval] = sock;  //收到SYN报文后放进LISTEN的半连接队列中\n        established_socks[hashval] = sock; //还会将该新建的socket放到ehash中\n\n        uint32_t seq = 0;  \n        uint32_t ack = get_seq(pkt) + 1; //确认号是SYN报文序列号+1\n        uint8_t flag = SYN_FLAG_MASK | ACK_FLAG_MASK; //状态记为SYN+ACK，这里采用位运算|\n        char *SYNACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(SYNACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, SYN_RECV);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == (ACK_FLAG_MASK | SYN_FLAG_MASK)){ //第三次握手\n        //printf(\"client收到SYCACK, 准备发送ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == SYN_FLAG_MASK){ //第三次握手（奇怪）\n        // //printf(\"client收到SYCACK, 准备发送ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == (SYN_FLAG_MASK | ACK_FLAG_MASK)){  //三次握手第三个包的重传\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == SYN_RECV && get_flags(pkt) == ACK_FLAG_MASK){\n        // //printf(\"server收到ACK\\n\");\n        sock->window.wnd_recv->expect_seq = get_seq(pkt) + get_plen(pkt) - DEFAULT_HEADER_LEN;\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        com_connection[hash] = sock;\n        half_connection[hash] = NULL;\n        change_sock_state(sock, ESTABLISHED);\n        if (get_plen(pkt) > DEFAULT_HEADER_LEN) { //ACK包携带信息\n            pkt2buffer(sock, pkt);\n        }\n    }\n```\n**6. pkt2buffer( )**\n```C\nvoid pkt2buffer(tju_tcp_t* sock, char* pkt) {\n    //printf(\"bg6\\n\");\n    uint32_t data_len = get_plen(pkt) - DEFAULT_HEADER_LEN;\n\n    while (pthread_mutex_lock(&(sock->recv_lock)) != 0); // 加锁\n    if (sock->received_buf == NULL){\n        sock->received_buf = malloc(data_len);\n    }\n    else{\n        sock->received_buf = realloc(sock->received_buf, sock->received_len + data_len);\n    }\n    memcpy(sock->received_buf + sock->received_len, pkt + DEFAULT_HEADER_LEN, data_len);    \n    sock->received_len += data_len;\n    pthread_mutex_unlock(&(sock->recv_lock)); // 解锁\n    //printf(\"ed6\\n\");\n}\n```\n### 四次挥手关闭连接\n**1. tju_close ( )**\n四次挥手有两种情况，分别为先后关闭和同时关闭，两种方式首先都需要调用`tju_close( )`函数，因此，在`tju_close( )`函数中，需要构造一个 FIN+ACK 报文，seq和ack都是当前报文窗口的下一个数值，并把自身状态变为 FIN-WAIT1。\n```C\nint tju_close (tju_tcp_t* sock){\n    uint16_t flag = FIN_FLAG_MASK | ACK_FLAG_MASK;\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_send->nextseq;\n    char* FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n    sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n    change_sock_state(sock, FIN_WAIT_1);\n    sock->window.wnd_send->nextseq++;\n\n    while (sock->state != CLOSED) ;\n    //printf(\"连接完全关闭\\n\");\n    return 0;\n}\n```\n**2. tju_handle_packet( )**\n接下来分为两种情况，但处理过程均在`tju_handle_packet( )`中完成，`tju_handle_packet( )`作为对收到的包进行响应的函数。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    ``````\n    ``````\n    ``````\n    else if (sock->state == ESTABLISHED && get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK)){ // server收到第一次挥手，并进行第二次挥手和第三次挥手\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第二次挥手报文\\n\");\n        change_sock_state(sock, CLOSE_WAIT);\n        \n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        seq = sock->window.wnd_send->nextseq;\n        ack = get_seq(pkt) + 1;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第三次挥手报文\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == ESTABLISHED && get_flags(pkt) == FIN_FLAG_MASK){ // server收到第一次挥手，并进行第二次挥手和第三次挥手\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, CLOSE_WAIT);\n        //printf(\"发送第二次挥手报文\\n\");\n\n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第三次挥手报文\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == FIN_WAIT_1 && get_flags(pkt) == ACK_FLAG_MASK){ // client收到第二次挥手\n        change_sock_state(sock, FIN_WAIT_2);\n        //printf(\"收到第二次挥手报文\\n\");\n    } \n    else if (sock->state == FIN_WAIT_2 && (get_flags(pkt) == (ACK_FLAG_MASK | FIN_FLAG_MASK))){ // client收到第三次挥手进行第四次挥手并关闭连接\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint32_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN,flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"收到第三次挥手报文, 并发出第四次挥手\\n\");\n        change_sock_state(sock, TIME_WAIT);\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,    sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        //这里要等待2MSL\n        change_sock_state(sock, CLOSED);\n        established_socks[hash] = NULL;\n        //printf(\"关闭连接\\n\");\n    } \n    else if (sock->state == LAST_ACK && (get_flags(pkt) == ACK_FLAG_MASK)){ // server收到第四次挥手并关闭连接\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"关闭连接\\n\");\n    }\n    else if (sock->state == FIN_WAIT_1 && (get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK))){ // 同时关闭收到第一次挥手\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK,DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n        // //printf(\"同时关闭发出ACK\\n\");\n    } \n    else if(sock->state == FIN_WAIT_1 && get_flags(pkt) == FIN_FLAG_MASK){ // 同时关闭收到第一次挥手\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == CLOSING && get_flags(pkt) == ACK_FLAG_MASK){ // 同时关闭时收到第三次挥手\n        change_sock_state(sock, TIME_WAIT);\n        //等待2MSL\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"同时关闭彻底关闭\\n\");\n    }\n}\n```\n## 可靠数据传输\n### 发送缓冲区管理\n**1. `global.h` 中宏定义 TCP 发送窗口大小。**\n```C\n#define TCP_SENDWN_SIZE 1000 \n```\n**2. `tju_packet.h` 中为发送缓冲区创建1000个报文长度的循环队列，方便数据包超时重传。**\n```C\n// TCP 报文的结构定义\ntypedef struct {\n\ttju_header_t header;\n\tstruct timeval sent_time;\n\tchar* data;\n} tju_packet_t;\ntju_packet_t* pktlist[TCP_SENDWN_SIZE];\n```\n**3. tju_send( )**\n上层调用 `tju_send( )` 时，我们在 `tju_send( )`函数内创建发送线程并把发送数据存入缓冲区中。\n&emsp;这里我们先了解一下创建线程 `pthread_create( )`函数。\n>int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg);\n>- tidp：事先创建好的pthread_t类型的参数。成功时tidp指向的内存单元被设置为新创建线程的线程ID。\n>- attr：用于定制各种不同的线程属性。APUE的12.3节讨论了线程属性。通常直接设为NULL。\n>- start_rtn：新创建线程从此函数开始运行。无参数是arg设为NULL即可。\n>- arg：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。\n>- 返回值为 0（表示线程成功创建）。\n```C\nint send_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    // 这里当然不能直接简单地调用sendToLayer\n    if(!send_thread_flag){\n        send_thread_flag = 1;\n        pthread_t sendthreadid;\n        int ret = pthread_create(&sendthreadid, NULL, send_pkt, (void *)sock);\n    }\n\n    while (pthread_mutex_lock(&(sock->send_lock)) != 0) ;\n    memcpy(sock->sending_buf + sock->index, (char*)buffer, len);\n    sock->sending_len += len;\n    sock->index += len;\n    pthread_mutex_unlock(&(sock->send_lock));\n\n    return 0;\n}\n```\n**4. send_pkt( )**\n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    //printf(\"bg4\\n\");\n    //struct timeval start_time, now_time;\n    //gettimeofday(&start_time, NULL);\n    //long deltatime = 0; //时间差\n    while (1){ //不断检查和发送数据包\n        if (sock->window.wnd_send->nextseq < sock->index){ //检查发送窗口：检查当前发送序列号是否小于索引，确保有数据需要发送。\n            //gettimeofday(&now_time, NULL);\n            //deltatime = now_time.tv_sec - start_time.tv_sec;\n\n            while (pthread_mutex_lock(&(sock->send_lock)) != 0);\n            int unlen = sock->sending_len - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base); //计算当前未发送的数据长度。 \n            int len = min(unlen, MAX_DLEN); //确定本次发送的长度，取未发送长度和最大数据长度中的最小值。 \n            pthread_mutex_unlock(&(sock->send_lock));\n            int leftlen = sock->window.wnd_send->rwnd - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base);\n            len =len>leftlen?leftlen:len;            \n\n            if (sock->window.wnd_send->nextseq - sock->window.wnd_send->base + len <= sock->window.wnd_send->rwnd) { //检查窗口大小：检查当前已发送的长度加上本次发送长度是否在接收窗口范围内。 \n                uint32_t seq = sock->window.wnd_send->nextseq;\n                uint32_t ack = seq + len; //不理解 \n                uint8_t flag = ACK_FLAG_MASK;\n                uint16_t pkt_len = len + DEFAULT_HEADER_LEN;\n                char *data = (char *)malloc(MAX_DLEN);\n                memcpy(data, sock->sending_buf + sock->window.wnd_send->nextseq, len);\n                tju_packet_t *datapacket = create_packet(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n\n                sendToLayer3(ACK, pkt_len);\n                \n                sock->window.wnd_send->nextseq += len;\n                pktlist[sock->packetr] = datapacket;\n                gettimeofday(&pktlist[sock->packetr]->sent_time, NULL);\n                sock->packetr = (sock->packetr + 1) % TCP_SENDWN_SIZE;\n                if (len == (int)(sock->window.wnd_send->nextseq - sock->window.wnd_send->base)){\n                    gettimeofday(&(sock->window.wnd_send->send_time), NULL);\n                    \n                    while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n                    sock->window.wnd_send->ack_cnt = 0;\n                    pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n                }\n            }\n        }\n    }\n    printf(\"ed4\\n\");\n}\n```\n### 失序报文数组的管理\n**1. tju_handle_packet( )**\n`tju_handle_packet( )`中添加建立连接后收到数据包的处理。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    `````` 建立连接 ``````\n    ````````````````````\n    ````````````````````\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == ACK_FLAG_MASK){ //收到数据包\n        char hostname[8];\n        gethostname(hostname, 8);\n        if (strcmp(hostname, \"server\") == 0){\n            serverrdt(sock, pkt);\n        } \n        else{\n            clientrdt(sock, pkt);\n        } \n    }\n    `````` 关闭连接 ``````\n    ````````````````````\n    ````````````````````\n}\n```\n**2. `tju_tcp_t` 结构体中创建空间用来存储失序报文并记录失序报文的个数。**\n```C\n// TJU_TCP 结构体 保存TJU_TCP用到的各种数据\ntypedef struct {\n\tchar unorder[100][MAX_LEN]; //失序报文数组\n\tint unolen; //失序报文个数\n} tju_tcp_t;\n```\n**3. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){ // 服务器端处理数据包\n    if (get_seq(pkt) < (sock->window.wnd_recv->expect_seq)){ //函数发送一个 ACK 响应已确认接收\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if(get_seq(pkt) > (sock->window.wnd_recv->expect_seq)){ //数据包乱序，函数将包暂存，并发送 ACK，同时更新接收窗口\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n\n        if((sock->unolen) > MAX_PKT_IN_WINDOW)  return;\n        memcpy(sock->unorder[sock->unolen], pkt, get_plen(pkt));\n        sock->unolen++;\n    }\n    else{ //刚刚好\n        sock->window.wnd_send->nextseq=get_ack(pkt);\n        sock->window.wnd_recv->expect_seq+=get_plen(pkt)-DEFAULT_HEADER_LEN;\n        pkt2buffer(sock,pkt);\n        if(sock->unolen == 0){\n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag,TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n        else{\n            int len = sock->unolen;\n\n            for(int i = 0; i < len; i++){\n                for(int j = i + 1; j < len; j++){\n                    if(get_seq(sock->unorder[i])>get_seq(sock->unorder[j])){\n                        my_swap(&sock->unorder[i], &sock->unorder[j]);\n                    }\n                }\n            }\n            int index = 0;\n            for(; index < len; index++){\n                if(get_seq(sock->unorder[index]) == sock->window.wnd_recv->expect_seq){\n                    sock->window.wnd_send->nextseq = get_ack(sock->unorder[index]);\n                    sock->window.wnd_recv->expect_seq += get_plen(sock->unorder[index]) - DEFAULT_HEADER_LEN;\n                    pkt2buffer(sock, sock->unorder[index]);\n                }\n                else if(get_seq(sock->unorder[index]) < (sock->window.wnd_recv->expect_seq)) continue;\n                else break;\n            }\n            for (int i = index; i < len; i++){\n                memcpy(sock->unorder[i - index], sock->unorder[i], sizeof(sock->unorder[i]));\n            }\n            sock->unolen -= index;\n           \n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n    }\n}\n```\n**4. my_swap( )**\n```C\nvoid my_swap(char** a, char** b){\n    char* tem = (char*)malloc(MAX_LEN);\n    memcpy(tem, a, get_plen(b));\n    memcpy(a, b, get_plen(b));\n    memcpy(b, tem, get_plen(tem));\n    free(tem);\n}\n```\n### 实现累计应答\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/vKkuC1ibGfmo2sM.png\" width=\"60%\" />\n\nFigure 1. 累计应答\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )`函数中添加累计应答处理。当发送方收到任意大于当前base的ack报文后，直接把当前base进行更新即可。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    if (sock->window.wnd_send->base == sock->window.wnd_send->nextseq) return;\n    if (get_ack(pkt) < sock->window.wnd_send->base) return;\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        ``````\n        ``````\n        ``````\n        while(pthread_mutex_lock(&(sock->send_lock)) != 0); //加锁\n        while(sock->window.wnd_send->base < get_ack(pkt) && sock->window.wnd_send->base < sock->window.wnd_send->nextseq ){   \n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            int datalen = pkt_len - DEFAULT_HEADER_LEN;\n            sock->sending_len -= datalen;\n            sock->window.wnd_send->base += datalen;\n            sock->packetl = (sock->packetl + 1) % TCP_SENDWN_SIZE;\n        }\n        pthread_mutex_unlock(&(sock->send_lock)); //解锁\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n### 超时重传\n**1. tju_send( )**\n`tju_send( )` 中创建了一个新的线程判断是否要进行重传。\n```C\nint resend_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    ``````\n    ``````\n    ``````\n    if (!resend_thread_flag){\n        resend_thread_flag = 1;\n        pthread_t resendthreadid;\n        int ret = pthread_create(&resendthreadid, NULL,resend_pkt, (void *)sock);\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n**2. resend_pkt( )**\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    struct timeval start_time,now_time;\n    gettimeofday(&start_time, NULL);\n    long deltatime = 0;\n    while (1){\n        if (sock->window.wnd_send->base < sock->window.wnd_send->nextseq){\n            gettimeofday(&now_time, NULL);\n            deltatime = now_time.tv_sec - start_time.tv_sec;\n            if (deltatime > 100) break; //不理解\n            long nowtimeval = 1000000 * (now_time.tv_sec - sock->window.wnd_send->send_time.tv_sec) +  (now_time.tv_usec - sock->window.wnd_send->send_time.tv_usec);\n            long timeoutval = 1000000 * (sock->window.wnd_send->timeout.tv_sec) + (sock->window.wnd_send->timeout.tv_usec);\n            if (nowtimeval > timeoutval){ //超时重传\n                while(pktlist[sock->packetl] == NULL);\n                uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n                uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n                uint8_t flag = ACK_FLAG_MASK;\n                int pkt_len = pktlist[sock->packetl]->header.plen;\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack,DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n                sendToLayer3(ACK, pkt_len);\n                gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);\n                gettimeofday(&sock->window.wnd_send->send_time, NULL);\n            }\n        }\n    }\n}\n```\n**3. clientrdt( )**\n`clientrdt( )` 函数中添加动态设置超时间隔的实现。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        //更新RTO\n        struct timeval nowtime;\n        gettimeofday(&nowtime, NULL);\n        long ntime = 1000000 * nowtime.tv_sec + nowtime.tv_usec;\n        long samplertt = 1000000 * (nowtime.tv_sec-pktlist[sock->packetl]->sent_time.tv_sec)+nowtime.tv_usec-pktlist[sock->packetl]->sent_time.tv_usec;\n        long estmatedrtt = sock->window.wnd_send->estmated_rtt;\n        long devrtt = sock->window.wnd_send->dev_rtt;\n        estmatedrtt = 1.0 * estmatedrtt * 7 / 8 + samplertt / 8;\n        devrtt = 1.0 * devrtt * 3 / 4 + (samplertt > 1.0 * estmatedrtt ? (samplertt - estmatedrtt) : (estmatedrtt - samplertt)) / 4;\n        sock->window.wnd_send->timeout.tv_usec = (estmatedrtt + 4 * devrtt) % 1000000;\n        sock->window.wnd_send->timeout.tv_sec = (estmatedrtt + 4 * devrtt) / 1000000;\n        sock->window.wnd_send->estmated_rtt = estmatedrtt;\n        sock->window.wnd_send->dev_rtt = devrtt;\n        double dsamplertt=(double)samplertt/(double)1000000;\n        double destmatedrtt=(double)estmatedrtt/(double)1000000;\n        double ddevrtt=(double)devrtt/(double)1000000;\n        double dtimegap=(double)(estmatedrtt + 4 * devrtt)/(double)1000000;\n        \n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt = 1;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n        ``````\n        ``````\n        ``````\n    }\n}\n```\n### 快速重传\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/cj2PfZsz8abBVW9.png\" width=\"60%\" />\n\nFigure 1. 快速重传\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )` 函数中添加快速重传的实现。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) == sock->window.wnd_send->base){ //冗余ACK\n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt++;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n        if(sock->window.wnd_send->ack_cnt == 3){ //快速重传 \n            ``````\n            uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n            uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n            uint8_t flag = ACK_FLAG_MASK;\n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, pkt_len, ACK_FLAG_MASK, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n            sendToLayer3(ACK, pkt_len);\n            sock->window.wnd_send->ack_cnt = 0;\n            gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);            \n        }\n        return;\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n## 流量控制\n### 接收方计算接受缓冲区大小\n**1. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){// 服务端处理数据包\n    ``````\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_recv->expect_seq;\n    uint8_t flag = ACK_FLAG_MASK;\n    char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n    ``````\n}\n```\n### 发送方调整发送缓冲区大小\n**1. clientrdt( )**\n`clientrdt( )`函数确定window_size大小。\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){\n    ``````\n    ``````get_advertised_window(pkt)``````\n    ``````\n}\n```\n**2. get_advertised_window( )**\n```C\nuint16_t get_advertised_window(char* msg){\n    int offset = 17;\n    uint16_t var;\n    memcpy(&var, msg+offset, SIZE16);\n    return ntohs(var);\n}\n```\n### 0窗口探测\n**1. send_pkt( )**\n`send_pkt( )`发送数据的线程中加入一个判断条件。\n0窗口探测用于在ADVERTISED WINDOW为0的情况下，发送大小为1的数据报文以获得实时的窗口返回值。  \n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    ``````\n    if((sock->window.wnd_send->nextseq > sock->window.wnd_send->base)&&sock->window.wnd_send->rwnd == 0){\n        len = 1;\n    }\n    if (len > 0){\n        ``````\n        ``````\n        ``````        \n    }\n    ``````\n}\n```\n## 拥塞控制\n### 慢启动\n**1. 套接字的初始化使得发送方从其他状态进入慢启动状态。**\n```C\ntju_tcp_t* tju_socket(){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n**2. `resend_pkt( )`函数超时事件使得发送方从其他状态进入慢启动状态。**\n```C\nif (nowtimeval > timeoutval){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n在慢启动状态下，发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS（MAX_DLEN）。虽然是不断的自增 MSS，但是由于拥塞窗口的增大（进而导致发送窗口的增大），每次自增的次数为 1->2->4->8 直至达到ssthresh，所以拥塞窗口整体上呈现指数增长的趋势。\n**3. clientrdt( )**\n`clientrdt( )` 函数中发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS。\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //慢启动\n        ``````    \n        else if(get_ack(pkt) > sock->window.wnd_send->base){ // new ack\n            sock->window.wnd_send->cwnd += MSS;\n            \n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            ``````\n        }\n        ``````\n    }\n    ``````\n}\n```\n**4. resend_pkt( )**\n`resend_pkt( )` 函数中处理超时重传导致慢启动参数变化。\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    ``````\n    if (nowtimeval > timeoutval){\n        sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2; //拥塞阈值变成拥塞窗口大小的一半\n        if(sock->window.wnd_send->ssthresh < MAX_DLEN) sock->window.wnd_send->ssthresh = MSS; //调整\n        sock->window.wnd_send->cwnd = MSS; //拥塞窗口变成1MSS\n        sock->window.wnd_send->congestion_status = SLOW_START; //拥塞状态不变\n    }\n    ``````\n}\n```\n### 拥塞避免\n**1. 拥塞窗口超过 ssthresh 进入拥塞避免状态。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //慢启动\n        ``````\n        if(sock->window.wnd_send->cwnd >= sock->window.wnd_send->ssthresh){ //cwnd达到ssthresh，转为拥塞避免状态\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n        ``````\n    }\n    ``````\n}\n```\n**2. 快速恢复阶段收到正确的 ACK 使得发送方从其他状态进入拥塞避免状态。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //快速恢复\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n          \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n}\n```\n**3. 在拥塞避免状态下，发送方每当收到一个正确的 ACK 报文，拥塞窗口就会增大（1/cwnd）个 MSS。拥塞窗口整体上呈现线性增长的趋势。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    else if (sock->window.wnd_send->congestion_status == CONGESTION_AVOIDANCE) { //拥塞避免\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd += MSS * ((double)MSS / (double)sock->window.wnd_send->cwnd);\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n        }\n    }\n    ``````\n}\n```\n### 快速恢复\n**1. `clientrdt( )` 发送方收到 3 个冗余 ACK 时，进入快速恢复状态。**\n```C\nif(sock->window.wnd_send->ack_cnt == 3){  //快速重传\n    sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2;\n    sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh + 3 * MSS;\n    sock->window.wnd_send->congestion_status = FAST_RECOVERY; //快速恢复\n    ``````\n}\n```\n**2. 在快速恢复状态下，如果还是收到冗余 ACK，那么依然在此状态，cwnd+=MSS；当收到正确 ACK 时，则进入拥塞避免状态 ，cwnd=ssthresh；当超时时，回到慢启动，cwnd=1MSS。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    ``````\n    ``````    \n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //快速恢复\n        if(get_ack(pkt) == sock->window.wnd_send->base){//dup ack\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt++;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n            sock->window.wnd_send->cwnd += MSS;\n                        \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = FAST_RECOVERY;\n            return;\n        }\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));  \n         \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n    ``````\n    ``````\n}\n```","tags":["实践","计算机网络"]},{"title":"C语言手写Httpd网站服务器","url":"/post/c29c4a94.html","content":"\n---\n## 执行WEB服务前的准备工作\n### 创建项目\n```C\n#include <stdio.h>\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port){\n    return 0;\n}\n\nint main(void){\n    //httpd默认的端口是80，这里指定了8000端口，也可以使用其它端口\n    unsigned short port = 8000;\n\n    // 初始化网络，并使用指定端口来创建服务端的套接字\n    int server_sock = startup(&port);\n    printf(\"httpd running on port %d\\n\", port);\n\n    return(0);\n}\n```\n### 网络通信初始化\n```C\n//网络通信需要包含的头文件、需要加载的库文件\n#include <winsock2.h>\n#pragma comment (lib, \"WS2_32.lib\")\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    WSADATA wsaData; // 网络通信相关的版本等信息\n    int ret = WSAStartup( // WSAStartup 网络通信初始化，\n        MAKEWORD(1, 1),   // 指定使用Windows Sockets规范的1.1版本\n        &wsaData);        // 存储初始化后的版本等信息结果\n    if (ret) {\n        return -1;\n    }\n\n    return 0;\n}\n```\n### 创建套接字\n```C\nvoid error_die(const char* sc) {\n    perror(sc); //打印错误原因\n    exit(1);\n}\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    int server_socket = socket(PF_INET, //套接字的类型（网络套接字、文件套接字，此处是前者）\n        SOCK_STREAM,  //数据包的类型（数据流、数据报，此处是前者）               \n        IPPROTO_TCP); //具体协议\n    if (server_socket == -1) { //打印错误提示，并结束程序\n        error_die(\"socket\");\n    }\n}\n```\n### 设置套接字属性--端口可复用\n```C\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    //设置端口可复用（端口复用）\n    int opt = 1;\n    ret = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n    if (ret == -1) {\n        error_die(\"setsockopt\");\n    }\n}\n```\n### 绑定套接字和网络地址\n```C\nint startup(unsigned short* port) {\n    //配置服务器的网络地址\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(*port);\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    //绑定套接字\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        error_die(\"[bind]\");\n    }\n}\n```\n### 获取动态端口\n```C\nint startup(unsigned short* port) {\n    // 动态分配端口\n    if (*port == 0) {\n        int namelen = sizeof(server_addr);\n        if (getsockname(server_socket, (struct sockaddr*)&server_addr, &namelen) <0) {\n            error_die(\"getsockname\");\n        }\n        *port = ntohs(server_addr.sin_port);\n    }\n    return server_socket;\n}\n```\n### 创建监听队列\n```C\nint startup(unsigned short* port) {\n    //创建监听队列\n    if (listen(server_socket, 5) < 0) {\n        error_die(\"listen\");\n    }\n    return server_socket;\n}\n```","tags":["c","服务器"]},{"title":"C语言手写植物大战僵尸","url":"/post/7d572acd.html","content":"\n---\n## C语言手写植物大战僵尸\n### 创建主场景\n```C\n#include<stdio.h>\n#include<graphics.h>\n\n#define WIN_WIDTH 900\n#define WIN_HEIGHT 600\n\nIMAGE imgBg;\n\n//游戏初始化\nvoid gameInit() {\n\tloadimage(&imgBg, \"res/bg.jpg\");\n\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT);\n}\n\n//更新窗口\nvoid updateWindow() {\n\tputimage(0, 0, &imgBg);\n}\n\nint main(void) {\n\t//游戏初始化\n\tgameInit();\n\n\t//更新窗口\n\tupdateWindow();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物卡牌\n```C\n#include \"tools.h\"\n\n//#define ZHI_WU_CUNT 3\n\nenum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT };\n\nIMAGE imgBar;\nIMAGE imgCards[ZHI_WU_COUNT];\n\nvoid gameInit() {\n\tloadimage(&imgBar, \"res/bar.png\");\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\t//生成植物卡牌的文件名\n\t\tsprintf_s(name, sizeof(name), \"res/Cards/card_%d.png\", i + 1);\n\t\tloadimage(&imgCards[i], name);\n\t}\n}\n\nvoid updateWindow() {\n\t//putimage(250, 0, &imgBar); //有黑边\n\tputimagePNG(250, 0, &imgBar);\n\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tint x = 338 + i * 65;\n\t\tint y = 6;\n\t\tputimage(x, y, &imgCards[i]);\n\t}\n}\n```\n### 实现植物的选择和拖动\n```C\nIMAGE* imgZhiWu[ZHI_WU_COUNT][20];\n\nint curX, curY; //当前选中的植物，在移动过程中的位置\nint curZhiWu; //0:没有选中，1:选择了第一种植物 etc.\n\nbool fileExist(const char* name) {\n\tFILE* fp = fopen(name, \"r\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfclose(fp);\n\t\treturn true;\n\t}\n}\n\nvoid gameInit() {\n\tmemset(imgZhiWu, 0, sizeof(imgZhiWu));\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tsprintf_s(name, sizeof(name), \"res/zhiwu/%d/%d.png\", i, j + 1);\n\t\t\t//先判断这个文件是否存在\n\t\t\tif (fileExist(name)) {\n\t\t\t\timgZhiWu[i][j] = new IMAGE;\n\t\t\t\tloadimage(imgZhiWu[i][j], name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurZhiWu = 0;\n\t//创建游戏的图形窗口\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT, 1); //加一个参数1，保留后台界面，方便调试\n}\n\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲（先打印到内存中）\n\n\t//渲染 拖动过程中的植物\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲（再一次性打印到窗口）\n}\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;//状态变量（先点击再拖动）\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\t\t\t\tint index = (msg.x - 338) / 65; //选择卡牌序号\n\t\t\t\tprintf(\"%d\\n\", index);\n\t\t\t\tstatus = 1; //可以拖动\n\t\t\t\tcurZhiWu = index + 1;\n\t\t\t}\n\t\t}\n\t\telse if (msg.message == WM_MOUSEMOVE && status == 1) { //鼠标移动\n\t\t\tcurX = msg.x;\n\t\t\tcurY = msg.y;\n\n\t\t}\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\n\t\t}\n\t}\n\n}\nint main(void) {\n\tgameInit();\n\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物的种植\n```C\nstruct zhiwu {\n\tint type;\t\t//0:没有选中，1:第一种植物\tetc.\t\t\t\t\n\tint frameIndex; //序列帧的序号\n};\n\nstruct zhiwu map[3][9];\n\nvoid gameInit() {\n\tmemset(map, 0, sizeof(map));\n}\n\nvoid updateWindow() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tint x = 256 + j * 81;\n\t\t\t\tint y = 179 + i * 102 + 14;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tputimagePNG(x, y, imgZhiWu[zhiWuType][index]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid userClick() {\n\tif (peekmessage(&msg)) {\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\t\t\tif (msg.x > 256 && msg.y > 179 && msg.y < 489) {\n\t\t\t\tint row = (msg.y - 179) / 102;\n\t\t\t\tint col = (msg.x - 256) / 81;\n\t\t\t\t//printf(\"%d, %d\\n\", row, col);\n\t\t\t\tif (map[row][col].type == 0) {\n\t\t\t\t\tmap[row][col].type = curZhiWu;\n\t\t\t\t\tmap[row][col].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurZhiWu = 0;\n\t\t\tstatus = 0;\n\t\t}\n\t}\n}\n```\n### 实现植物的摇摆\n```C\n//更新游戏相关数据\nvoid updateGame() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tmap[i][j].frameIndex++;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tif (imgZhiWu[zhiWuType][index] == NULL) {\n\t\t\t\t\tmap[i][j].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t\tupdateGame(); //更新游戏相关数据\n\n\t\tSleep(10);//帧等待\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 优化游戏循环和游戏渲染循序\n```C\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲\n\n\t//渲染 拖动过程中的植物（放到了最后）\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲\n}\n\nint main(void) {\n\tgameInit();\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 制作启动菜单\n```C\nvoid startUI() { //启动菜单\n\tIMAGE imgBg,imgMenu1,imgMenu2;\n\tloadimage(&imgBg, \"res/menu.png\");\n\tloadimage(&imgMenu1, \"res/menu1.png\");\n\tloadimage(&imgMenu2, \"res/menu2.png\");\n\n\tint flag = 0;\n\twhile (1) {\n\t\tBeginBatchDraw();\n\t\tputimage(0, 0, &imgBg);\n\t\tputimagePNG(474, 75, flag ? &imgMenu2: &imgMenu1);\n\n\t\tExMessage msg;\n\t\tif (peekmessage(&msg)) {\n\t\t\tif (msg.message == WM_LBUTTONDOWN&&\n\t\t\t\t\tmsg.x>474&&msg.x<474+300&&\n\t\t\t\t\tmsg.y>75&&msg.y<75+140){\n\t\t\t\tflag = 1;\n\t\t\t\t//EndBatchDraw();\n\t\t\t}\n\t\t\telse if (msg.message == WM_LBUTTONUP&&flag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEndBatchDraw();\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\n\tstartUI();\n\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\n\t\tSleep(10);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 创建随机阳光\n```C\n#include<time.h>\n\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n};\n\n//阳光池\nstruct sunshineBall balls[10];\nIMAGE imgSunshineBall[29];\n\n\nvoid gameInit() {\n\tmemset(balls, 0, sizeof(balls));\n\tfor (int i = 0; i < 29; i++) {\n\t\tsprintf_s(name, sizeof(name), \"res/sunshine/%d.png\", i + 1);\n\t\tloadimage(&imgSunshineBall[i], name);\n\t}\n\n\t//配置随机种子\n\tsrand(time(NULL));\n}\n\nvoid creatSunshine() {\n\tstatic int count = 0;\n\tstatic int fre = 400;\n\tcount++;\n\tif (count >= fre) { //每fre帧创建一个阳光，fre随机改变\n\t\tfre = 200 + rand() % 200;\n\t\tcount = 0;\n\n\t\t//从阳光池中取一个可以使用的\n\t\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\n\t\tint i;\n\t\tfor (i = 0; i < ballMax && balls[i].used; i++);\n\t\tif (i >= ballMax) return;\n\n\t\tballs[i].used = true;\n\t\tballs[i].frameIndex = 0;\n\t\tballs[i].x = 260 + rand() % (900 - 260);\n\t\tballs[i].y = 60;\n\t\tballs[i].destY = 200 + (rand() % 4) * 90;\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine();\n}\n```\n### 显示随机阳光\n```C\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n\tint timer; //计时器\n};\n\nvoid updateWindow() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tIMAGE* img = &imgSunshineBall[balls[i].frameIndex];\n\t\t\tputimagePNG(balls[i].x, balls[i].y, img);\n\t\t}\n\t}\n}\n\t\nvoid creatSunshine() {\n\tif (count >= fre) {\n\t\tballs[i].timer = 0;\n\t}\n}\n\nvoid updateSunshine() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tballs[i].frameIndex = (balls[i].frameIndex + 1) % 29;\n\t\t\tif (balls[i].timer == 0) { //未到达地面\n\t\t\t\tballs[i].y += 2;\n\t\t\t}\n\t\t\tif (balls[i].y >= balls[i].destY) {\n\t\t\t\t//balls[i].used = false;\n\t\t\t\tballs[i].timer++;\n\t\t\t\tif (balls[i].timer > 100) { //掉到地面100帧之后\n\t\t\t\t\tballs[i].used = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine(); //创建阳光\n\tupdateSunshine(); //更新阳光的状态\n}\n```\n### 收集阳光、显示阳光值\n```C\n#include<mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\nint sunshine; //总阳光值\n\nvoid gameInit() {\n\tsunshine = 150;\n\n\t//设置字体\n\tLOGFONT f;\n\tgettextstyle(&f);                     // 获取当前字体设置\n\tf.lfHeight = 30;                      // 设置字体高度为 48\n\tf.lfWidth = 15;\n\tstrcpy(f.lfFaceName, \"Segoe UI Black\"); \n\tf.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  \n\tsettextstyle(&f);                     // 设置字体样式\n\tsetbkmode(TRANSPARENT);\t\t\t\t  //背景模式透明\n\tsetcolor(BLACK);\t\t\t\t\t  //字体颜色\n}\n\nvoid updateWindow() {\n\tchar scoreText[8];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", sunshine);\n\touttextxy(276, 67, scoreText); //在指定位置输出文本--分数\n}\n\nvoid collectSunshine(ExMessage* msg) {\n\tint count = sizeof(balls) / sizeof(balls[0]);\n\tint w = imgSunshineBall[0].getwidth(); //阳光球宽度\n\tint h = imgSunshineBall[0].getheight();//阳光球高度\n\tfor (int i = 0; i < count; i++) {\n\t\tif (balls[i].used) {\n\t\t\tint x = balls[i].x;\n\t\t\tint y = balls[i].y;\n\t\t\tif (msg->x > x && msg->x < x + w && msg->y > y && msg->y < y + h) {\n\t\t\t\tballs[i].used = false;\n\t\t\t\tsunshine += 25;\n\t\t\t\tmciSendString(\"play res/sunshine.mp3\", 0, 0, 0); //添加音效\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollectSunshine(&msg);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```","tags":["c","PvZ"]},{"title":"Java 综合实战（一）","url":"/post/70803326.html","content":"\n---\n## Java 综合实战（一）\n### 健康计算器\n**需求：开发一个简单的健康计算器应用程序，它可以接受用户的输入（如年龄、性别、体重、身高），并计算出用户的 BMI（身体质量指数）和 BMR（基础代谢率）。**\n```Java\npackage test;\n\nimport java.util.Scanner;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请您输入您的身高：\");\n        double height=sc.nextDouble();\n\n        System.out.println(\"请您输入您的体重：\");\n        double weight=sc.nextDouble();\n\n        System.out.println(\"请您输入您的性别（男/女）：\");\n        String sex=sc.next();\n\n        System.out.println(\"请您输入您的年龄：\");\n        int age=sc.nextInt();\n\n        double bmi=calcBMI(height,weight);\n        System.out.println(\"您的BMI值为：\"+bmi);\n\n        double bmr=calcBMR(height,weight,age,sex);\n        System.out.println(\"您的BMR值为：\"+bmr);\n    }\n\n    public static double calcBMI(double height,double weight){\n        return weight/(height*height);\n    }\n\n    public static double calcBMR(double height,double weight,int age,String sex){\n        double bmr=0;\n        if(sex.equals(\"男\")){\n            bmr=88.362+13.397*weight+4.799*height-5.677*age;\n        }\n        else{\n            bmr=447.593+9.247*weight+3.098*height-4.330*age;\n        }\n        return bmr;\n    }\n}\n```\n### 简单计算器\n**需求：设计一个可以执行基本数学运算（加、减、乘、除）的计算器程序。** \n**功能描述：用户输入两个数字、一个运算符（+、-、*、/）。根据所选运算符执行相应的数学运算，显示运算结果。**\n```Java\npackage test1;\n\nimport java.util.Scanner;\n\npublic class test1 {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请输入第一个数字：\");\n        double num1=sc.nextDouble();\n\n        System.out.println(\"请输入第二个数字：\");\n        double num2=sc.nextDouble();\n\n        System.out.println(\"请输入运算符（+、-、*、/）：\");\n        String operator=sc.next();\n\n        double result=calculate(num1,num2,operator);\n        System.out.println(\"计算结果为：\"+result);\n    }\n\n    public static double calculate(double num1,double num2,String operator){\n        double result=0;\n        switch (operator){\n            case \"+\":\n                result=num1+num2;\n                break;\n            case \"-\":\n                result=num1-num2;\n                break;\n            case \"*\":\n                result=num1*num2;\n                break;\n            case \"/\":\n                result=num1/num2;\n                break;\n            default:\n                System.out.println(\"输入的运算符有误！\");\n        }\n        return result;\n    }\n}\n```\n### 猜数字小游戏\n**需求：随机生成一个1-100之间的数据，提示用户猜测，猜大提示过大，猜小提示过小，直到猜中结束游戏。**\n```Java\npackage test1;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class test2 {\n    public static void main(String[] args) {\n        guessNumber();\n    }\n\n    public static void guessNumber(){\n        /*方法一*/\n        //Math.random()返回[0,1)之间的随机小数\n        //(int)(Math.random()*100)==>[0,100)的整数==>[0,99]+1==>[1,100]\n        //int number=(int)(Math.random()*100)+1;\n\n        /*方法二*/\n        Random r=new Random();\n        int number=r.nextInt(100)+1;\n\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            System.out.println(\"请输入一个1~100之间的数字：\");\n            int guess=sc.nextInt();\n            if(guess<number){\n                System.out.println(\"猜小了，再试试吧！\");\n            }\n            else if(guess>number){\n                System.out.println(\"猜大了，再试试吧！\");\n            }\n            else{\n                System.out.println(\"恭喜你猜对了！\");\n                break;\n            }\n        }\n    }\n}\n```\n### 开发一个验证码\n**需求：开发一个程序，可以生成指定位数的验证码，每位可以是数字，大小写字母。**\n```Java\npackage test1;\n\npublic class test3 {\n    public static void main(String[] args) {\n        System.out.println(getCode(6));\n    }\n\n    public static String getCode(int n){\n        String code=\"\";\n\n        for(int i=0;i<n;i++){\n            int type=(int)(Math.random()*3); //数字0/大写1/小写2\n            \n            switch(type){\n                case 0:\n                    int num=(int)(Math.random()*10);\n                    code+=num;\n                    break;\n                case 1:\n                    int num1=(int)(Math.random()*26)+65;\n                    code+=(char)num1;\n                    break;\n                case 2:\n                    int num2=(int)(Math.random()*26)+97;\n                    code+=(char)num2;\n                    break;\n            }\n        }\n        return code;\n    }\n}\n```\n### 找素数\n**需求：输出101-200之间的所有素数以及总个数。**\n```Java\npackage test1;\n\npublic class test4 {\n    public static void main(String[] args) {\n        //目标：找出101-200之间的全部素数\n        int count=0;\n        for(int i=101;i<=200;i++){\n            if(isPrime(i)){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println(\"素数的个数为：\"+count);\n    }\n\n    public static boolean isPrime(int num){\n        for(int i=2;i*i<=num;i++){\n            if(num%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n### 斗地主游戏\n**需求：开发一个简易版的斗地主游戏，要求只完成做牌（存储54张牌）、洗牌。**\n```Java\npackage test2;\n\npublic class test1 {\n    public static void main(String[] args) {\n       start();\n    }\n    public static void start(){\n        String[] poker=new String[54];\n        String[] colors={\"♠\",\"♥\",\"♣\",\"♦\"};\n        String[] nums={\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"};\n\n        int index=0;\n        for(int i=0;i<colors.length;i++){\n            for(int j=0;j<nums.length;j++){\n                poker[index++]=colors[i]+nums[j];\n            }\n        }\n        poker[index++]=\"Big Joker\";\n        poker[index++]=\"Small Joker\";\n\n        //打印牌\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n\n        //洗牌\n        for(int i=0;i<poker.length;i++){\n            int j=(int)(Math.random()*poker.length);\n            String temp=poker[i];\n            poker[i]=poker[j];\n            poker[j]=temp;\n        }\n\n        System.out.println(\"洗牌后：\");\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n    }\n}\n```\n### 石头迷阵游戏\n**需求：只需完成数据初始化**\n```Java\npackage test2;\n\npublic class test2 {\n    public static void main(String[] args) {\n        start(5);\n    }\n    public static void start(int n) {\n       int[][] arr=new int[n][n];\n\n       int count=1;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               arr[i][j]=count++;\n           }\n       }\n\n       print(arr);\n\n       //打乱二维数组中的元素顺序\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                int x=(int)(Math.random()*arr.length);\n                int y=(int)(Math.random()*arr[i].length);\n                int temp=arr[i][j];\n                arr[i][j]=arr[x][y];\n                arr[x][y]=temp;\n            }\n        }\n        System.out.println(\"------------------\");\n        System.out.println(\"打乱后：\");\n        print(arr);\n    }\n    public static void print(int[][] arr){\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                System.out.print(arr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```","tags":["Java"]},{"title":"Markdown 语法","url":"/post/78e09c9c.html","content":"\n## Markdown 标题\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n```\n&nbsp;**或者在文本下方添加任意数量的 = 或 - 分别用于表示一级标题或二级标题**\n``` markdown\n一级标题\n=========\n\n二级标题\n---------\n```\n\n## Markdown 字体\n``` markdown\n*斜体文字*\n\n_斜体文字_\n\n**粗体文字**\n\n__粗体文字__\n\n***粗斜体文字***\n\n___粗斜体文字___\n```\n\n## Markdown 引用\n``` markdown\n>这是引用的内容\n\n>>这是引用的内容\n\n>>>>>>>>>>这是引用的内容\n```\n\n## Markdown 分割线\n&nbsp;**三个或者三个以上的 - 或者 * 或者 _ 都可以**\n``` markdown\n---\n\n****\n\n____\n```\n  \n## Markdown 下划线\n``` markdown\n<u>带下划线文本</u>   \n```\n\n## Markdown 删除线\n``` markdown \n~~tencent.com~~\n```\n\n## Markdown 图片\n### 插入互联网上图片\n``` markdown\n![图片描述](图片链接 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n### 插入本地图片\n``` markdown\n![图片描述](图片本地路径 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n## Markdown 超链接\n``` markdown\n[超链接名](超链接地址 \"超链接title\")\n```\n&nbsp;**注：title可加可不加**\n\n## Markdown 列表\n### 无序列表\n&nbsp;**无序列表用 - + * 任何一种都可以**\n``` markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n### 有序列表\n``` markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n### 嵌套列表\n&nbsp;**上一级和下一级之间敲一个Tab键即可**\n``` markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n## Markdown 表格\n``` markdown\n|表头|表头|表头|\n|---|:--:|---:|\n|内容|内容|内容|\n|内容|内容|内容|\n```\n\n>第二行分割表头和内容\n>-有一个就行，为了对齐，多加了几个\n>文字默认居左\n>-两边加：表示文字居中\n>-右边加：表示文字居右\n\n## Markdown 代码\n### 单行代码\n``` markdown\n`hello world`\n```\n\n### 代码块\n``` markdown\n(```)语言\n  代码内容\n(```)\n```\n\n## Markdown 流程图\n``` markdown\n(```)flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n(```)\n```\n## Markdown 换行\n``` markdown\n连续两个以上空格+回车\n```\n&nbsp;**或者**\n``` markdown\n使用html语言换行标签<br>\n```\n\n## Markdown 缩进字符\n``` markdown\n&nbsp;  缩进1/4中文\n&ensp;  缩进半个中文，一个字符\n&emsp;  缩进一个中文，2个字符\n```","tags":["Markdown"]},{"title":"Hello World","url":"/post/4a17b156.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]