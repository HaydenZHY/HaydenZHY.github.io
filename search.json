[{"title":"æ•°æ®åº“å®è·µ","url":"/2024/12/06/æ•°æ®åº“å®è·µ/","content":"---\n- å¤©æ´¥å¤§å­¦ 2024 æ•°æ®åº“è¯¾ç¨‹å®è·µ\n- Lab Memberï¼šæµ·æ£ æœªé›¨ï¼Œæ¢¨èŠ±å…ˆé›ªï¼Œæµè¤æŸ“å¤\n- æœ€ç»ˆæˆç»© +âˆ åˆ†æ ğŸ˜‹\n---","tags":["æ•°æ®åº“","å®è·µ"]},{"title":"ICPCç®—æ³•æ¨¡ç‰ˆ","url":"/2024/11/29/ICPCç®—æ³•æ¨¡ç‰ˆ/","content":"# Part 1. æ•°æ®ç»“æ„\n\n## 1.çº¿æ®µæ ‘ï¼ˆSegment Trees)\n\nå…³é”®è¯ï¼šå®šé•¿åºåˆ—æ“ä½œï¼ŒåŒºé—´ä¿®æ”¹ä¸æŸ¥è¯¢ã€‚\n\n**ACLibraryå¯¹æ‡’æ ‡è®°çº¿æ®µæ ‘é€‚é…çš„å®šä¹‰ï¼Œä¸æ¶‰åŠåŒºé—´æ‡’æ ‡è®°çš„æ™®é€šçº¿æ®µæ ‘æ²¡æœ‰$F$çš„é™åˆ¶ï¼š**\n\nIt is the data structure for the pair of a monoid $(<S, \\cdot>: S \\cdot S \\to S, e \\in S)$ and a set $F$ of $S \\to S$â€‹ mappings that satisfies the following properties.\n\n1. $F$ contains the identity map $\\mathrm{id}$, where the identity map is the map that satisfies $\\mathrm{id}(x) = x$ for all $x \\in S$.\n2. $F$ is closed under composition, i.e., $f \\circ g \\in F$ holds for all $f, g \\in F$â€‹.\n3. $f(x \\cdot y) = f(x) \\cdot f(y)$ holds for all $f \\in F$ and $x, y \\in S$.\n\nGiven an array $S$ of length $N$, it processes the following queries in $O(\\log N)$ time. \n\n1. Acting the map $f\\in F$ (cf. $x = f(x)$) on all the elements of an interval\n2. Calculating the product of the elements of an interval\n\n**ä¸­æ–‡ç¿»è¯‘ï¼š**\n\næ‡’æ ‡è®°çº¿æ®µæ ‘æ˜¯é€‚é…äºæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„***å¹ºåŠç¾¤***$(<S, \\cdot>: S \\cdot S \\to S, e \\in S)$å’Œå±äº***çº¿æ€§ç©ºé—´*** $V:S\\to S$çš„å­ç©ºé—´$F$:\n\n1. $F$æœ‰å•ä½æ˜ å°„$f\\in F,s.t.\\ \\forall x\\in S, f(x)=x$\n2. ä»£æ•°ç³»ç»Ÿ$<F,\\circ>$å°é—­ï¼Œå…¶ä¸­$\\circ$è¡¨å‡½æ•°å¤åˆï¼Œä¸æ»¡è¶³äº¤æ¢å¾‹ï¼Œå¤åˆé¡ºåºä»å³åˆ°å·¦ï¼Œå³$(f\\circ g)(x)=f(g(x))$â€‹\n3. $F$å¿…é¡»æ˜¯çº¿æ€§ç©ºé—´ï¼Œå³$\\forall f \\in F,$ $\\forall x, y \\in S, $  $f(x \\cdot y) = f(x) \\cdot f(y)$â€‹.\n\nç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$N$çš„$S$ç±»å‹çš„æ•°ç»„ï¼Œè¦æ±‚åœ¨$O(log\\ N)$çš„æ—¶é—´å†…å®Œæˆä»¥ä¸‹ç±»å‹æ“ä½œï¼š\n\n1. å¯¹ä¸€ä¸ªæˆ–è€…ä¸€æ®µåŒºé—´çš„å€¼åº”ç”¨çº¿æ€§æ˜ å°„$f$â€‹ï¼Œå¹¶æ”¹ä¸ºå¯¹åº”ç»“æœã€‚\n\n   $\\forall x_i\\in S,\\ i\\in[l,r), \\ x_i:=f(x_i)$\n\n2. æ±‚ä¸€ä¸ªæˆ–è€…ä¸€æ®µåŒºé—´çš„å€¼å¯¹å¹ºåŠç¾¤ä¹˜æ³• ï¼ˆ$\\cdot$ï¼‰ è¿ç®—çš„ç»“æœã€‚\n   $$\n   \\large ans=\\prod_{i=l}^r x_i \\in S\n   $$\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.1 æ™®é€šçº¿æ®µæ ‘ï¼ˆé™æ€å¼€ç‚¹åŒºé—´åŠ ï¼Œæ°¸ä¹…åŒ–æ‡’æ ‡è®°ï¼Œå½“å¿ƒçˆ†æ ‡è®°é—®é¢˜ï¼Œç é‡å°ï¼‰\n\n**åˆ‡è®°å•ç‚¹ä¿®æ”¹çš„if-elseå¿…é¡»å†™å…¨ï¼ï¼ï¼**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int sum;\n    int lazy;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nvoid update(int pos, int val, int rt, int cl, int cr)\n{\n    tree[rt].sum += val;\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(pos, val, rt << 1, cl, mid);\n    else\n        update(pos, val, rt << 1 | 1, mid + 1, cr);\n    return;\n}\nvoid update(int l, int r, int val, int rt, int cl, int cr)\n{\n    tree[rt].sum += val * (min(r, cr) - max(l, cl) + 1);\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].lazy += val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, val, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, val, rt << 1 | 1, mid + 1, cr);\n}\nint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    int res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res + tree[rt].lazy * (min(r, cr) - max(l, cl) + 1);\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        update(i, x, 1, 1, n);\n    }\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, n);\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.2 æ™®é€šçº¿æ®µæ ‘(é™æ€å¼€ç‚¹åŒºé—´åŠ ï¼Œæ ‡è®°æ°¸ä¹…åŒ–)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int sum;\n    int lazy;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nint a[maxn];\nvoid pushup(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid pushdown(int rt, int cl, int cr)\n{\n    int mid = (cl + cr) >> 1;\n    if (tree[rt].lazy)\n    {\n        tree[rt << 1].lazy += tree[rt].lazy;\n        tree[rt << 1 | 1].lazy += tree[rt].lazy;\n        tree[rt << 1].sum += tree[rt].lazy * (mid - cl + 1);\n        tree[rt << 1 | 1].sum += tree[rt].lazy * (cr - mid);\n        tree[rt].lazy = 0;\n    }\n    return;\n}\nvoid build(int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt] = {a[cl], 0};\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    build(rt << 1, cl, mid);\n    build(rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nvoid update(int pos, int val, int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt].sum += val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(pos, val, rt << 1, cl, mid);\n    else\n        update(pos, val, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nvoid update(int l, int r, int val, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].sum += val * (cr - cl + 1);\n        tree[rt].lazy += val;\n        return;\n    }\n    pushdown(rt, cl, cr);\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, val, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, val, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    pushdown(rt, cl, cr);\n    int res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        update(i, x, 1, 1, n);\n    }\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, n);\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.3 æ™®é€šçº¿æ®µæ ‘ï¼ˆé™æ€åŒºé—´åŠ ã€åŒºé—´ä¹˜ï¼Œéæ°¸ä¹…åŒ–ï¼‰\n\nè´´å‡ºæ¥è®°å¾—æ‡’æ ‡è®°é¡ºåºæ€è€ƒé—®é¢˜ã€‚æ³¨æ„ï¼Œæ‡’æ ‡è®°ä¸‹ä¼ çš„æ—¶å€™æ˜¯$f_{rt}\\ \\circ \\ f_{sons}$çš„å¤åˆå‡½æ•°é¡ºåºã€‚æ ¹æ®Segtrees.hæ€æƒ³æ€è€ƒã€‚\n\n```cpp\n#include <bits/stdc++.h>\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nusing namespace std;\n#define int long long\nusing mint = MLong<0>;\nstruct node\n{\n    mint sum;\n    mint lazyadd = 0;\n    mint lazymul = 1;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 2];\nmint a[maxn];\nvoid pushup(int rt)\n{\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid pushdown(int rt, int cl, int cr)\n{\n    // å„¿å­èŠ‚ç‚¹å·²æœ‰ax+b,ä¼ ä¸‹æ¥c(ax+b)+d=cax+cb+d);\n    int mid = (cl + cr) >> 1;\n    if (tree[rt].lazyadd != 0 || tree[rt].lazymul != 1)\n    {\n        tree[rt << 1].lazyadd *= tree[rt].lazymul;\n        tree[rt << 1].lazyadd += tree[rt].lazyadd;\n\n        tree[rt << 1 | 1].lazyadd *= tree[rt].lazymul;\n        tree[rt << 1 | 1].lazyadd += tree[rt].lazyadd;\n\n        tree[rt << 1].lazymul *= tree[rt].lazymul;\n        tree[rt << 1 | 1].lazymul *= tree[rt].lazymul;\n\n        tree[rt << 1].sum = tree[rt << 1].sum * tree[rt].lazymul + tree[rt].lazyadd * (mid - cl + 1);\n        tree[rt << 1 | 1].sum = tree[rt << 1 | 1].sum * tree[rt].lazymul + tree[rt].lazyadd * (cr - mid);\n        tree[rt].lazyadd = 0;\n        tree[rt].lazymul = 1;\n    }\n\n    return;\n}\nvoid build(int rt, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        tree[rt].sum = a[cl];\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    build(rt << 1, cl, mid);\n    build(rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nvoid update(int l, int r, int add, int mul, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].sum *= mul;\n        tree[rt].sum += add * (cr - cl + 1);\n\n        tree[rt].lazyadd *= mul;\n        tree[rt].lazyadd += add;\n\n        tree[rt].lazymul *= mul;\n\n        return;\n    }\n    pushdown(rt, cl, cr);\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        update(l, r, add, mul, rt << 1, cl, mid);\n    if (r > mid)\n        update(l, r, add, mul, rt << 1 | 1, mid + 1, cr);\n    pushup(rt);\n}\nmint query(int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        return tree[rt].sum;\n    }\n    pushdown(rt, cl, cr);\n    mint res = 0;\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        res += query(l, r, rt << 1, cl, mid);\n    if (r > mid)\n        res += query(l, r, rt << 1 | 1, mid + 1, cr);\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    int m;\n    cin >> m;\n    mint::setMod(m);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        if (op == 1)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, 0, d, 1, 1, n);\n            /*for (int i = 1; i <= n; i++)\n            {\n                cout << query(i, i, 1, 1, n) << \" \";\n            }\n            cout << endl;*/\n        }\n        else if (op == 2)\n        {\n            int l, r, d;\n            cin >> l >> r >> d;\n            update(l, r, d, 1, 1, 1, n);\n            /*for (int i = 1; i <= n; i++)\n            {\n                cout << query(i, i, 1, 1, n) << \" \";\n            }\n            cout << endl;*/\n        }\n        else\n        {\n            int l, r;\n            cin >> l >> r;\n            cout << query(l, r, 1, 1, n) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.4 Segtree.h/lazy_segtree\n\nACLibraryçº¿æ®µæ ‘ï¼Œéé€’å½’æ¨¡å¼ï¼Œçº¿æ®µæ ‘ä¸‹æ ‡ä»0å¼€å§‹ã€‚ä¸‹æ–‡æ‰€æåŠåŒºé—´é»˜è®¤å·¦é—­å³å¼€ã€‚\n\nå‡½æ•°åˆ—è¡¨\n\n`bit_ceil` : å–æ¯”å‚æ•°å¤§çš„æœ€è¿‘çš„$2^n$\n\n`countr_zero` : å–å‚æ•°çš„äºŒè¿›åˆ¶ç»“å°¾æœ‰å¤šå°‘ä¸ª$0$\n\n`pushup` : å­—é¢å«ä¹‰\n\n`upd` : ä¿®æ”¹å®Œæ•´çº¿æ®µæ ‘èŠ‚ç‚¹æ‰€ä»£è¡¨åŒºé—´\n\n`pushdown` ï¼š å­—é¢å«ä¹‰\n\n`explicit lazy_segtree(const vector<S> &v)` : æ„é€ å‡½æ•°\n\n`void set(int p, S x)` : å•ç‚¹ä¿®æ”¹ä¸º$x$ï¼ˆ***å•ç‚¹æ”¹ä¸º***ï¼‰\n\n`S get(int p)` : å•ç‚¹æŸ¥è¯¢\n\n`S query(int l, int r)` : æŸ¥è¯¢åŒºé—´$[l,r)$è¿›è¡Œ$op$çš„ç»“æœ\n\n`void modify(int p, F f)` : å•ç‚¹åº”ç”¨ä¿®æ”¹ï¼ˆ***å•ç‚¹åŠ ***ï¼‰\n\n`void modify(int l, int r, F f)` : åŒºé—´$[l,r)$åº”ç”¨ä¿®æ”¹ (***åŒºé—´åŠ ***)\n\n`template <bool (*g)(S)> int max_right(int l)` : çº¿æ®µæ ‘äºŒåˆ†æŸ¥è¯¢ä»$l$å¼€å§‹çš„æœ€å³ç«¯ç‚¹$r$ï¼Œæ»¡è¶³$g(op[l,l+1,\\cdots,\\textcolor{red}{r-1}])=true$.\n\n`template <bool (*g)(S)> int min_left(int r)` : çº¿æ®µæ ‘äºŒåˆ†æŸ¥è¯¢åˆ°$r$çš„æœ€å·¦ç«¯ç‚¹$l$ï¼Œæ»¡è¶³$g(op[l,l+1,\\cdots,\\textcolor{red}{r-1}])=true$.\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Segtrees\n{\n    int bit_ceil(int n)\n    {\n        int x = 1;\n        while (x < n)\n            x *= 2;\n        return x;\n    }\n    int countr_zero(unsigned int n)\n    {\n        return __builtin_ctz(n);\n    }\n    template <class S,S (*op)(S, S),S (*e)(),class F,S (*mp)(F, S),F (*comp)(F, F),F (*id)()>\n    struct lazy_segtree\n    {\n    private:\n        int _n, size, log;\n        vector<S> d;\n        vector<F> lz;\n        void pushup(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }\n        void upd(int k, F f)\n        {\n            d[k] = mp(f, d[k]);\n            if (k < size)\n                lz[k] = comp(f, lz[k]);\n        }\n        void pushdown(int k)\n        {\n            upd(k << 1, lz[k]);\n            upd(k << 1 | 1, lz[k]);\n            lz[k] = id();\n        }\n\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        explicit lazy_segtree(int n) : lazy_segtree(vector<S>(n, e())) {}\n        explicit lazy_segtree(const vector<S> &v) : _n(int(v.size()))\n        {\n            size = bit_ceil((_n));\n            log = countr_zero(size);\n            d = vector<S>(2 * size, e());\n            lz = vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                pushup(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            return d[p];\n        }\n        /*æŸ¥è¯¢åŒºé—´[l,r)çš„ç»“æœ,l=ræ—¶è¿”å›å¹ºå…ƒ*/\n        S query(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    pushdown(l >> i);\n                if (((r >> i) << i) != r)\n                    pushdown((r - 1) >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_query() { return d[1]; }\n        void modify(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(p >> i);\n            d[p] = mp(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        void modify(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    pushdown(l >> i);\n                if (((r >> i) << i) != r)\n                    pushdown((r - 1) >> i);\n            }\n            int l2 = l, r2 = r;\n            while (l < r)\n            {\n                if (l & 1)\n                    upd(l++, f);\n                if (r & 1)\n                    upd(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    pushup(l >> i);\n                if (((r >> i) << i) != r)\n                    pushup((r - 1) >> i);\n            }\n        }\n        /*\n         * @brief çº¿æ®µæ ‘äºŒåˆ†ï¼ŒæŸ¥è¯¢åŒºé—´[l,n)æ»¡è¶³gçš„æœ€å³ç«¯ç‚¹r\n         * @tparam G æŸ¥è¯¢å‡½æ•°gï¼Œå‚æ•°ç±»å‹S\n         * @param l åŒºé—´å·¦ç«¯ç‚¹\n         * @return åŒºé—´[l,n)æ»¡è¶³g( op([l,l+1,Â·Â·Â·,r) )çš„æœ€å³ç«¯ç‚¹r\n         */\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x)\n                             { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                pushdown(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        pushdown(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x)\n                            { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                pushdown((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        pushdown(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.5 Segtree.h/segtree\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Segtrees\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        explicit segtree(int n) : segtree(vector<S>(n, e())) {}\n        explicit segtree(const vector<S> &v) : _n(v.size())\n        {\n            size = bit_ceil(_n);\n            log = countr_zero(size);\n            d = vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                pushup(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                pushup(p >> i);\n        }\n        S get(int p) const\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S query(int l, int r) const\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_query() const { return d[1]; }\n        template <bool (*f)(S)>\n        int max_right(int l) const\n        {\n            return max_right(l, [](S x)\n                             { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f) const\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)>\n        int min_left(int r) const\n        {\n            return min_left(r, [](S x)\n                            { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f) const\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        vector<S> d;\n        void pushup(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.6 çº¿æ®µæ ‘åˆå¹¶\n\nåŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘åˆå¹¶ï¼Œå¸¸å‡ºç°äºæ ‘ä¸Šé—®é¢˜ï¼Œçˆ¶äº²èŠ‚ç‚¹ç»§æ‰¿å­èŠ‚ç‚¹ä¿¡æ¯ã€‚æ ‘ä¸Šå·®åˆ†ç»“åˆçº¿æ®µæ ‘åˆå¹¶ç»´æŠ¤è·¯å¾„ä¸Šä¿¡æ¯ã€‚\n\nç¤ºä¾‹æ˜¯éæ°¸ä¹…åŒ–æ ‡è®°çš„å†™æ³•ã€‚æ ¸å¿ƒå°±è¿™ä¸€ä¸ªï¼Œå…·ä½“å¯å‚è€ƒä¸»å¸­æ ‘å†™æ³•ã€‚\n\n```cpp\nint merge(int rt1, int rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n        return rt1 | rt2;\n    if (cl == cr)\n    {\n        tree[rt1].maxnum += tree[rt2].maxnum;\n        return rt1;\n    }\n    int mid = (cl + cr) >> 1;\n    tree[rt1].l = merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    tree[rt1].r = merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    pushup(rt1);\n    return rt1;\n}\n```\n\nè£¸æ¨¡æ¿è§ä¸‹é¢çº¿æ®µæ ‘åˆ†è£‚ä¸­ï¼Œæœ‰çº¿æ®µæ ‘åˆå¹¶éƒ¨åˆ†ã€‚\n\nè‡ªå·±é£æ ¼çš„ä¸»å¸­æ ‘æ˜¯ç”¨çº¿æ®µæ ‘åˆå¹¶å†™çš„ï¼Œæ€è·¯æ›´æ¸…æ™°ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.7 çº¿æ®µæ ‘åˆ†è£‚\n\nå…«è¾ˆå­ç¢°ä¸ä¸Šä¸€ä¸ªã€‚\n\nç»™å‡ºä¸€ä¸ªå¯é‡é›† $a$ï¼ˆç¼–å·ä¸º $1$ï¼‰ï¼Œå®ƒæ”¯æŒä»¥ä¸‹æ“ä½œï¼š\n\n`0 p x y`ï¼šå°†å¯é‡é›† $p$ ä¸­å¤§äºç­‰äº $x$ ä¸”å°äºç­‰äº $y$ çš„å€¼ç§»åŠ¨åˆ°ä¸€ä¸ªæ–°çš„å¯é‡é›†ä¸­ï¼ˆæ–°å¯é‡é›†ç¼–å·ä¸ºä» $2$ å¼€å§‹çš„æ­£æ•´æ•°ï¼Œæ˜¯ä¸Šä¸€æ¬¡äº§ç”Ÿçš„æ–°å¯é‡é›†çš„ç¼–å·+1ï¼‰ã€‚\n\n`1 p t`ï¼šå°†å¯é‡é›† $t$ ä¸­çš„æ•°æ”¾å…¥å¯é‡é›† $p$ï¼Œä¸”æ¸…ç©ºå¯é‡é›† $t$ï¼ˆæ•°æ®ä¿è¯åœ¨æ­¤åçš„æ“ä½œä¸­ä¸ä¼šå‡ºç°å¯é‡é›† $t$ï¼‰ã€‚\n\n`2 p x q`ï¼šåœ¨ $p$ è¿™ä¸ªå¯é‡é›†ä¸­åŠ å…¥ $x$ ä¸ªæ•°å­— $q$ã€‚\n\n`3 p x y`ï¼šæŸ¥è¯¢å¯é‡é›† $p$ ä¸­å¤§äºç­‰äº $x$ ä¸”å°äºç­‰äº $y$ çš„å€¼çš„ä¸ªæ•°ã€‚\n\n`4 p k`ï¼šæŸ¥è¯¢åœ¨ $p$ è¿™ä¸ªå¯é‡é›†ä¸­ç¬¬ $k$â€‹ å°çš„æ•°ï¼Œä¸å­˜åœ¨æ—¶è¾“å‡º `-1`ã€‚\n\n```cpp\n// çº¿æ®µæ ‘åˆ†è£‚\n// çº¿æ®µæ ‘åˆå¹¶é€†å‘æ“ä½œ\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n// #define DEBUG 1\nconst int maxn = 3e5 + 9;\nint n, m, tot = 0, root[maxn], a[maxn];\nstruct node\n{\n    int l, r, sum;\n    int cl, cr;\n} tree[maxn << 5];\n#define ls(rt) tree[rt].l\n#define rs(rt) tree[rt].r\n#define rcl(rt) tree[rt].cl\n#define rcr(rt) tree[rt].cr\n#define sum(rt) tree[rt].sum\nvoid pushup(int rt)\n{\n    sum(rt) = sum(ls(rt)) + sum(rs(rt));\n}\nvoid update(int &rt, int num, int pos, int cl = 1, int cr = n) // å•ç‚¹ä¿®æ”¹æƒå€¼çº¿æ®µæ ‘\n{\n    if (!rt)\n    {\n        rt = ++tot;\n        rcl(rt) = cl, rcr(rt) = cr;\n    }\n    if (cl == cr)\n    {\n        sum(rt) += num;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(ls(rt), num, pos, cl, mid);\n    else\n        update(rs(rt), num, pos, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nint querykth(int &rt, int k, int cl = 1, int cr = n) // æŸ¥è¯¢åŒºé—´ç¬¬kå°ï¼Œçº¿æ®µæ ‘ä¸ŠäºŒåˆ†\n{\n    if (!rt)\n        return -1;\n    if (cl == cr)\n        return cl;\n    int mid = (cl + cr) >> 1LL;\n    if (sum(ls(rt)) >= k)\n        return querykth(ls(rt), k, cl, mid);\n    else\n        return querykth(rs(rt), k - sum(ls(rt)), mid + 1, cr);\n}\nint queryinterval(int &rt, int l, int r, int cl = 1, int cr = n) // æŸ¥è¯¢å¤§äºç­‰äºxå°äºç­‰äºyçš„å…ƒç´ ä¸ªæ•°\n{\n    if (l <= cl && cr <= r)\n        return sum(rt);\n    int mid = (cl + cr) >> 1LL, ans = 0;\n    if (l <= mid)\n        ans += queryinterval(ls(rt), l, r, cl, mid);\n    if (r > mid)\n        ans += queryinterval(rs(rt), l, r, mid + 1, cr);\n    return ans;\n}\nvoid segmerge(int &rt1, int &rt2, int cl = 1, int cr = n)\n{\n    if (!rt1 || !rt2)\n        return void(rt1 = rt1 + rt2);\n    if (cl == cr)\n        return void(sum(rt1) += sum(rt2));\n    int mid = (cl + cr) >> 1;\n    segmerge(ls(rt1), ls(rt2), cl, mid);\n    segmerge(rs(rt1), rs(rt2), mid + 1, cr);\n    pushup(rt1);\n    return;\n}\nvoid segsplit(int &rt1, int &rt2, int l, int r, int cl = 1, int cr = n)\n{\n    if (!rt1)\n    {\n        return;\n    }\n    if (l <= cl && cr <= r)\n    {\n        rt2 = rt1;\n        rt1 = 0;\n        return;\n    }\n    if (!rt2)\n    {\n        rt2 = ++tot;\n        rcl(rt2) = cl, rcr(rt2) = cr;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        segsplit(ls(rt1), ls(rt2), l, r, cl, mid);\n    if (r > mid)\n        segsplit(rs(rt1), rs(rt2), l, r, mid + 1, cr);\n    pushup(rt1);\n    pushup(rt2);\n    return;\n}\nint cnt = 1;\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        update(root[1], a[i], i);\n    }\n    while (m--)\n    {\n        int op, x, y, z;\n        cin >> op;\n        switch (op)\n        {\n        case 0:\n            cnt++;\n            cin >> x >> y >> z;\n            segsplit(root[x], root[cnt], y, z);\n            break;\n        case 1:\n            cin >> x >> y;\n            segmerge(root[x], root[y]);\n            break;\n        case 2:\n            cin >> x >> y >> z;\n            update(root[x], y, z);\n            break;\n        case 3:\n            cin >> x >> y >> z;\n            cout << queryinterval(root[x], y, z) << endl;\n            break;\n        case 4:\n            cin >> x >> y;\n            cout << querykth(root[x], y) << endl;\n            break;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.8 æ‰«æçº¿\n\n#### 1.8.1 æ±‚çŸ©å½¢é¢ç§¯çš„å¹¶\n\næ‰«æçº¿é—®é¢˜ ***åˆ‡è®°åˆ‡è®°*** ç»´æŠ¤å¥½***ä»€ä¹ˆæ—¶å€™æ‰«è¿‡ï¼Œæ‰«è¿‡çš„éƒ¨åˆ†æ€ä¹ˆç®—ï¼Œå·²ç»æ‰«å®Œçš„éƒ¨åˆ†å¦‚ä½•åˆ é™¤çš„è¾¹ç•Œé—®é¢˜***ï¼Œä¹Ÿæ˜¯é‡ç‚¹DEBUGéƒ¨åˆ†.\n\næ±‚çŸ©å½¢é¢ç§¯çš„å¹¶æ¯æ¬¡æŸ¥è¯¢çš„æ˜¯æ•´ä¸ªåŒºé—´å†…çº¿æ®µçš„é•¿åº¦ã€‚\n\n***Codeforces***ä¸Šæœ‰ä¸€é“ç»´æŠ¤çº¿æ®µçš„åŠ å…¥å’Œåˆ é™¤ï¼ŒåŒºé—´æŸ¥è¯¢æŸä¸ªåŒºé—´æ˜¯å¦æœ‰çº¿æ®µè¦†ç›–çš„é¢˜ï¼Œ***æ³¨æ„ï¼Œå¦‚æœæ¶‰åŠåˆ°æ­¤é—®é¢˜***ï¼Œ**ä»…**æ‰«æçº¿æ€æƒ³ä¸­**æ ‡è®°ä¸ä¸‹ä¼ åªç»´æŠ¤å½“å‰çº¿æ®µæ ‘ç»“ç‚¹æ‰€è¡¨ç¤ºçš„å®Œæ•´åŒºé—´æ˜¯å¦æœ‰çº¿æ®µ**çš„ç±»çº¿æ®µæ ‘åˆ†æ²»æ€æƒ³***è¿˜éœ€è¦é¢å¤–åˆ¤å®šä»¥ä¸‹å†…å®¹ï¼š***\n\n***å¦‚æœç›®æ ‡åŒºé—´$[l,r]$å·²ç»è¢«æŸæ¡é•¿çº¿æ®µå®Œæ•´è¦†ç›–ï¼Œç›´æ¥è¿”å›$true$â€‹â€‹å³å¯ã€‚***\n\n```cpp\n// æ‰«æçº¿æ¨¡æ¿\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nstruct segtrees\n{\n    int l, r;\n    i64 sum = 0;\n    int tags = 0;\n};\nconst int maxn = 4e5 + 9;\nsegtrees tree[maxn << 2];\nint n, m;\ni64 points[maxn];\nvoid update(int rt, int cl, int cr)\n{\n    if (tree[rt].tags)\n    {\n        tree[rt].sum = points[cr + 1] - points[cl];\n        return;\n    }\n    tree[rt].sum = tree[rt << 1].sum + tree[rt << 1 | 1].sum;\n    return;\n}\nvoid modifytags(int l, int r, int d, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        tree[rt].tags += d;\n        update(rt, cl, cr);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        modifytags(l, r, d, rt << 1, cl, mid);\n    if (r > mid)\n        modifytags(l, r, d, rt << 1 | 1, mid + 1, cr);\n    update(rt, cl, cr);\n    return;\n}\nstruct node\n{\n    int x1, y1, x2, y2;\n} rem[maxn];\nvector<tuple<int, int, int, int>> op;\nsigned main()\n{\n    cin >> n;\n    int cnt = 0;\n    int S = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 > x2)\n            swap(x1, x2);\n        if (y1 > y2)\n            swap(y1, y2);\n        rem[i] = {x1, y1, x2, y2};\n        points[++cnt] = x1;\n        points[++cnt] = x2;\n    }\n    sort(points + 1, points + 1 + cnt);\n    S = unique(points + 1, points + 1 + cnt) - points - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int x1 = lower_bound(points + 1, points + 1 + S, rem[i].x1) - points;\n        int x2 = lower_bound(points + 1, points + 1 + S, rem[i].x2) - points;\n        op.push_back({rem[i].y1, x1, x2 - 1, 1});\n        op.push_back({rem[i].y2, x1, x2 - 1, -1});\n    }\n    sort(op.begin(), op.end());\n    i64 ans = 0;\n    i64 last = 0;\n    for (auto [y, x1, x2, d] : op)\n    {\n        ans += (y - last) * tree[1].sum;\n        modifytags(x1, x2, d, 1, 1, S);\n        last = y;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.8.2 ç»´æŠ¤çº¿æ®µçš„å¹¶\n\nå…¶å®æœ‰ç‚¹åºŸè¯ï¼Œæœ¬è´¨ä¸Šä¸æ˜¯æ‰«æçº¿ï¼Œä½†æ˜¯ç¡®å®æ˜¯é€šè¿‡ç»´æŠ¤çº¿æ®µåŒºé—´çš„å¹¶åˆ¤æ–­æ­¤æ—¶æœ‰å¤šå°‘ä¸ªåˆæ³•æƒ…å†µï¼Œæ¥æºäºç‰›å®¢å¤šæ ¡çš„$Interval Selection$:\n\n\n\næœ‰ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ï¼Œå½“ä¸”ä»…å½“ $a_l,a_{l+1},\\dots a_r$ ä¸­çš„æ¯ä¸ªå…ƒç´ åœ¨å½“å‰åŒºé—´å†…æ°å¥½å‡ºç° $k$ æ¬¡æ—¶ï¼Œæ•°ç»„ä¸­çš„å­æ•°ç»„ $[l,r]$ æ‰æ˜¯å¥½æ•°ç»„ã€‚  \n\nä¾‹å¦‚ï¼Œå¯¹äº$a=[1,1,2,3,2,3,1]$å’Œ$k=2$ï¼ŒåŒºé—´$[1,2]$ã€$[3,6]$ã€$[1,6]$ç­‰éƒ½æ˜¯å¥½çš„ã€‚ä½†æ˜¯ï¼Œ$[1,3]$ä¸ç¬¦åˆæ¡ä»¶ï¼Œå› ä¸ºå…ƒç´ $2$åªå‡ºç°äº†ä¸€æ¬¡ï¼›$[1,7]$ä¸ç¬¦åˆæ¡ä»¶ï¼Œå› ä¸ºå…ƒç´ $1$å‡ºç°äº†$3$æ¬¡ã€‚  \n\nè¯·æ‰¾å‡ºå¯ä»¥é€‰æ‹©çš„å¥½åŒºé—´çš„ä¸ªæ•°ã€‚\n\n\n\né€šè¿‡çº¿æ®µå¹¶ç»´æŠ¤ä¸åˆæ³•åŒºé—´æ•°é‡å³å¯ï¼Œçº¿æ®µäº¤è¿‡äºéš¾ä»¥ç»´æŠ¤ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\n#define IOS                      \\\n    ios::sync_with_stdio(false); \\\n    cin.tie(0);                  \\\n    cout.tie(0);\nconst int maxn = 2e5 + 9;\nint a[maxn], b[maxn];\nstruct node\n{\n    int l;\n    int r;\n    int cover;\n    int sum;\n} tree[maxn << 2LL];\nint n;\n#define ls(rt) tree[rt << 1LL]\n#define rs(rt) tree[rt << 1LL | 1]\n#define cover(rt) tree[rt].cover\n#define sum(rt) tree[rt].sum\n#define getl(rt) tree[rt].l\n#define getr(rt) tree[rt].r\nvoid pushup(int rt)\n{\n    if (cover(rt))\n        sum(rt) = 0;\n    else if (getl(rt) == getr(rt))\n    {\n        sum(rt) = 1;\n    }\n    else\n        sum(rt) = sum(rt << 1LL) + sum(rt << 1LL | 1);\n    return;\n}\nvoid modify(int l, int r, int d, int rt = 1, int cl = 1, int cr = n)\n{\n    if (l <= cl && cr <= r)\n    {\n        cover(rt) += d;\n        pushup(rt);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (l <= mid)\n        modify(l, r, d, rt << 1LL, cl, mid);\n    if (r > mid)\n        modify(l, r, d, rt << 1LL | 1, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nint querysum(int l, int r, int rt = 1, int cl = 1, int cr = n)\n{\n    if (cover(rt))\n        return 0;\n    if (l <= cl && cr <= r)\n    {\n        return sum(rt);\n    }\n    int mid = (cl + cr) >> 1;\n    int ans = 0;\n    if (l <= mid)\n        ans += querysum(l, r, rt << 1LL, cl, mid);\n    if (r > mid)\n        ans += querysum(l, r, rt << 1LL | 1, mid + 1, cr);\n    return ans;\n}\nvoid build(int rt = 1, int l = 1, int r = n)\n{\n    getl(rt) = l;\n    getr(rt) = r;\n    cover(rt) = 0;\n    if (l == r)\n    {\n        sum(rt) = 1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(rt << 1LL, l, mid);\n    build(rt << 1LL | 1, mid + 1, r);\n    pushup(rt);\n    return;\n}\nint k;\nvector<int> rem[maxn];\nvoid solve()\n{\n    cin >> n >> k;\n    build();\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        b[i] = a[i];\n    }\n    sort(b + 1, b + n + 1);\n    int m = unique(b + 1, b + n + 1) - b - 1;\n    for (int i = 1; i <= m; i++)\n    {\n        rem[i].clear();\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (rem[a[i]].empty())\n        {\n            rem[a[i]].push_back(0);\n        }\n        rem[a[i]].push_back(i);\n        int t = rem[a[i]].size() - 1;\n        int l = rem[a[i]][t - 1] + 1, r = rem[a[i]][t];\n        modify(l, r, 1);\n        if (t >= k)\n        {\n            l = rem[a[i]][t - k] + 1;\n            r = rem[a[i]][t - k + 1];\n            modify(l, r, -1);\n            if (l >= 2)\n                modify(1, l - 1, 1);\n            ans += querysum(l, r);\n        }\n    }\n    cout << ans << endl;\n    return;\n}\nsigned main()\n{\n    IOS;\n    int t = 1;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.9 ä¸»å¸­æ ‘ï¼ˆé™æ€åŒºé—´ç¬¬kå°ã€å°äºç­‰äºç¬¬kå°çš„å’Œã€å°äºç­‰äºå‰kå°æœ‰å¤šå°‘ä¸ªæ•°ï¼‰\n\nè®°ä½ä¸»å¸­æ ‘çš„æ ¹æœ¬æ€æƒ³åœ¨äºç»´æŠ¤å‰ç¼€å’Œã€‚\n\nå¦å¤–ï¼Œä¸»å¸­æ ‘å¤æ‚åº¦$O(Knlogn)$ï¼Œå¸¸æ•°è¾ƒå¤§ï¼Œ$n\\le 5e5$æ—¶å¦‚æœç¡®å®šå¿…é¡»ç”¨åˆ°ä¸»å¸­æ ‘ï¼Œç®—æ³•å¤æ‚åº¦å¿…é¡»ä¸¥æ ¼çº¯$O(nlogn)$ï¼Œ$O(nlog^2n)$å¯èƒ½ä¼š$\\color{red}TLE$â€‹\n\n***é™„è®®ï¼šå…¶å®ä¸»å¸­æ ‘æ ¹æœ¬å°±ä¸éœ€è¦ç¦»æ•£åŒ–ï¼ŒåŠ¨æ€å¼€ç‚¹çš„å±æ€§ç¡®ä¿äº†æ ‘æ·±åº¦æœ€å¤š $logV$ï¼Œä¸€å…± $10^5$çº§åˆ«çš„æ•°å­—ç¡®ä¿äº†æœ€å¤š$O(nlogV)$çš„ç©ºé—´å¤æ‚åº¦ï¼Œä¸€å®šä¸ä¼šè¶…ï¼Œå°±æ˜¯å¸¸æ•°ç¨å¾®å¤§ä¸€ç‚¹è€Œå·²ã€‚è¿™æ„å‘³ç€ä¸»å¸­æ ‘å¯ä»¥å®Œå…¨åšåˆ°å¹³æ›¿ $01Trie$æ±‚å¼‚æˆ–æœ€å€¼é—®é¢˜ã€‚***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nstruct node\n{\n    int l, r;\n    i64 sum;\n    i64 cnt;\n};\nint tot = 0;\nconst int maxn = 5e5 + 9;\ni64 bs[maxn]; // ç¦»æ•£åŒ–æ•°ç»„ï¼Œä¸‹æ ‡ç¦»æ•£åŒ–ï¼Œå†…å­˜ä¸ºåŸæ•°å­—\ni64 a[maxn];\nnode tree[maxn << 5];\nint root[maxn];\nvoid init(int n)\n{\n    for (int i = 0; i <= n; i++)\n    {\n        root[i] = 0;\n    }\n    tot = 0;\n    return;\n}\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0, 0};\n    return tot;\n}\nvoid update(int &rt, int pos, int cl, int cr)\n{\n    if (!rt)\n    {\n        rt = newnode();\n    }\n    tree[rt].cnt++;\n    tree[rt].sum += bs[pos];\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(tree[rt].l, pos, cl, mid);\n    else\n        update(tree[rt].r, pos, mid + 1, cr);\n}\nvoid merge(int &rt1, int &rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n    {\n        rt1 |= rt2;\n        return;\n    }\n    tree[rt1].cnt += tree[rt2].cnt;\n    tree[rt1].sum += tree[rt2].sum;\n    if (cl == cr)\n    {\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    return;\n}\ntuple<i64, i64, int> querykth(int rt1, int rt2, int k, int cl, int cr)\n{\n    if (cl == cr)\n    {\n        return {bs[cl], tree[rt2].sum - tree[rt1].sum, tree[rt2].cnt - tree[rt1].cnt};\n    }\n    int mid = (cl + cr) >> 1;\n    int nowcnt = tree[tree[rt2].l].cnt - tree[tree[rt1].l].cnt;\n    i64 nowsum = tree[tree[rt2].l].sum - tree[tree[rt1].l].sum;\n    if (nowcnt >= k)\n        return querykth(tree[rt1].l, tree[rt2].l, k, cl, mid);\n    auto [kthrl, rsum, rcnt] = querykth(tree[rt1].r, tree[rt2].r, k - nowcnt, mid + 1, cr);\n    return {kthrl, nowsum + rsum, nowcnt + rcnt};\n}\nint sz = 0;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\né™„ï¼šå…³äºä¸»å¸­æ ‘çš„å†…å­˜å›æ”¶é—®é¢˜\n\néœ€è¦æ‰“æ ‡è®°ï¼Œä¸€ä¸ªæƒ³åˆ é™¤çš„ç‚¹å¯ä»¥è¢«åˆ é™¤å½“ä¸”ä»…å½“ä»»ä½•ç‰ˆæœ¬éƒ½æ²¡æœ‰å†ä½¿ç”¨è¿™ä¸ªç‚¹ã€‚å°¤å…¶æ³¨æ„`merge`å‡½æ•°çš„å¤„ç†é—®é¢˜ã€‚ç†è®ºä¸Šæ¶‰åŠä¸»å¸­æ ‘è€ç‰ˆæœ¬åˆ é™¤åˆ é™¤çš„é¢˜ç›®ï¼Œä¸åº”å½“åœ¨å†…å­˜ä¸Šè¿›è¡Œå¡åˆ¶æ— å†…å­˜å›æ”¶æ— æ³•é€šè¿‡çš„æ•°æ®ã€‚\n\n```cpp\nint newnode()\n{\n    if (tot + 1 < inf)\n        tot++;\n    else\n        tot = qs.front(), qs.pop();\n    viscnt[tot]++;\n    tree[tot] = {0, 0, 0};\n    return tot;\n}\nvoid del_tree(int rt)\n{\n    if (!rt)\n        return;\n    del_tree(tree[rt].l);\n    del_tree(tree[rt].r);\n    viscnt[rt]--;\n    if (!viscnt[rt])\n    {\n        qs.push(rt);\n        tree[rt] = {0, 0, 0};\n    }\n    return;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.10 ä¸»å¸­æ ‘ç»´æŠ¤åŒºé—´æœ¬è´¨ä¸åŒçš„å…ƒç´ ä¸ªæ•°ï¼ˆHHçš„é¡¹é“¾ï¼‰\n\nç»™å®šæ•°ç»„$a$ï¼Œæ¯æ¬¡è¯¢é—®$[l,r]$ä¸­æœ‰å¤šå°‘ä¸ªä¸åŒå…ƒç´ çš„å€¼å‡ºç°ï¼Ÿ\n\nä¸€ä¸ª$trival$çš„åšæ³•æ˜¯æ•°æ¯ä¸ªå…ƒç´ æœ€åä¸€æ¬¡å‡ºç°çš„é‚£ä¸€ä¸ªã€‚ä¸»å¸­æ ‘ä¸‹æ ‡å¼€ä½ç½®ï¼Œè®°å½•è¯¥ä½ç½®æ˜¯å¦æœ‰é¢œè‰²ã€‚\n\nè®°å½•***é¢œè‰²$k$æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ä¸º $pre_k$***ï¼Œå½“å‰ä¸º$i$ä½ç½®ï¼Œé¢œè‰²ä¸º$k$ï¼Œåˆ™å°†$pos=pre_k$ä½ç½®çš„çº¿æ®µæ ‘èŠ‚ç‚¹$-1$è¡¨ç¤ºè¯¥ä½ç½®ä¸å†è®¡ç®—ï¼Œ$pos=i$ä½ç½®èŠ‚ç‚¹$+1$è¡¨ç¤ºè¯¥èŠ‚ç‚¹è®¡ç®—é¢œè‰²ï¼Œæ›´æ–°$pre_k=i$ã€‚è¯¢é—®$[l,r]$æ—¶æŸ¥è¯¢$root[r]$ç‰ˆæœ¬ä¸»å¸­æ ‘ã€‚\n\nç¬¬ä¸€ç§åšæ³•æœ‰ç‚¹åƒæ ‘çŠ¶æ•°ç»„ç¦»çº¿æ‰«æçº¿ï¼Œä¸å†å†™ã€‚\n\n***ç¬¬äºŒä¸ªæ›´Trivalçš„ä¸»å¸­æ ‘åšæ³•***ï¼š\n\næ•°æ¯ä¸ªå…ƒç´ æ•°æœ€å·¦ä¾§å‡ºç°çš„é‚£ä¸€ä¸ªã€‚æ€è€ƒï¼Œ$[l,r]$ä¸­ä½ç½®$i$ä¸Šçš„å…ƒç´ å¦‚æœåšå‡ºè´¡çŒ®ï¼Œé‚£ä¹ˆè®°$pre_i$ä¸º***ä½ç½® $i$ä¸Šçš„é¢œè‰²åœ¨ $i$å‰æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®***ï¼Œç¬¬ä¸€æ¬¡å‡ºç°æ—¶è®°ä½œ$pre_i=0$ï¼Œåˆ™å¿…ç„¶æœ‰$pre_i<l$.\n\nå¯¹ä½ç½®å¼€æƒå€¼æ ‘æ¡¶ï¼Œç»´æŠ¤$pre$æ•°ç»„ä¸­å€¼$v=pre[i]$å‡ºç°äº†å¤šå°‘æ¬¡ã€‚æŸ¥è¯¢åŒºé—´$[l,r]$ï¼Œåˆ™ä¸»å¸­æ ‘æŸ¥è¯¢$root[l-1]$å’Œ$root[r]$çš„å·®ä¸­ï¼Œå°äº$l$çš„å€¼çš„å’Œã€‚æ³¨æ„ï¼Œæƒæ ‘ä¸‹æ ‡ä»$0$å¼€å§‹ï¼Œå› ä¿è¯$pre_i=0$è¡¨ç¤ºä½ç½®$i$â€‹â€‹ä¸Šçš„é¢œè‰²åœ¨æ•´ä¸ªåºåˆ—ä¸­ç¬¬ä¸€æ¬¡å‡ºç°ã€‚\n\nç¬¬äºŒç§æ–¹æ³•æ›´æ–¹ä¾¿äºç»´æŠ¤ä¸€äº›è¢«æ±‚å’Œçš„ä¸œè¥¿ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.11 ä¸»å¸­æ ‘äºŒç»´æ•°ç‚¹ï¼ˆHEOI2017, SuperBigå¸¸æ•°ï¼Œä¸æ¨èï¼Œå»ºè®®ç¦»çº¿æ ‘çŠ¶æ•°ç»„æ‰«æçº¿ï¼Œè¿™é‡Œä¸»è¦è´´å‡ºæ¥ä¸»å¸­æ ‘æ„å»ºæ—¶æœ‰åŒºé—´updateæ ‡è®°æ°¸ä¹…åŒ–ï¼‰\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Segtree_presistent\n{\n    struct node\n    {\n        int l = 0, r = 0;\n        int sum = 0;\n        int lazy = 0;\n    };\n    vector<node> t;\n    vector<int> root;\n    int cnt = 0, n = 0;\n    void init(int _n)\n    {\n        n = _n;\n        cnt = 0;\n        root.assign(n + 1, 0);\n        t.assign(32 * n + 10, node());\n    }\n    void modify(int &rt, int l, int r, int d, int cl, int cr)\n    {\n        if (!rt)\n        {\n            rt = ++cnt;\n        }\n        t[rt].sum += 1ll * d * (min(r, cr) - max(l, cl) + 1);\n        if (l <= cl && cr <= r)\n        {\n            t[rt].lazy += d;\n            return;\n        }\n        int mid = (cl + cr) >> 1ll;\n        if (l <= mid)\n            modify(t[rt].l, l, r, d, cl, mid);\n        if (r > mid)\n            modify(t[rt].r, l, r, d, mid + 1, cr);\n        return;\n    }\n    int query(int rt, int l, int r, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (l <= cl && cr <= r)\n        {\n            return t[rt].sum;\n        }\n        int mid = (cl + cr) >> 1ll;\n        int res = 0;\n        if (l <= mid)\n            res += query(t[rt].l, l, r, cl, mid);\n        if (r > mid)\n            res += query(t[rt].r, l, r, mid + 1, cr);\n        return res + 1ll * (min(r, cr) - max(l, cl) + 1) * t[rt].lazy;\n    }\n    void merge(int &rt1, int &rt2, int cl, int cr)\n    {\n        if (!rt1 || !rt2)\n        {\n            rt1 = rt1 + rt2;\n            return;\n        }\n        t[rt1].sum += t[rt2].sum;\n        t[rt1].lazy += t[rt2].lazy;\n        if (cl == cr)\n            return;\n        int mid = (cl + cr) >> 1ll;\n        merge(t[rt1].l, t[rt2].l, cl, mid);\n        merge(t[rt1].r, t[rt2].r, mid + 1, cr);\n        return;\n    }\n};\nSegtree_presistent seg;\nconst int maxn = 1e6 + 9;\nstruct interval\n{\n    int l, r;\n    int w;\n};\nstruct Edge\n{\n    int n;\n    vector<vector<interval>> G;\n    void init(int _n)\n    {\n        n = _n;\n        G.assign(n + 1, vector<interval>());\n    }\n    void add_edge(int u, int l, int r, int w)\n    {\n        G[u].push_back({l, r, w});\n    }\n};\nEdge G;\nint a[maxn];\nint l[maxn], r[maxn];\nstack<int> s;\nint n, m, p, q;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> p >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        l[i] = 0, r[i] = n + 1;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        while (!s.empty() && a[s.top()] < a[i])\n        {\n            s.pop();\n        }\n        l[i] = s.empty() ? 0ll : s.top();\n        s.push(i);\n    }\n    while (!s.empty())\n    {\n        s.pop();\n    }\n    for (int i = n; i >= 1; i--)\n    {\n        while (!s.empty() && a[s.top()] < a[i])\n        {\n            s.pop();\n        }\n        r[i] = s.empty() ? 1ll * n + 1 : s.top();\n        s.push(i);\n    }\n    seg.init(n);\n    G.init(n);\n    for (int i = 1; i <= n; i++)\n    {\n        if (i != n)\n        {\n            G.add_edge(i, i + 1, i + 1, p);\n        }\n        if (l[i] && r[i] <= n)\n            G.add_edge(l[i], r[i], r[i], p);\n        if (l[i] && i + 1 <= r[i] - 1)\n        {\n            G.add_edge(l[i], i + 1, r[i] - 1, q);\n        }\n        if (r[i] <= n && l[i] + 1 <= i - 1)\n        {\n            G.add_edge(r[i], l[i] + 1, i - 1, q);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto [l, r, w] : G.G[i])\n        {\n            seg.modify(seg.root[i], l, r, w, 1, seg.n);\n        }\n        seg.merge(seg.root[i], seg.root[i - 1], 1, seg.n);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        cout << seg.query(seg.root[r], l, r, 1, seg.n) - seg.query(seg.root[l - 1], l, r, 1, seg.n) << endl;\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.12 å¸¦ä¿®ä¸»å¸­æ ‘/æ ‘å¥—æ ‘ï¼ˆåŠ¨æ€åŒºé—´ç¬¬kå°ï¼Œå•ç‚¹ä¿®æ”¹ï¼‰\n\n#### 1.12.1 åŠ¨æ€åŒºé—´ç¬¬kå°\n\nè¿™ä¸ªçœ‹æ€ä¹ˆç†è§£äº†ï¼Œä¸¥æ ¼æ„ä¹‰ä¸Šæ ¹æœ¬ä¸ç®—ä¸»å¸­æ ‘ï¼Œå±äºæ ‘çŠ¶æ•°ç»„å¥—æƒå€¼çº¿æ®µæ ‘ã€‚ä½†æ˜¯å¦‚æœæŒ‰å‰ç¼€å’Œç†è§£ä¸»å¸­æ ‘ï¼Œ`merge`å‡½æ•°è§†ä½œå¯¹å„ä¸ªç‹¬ç«‹æ ¹çš„æ ‘æ±‚å‰ç¼€å’Œï¼Œæ ‘çŠ¶æ•°ç»„å°±åƒæ˜¯ä¹‹å‰æš´åŠ›é¢„å¤„ç†å‰ç¼€å’Œå˜æˆäº†å°†æ ‘ç›´æ¥ç»‘åœ¨æ ‘çŠ¶æ•°ç»„ä¸Šï¼Œç”¨æ ‘çŠ¶æ•°ç»„æ±‚å‰ç¼€å’Œï¼Œä¹Ÿç®—è¯´å¾—è¿‡å»ã€‚\n\nç†è®ºä¸ŠåŒºé—´ä¿®æ”¹ä¹Ÿå¯ä»¥ï¼Ÿ\n\næ³¨æ„æ½œåœ¨çš„ç©ºé—´çˆ†ç‚¸é—®é¢˜ã€‚\n\n(æ˜¾ç„¶å¯ä»¥ï¼Œå…·ä½“å®ç°å‚è€ƒ1.11åŒºé—´åŠ ï¼Œ1.2åŒºé—´ä¹˜ï¼Œç›¸åŒé€»è¾‘)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 9;\n#define int long long\nint n;\nstruct node\n{\n    int l, r;\n    int sum;\n};\nnode tree[maxn << 5];\nint tot = 0;\nint root[maxn];\nint sz;\nint bs[maxn];\nint a[maxn];\nint q;\nint cnt = 0;\nint lowbit(int x)\n{\n    return (x & -x);\n}\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0ll};\n    return tot;\n}\nvoid upd(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n    {\n        rt = newnode();\n    }\n    tree[rt].sum += val;\n    if (cl == cr)\n        return;\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        upd(tree[rt].l, pos, val, cl, mid);\n    else\n        upd(tree[rt].r, pos, val, mid + 1, cr);\n    return;\n}\nvoid update(int realrt, int val)\n{\n    for (int i = realrt; i <= n; i += lowbit(i))\n    {\n        upd(root[i], a[realrt], val, 1, sz);\n    }\n}\nint query(vector<int> &rt1s, vector<int> &rt2s, int k, int cl, int cr)\n{\n    if (cl == cr)\n        return cl;\n    int mid = (cl + cr) >> 1;\n    int sums = 0;\n    for (auto j : rt2s)\n        sums += tree[tree[j].l].sum;\n    for (auto j : rt1s)\n        sums -= tree[tree[j].l].sum;\n    if (sums >= k)\n    {\n        for (auto &j : rt2s)\n            j = tree[j].l;\n        for (auto &j : rt1s)\n            j = tree[j].l;\n        return query(rt1s, rt2s, k, cl, mid);\n    }\n    else\n    {\n        for (auto &j : rt2s)\n            j = tree[j].r;\n        for (auto &j : rt1s)\n            j = tree[j].r;\n        return query(rt1s, rt2s, k - sums, mid + 1, cr);\n    }\n}\nint querykth(int l, int r, int k)\n{\n    vector<int> rt1, rt2;\n    for (int i = r; i; i -= lowbit(i))\n    {\n        rt2.push_back(root[i]);\n    }\n    for (int i = l - 1; i; i -= lowbit(i))\n    {\n        rt1.push_back(root[i]);\n    }\n    return query(rt1, rt2, k, 1, sz);\n}\n\nstruct qs\n{\n    int l, r, k;\n};\nstruct cs\n{\n    int pos, val;\n};\nsigned main()\n{\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        bs[++cnt] = a[i];\n    }\n    vector<tuple<char, qs, cs>> v(q + 1);\n    for (int i = 1; i <= q; i++)\n    {\n        char c;\n        cin >> c;\n        if (c == 'Q')\n        {\n            int l, r, k;\n            cin >> l >> r >> k;\n            v[i] = {c, {l, r, k}, {}};\n        }\n        else\n        {\n            int pos, val;\n            cin >> pos >> val;\n            bs[++cnt] = val;\n            v[i] = {c, {}, {pos, val}};\n        }\n    }\n    sort(bs + 1, bs + 1 + cnt);\n    sz = unique(bs + 1, bs + 1 + cnt) - bs - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = lower_bound(bs + 1, bs + 1 + sz, a[i]) - bs;\n        update(i, 1);\n    }\n    for (int i = 1; i <= q; i++)\n    {\n        auto [ch, qss, css] = v[i];\n        if (ch == 'Q')\n        {\n            cout << bs[querykth(qss.l, qss.r, qss.k)] << endl;\n        }\n        else\n        {\n            update(css.pos, -1);\n            a[css.pos] = lower_bound(bs + 1, bs + 1 + sz, css.val) - bs;\n            update(css.pos, 1);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.12.2 é™æ€äºŒç»´çŸ©å½¢ç¬¬kå°\n\nç©ºé—´å¤æ‚åº¦æé«˜ã€‚çœ‹æ•°æ®èŒƒå›´æ˜¯å¦é€‰æ‹©èŒƒå›´åˆ†æ²»ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct node\n{\n    int l, r;\n    int sum;\n    int cnt;\n};\nconst int maxn = 2e5 + 9;\nnode tree[maxn << 7];\nint tot = 0;\nconst int sz = 1009;\nint update(int rt, int pos, int cl, int cr)\n{\n    if (!rt)\n        rt = ++tot;\n    tree[rt].cnt++;\n    tree[rt].sum += pos;\n    if (cl == cr)\n    {\n        return rt;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        tree[rt].l = update(tree[rt].l, pos, cl, mid);\n    else\n        tree[rt].r = update(tree[rt].r, pos, mid + 1, cr);\n    return rt;\n}\nint querysum(int &rt, int l, int r, int cl, int cr)\n{\n    if (!rt)\n        return 0;\n    if (l <= cl && cr <= r)\n        return tree[rt].sum;\n    int mid = (cl + cr) >> 1;\n    int res = 0;\n    if (l <= mid)\n        res += querysum(tree[rt].l, l, r, cl, mid);\n    if (r > mid)\n        res += querysum(tree[rt].r, l, r, mid + 1, cr);\n    return res;\n}\nstruct Fenwick\n{\nprivate:\n    int n, m;\n    vector<vector<i64>> c;\n    int lowbit(int x) { return x & -x; }\n\npublic:\n    Fenwick(int n, int m) : n(n), m(m), c(n + 1, vector<i64>(m + 1, 0)) {}\n    Fenwick() : n(0), m(0) {}\n    void init(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        c.assign(n + 1, vector<i64>(m + 1, 0));\n    }\n    void add(int x, int y, i64 v)\n    {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = y; j <= m; j += lowbit(j))\n                c[i][j] = update(c[i][j], v, 1, sz);\n    }\n    vector<int> query(int x, int y)\n    {\n        vector<int> res;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = y; j; j -= lowbit(j))\n                res.push_back(c[i][j]);\n        return res;\n    }\n};\nint querysum(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[j].sum;\n    }\n    return sum;\n}\nint querycnt(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[j].cnt;\n    }\n    return sum;\n}\nint queryrcnt(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[tree[j].r].cnt;\n    }\n    return sum;\n}\nint queryrsum(vector<int> &rt)\n{\n    int sum = 0;\n    for (auto j : rt)\n    {\n        sum += tree[tree[j].r].sum;\n    }\n    return sum;\n}\nvoid didl(vector<int> &rt)\n{\n    for (auto &j : rt)\n    {\n        j = tree[j].l;\n    }\n}\nvoid didr(vector<int> &rt)\n{\n    for (auto &j : rt)\n    {\n        j = tree[j].r;\n    }\n}\nint queryans(int h, int cl, int cr,\n             vector<int> &rt1, vector<int> &rt2, vector<int> &rt3, vector<int> &rt4, int cnts)\n{\n    if (cl == cr)\n    {\n        int sums = querysum(rt1) + querysum(rt4) - querysum(rt2) - querysum(rt3);\n        if (sums >= h)\n        {\n            int nowcnt = querycnt(rt1) + querycnt(rt4) - querycnt(rt2) - querycnt(rt3);\n            while (nowcnt && sums - cl >= h)\n                nowcnt--, sums -= cl;\n            return cnts + nowcnt;\n        }\n        return -1;\n    }\n    int mid = (cl + cr) >> 1;\n    int sum = queryrsum(rt1) + queryrsum(rt4) - queryrsum(rt2) - queryrsum(rt3);\n    int newcnt = queryrcnt(rt1) + queryrcnt(rt4) - queryrcnt(rt2) - queryrcnt(rt3);\n    if (sum >= h)\n    {\n        didr(rt1), didr(rt2), didr(rt3), didr(rt4);\n        return queryans(h, mid + 1, cr, rt1, rt2, rt3, rt4, cnts);\n    }\n    else\n    {\n        didl(rt1), didl(rt2), didl(rt3), didl(rt4);\n        return queryans(h - sum, cl, mid, rt1, rt2, rt3, rt4, cnts + newcnt);\n    }\n}\nFenwick fw;\nint queryfinal(int x1, int x2, int y1, int y2, int h)\n{\n    vector<int> rt1, rt2, rt3, rt4;\n    rt1 = fw.query(x1 - 1, y1 - 1);\n    rt2 = fw.query(x2, y1 - 1);\n    rt3 = fw.query(x1 - 1, y2);\n    rt4 = fw.query(x2, y2);\n    return queryans(h, 1, sz, rt1, rt2, rt3, rt4, 0);\n}\nsigned main()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    fw.init(n + 10, m + 10);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n        {\n            int x;\n            cin >> x;\n            fw.add(i, j, x);\n        }\n    while (k--)\n    {\n        int x1, x2, y1, y2, h;\n        cin >> x1 >> y1 >> x2 >> y2 >> h;\n        int ans = queryfinal(x1, x2, y1, y2, h);\n        if (ans > 0)\n            cout << ans << endl;\n        else\n            cout << \"Poor QLW\" << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.13 ä¸»å¸­æ ‘å¯æŒä¹…åŒ–æ•°ç»„\n\nç»´æŠ¤è¿™æ ·çš„ä¸€ä¸ªé•¿åº¦ä¸º $ N $ çš„æ•°ç»„ï¼Œæ”¯æŒå¦‚ä¸‹å‡ ç§æ“ä½œ\n\n```\n1. å¯¹äºæ“ä½œ1ï¼Œæ ¼å¼ä¸º$ v_i \\ 1 \\ {loc}_i \\ {value}_i $ï¼Œå³ä¸ºåœ¨ç‰ˆæœ¬$ v_i $çš„åŸºç¡€ä¸Šï¼Œå°† $ a_{{loc}_i} $ ä¿®æ”¹ä¸º $ {value}_i $ã€‚\n\n2. å¯¹äºæ“ä½œ2ï¼Œæ ¼å¼ä¸º$ v_i \\ 2 \\ {loc}_i $ï¼Œå³è®¿é—®ç‰ˆæœ¬$ v_i $ä¸­çš„ $ a_{{loc}_i} $çš„å€¼ï¼Œæ³¨æ„ï¼š**ç”Ÿæˆä¸€æ ·ç‰ˆæœ¬çš„å¯¹è±¡åº”ä¸º $v_i$**ã€‚\n```\næ­¤å¤–ï¼Œæ¯è¿›è¡Œä¸€æ¬¡æ“ä½œï¼ˆ**å¯¹äºæ“ä½œ2ï¼Œå³ä¸ºç”Ÿæˆä¸€ä¸ªå®Œå…¨ä¸€æ ·çš„ç‰ˆæœ¬ï¼Œä¸ä½œä»»ä½•æ”¹åŠ¨**ï¼‰ï¼Œå°±ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„ç‰ˆæœ¬ã€‚ç‰ˆæœ¬ç¼–å·å³ä¸ºå½“å‰æ“ä½œçš„ç¼–å·ï¼ˆä»1å¼€å§‹ç¼–å·ï¼Œç‰ˆæœ¬0è¡¨ç¤ºåˆå§‹çŠ¶æ€æ•°ç»„ï¼‰\n\n***æ³¨æ„å’Œä¸»å¸­æ ‘ä¸ä¸€æ ·çš„åœ°æ–¹ï¼Œmergeå‡½æ•°ä¸èµ‹å€¼ï¼ˆå› ä¸ºæ˜¯æŠŠå‰©ä¸‹æœªå˜åŠ¨çš„éƒ¨åˆ†ç›´æ¥mergeè¿‡æ¥ï¼‰ï¼Œä¿®æ”¹æ—¶å…ˆæ”¹å†mergeï¼ŒæŸ¥è¯¢æ—¶å…ˆmergeå†æ”¹***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 2e6 + 9;\nint tot = 0;\nint sz;\nstruct node\n{\n    int l, r;\n    int num;\n};\nnode tree[maxn << 5];\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0};\n    return tot;\n}\nvoid merge(int &rt1, int &rt2, int cl, int cr)\n{\n    if (!rt1 || !rt2)\n    {\n        rt1 |= rt2;\n        return;\n    }\n    if (cl == cr)\n    {\n        // tree[rt1].num = tree[rt2].num;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    merge(tree[rt1].l, tree[rt2].l, cl, mid);\n    merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n    return;\n}\nvoid update(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n        rt = newnode();\n    if (cl == cr)\n    {\n        tree[rt].num = val;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        update(tree[rt].l, pos, val, cl, mid);\n    else\n        update(tree[rt].r, pos, val, mid + 1, cr);\n}\nint query(const int rt, int pos, int cl, int cr)\n{\n    if (!rt)\n        return 0;\n    if (cl == cr)\n    {\n        return tree[rt].num;\n    }\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        return query(tree[rt].l, pos, cl, mid);\n    else\n        return query(tree[rt].r, pos, mid + 1, cr);\n}\nvoid printtree(int rt, int cl = 1, int cr = sz)\n{\n    if (!rt)\n    {\n        cout << 0 << endl;\n        return;\n    }\n    if (cl == cr)\n    {\n        cout << tree[rt].num << endl;\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    printtree(tree[rt].l, cl, mid);\n    printtree(tree[rt].r, mid + 1, cr);\n}\nint root[maxn];\nint n, m;\nint ver = 0;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    sz = n;\n    for (int i = 1; i <= n; i++)\n    {\n        int val;\n        cin >> val;\n        update(root[0], i, val, 1, sz);\n    }\n    while (m--)\n    {\n        ver++;\n        int v, op, pos, val;\n        cin >> v >> op >> pos;\n        if (op == 1)\n        {\n            cin >> val;\n            update(root[ver], pos, val, 1, sz);\n            merge(root[ver], root[v], 1, sz);\n        }\n        else\n        {\n            merge(root[ver], root[v], 1, sz);\n            cout << query(root[ver], pos, 1, sz) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.14 ä¸»å¸­æ ‘å¯æŒä¹…åŒ–å¹¶æŸ¥é›†\n\nç»™å®š $n$ ä¸ªé›†åˆï¼Œç¬¬ $i$ ä¸ªé›†åˆå†…åˆå§‹çŠ¶æ€ä¸‹åªæœ‰ä¸€ä¸ªæ•°ï¼Œä¸º $i$ã€‚\n\næœ‰ $m$ æ¬¡æ“ä½œã€‚æ“ä½œåˆ†ä¸º $3$ ç§ï¼š\n\n - `1 a b` åˆå¹¶ $a,b$ æ‰€åœ¨é›†åˆï¼›\n - `2 k` å›åˆ°ç¬¬ $k$ æ¬¡æ“ä½œï¼ˆæ‰§è¡Œä¸‰ç§æ“ä½œä¸­çš„ä»»æ„ä¸€ç§éƒ½è®°ä¸ºä¸€æ¬¡æ“ä½œï¼‰ä¹‹åçš„çŠ¶æ€ï¼›\n - `3 a b` è¯¢é—® $a,b$ æ˜¯å¦å±äºåŒä¸€é›†åˆï¼Œå¦‚æœæ˜¯åˆ™è¾“å‡º $1$ï¼Œå¦åˆ™è¾“å‡º $0$ã€‚\n\n$n\\le 10^5,m\\le 10^5$\n\nåªéœ€æ³¨æ„ä¸€ä¸ªç‚¹ï¼Œè·¯å¾„å‹ç¼©å¹¶æŸ¥é›†å¤æ‚åº¦æ˜¯å‡æ‘Šçš„ï¼Œæ¶åŠ£æƒ…å†µä¸‹å•æ¬¡åˆå¹¶ä¼šæ˜¯$O(n)$â€‹çš„å¤æ‚åº¦ã€‚æ‰€ä»¥è¦ä¸ŠæŒ‰ç§©åˆå¹¶ï¼ˆå¯å‘å¼åˆå¹¶ï¼‰\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 2e5 + 9;\nstruct presistent_array\n{\n    int tot = 0;\n    int sz;\n    struct node\n    {\n        int l, r;\n        int num;\n    };\n    node tree[maxn << 5];\n    int newnode()\n    {\n        tot++;\n        tree[tot] = {0, 0, 0};\n        return tot;\n    }\n    void merge(int &rt1, int &rt2, int cl, int cr)\n    {\n        if (!rt1 || !rt2)\n        {\n            rt1 |= rt2;\n            return;\n        }\n        if (cl == cr)\n        {\n            // tree[rt1].num = tree[rt2].num;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        merge(tree[rt1].l, tree[rt2].l, cl, mid);\n        merge(tree[rt1].r, tree[rt2].r, mid + 1, cr);\n        return;\n    }\n    void update(int &rt, int pos, int val, int cl, int cr)\n    {\n        if (!rt)\n            rt = newnode();\n        if (cl == cr)\n        {\n            tree[rt].num = val;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            update(tree[rt].l, pos, val, cl, mid);\n        else\n            update(tree[rt].r, pos, val, mid + 1, cr);\n    }\n    int query(const int rt, int pos, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (cl == cr)\n        {\n            return tree[rt].num;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            return query(tree[rt].l, pos, cl, mid);\n        else\n            return query(tree[rt].r, pos, mid + 1, cr);\n    }\n    void printtree(const int rt)\n    {\n        for (int i = 1; i <= sz; i++)\n        {\n            cout << query(rt, i, 1, sz) << \" \";\n        }\n        cout << endl;\n    }\n    int root[maxn];\n};\narray<int, 2> vers[maxn];\nint n, m;\nint ver = 0;\nint verfa = 0, versiz = 0;\npresistent_array fa, siz; // å¼€ä¸¤ä¸ªæ•°ç»„ï¼Œç›´æ¥å°±æ˜¯å¯æŒä¹…åŒ–æ•°ç»„å°èµ·æ¥\nint getfather(int fart, int x)\n{\n    int getf = fa.query(fart, x, 1, n);\n    if (x == getf)\n        return x;\n    else\n        return getfather(fart, getf);\n}\nbool same(int fart, int u, int v)\n{\n    return getfather(fart, u) == getfather(fart, v);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    fa.sz = siz.sz = n;\n    vers[0] = {0, 0};\n    for (int i = 1; i <= n; i++)\n    {\n        fa.update(fa.root[vers[0][0]], i, i, 1, n);\n        siz.update(siz.root[vers[0][1]], i, 1, 1, n);\n    }\n    // fa.printtree(fa.root[0]);\n    // siz.printtree(siz.root[0]);\n    while (m--)\n    {\n        ver++;\n        vers[ver][0] = vers[ver][1] = ver;\n        int op, k;\n        cin >> op;\n        if (op == 2)\n        {\n            cin >> k;\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[k][0]], 1, n); // ç‰ˆæœ¬å›æ»š\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[k][1]], 1, n);\n        }\n        else if (op == 3)\n        {\n            int u, v;\n            cin >> u >> v;\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[ver - 1][0]], 1, n); // ç‰ˆæœ¬å¤åˆ¶\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[ver - 1][1]], 1, n);\n            cout << same(fa.root[vers[ver][0]], u, v) << endl;\n        }\n        else\n        {\n            int u, v;\n            cin >> u >> v;\n            u = getfather(fa.root[vers[ver - 1][0]], u);\n            v = getfather(fa.root[vers[ver - 1][0]], v);\n            if (u != v)\n            {\n                int szu = siz.query(siz.root[vers[ver - 1][1]], u, 1, n);\n                int szv = siz.query(siz.root[vers[ver - 1][1]], v, 1, n);\n                if (szu < szv)\n                {\n                    swap(szu, szv);\n                    swap(u, v);\n                }\n                fa.update(fa.root[vers[ver][0]], v, u, 1, n);           // fa[v]=u,å°å‘å¤§åˆå¹¶\n                siz.update(siz.root[vers[ver][1]], u, szu + szv, 1, n); // siz[u]+=sizv\n            }\n            fa.merge(fa.root[vers[ver][0]], fa.root[vers[ver - 1][0]], 1, n); // å…ˆæ”¹å†å¤åˆ¶\n            siz.merge(siz.root[vers[ver][1]], siz.root[vers[ver - 1][1]], 1, n);\n        }\n        // fa.printtree(fa.root[vers[ver][0]]);\n        // siz.printtree(siz.root[vers[ver][1]]);\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.15 Li-Chao Tree\n\nè¦æ±‚åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸‹ç»´æŠ¤ä¸¤ä¸ªæ“ä½œï¼š\n\n1. åœ¨å¹³é¢ä¸ŠåŠ å…¥ä¸€æ¡çº¿æ®µã€‚è®°ç¬¬ $i$ æ¡è¢«æ’å…¥çš„çº¿æ®µçš„æ ‡å·ä¸º $i$ã€‚\n2. ç»™å®šä¸€ä¸ªæ•° $k$ï¼Œè¯¢é—®ä¸ç›´çº¿ $x = k$ ç›¸äº¤çš„çº¿æ®µä¸­ï¼Œäº¤ç‚¹çºµåæ ‡æœ€å¤§çš„çº¿æ®µçš„ç¼–å·ã€‚\n\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼Œä¿è¯ $1 \\leq n \\leq 10^5$ï¼Œ$1 \\leq k, x_0, x_1 \\leq 39989$ï¼Œ$1 \\leq y_0, y_1 \\leq 10^9$â€‹ã€‚\n\næè¶…æ ‘å¯ä»¥ä¼˜ç§€çš„ç»´æŠ¤å¹³é¢å†…æ·»åŠ çº¿æ€§å‡½æ•°çº¿æ®µä»¥åŠæŸ¥è¯¢$max{f_i(x)}$ï¼Œå¯ç”¨äºæ–œç‡ä¼˜åŒ–$dp$â€‹ç­‰ã€‚ä¸æ”¯æŒåŠ å…¥çº¿æ®µååˆ é™¤ï¼Œå¦‚æœ‰å¿…è¦ï¼Œè€ƒè™‘***çº¿æ®µæ ‘åˆ†æ²»+æè¶…æ ‘å®ç°***ã€‚\n\næè¶…æ ‘çš„æ ¸å¿ƒä¸º$upd$å‡½æ•°ï¼Œæ›´æ–°çº¿æ®µæ ‘***å®Œæ•´èŠ‚ç‚¹***åŒºé—´å†…çš„ä¿¡æ¯ã€‚\n\nå…·ä½“æ¥è¯´ï¼Œè®¾å½“å‰åŒºé—´çš„ä¸­ç‚¹ä¸º$mid$ï¼Œæˆ‘ä»¬æ‹¿æ–°çº¿æ®µ$f$åœ¨ä¸­ç‚¹å¤„çš„å€¼ä¸åŸæœ€ä¼˜çº¿æ®µ$g$åœ¨ä¸­ç‚¹å¤„çš„å€¼ä½œæ¯”è¾ƒã€‚\n\nå¦‚æœæ–°çº¿æ®µ$f$æ›´ä¼˜ï¼Œåˆ™å°†$f$å’Œ$g$äº¤æ¢ã€‚é‚£ä¹ˆç°åœ¨è€ƒè™‘åœ¨ä¸­ç‚¹å¤„$f$ä¸å¦‚$g$ä¼˜çš„æƒ…å†µï¼š\n\n1. è‹¥åœ¨å·¦ç«¯ç‚¹å¤„$f$æ›´ä¼˜ï¼Œé‚£ä¹ˆ$f$å’Œ$g$å¿…ç„¶åœ¨å·¦åŠåŒºé—´ä¸­äº§ç”Ÿäº†äº¤ç‚¹ï¼Œ$f$åªæœ‰åœ¨å·¦åŒºé—´æ‰å¯èƒ½ä¼˜äº $g$ï¼Œé€’å½’åˆ°å·¦å„¿å­ä¸­è¿›è¡Œä¸‹ä¼ ï¼›\n2. è‹¥åœ¨å³ç«¯ç‚¹å¤„$f$æ›´ä¼˜ï¼Œé‚£ä¹ˆ$f$å’Œ$g$å¿…ç„¶åœ¨å³åŠåŒºé—´ä¸­äº§ç”Ÿäº†äº¤ç‚¹ï¼Œ$f$åªæœ‰åœ¨å³åŒºé—´æ‰å¯èƒ½ä¼˜äº $g$ï¼Œé€’å½’åˆ°å³å„¿å­ä¸­è¿›è¡Œä¸‹ä¼ ï¼›\n3. è‹¥åœ¨å·¦å³ç«¯ç‚¹å¤„$g$éƒ½æ›´ä¼˜ï¼Œé‚£ä¹ˆ$f$ä¸å¯èƒ½æˆä¸ºç­”æ¡ˆï¼Œä¸éœ€è¦ç»§ç»­ä¸‹ä¼ ã€‚\n\né™¤äº†è¿™ä¸¤ç§æƒ…å†µä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ç§æƒ…å†µæ˜¯$f$å’Œ$g$åˆšå¥½äº¤äºä¸­ç‚¹ï¼Œåœ¨ç¨‹åºå®ç°æ—¶å¯ä»¥å½’å…¥ä¸­ç‚¹å¤„$f$ä¸å¦‚$g$ä¼˜çš„çš„æƒ…å†µï¼Œç»“æœä¼šå¾€$f$æ›´ä¼˜çš„ä¸€ä¸ªç«¯ç‚¹è¿›è¡Œé€’å½’ä¸‹ä¼ ã€‚\n\næœ€åå°†$g$ä½œä¸ºå½“å‰åŒºé—´çš„æ‡’æ ‡è®°ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\n#define d64 long double\n// #define MOD1 39989\n#define MOD1 39989\n#define MOD2 1000000000\nconst int maxn = 2e5 + 5;\nstruct node\n{\n    // int l, r;\n    int bestcnt;\n} tree[maxn << 2LL];\nint n, m;\nint lastans = 0;\nint cnt = 0;\nstruct segments\n{\n    // int l, r;\n    d64 k, b;\n} segs[maxn];\nint cmp(d64 x, d64 y)\n{\n    if (x - y > 1e-9)\n        return 1;\n    if (y - x > 1e-9)\n        return -1;\n    return 0;\n}\nd64 calc(int id, int x)\n{\n    return segs[id].k * x + segs[id].b;\n}\nvoid add(int x0, int y0, int x1, int y1)\n{\n    cnt++;\n    if (x0 == x1)\n        segs[cnt].k = 0, segs[cnt].b = max(y0, y1);\n    else\n        segs[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), segs[cnt].b = y0 - segs[cnt].k * x0;\n}\nvoid upd(int now, int rt, int cl, int cr)\n{\n    int mid = (cl + cr) >> 1LL;\n    int &v = tree[rt].bestcnt;\n    int bmid = cmp(calc(now, mid), calc(v, mid));\n    if (bmid == 1 || (!bmid && now < v))\n        swap(now, v);\n    int bl = cmp(calc(now, cl), calc(v, cl)), br = cmp(calc(now, cr), calc(v, cr));\n    if (bl == 1 || (!bl && now < v))\n        upd(now, rt << 1LL, cl, mid);\n    if (br == 1 || (!br && now < v))\n        upd(now, rt << 1LL | 1LL, mid + 1, cr);\n    return;\n}\nvoid update(int now, int l, int r, int rt, int cl, int cr)\n{\n    if (l <= cl && cr <= r)\n    {\n        upd(now, rt, cl, cr);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (l <= mid)\n        update(now, l, r, rt << 1LL, cl, mid);\n    if (r > mid)\n        update(now, l, r, rt << 1LL | 1LL, mid + 1, cr);\n    return;\n}\npair<double, int> max(pair<double, int> a, pair<double, int> b)\n{\n    if (cmp(a.first, b.first) == 1)\n        return a;\n    if (cmp(a.first, b.first) == -1)\n        return b;\n    return a.second < b.second ? a : b;\n}\npair<double, int> query(int d, int rt, int cl, int cr)\n{\n    if (cr < d || cl > d)\n        return {0, 0};\n    int mid = (cl + cr) >> 1LL;\n    double res = calc(tree[rt].bestcnt, d);\n    if (cl == cr)\n        return {res, tree[rt].bestcnt};\n    return max({res, tree[rt].bestcnt}, max(query(d, rt << 1LL, cl, mid), query(d, rt << 1LL | 1LL, mid + 1, cr)));\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int opt;\n        cin >> opt;\n        if (opt == 1)\n        {\n            int l, r, a, b;\n            cin >> l >> a >> r >> b;\n            l = (l + lastans - 1) % MOD1 + 1;\n            r = (r + lastans - 1) % MOD1 + 1;\n            a = (a + lastans - 1) % MOD2 + 1;\n            b = (b + lastans - 1) % MOD2 + 1;\n            if (l > r)\n                swap(l, r), swap(a, b);\n            add(l, a, r, b);\n            update(cnt, l, r, 1, 1, MOD1);\n        }\n        else\n        {\n            int x;\n            cin >> x;\n            x = (x + lastans - 1) % MOD1 + 1;\n            pair<double, int> ans = query(x, 1, 1, MOD1);\n            cout << ans.second << endl;\n            lastans = ans.second;\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.16 ç±»Li-Chao Tree  /  é€’å½’åŒºé—´åˆå¹¶\n\næ€ç»´ï¼Œå’Œæè¶…æ ‘æ²¡æœ‰å…³ç³»ï¼Œåœ¨äºä¸¤ä¸ªåŒºé—´åˆå¹¶`pushup`çš„æ—¶å€™æ¯”è¾ƒå›°éš¾ï¼Œéœ€è¦åƒæè¶…æ ‘çš„`upd`ä¸€æ ·é€’å½’å¤„ç†çš„æƒ…å†µã€‚\n\n```cpp\nvoid pushup1(int rt)\n{\n    tree[rt].maxn = max(tree[rt << 1].maxn, tree[rt << 1 | 1].maxn);\n}\nint pushup2(d32 tar, int rt, int cl, int cr)\n{\n    if (tree[rt].maxn <= tar)\n        return 0;\n    if (a[cl] > tar)\n        return tree[rt].len;\n    if (cl == cr)\n    {\n        return (a[cl] > tar);\n    }\n    int mid = (cl + cr) >> 1;\n    if (tree[rt << 1].maxn <= tar)\n        return pushup2(tar, rt << 1 | 1, mid + 1, cr);\n    return pushup2(tar, rt << 1, cl, mid) + tree[rt].len - tree[rt << 1].len;\n}\nvoid pushup(int rt, int cl, int cr)\n{\n    pushup1(rt);\n    int mid = (cl + cr) >> 1;\n    tree[rt].len = tree[rt << 1].len + pushup2(tree[rt << 1].maxn, rt << 1 | 1, mid + 1, cr);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.17 çº¿æ®µæ ‘åˆ†æ²»\n\nå‡å¦‚ä½ éœ€è¦ç»´æŠ¤ä¸€äº›ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯ä¼šåœ¨æŸä¸€ä¸ªæ—¶é—´æ®µå†…å‡ºç°ï¼Œè¦æ±‚åœ¨ç¦»çº¿çš„å‰æä¸‹å›ç­”æŸä¸€ä¸ªæ—¶åˆ»çš„ä¿¡æ¯å¹¶ï¼Œåˆ™å¯ä»¥è€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘åˆ†æ²»çš„æŠ€å·§ã€‚\n\nå®é™…ä¸Šçº¿æ®µæ ‘åˆ†æ²»å¸¸æœ‰ä»¥ä¸‹ç”¨é€”ï¼š\n\n1. ç”¨åŸæœ¬ä¸æ”¯æŒåˆ é™¤ä½†æ˜¯æ”¯æŒæ’¤é”€çš„æ•°æ®ç»“æ„æ¥æ¨¡æ‹Ÿåˆ é™¤æ“ä½œã€‚å¦‚æœ´ç´ çš„å¹¶æŸ¥é›†æ— æ³•é«˜æ•ˆæ”¯æŒåˆ è¾¹æ“ä½œã€‚\n2. ä¸åŒå±æ€§çš„æ•°æ®åˆ†åˆ«è®¡ç®—ã€‚å¦‚éœ€è¦æ±‚å‡ºé™¤äº†æŸä¸€ç§é¢œè‰²å¤–ï¼Œå…¶ä»–é¢œè‰²æ•°æ®çš„ç­”æ¡ˆã€‚\n\né¦–å…ˆæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªçº¿æ®µæ ‘æ¥ç»´æŠ¤æ—¶åˆ»ï¼Œæ¯ä¸€ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸€ä¸ª `vector` æ¥å­˜å‚¨ä½äºè¿™ä¸€æ®µæ—¶åˆ»çš„ä¿¡æ¯ã€‚\n\næ’å…¥ä¸€ä¸ªä¿¡æ¯åˆ°çº¿æ®µæ ‘ä¸­å’Œæ™®é€šçº¿æ®µæ ‘çš„åŒºé—´ä¿®æ”¹æ˜¯ç±»ä¼¼çš„ã€‚\n\nç„¶åæˆ‘ä»¬è€ƒè™‘å¦‚ä½•å¤„ç†æ¯ä¸€ä¸ªæ—¶é—´æ®µçš„ä¿¡æ¯å¹¶ã€‚è€ƒè™‘ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ†æ²»ï¼Œç»´æŠ¤å½“å‰çš„ä¿¡æ¯å¹¶ï¼Œç„¶åæ¯åˆ°ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™å°†è¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰ä¿¡æ¯è¿›è¡Œåˆå¹¶ã€‚å›æº¯æ—¶æ’¤é”€è¿™ä¸€éƒ¨åˆ†çš„è´¡çŒ®ã€‚æœ€ååˆ°è¾¾å¶å­èŠ‚ç‚¹æ—¶çš„ä¿¡æ¯å¹¶å°±æ˜¯å¯¹åº”çš„ç­”æ¡ˆã€‚\n\nå¦‚æœæ›´æ”¹ä¿¡æ¯çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(T(n))$ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®ä¸€ä¸ªæ ˆä¿ç•™æ›´æ”¹ï¼Œä»¥$O(T(n))$çš„æ—¶é—´å¤æ‚åº¦æ’¤é”€ã€‚æ’¤é”€ä¸ç»´æŒå‡æ‘Šå¤æ‚åº¦ã€‚\n\næ•´ä¸ªåˆ†æ²»æµç¨‹çš„æ€»æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlogn(T(n)+M(n)))$çš„ï¼Œå…¶ä¸­$O(M(n))$ä¸ºåˆå¹¶ä¿¡æ¯çš„æ—¶é—´å¤æ‚åº¦ï¼Œç©ºé—´å¤æ‚åº¦ä¸º$O(nlogn)$â€‹ã€‚\n\nå¹¶æŸ¥é›†ä¸å«Œéº»çƒ¦æœ€å¥½å†™å¯æŒä¹…åŒ–ï¼Œä¸ç”¨æ ˆï¼Œé€Ÿåº¦è¿˜åå¿«ä¸€ç‚¹,ç¼ºç‚¹æ˜¯ç é‡ç¡®å®é«˜ï¼Œè€Œä¸”ä¸€æ—¦æŠ„é”™äº†ä¸å¥½DEBUGã€‚***å¦‚æœå†™æ™®é€šå¹¶æŸ¥é›†ï¼Œå¿…é¡»å†™æŒ‰ç§©åˆå¹¶ï¼Œè·¯å¾„å‹ç¼©å› ä¸ºå‡æ‘Šå¤æ‚åº¦ä¸è¢«æ”¯æŒ***ã€‚æ’¤é”€æ—¶ï¼Œç›´æ¥é€šè¿‡æ ˆæ‰€è®°å½•çš„`merge`å‰çš„ä¿¡æ¯ç›´æ¥å¤åŸå³å¯ã€‚\n\n```cpp\n#define ls (i << 1)\n#define rs (i << 1 | 1)\n#define mid ((l + r) >> 1)\n\nvector<Object> tree[N << 2];  // çº¿æ®µæ ‘\n\nvoid update(int ql, int qr, Object obj, int i, int l, int r) {  // æ’å…¥\n  if (ql <= l && r <= qr) {\n    tree[i].push_back(obj);\n    return;\n  }\n  if (ql <= mid) update(ql, qr, obj, ls, l, mid);\n  if (qr > mid) update(ql, qr, obj, rs, mid + 1, r);\n}\n\nstack<Object> sta;  // ç”¨äºæ’¤é”€çš„æ ˆ\nObject now;         // å½“å‰çš„ä¿¡æ¯å¹¶\nObject ans[N];      // ç­”æ¡ˆ\n\nvoid solve(int i, int l, int r) {\n  auto lvl = sta.size();  // è®°å½•ä¸€ä¸‹åº”å½“æ’¤é”€åˆ°ç¬¬å‡ ä¸ª\n  for (Object x : tree[i]) sta.push(now), now = Merge(now, x);  // åˆå¹¶ä¿¡æ¯\n  if (l == r)\n    ans[i] = now;  // è®°å½•ä¸€ä¸‹ç­”æ¡ˆ\n  else\n    solve(ls, l, mid), solve(rs, mid + 1, r);  // åˆ†æ²»\n  while (sta.size() != lvl) {                  // æ’¤é”€ä¿¡æ¯\n    now = sta.top();\n    sta.pop();\n  }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.18 çº¿æ®µæ ‘ç»´æŠ¤æœ€å¤§å­æ®µå’Œ\n\nçº¿æ®µæ ‘ç»“ç‚¹ç»´æŠ¤åŒºé—´æœ€å€¼ï¼ŒåŒºé—´å‰ç¼€å’Œæœ€å€¼ï¼ŒåŒºé—´åç¼€å’Œæœ€å€¼ï¼ŒåŒºé—´$op$â€‹â€‹çš„æ—¶å€™æ¯”è¾ƒä¸€ä¸‹ä¸¤ä¸ªåŒºé—´çš„åŒºé—´æœ€å¤§å­æ®µå’Œä»¥åŠå‰æ®µåç¼€+åæ®µå‰ç¼€çš„å’Œå³å¯ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nconst int maxn = 5e5 + 9;\nstruct segtree\n{\n    struct node\n    {\n        i64 sum, pre, suf, maxans;\n    };\n    node tree[maxn << 2];\n    i64 a[maxn];\n    void pushup(int rt)\n    {\n        int lson = rt << 1, rson = rt << 1 | 1;\n        i64 interval = tree[lson].suf + tree[rson].pre;\n        tree[rt].sum = tree[lson].sum + tree[rson].sum;\n        tree[rt].pre = max(tree[lson].pre, tree[lson].sum + tree[rson].pre);\n        tree[rt].suf = max(tree[rson].suf, tree[rson].sum + tree[lson].suf);\n        tree[rt].maxans = max(max(tree[lson].maxans, tree[rson].maxans), interval);\n        return;\n    }\n    void build(int rt, int cl, int cr)\n    {\n        if (cl == cr)\n        {\n            tree[rt].sum = tree[rt].pre = tree[rt].suf = tree[rt].maxans = a[cl];\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        build(rt << 1, cl, mid);\n        build(rt << 1 | 1, mid + 1, cr);\n        pushup(rt);\n        return;\n    }\n    void modify(int pos, int val, int rt, int cl, int cr)\n    {\n        if (cl == cr)\n        {\n            tree[rt].sum = tree[rt].pre = tree[rt].suf = tree[rt].maxans = val;\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            modify(pos, val, rt << 1, cl, mid);\n        else\n            modify(pos, val, rt << 1 | 1, mid + 1, cr);\n        pushup(rt);\n        return;\n    }\n    node query(int l, int r, int rt, int cl, int cr)\n    {\n        if (l <= cl && cr <= r)\n        {\n            return tree[rt];\n        }\n        int mid = (cl + cr) >> 1;\n        if (r <= mid)\n            return query(l, r, rt << 1, cl, mid);\n        if (l > mid)\n            return query(l, r, rt << 1 | 1, mid + 1, cr);\n        node lson = query(l, r, rt << 1, cl, mid);\n        node rson = query(l, r, rt << 1 | 1, mid + 1, cr);\n        node ret;\n        i64 interval = lson.suf + rson.pre;\n        ret.sum = lson.sum + rson.sum;\n        ret.pre = max(lson.pre, lson.sum + rson.pre);\n        ret.suf = max(rson.suf, rson.sum + lson.suf);\n        ret.maxans = max(max(lson.maxans, rson.maxans), interval);\n        return ret;\n    }\n};\nsegtree seg;\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> seg.a[i];\n    }\n    seg.build(1, 1, n);\n    for (int i = 1; i <= m; i++)\n    {\n        int op, x, y;\n        cin >> op >> x >> y;\n        if (op == 1)\n        {\n            if (x > y)\n                swap(x, y);\n            cout << seg.query(x, y, 1, 1, n).maxans << endl;\n        }\n        else\n        {\n            seg.modify(x, y, 1, 1, n);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.19 æƒå€¼æ ‘ç»´æŠ¤åŒºé—´æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•°\n\n$HH$çš„é¡¹é“¾ï¼Œç¢°åˆ°ç›¸åŒçš„æ•°å°±æŠŠå‰é¢é‚£ä¸ªå‡ºç°çš„ä½ç½®åˆ æ‰ï¼ˆæƒå€¼æ ‘-1ï¼‰ï¼Œåé¢æ–°å‡ºç°çš„ä½ç½®åŠ ä¸Šï¼ˆæƒå€¼æ ‘+1ï¼‰\n\nè¿™ç©æ„å„¿æ²¡æ±‚å‰ç¼€å’Œï¼Œä¸èƒ½ç®—ä¸»å¸­æ ‘ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n        x = x * 10 + ch - '0', ch = getchar();\n    return x * f;\n}\nvoid write(int x)\n{\n    if (x < 0)\n        putchar('-'), x = -x;\n    if (x > 9)\n        write(x / 10);\n    putchar(x % 10 + '0');\n    return;\n}\nstruct Persistant_segtree\n{\nprivate:\n    struct node\n    {\n        int l = 0, r = 0;\n        int sum = 0;\n    };\n    vector<node> tree;\n    int tot;\n    int n;\n\npublic:\n    Persistant_segtree(int n) : n(n), tot(0)\n    {\n        tree.assign((n << 5) + 9, node());\n    }\n    Persistant_segtree() : n(0), tot(0)\n    {\n        tree.clear();\n    }\n    void init(int n)\n    {\n        this->n = n;\n        tot = 0;\n        tree = vector<node>((n << 5) + 9);\n    }\n    void update(int &rt1, int rt2, int pos, int val, int cl, int cr)\n    {\n        if (!rt1)\n            rt1 = ++tot;\n        tree[rt1].sum = tree[rt2].sum + val;\n        if (cl == cr)\n        {\n            return;\n        }\n        int mid = (cl + cr) >> 1;\n        if (pos <= mid)\n            update(tree[rt1].l, tree[rt2].l, pos, val, cl, mid), tree[rt1].r = tree[rt2].r;\n        else\n            update(tree[rt1].r, tree[rt2].r, pos, val, mid + 1, cr), tree[rt1].l = tree[rt2].l;\n    }\n    int query(int &rt, int l, int r, int cl, int cr)\n    {\n        if (!rt)\n            return 0;\n        if (l <= cl && cr <= r)\n            return tree[rt].sum;\n        int mid = (cl + cr) >> 1;\n        int res = 0;\n        if (l <= mid)\n            res += query(tree[rt].l, l, r, cl, mid);\n        if (r > mid)\n            res += query(tree[rt].r, l, r, mid + 1, cr);\n        return res;\n    }\n};\nPersistant_segtree pst;\nconst int maxn = 1e6 + 9;\nint a[maxn], lastpos[maxn], root[maxn];\n#define endl '\\n'\nint main()\n{\n    int n, m;\n    n = read();\n    pst.init(maxn);\n    for (int i = 1; i <= n; i++)\n        a[i] = read();\n    for (int i = 1; i <= n; i++)\n    {\n        if (lastpos[a[i]])\n        {\n            pst.update(root[i], root[i - 1], lastpos[a[i]], -1, 1, n);\n            pst.update(root[i], root[i], i, 1, 1, n);\n            lastpos[a[i]] = i;\n        }\n        else\n        {\n            pst.update(root[i], root[i - 1], i, 1, 1, n);\n            lastpos[a[i]] = i;\n        }\n    }\n    m = read();\n    while (m--)\n    {\n        int l, r;\n        l = read(), r = read();\n        write(pst.query(root[r], l, r, 1, n));\n        putchar(endl);\n    }\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.20  çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾\n\né€šè¿‡çº¿æ®µæ ‘åŒºé—´çš„æ€§è´¨å®ç°çº¿æ®µæ ‘åŒºé—´è¿è¾¹å»ºå›¾ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä»åŒºé—´è¿å‡ºéœ€è¦èµ°å‡ºæ ‘ï¼Œå‘åŒºé—´è¿å…¥éœ€è¦èµ°å…¥æ ‘ï¼Œå¿…é¡»ä¿è¯å»ºç«‹ä¸¤æ£µæ ‘ï¼Œå‡ºæ ‘å‘æ ¹æœ‰å‘è¾¹$(sons\\to fa)$ï¼Œå…¥æ ‘ä»æ ¹å‘ä¸‹æœ‰å‘è¾¹$(fa\\to sons)$ï¼Œä¸å¯ä»¥ä¸²è¡Œã€‚å¶å­ç»“ç‚¹ä¸¤æ£µæ ‘å€’æ˜¯å¯ä»¥å…±äº«ï¼Œä¸å…±äº«çš„è¯å¶å­ç»“ç‚¹è¦åšå¥½æ— å‘è¾¹è”é€šï¼Œè¯¦æƒ…è§ç¤ºä¾‹ã€‚\n\n<img src=\"https://oi-wiki.org/ds/images/segt6.svg\" alt=\"å‡ºæ ‘\" style=\"zoom:50%;\" />\n\n<img src=\"https://oi-wiki.org/ds/images/segt5.svg\" alt=\"å…¥æ ‘\" style=\"zoom:50%;\" />\n\næœ‰$n$ä¸ªç‚¹ã€$q$æ¬¡æ“ä½œã€‚æ¯ä¸€ç§æ“ä½œä¸ºä»¥ä¸‹ä¸‰ç§ç±»å‹ä¸­çš„ä¸€ç§:\n\n1. è¿ä¸€æ¡$uâ†’v$çš„æœ‰å‘è¾¹,æƒå€¼ä¸º$w$ã€‚\n2. å¯¹äºæ‰€æœ‰$iâˆˆ[l,r]$è¿ä¸€æ¡$uâ†’i$çš„æœ‰å‘è¾¹,æƒå€¼ä¸º$Ï‰$ã€‚\n3. å¯¹äºæ‰€æœ‰$iâˆˆ[l,r]$è¿ä¸€æ¡$iâ†’u$çš„æœ‰å‘è¾¹,æƒå€¼ä¸º$Ï‰$ã€‚\n\næ±‚ä»ç‚¹$s$åˆ°å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯ã€‚\n\n$1â‰¤n,qâ‰¤10^5,1â‰¤wâ‰¤10^9$â€‹ã€‚\n\n```cpp\n// çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾\n// åŒºé—´å¯¹åŒºé—´è¿è¾¹ï¼ŒåŒºé—´å¯¹å•ç‚¹è¿è¾¹ï¼Œå•ç‚¹å¯¹åŒºé—´è¿è¾¹\n// æ˜¾ç„¶çš„ï¼Œéœ€è¦åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ï¼Œå»ºç«‹çš„è™šç‚¹å‚ä¸è·‘æœ€çŸ­è·¯\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF = 1e18;\nint tottree = 0, cnt = 0;\nint root1 = 0, root2 = 0;\nint n;\nconst int maxn = 4e5 + 9;\nint head[maxn << 3LL], to[maxn << 3LL], nxt[maxn << 3LL], w[maxn << 3LL];\nint rtnum1[maxn], rtnum2[maxn];\nstruct node\n{\n    int l, r;\n    int cl, cr;\n};\nnode tree[maxn << 3LL];\nvoid add_edge(int u, int v, int w)\n{\n    to[++cnt] = v;\n    ::w[cnt] = w;\n    nxt[cnt] = head[u];\n    head[u] = cnt;\n}\nvoid build1(int &rt, int cl = 1, int cr = n) // å‡ºæ ‘ï¼ŒåŒºé—´è¿å‡º\n{\n    if (!rt)\n        rt = ++tottree;\n    tree[rt].cl = cl;\n    tree[rt].cr = cr;\n    if (cl == cr)\n    {\n        rtnum1[cl] = rt;\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    build1(tree[rt].l, cl, mid);\n    build1(tree[rt].r, mid + 1, cr);\n    add_edge(tree[rt].l, rt, 0);\n    add_edge(tree[rt].r, rt, 0);\n    return;\n}\nvoid build2(int &rt, int cl = 1, int cr = n) // å…¥æ ‘ï¼ŒåŒºé—´è¿å…¥\n{\n    if (!rt)\n        rt = ++tottree;\n    tree[rt].cl = cl;\n    tree[rt].cr = cr;\n    if (cl == cr)\n    {\n        rtnum2[cl] = rt;\n        add_edge(rt, rtnum1[cl], 0);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    build2(tree[rt].l, cl, mid);\n    build2(tree[rt].r, mid + 1, cr);\n    add_edge(rt, tree[rt].l, 0);\n    add_edge(rt, tree[rt].r, 0);\n    return;\n}\nvoid update1(int &rt, int u, int vl, int vr, int w, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (vl <= cl && cr <= vr)\n    {\n        add_edge(rtnum1[u], rt, w);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (vl <= mid)\n        update1(tree[rt].l, u, vl, vr, w, cl, mid);\n    if (vr > mid)\n        update1(tree[rt].r, u, vl, vr, w, mid + 1, cr);\n}\nvoid update2(int &rt, int v, int ul, int ur, int w, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (ul <= cl && cr <= ur)\n    {\n        add_edge(rt, rtnum2[v], w);\n        return;\n    }\n    int mid = (cl + cr) >> 1LL;\n    if (ul <= mid)\n        update2(tree[rt].l, v, ul, ur, w, cl, mid);\n    if (ur > mid)\n        update2(tree[rt].r, v, ul, ur, w, mid + 1, cr);\n}\nint dist[maxn << 3LL];\nbool vis[maxn << 3LL];\nvoid updist(int &rt, int cl = 1, int cr = n)\n{\n    if (!rt)\n        return;\n    if (cl == cr)\n        return;\n    int mid = (cl + cr) >> 1LL;\n    dist[tree[rt].l] = min(dist[rt], dist[tree[rt].l]);\n    dist[tree[rt].r] = min(dist[rt], dist[tree[rt].r]);\n    updist(tree[rt].l, cl, mid);\n    updist(tree[rt].r, mid + 1, cr);\n    return;\n}\nvoid dijkstra(int s)\n{\n    // memset(dist, 0x3f3f3f3f, sizeof(int) * (tottree + 10));\n    for (int i = 1; i <= tottree + 10; i++)\n        dist[i] = INF, vis[i] = 0;\n    struct qu\n    {\n        int dis, pos;\n        bool operator<(const qu &x) const\n        {\n            return x.dis < dis;\n        }\n    };\n    priority_queue<qu> q;\n    dist[rtnum1[s]] = 0;\n    q.push({0, rtnum1[s]});\n    while (!q.empty())\n    {\n        auto [disu, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (int i = head[u]; i; i = nxt[i])\n        {\n            int v = to[i];\n            if (dist[v] > dist[u] + w[i])\n            {\n                dist[v] = dist[u] + w[i];\n                q.push({dist[v], v});\n            }\n        }\n    }\n    // updist(root);\n    return;\n}\nvoid clear()\n{\n    memset(head, 0, sizeof(int) * (tottree + 10));\n    cnt = 0, tottree = 0;\n    root1 = 0, root2 = 0;\n    return;\n}\nvoid solve()\n{\n    int q, s;\n    cin >> n >> q >> s;\n    build1(root1);\n    build2(root2);\n    while (q--)\n    {\n        int op;\n        cin >> op;\n        int u, v, w, l, r;\n        switch (op)\n        {\n        case 1:\n            cin >> u >> v >> w;\n            add_edge(rtnum1[u], rtnum2[v], w);\n            break;\n        case 2:\n            cin >> u >> l >> r >> w;\n            update1(root2, u, l, r, w);\n            break;\n        case 3:\n            cin >> v >> l >> r >> w;\n            update2(root1, v, l, r, w);\n            break;\n        }\n    }\n    dijkstra(s);\n    for (int i = 1; i <= n; i++)\n    {\n        if (i == s)\n        {\n            cout << \"0 \";\n            continue;\n        }\n        if (dist[rtnum2[i]] == INF)\n            cout << \"-1 \";\n        else\n            cout << dist[rtnum2[i]] << \" \";\n    }\n    cout << endl;\n    clear();\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *1.21 å‰å¸æœºçº¿æ®µæ ‘\n\nçº¿æ®µæ ‘ç»´æŠ¤åŒºé—´æœ€å€¼æ“ä½œä¸åŒºé—´å†å²æœ€å€¼çš„æ¨¡æ¿ã€‚\n\nç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°åˆ— $A$ï¼ŒåŒæ—¶å®šä¹‰ä¸€ä¸ªè¾…åŠ©æ•°ç»„ $B$ï¼Œ$B$ å¼€å§‹ä¸ $A$ å®Œå…¨ç›¸åŒã€‚æ¥ä¸‹æ¥è¿›è¡Œäº† $m$ æ¬¡æ“ä½œï¼Œæ“ä½œæœ‰äº”ç§ç±»å‹ï¼ŒæŒ‰ä»¥ä¸‹æ ¼å¼ç»™å‡ºï¼š\n\n- `1 l r k`ï¼šå¯¹äºæ‰€æœ‰çš„ $i\\in[l,r]$ï¼Œå°† $A_i$ åŠ ä¸Š $k$ï¼ˆ$k$ å¯ä»¥ä¸ºè´Ÿæ•°ï¼‰ã€‚\n- `2 l r v`ï¼šå¯¹äºæ‰€æœ‰çš„ $i\\in[l,r]$ï¼Œå°† $A_i$ å˜æˆ $\\min(A_i,v)$ã€‚\n- `3 l r`ï¼šæ±‚ $\\sum_{i=l}^{r}A_i$ã€‚\n- `4 l r`ï¼šå¯¹äºæ‰€æœ‰çš„ $i\\in[l,r]$ï¼Œæ±‚ $A_i$ çš„æœ€å¤§å€¼ã€‚\n- `5 l r`ï¼šå¯¹äºæ‰€æœ‰çš„ $i\\in[l,r]$ï¼Œæ±‚ $B_i$ çš„æœ€å¤§å€¼ã€‚\n\nåœ¨æ¯ä¸€æ¬¡æ“ä½œåï¼Œæˆ‘ä»¬éƒ½è¿›è¡Œä¸€æ¬¡æ›´æ–°ï¼Œè®© $B_i\\gets\\max(B_i,A_i)$ã€‚\n\nä¿è¯ $1\\leq n,m\\leq 5\\times 10^5$,$-5\\times10^8\\leq A_i\\leq 5\\times10^8$,\n\n$op\\in[1,5]$,$1 \\leq l\\leq r \\leq n$,$-2000\\leq k\\leq 2000$,\n\n$-5\\times10^8\\leq v\\leq 5\\times10^8$â€‹â€‹ã€‚\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*o=obuf;\n#define g()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ninline int read()\n{\n    int s=0,f=1;char c=g();\n    for(;!isdigit(c);c=g())\n        if(c=='-')f=-1;\n    for(;isdigit(c);c=g())\n        s=s*10+c-'0';\n    return s*f;\n}\ninline void write(ll x)\n{\n    static char buf[20];\n    static int len=-1;\n    if(x<0)putchar('-'),x=-x;\n    do buf[++len]=x%10,x/=10;while(x);\n    while(len>=0)putchar(buf[len--]+'0');\n    putchar('\\n');\n}\nint n,m,op,l,r,k,v;\nstruct segment_tree{\n    ll sum;\n    int l,r,maxa,cnt,se,maxb;\n    int add1,add2,add3,add4;\n}s[2000005];\ninline void push_up(int p)\n{\n    s[p].sum=s[p*2].sum+s[p*2+1].sum;\n    s[p].maxa=max(s[p*2].maxa,s[p*2+1].maxa);\n    s[p].maxb=max(s[p*2].maxb,s[p*2+1].maxb);\n    if(s[p*2].maxa==s[p*2+1].maxa)\n    {\n        s[p].se=max(s[p*2].se,s[p*2+1].se);\n        s[p].cnt=s[p*2].cnt+s[p*2+1].cnt;\n    }\n    else if(s[p*2].maxa>s[p*2+1].maxa)\n    {\n        s[p].se=max(s[p*2].se,s[p*2+1].maxa);\n        s[p].cnt=s[p*2].cnt;\n    }\n    else\n    {\n        s[p].se=max(s[p*2].maxa,s[p*2+1].se);\n        s[p].cnt=s[p*2+1].cnt;\n    }\n}\nvoid build(int l,int r,int p)\n{\n    s[p].l=l,s[p].r=r;\n    if(l==r)\n    {\n        s[p].sum=s[p].maxa=s[p].maxb=read();\n        s[p].cnt=1,s[p].se=-2e9;\n        return;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,p*2);\n    build(mid+1,r,p*2+1);\n    push_up(p);\n}\ninline void change(int k1,int k2,int k3,int k4,int p)\n{\n    s[p].sum+=1ll*k1*s[p].cnt+1ll*k2*(s[p].r-s[p].l+1-s[p].cnt);\n    s[p].maxb=max(s[p].maxb,s[p].maxa+k3);\n    s[p].maxa+=k1;\n    if(s[p].se!=-2e9)s[p].se+=k2;\n    s[p].add3=max(s[p].add3,s[p].add1+k3);\n    s[p].add4=max(s[p].add4,s[p].add2+k4);\n    s[p].add1+=k1,s[p].add2+=k2;\n}\ninline void push_down(int p)\n{\n    int maxn=max(s[p*2].maxa,s[p*2+1].maxa);\n    if(s[p*2].maxa==maxn)\n        change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2);\n    else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2);\n    if(s[p*2+1].maxa==maxn)\n        change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2+1);\n    else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2+1);\n    s[p].add1=s[p].add2=s[p].add3=s[p].add4=0;\n}\nvoid update_add(int p)\n{\n    if(l>s[p].r||r<s[p].l)return;\n    if(l<=s[p].l&&s[p].r<=r)\n    {\t\n        s[p].sum+=1ll*k*s[p].cnt+1ll*k*(s[p].r-s[p].l+1-s[p].cnt);\n        s[p].maxa+=k;\n        s[p].maxb=max(s[p].maxb,s[p].maxa);\n        if(s[p].se!=-2e9)s[p].se+=k;\n        s[p].add1+=k,s[p].add2+=k;\n        s[p].add3=max(s[p].add3,s[p].add1);\n        s[p].add4=max(s[p].add4,s[p].add2);\n        return;\n    }\n    push_down(p);\n    update_add(p*2),update_add(p*2+1);\n    push_up(p);\n}\nvoid update_min(int p)\n{\n    if(l>s[p].r||r<s[p].l||v>=s[p].maxa)return;\n    if(l<=s[p].l&&s[p].r<=r&&s[p].se<v)\n    {\n        int k=s[p].maxa-v;\n        s[p].sum-=1ll*s[p].cnt*k;\n        s[p].maxa=v,s[p].add1-=k;\n        return;\n    }\n    push_down(p);\n    update_min(p*2),update_min(p*2+1);\n    push_up(p);\n}\nll query_sum(int p)\n{\n    if(l>s[p].r||r<s[p].l)return 0;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].sum;\n    push_down(p);\n    return query_sum(p*2)+query_sum(p*2+1);\n}\nint query_maxa(int p)\n{\n    if(l>s[p].r||r<s[p].l)return -2e9;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].maxa;\n    push_down(p);\n    return max(query_maxa(p*2),query_maxa(p*2+1));\n}\nint query_maxb(int p)\n{\n    if(l>s[p].r||r<s[p].l)return -2e9;\n    if(l<=s[p].l&&s[p].r<=r)return s[p].maxb;\n    push_down(p);\n    return max(query_maxb(p*2),query_maxb(p*2+1));\n}\nint main()\n{\n    n=read(),m=read();\n    build(1,n,1);\n    while(m--)\n    {\n        op=read(),l=read(),r=read();\n        if(op==1)k=read(),update_add(1);\n        else if(op==2)v=read(),update_min(1);\n        else if(op==3)write(query_sum(1));\n        else if(op==4)printf(\"%d\\n\",query_maxa(1));\n        else printf(\"%d\\n\",query_maxb(1));\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *1.22 æ ‘ä¸Šæ•°æ®ç»“æ„è­¦ç¤ºï¼ˆæ ‘ä¸Šçº¿æ®µæ ‘ï¼‰\n\nä¸€èˆ¬è€Œè¨€ï¼Œæ ‘ä¸Šæ•°æ®ç»“æ„ä¸»è¦æ˜¯æ ‘ä¸Šæƒå€¼æ ‘ä»¥åŠæ ‘ä¸ŠåŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ã€‚è¿™é‡ŒæåŠä¸¤ä¸ª**éœ€è¦æ³¨æ„çš„ç‚¹**\n\n1. ä¸»å¸­æ ‘/çº¿æ®µæ ‘åˆå¹¶å†™æ³•çš„$merge$å‡½æ•°åœ¨å‘çˆ¶èŠ‚ç‚¹åˆå¹¶çš„æ—¶å€™ä¼šæœ‰æ‹·è´èŠ‚ç‚¹ï¼ˆä¸»å¸­æ ‘åŸç†ï¼‰ï¼Œ**å¦‚æœæœ‰å¤šä¸ªå„¿å­èŠ‚ç‚¹ï¼Œè¿™ç§è¡Œä¸ºä¼šå¯¼è‡´çˆ¶èŠ‚ç‚¹ä¿¡æ¯åˆå¹¶å®Œå…¨ä¹‹åï¼Œå­èŠ‚ç‚¹çš„ä¸»å¸­æ ‘ä¿¡æ¯è¢«æ±¡æŸ“ã€‚**å¦‚æœè¦è¿™ä¹ˆåšï¼Œæ¶‰åŠåˆ°å­æ ‘ä¿¡æ¯æŸ¥è¯¢ï¼Œéœ€è¦åˆå¹¶dfsçš„åŒæ—¶è¿›è¡Œç¦»çº¿å¤„ç†ï¼Œä¿è¯æ±¡æŸ“ä¹‹åä¸å†æŸ¥è¯¢ã€‚\n\n   è§£å†³æ–¹æ³•æ˜¯æ ‘é“¾å‰–åˆ†ï¼Œå°¤å…¶æ˜¯å­æ ‘ä¿¡æ¯ç»´æŠ¤ï¼Œæ›´æ˜¯æ ‘å‰–ä¸ºé‡ä¸­ä¹‹é‡ã€‚\n\n   æ ‘ä¸Šå·®åˆ†ä¸ä¼šå› ä¸ºè¿™ä¸ªå—å½±å“çš„åŸå› åœ¨äºï¼Œæ ‘ä¸Šå·®åˆ†çš„ä¿¡æ¯åˆå¹¶æ˜¯çˆ¶èŠ‚ç‚¹å‘å­èŠ‚ç‚¹åˆå¹¶ï¼Œå­èŠ‚ç‚¹ç»§æ‰¿çˆ¶èŠ‚ç‚¹çš„ä¿¡æ¯ä»¥è®°å½•**ä»è‡ªå·±ç›´åˆ°æ ¹**è·¯å¾„ä¸Šçš„æ‰€æœ‰æ•°ä¿¡æ¯ï¼Œå­èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹å¯ä»¥ç»§æ‰¿ï¼Œæ„å‘³ç€çˆ¶èŠ‚ç‚¹çš„ä¿¡æ¯ä¸ä¼šè¢«æ±¡æŸ“ã€‚\n\n   ï¼ˆABC239E æ ‘ä¸Šå­æ ‘ç¬¬$K$â€‹å¤§å› ä¸ºè¿™ä¸ªé—®é¢˜å¯¼è‡´WAï¼‰\n\n2. æ ‘ä¸Šåˆå¹¶ï¼Œ**ä¸€å®šæ£€æŸ¥æœ‰æ²¡æœ‰å†™**`cl==cr`é‡Œé¢çš„$\\color{red}return$\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.å †(Heap)\n\nå…³é”®è¯ï¼šæœ‰åºåºåˆ—ï¼Œåªå…³å¿ƒæœ€å€¼\n\n### 2.1 å¯å¹¶å †ï¼ˆå·¦åæ ‘ï¼‰\n\nå®šä¹‰å·¦åæ ‘ä¸­å·¦å„¿å­ç»“ç‚¹çš„$dist_l$ä¸€å®šå¤§äºç­‰äºå³å„¿å­èŠ‚ç‚¹çš„$dist_r$.\n\nå®šä¹‰æŸèŠ‚ç‚¹$u$çš„$dist_u$ä¸ºå…¶åˆ°$u$â€‹â€‹æ‰€åœ¨å­æ ‘ä¸­æœ€è¿‘çš„å¤–èŠ‚ç‚¹ï¼ˆæ²¡æœ‰å·¦å„¿å­æˆ–è€…å³å„¿å­ï¼‰çš„è·ç¦»ã€‚\n\nä¸€å¼€å§‹æœ‰ $n$ ä¸ªå°æ ¹å †ï¼Œæ¯ä¸ªå †åŒ…å«ä¸”ä»…åŒ…å«ä¸€ä¸ªæ•°ã€‚æ¥ä¸‹æ¥éœ€è¦æ”¯æŒä¸¤ç§æ“ä½œï¼š\n\n1. `1 x y`ï¼šå°†ç¬¬ $x$ ä¸ªæ•°å’Œç¬¬ $y$ ä¸ªæ•°æ‰€åœ¨çš„å°æ ¹å †åˆå¹¶ï¼ˆè‹¥ç¬¬ $x$ æˆ–ç¬¬ $y$ ä¸ªæ•°å·²ç»è¢«åˆ é™¤æˆ–ç¬¬ $x$ å’Œç¬¬ $y$ ä¸ªæ•°åœ¨åŒä¸€ä¸ªå †å†…ï¼Œåˆ™æ— è§†æ­¤æ“ä½œï¼‰ã€‚\n\n2. `2 x`ï¼šè¾“å‡ºç¬¬ $x$ ä¸ªæ•°æ‰€åœ¨çš„å †æœ€å°æ•°ï¼Œå¹¶å°†è¿™ä¸ªæœ€å°æ•°åˆ é™¤ï¼ˆè‹¥æœ‰å¤šä¸ªæœ€å°æ•°ï¼Œä¼˜å…ˆåˆ é™¤å…ˆè¾“å…¥çš„ï¼›è‹¥ç¬¬ $x$ ä¸ªæ•°å·²ç»è¢«åˆ é™¤ï¼Œåˆ™è¾“å‡º $-1$â€‹ å¹¶æ— è§†åˆ é™¤æ“ä½œï¼‰ã€‚\n\n***æ³¨æ„ï¼Œè¿™ä¸ªé¢˜éœ€è¦æŸ¥æŸä¸ªæ•°åœ¨å“ªä¸ªå †ï¼Œéœ€è¦å¹¶æŸ¥é›†ï¼Œè€Œä¸”å› ä¸ºè·¯å¾„å‹ç¼©çš„ä¸æˆæ ·å­ï¼Œä½†å‡¡æ¶‰åŠåˆ°å¼¹å‡ºå †é¡¶ï¼Œå¿…é¡»è¿è¢«åˆ é™¤å…ƒç´ ä¸€èµ·è°ƒæ•´è€Œä¸æ˜¯å°†åˆ é™¤å…ƒç´ ç®€ç®€å•å•çš„ fa å½’0å°±å¯ä»¥ã€‚***\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct heap\n{\n    int dis, l, r, fa, val;\n};\nconst int maxn = 1e5 + 9;\nheap tr[maxn << 5];\nint n, m;\nint getfather(int x)\n{\n    return tr[x].fa == x ? x : tr[x].fa = getfather(tr[x].fa);\n}\nint merge(int x, int y)\n{\n    if (!x || !y)\n        return x | y;\n    if (tr[x].val > tr[y].val)\n        swap(x, y);\n    tr[x].r = merge(tr[x].r, y);\n    if (tr[tr[x].l].dis < tr[tr[x].r].dis)\n        swap(tr[x].l, tr[x].r);\n    tr[x].dis = tr[tr[x].r].dis + 1;\n    tr[tr[x].l].fa = tr[tr[x].r].fa = tr[x].fa = x;\n    return x;\n}\nint pop(int x)\n{\n    tr[x].val = -1;\n    tr[tr[x].l].fa = tr[x].l;\n    tr[tr[x].r].fa = tr[x].r;\n    tr[x].fa = merge(tr[x].l, tr[x].r);\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i)\n        tr[i].fa = i, cin >> tr[i].val;\n    int t, x, y;\n    for (int i = 1; i <= m; ++i)\n    {\n        cin >> t >> x;\n        if (t == 1)\n        {\n            cin >> y;\n            if (tr[x].val == -1 || tr[y].val == -1)\n                continue;\n            int l = getfather(x), r = getfather(y);\n            if (l != r)\n                tr[l].fa = tr[r].fa = merge(l, r);\n        }\n        else\n        {\n            if (tr[x].val == -1)\n                cout << -1 << endl;\n            else\n                cout << tr[getfather(x)].val << endl, pop(getfather(x));\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 å¸¦æ‡’æ ‡è®°å·¦åæ ‘\n\nåƒåŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ä¸€æ ·ï¼Œåˆå¹¶æ—¶æ³¨æ„æ ‡è®°ä¸‹ä¼ é—®é¢˜\n\n```cpp\nstruct node\n{\n    int dis, val; int ch[2]; int fa; int lazyadd = 0, lazymul = 1;\n    int id; int cnt; int lazyc = 0;\n};\nint &rs(int rt) {return tree[rt].ch[tree[tree[rt].ch[0]].dis > tree[tree[rt].ch[1]].dis];/*æ³¨æ„rså†™æ³•*/}\nint &ls(int rt) {return tree[rt].ch[1 ^ (tree[tree[rt].ch[0]].dis > tree[tree[rt].ch[1]].dis)];/*æ›´æ³¨æ„lså†™æ³•*/}\nint &dis(int rt) {return tree[rt].dis;}\nint &val(int rt) {return tree[rt].val;}\nint &fa(int rt) {return tree[rt].fa;}\nint &lazyadd(int rt) {return tree[rt].lazyadd;}\nint &lazymul(int rt) {return tree[rt].lazymul;}\nint &lazyc(int rt) {return tree[rt].lazyc;}\nint &vcnt(int rt) {return tree[rt].cnt;}\nint &id(int rt) {return tree[rt].id;}\nvoid pushdown(int rt)\n{\n    if (!rt)\n        return;\n    if (lazyadd(rt) != 0 || lazymul(rt) != 1 || lazyc(rt) != 0)\n    {\n        if (ls(rt))\n        {\n            val(ls(rt)) = val(ls(rt)) * lazymul(rt) + lazyadd(rt);\n            vcnt(ls(rt)) += lazyc(rt);\n            lazymul(ls(rt)) *= lazymul(rt);\n            lazyadd(ls(rt)) = lazyadd(ls(rt)) * lazymul(rt) + lazyadd(rt);\n            lazyc(ls(rt)) += lazyc(rt);\n        }\n        if (rs(rt))\n        {\n            val(rs(rt)) = val(rs(rt)) * lazymul(rt) + lazyadd(rt);\n            vcnt(rs(rt)) += lazyc(rt);\n            lazymul(rs(rt)) *= lazymul(rt);\n            lazyadd(rs(rt)) = lazyadd(rs(rt)) * lazymul(rt) + lazyadd(rt);\n            lazyc(rs(rt)) += lazyc(rt);\n        }\n        lazyadd(rt) = 0;\n        lazymul(rt) = 1;\n        lazyc(rt) = 0;\n    }\n    return;\n}\nint merge(int rt1, int rt2)\n{\n    if (!rt1 || !rt2)\n        return rt1 | rt2;\n    if (val(rt1) > val(rt2))\n        swap(rt1, rt2);\n    pushdown(rt1);\n    int &r = rs(rt1);\n    r = merge(r, rt2);\n    fa(r) = rt1;\n    dis(rt1) = dis(rs(rt1)) + 1; // ä¸¥ç¦ä½¿ç”¨pushupäºæ­¤ï¼Œpushupåªç”¨äºåˆ é™¤ä»»æ„éæ ¹èŠ‚ç‚¹æ—¶ä½¿ç”¨ï¼Œåˆ é™¤æ ¹èŠ‚ç‚¹è¦pop\n    return rt1;\n}\nint pop(int rt1)\n{\n    pushdown(rt1);\n    return merge(ls(rt1), rs(rt1));\n}\nint tot = 0;\nint push(int rt1, int val, int id)\n{\n    tree[++tot].val = val;\n    tree[tot].id = id;\n    return merge(rt1, tot);\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### *2.3 æ”¯æŒåˆ é™¤ä»»æ„èŠ‚ç‚¹å¯å¹¶å †\n\næ²¡æœ‰ä¸“é—¨çš„é¢˜ï¼Œæœ‰æ¶‰åŠåˆ°å¯å¹¶å †åˆ å¯¹åº”èŠ‚ç‚¹çš„ç†è®ºä¸Šä¸»å¸­æ ‘éƒ½å¯ä»¥åšï¼Œè€Œä¸”å¤æ‚åº¦æ˜¯ä¸€æ ·çš„ï¼Œä¼˜å…ˆå†™è‡ªå·±é¡ºæ‰‹çš„ã€‚\n\nè¿™é‡Œæ˜¯OI-wikiçš„\n\n```cpp\nvoid erase(int x) {\n  int y = merge(ls(x), rs(x));\n  fa(y) = fa(x);\n  if (ls(fa(x)) == x)\n    ls(fa(x)) = y;\n  else if (rs(fa(x)) == x)\n    rs(fa(x)) = y;\n  pushup(fa(y));\n}\n```\n\n### *2.4 GNU/GCC pb_dsåº“\n\n`pb_ds`åº“æä¾›äº†äº”ç§å¯å¹¶å †ï¼Œé»˜è®¤å¤§æ ¹å †ï¼Œ`greater`æ ‡ç­¾ä½¿ç”¨å’Œæ™®é€š$STL$ä¸€è‡´ã€‚\n\n```cpp\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n__gnu_pbds::priority_queue<int>q;//å› ä¸ºæ”¾ç½®å’Œstdé‡å¤ï¼Œæ•…éœ€è¦å¸¦ä¸Šå‘½åç©ºé—´\n__gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> q;//æœ€å¿«\n__gnu_pbds::priority_queue<int,greater<int>,binary_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,binomial_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,rc_binomial_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int>,thin_heap_tag> q;\n__gnu_pbds::priority_queue<int,greater<int> > q;\n```\n\n`pairing_heap_tag` : `push`å’Œ`join`ä¸º$O(1)$,å…¶ä½™ä¸ºå‡æ‘Š$O(logn)$ã€‚\n\n`binary_heap_tag`:åªæ”¯æŒ`push`å’Œ`pop`,å‡ä¸ºå‡æ‘Š$O(logn)$ã€‚\n\n`binomial_heap_tag`:`push`ä¸ºå‡æ‘Š$O(1)$,å…¶ä½™ä¸º$O(logn)$ã€‚\n\n`rc_binomial_heap_tag`: `push`ä¸º$O(1)$,å…¶ä½™ä¸º$O(logn)$ã€‚\n\n`thin_heap_tag`: `push`ä¸º$O(1)$,ä¸æ”¯æŒ`join`,å…¶ä½™ä¸º$O(logn)$;ä½†æ˜¯å¦‚æœåªæœ‰`increase_key`,é‚£ä¹ˆ`modify`ä¸ºå‡æ‘Š$O(1)$â€‹ã€‚â€œä¸æ”¯æŒâ€ä¸æ˜¯ä¸èƒ½ç”¨,è€Œæ˜¯ç”¨èµ·æ¥å¾ˆæ…¢\n\næ“ä½œè¡¨ï¼š\n\n- `size()`ç”¨æ³•åŒstd\n\n- `empty()`ç”¨æ³•åŒstd\n\n- `push(const_reference r_val)`æ³¨æ„`push`è¿”å›`point_iterator`ï¼Œè¢«`push`å…ƒç´ å…¥å †åä½ç½®\n\n- `top()`æ²¡åŒºåˆ«â€¦\n\n- `pop()`å¼¹å‡ºå †é¡¶\n\n- `point_iterator`å¯¹åº”æŸå…ƒç´ çš„è¿­ä»£å™¨\n\n- `erase(point_iterator it)`åˆ é™¤å¯¹åº”ç‚¹\n\n- `modify(point_iterator it,const_reference r_new_val)`ä¿®æ”¹å¯¹åº”ç‚¹çš„å€¼\n\n  è¿™æ˜¯ä¼˜åŒ–$dijkstra$ç¥æ–¹æ³•,å‡æ‘Šå¤æ‚åº¦$O(1)$â€‹\n\n  ä¼˜åŒ–$dijkstra$çš„æ€è·¯å°±æ˜¯åœ¨å‰é¢æåˆ°çš„$std$ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–çš„åŸºç¡€ä¸Š,ç»´æŠ¤ä¸€ä¸ª`point_iterator`æ•°ç»„,`push`çš„æ—¶å€™å­˜ä¸‹`push`æ—¶è¿”å›çš„è¿­ä»£å™¨,æ›´æ–°`dis`æ˜¯åˆ¤æ–­æ˜¯å¦å­˜åœ¨æ­¤è¿­ä»£å™¨,è‹¥å­˜åœ¨$O(1)$`modify`,ä¸å­˜åœ¨å‡æ‘Š$O(1)$`push`\n\n- `clear()`åŸºæœ¬æ²¡ä»€ä¹ˆç”¨,è¿˜ä¸å¦‚é‡æ–°å®šä¹‰ä¸€ä¸ªâ€¦\n\n- `join(priority_queue &other)`å¯å¹¶å †å•Š,è¿˜æ˜¯$O(1)$çš„,æ³¨æ„åˆå¹¶å`other`ä¼šè¢«æ¸…ç©º\n\n- å…¶ä»–è¿­ä»£å™¨åŒstd\n\nä½¿ç”¨ç¤ºä¾‹ï¼š\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n#define int long long\nusing mergeable_priority_queue = __gnu_pbds::priority_queue<int, less<int>, __gnu_pbds::pairing_heap_tag>;\nconst int maxn = 2e5 + 9;\nint ans = 0;\nvector<int> connects[maxn];\nmergeable_priority_queue qs[maxn];\nint sum[maxn];\nint L[maxn];\nint n, m;\nvoid dfs(int u, int fa)\n{\n    for (auto v : connects[u])\n    {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n        qs[u].join(qs[v]);\n        sum[u] += sum[v];\n    }\n    while (!qs[u].empty() && sum[u] > m)\n    {\n        sum[u] -= qs[u].top();\n        qs[u].pop();\n    }\n    ans = max(ans, (int)(qs[u].size()) * L[u]);\n    return;\n}\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        int fa, c, l;\n        cin >> fa >> c >> l;\n        qs[i].push(c);\n        sum[i] += c, L[i] = l;\n        connects[fa].push_back(i);\n        connects[i].push_back(fa);\n    }\n    dfs(0, 0);\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 3.STè¡¨ï¼ˆSparse Tableï¼‰\n\nå…³é”®è¯ï¼šé™æ€åŒºé—´ï¼Œå¯é‡å¤è´¡çŒ®\n\nç¨€ç–è¡¨ï¼Œå€å¢ï¼Œå¯ä»¥è§£å†³å¯é‡å¤è´¡çŒ®é—®é¢˜ï¼š\n\nä»£æ•°ç³»ç»Ÿ$<S,\\cdot >$æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š\n\n1. è¯¥ä»£æ•°ç³»ç»Ÿä¸ºåŠç¾¤ã€‚\n2. å¯¹äº$\\forall x\\in S,x\\cdot x=x$â€‹ï¼ˆå¯é‡å¤è´¡çŒ®ï¼‰\n\né™¤ RMQ ä»¥å¤–ï¼Œè¿˜æœ‰å…¶å®ƒçš„ã€Œå¯é‡å¤è´¡çŒ®é—®é¢˜ã€ã€‚ä¾‹å¦‚ã€ŒåŒºé—´æŒ‰ä½ä¸ã€ã€ã€ŒåŒºé—´æŒ‰ä½æˆ–ã€ã€ã€ŒåŒºé—´ GCDã€ï¼ŒST è¡¨éƒ½èƒ½é«˜æ•ˆåœ°è§£å†³ã€‚\n\nå¦‚æœç¢°åˆ°æ¶å¿ƒçš„å¡å†…å­˜çš„ï¼Œè€ƒè™‘STè¡¨å­˜å¯¹åº”ç­”æ¡ˆåœ¨åŸæ•°ç»„çš„ä¸‹æ ‡ï¼ŒèŠ‚çœç©ºé—´ã€‚\n\n### 3.1 é™æ€åŒºé—´æœ€å€¼ï¼Œä¸€ç»´STè¡¨\n\n```cpp\n// STè¡¨ï¼Œé™æ€åŒºé—´æœ€å¤§å€¼\n#include <bits/stdc++.h>\nusing namespace std;\nint getlog(int n)\n{\n    int ans = 0;\n    while (n)\n    {\n        n >>= 1;\n        ans++;\n    }\n    return ans - 1;\n}\nconst int maxn = 5e5 + 10;\nint st[maxn][20];\n#define endl '\\n'\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    int q;\n    cin >> q;\n    int logn = getlog(n);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> st[i][0];\n    }\n    for (int j = 1; j <= logn; j++)\n    {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++)\n        {\n            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n    while (q--)\n    {\n        int l, r;\n        cin >> l >> r;\n        int dis = r - l + 1;\n        int k = getlog(dis);\n        cout << max(st[l][k], st[r - (1 << k) + 1][k]) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.2 é™æ€åŒºé—´æœ€å€¼ï¼ŒäºŒç»´STè¡¨\n\nç±»æ¯”ä¸€ç»´$ST$ è¡¨ï¼Œæˆ‘ä»¬å®šä¹‰æ•°ç»„$st[i][j][k][p]$è¡¨ç¤ºä»$(i,j)$å¾€ä¸‹$2^k$ä¸ªå…ƒç´ ï¼Œå¾€å³$2^p$ä¸ªå…ƒç´ çš„æœ€å€¼ã€‚\n\nå»ºè¡¨çš„è¯ï¼ŒåŒæ ·ç±»æ¯”ä¸€ç»´$ST$è¡¨ï¼Œå¤–å±‚ä¸¤ä¸ªå¾ªç¯$k$ å’Œ$p$ , ç„¶åå†…å±‚å–æœ€å€¼å°±è¡Œäº†ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œ$k$ å’Œ$p$è¦ä»$0$â€‹å¼€å§‹å¾ªç¯ï¼Œå› ä¸ºä¸€è¡Œæˆ–è€…ä¸€åˆ—çš„æƒ…å†µä¹Ÿè¦ç»´æŠ¤ã€‚\n\nå¤æ‚åº¦$O(n^2log^2n)$\n\n```cpp\nvoid build_st()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            if (i == 0 && j == 0)\n                continue;\n            for (int k = 1; k <= n - (1 << i) + 1; k++)\n            {\n                for (int p = 1; p <= n - (1 << j) + 1; p++)\n                {\n                    if (i == 0)\n                        st[k][p][i][j] = min(st[k][p][i][j - 1], st[k][p + (1 << j - 1)][i][j - 1]);\n                    else\n                        st[k][p][i][j] = min(st[k][p][i - 1][j], st[k + (1 << i - 1)][p][i - 1][j]);\n                }\n            }\n        }\n    }\n}\n\nint query(int r1, int c1, int r2, int c2)\n{\n    int k1 = log2(r2 - r1 + 1);\n    int k2 = log2(c2 - c1 + 1);\n    return min(st[r1][c1][k1][k2], min(st[r2 - (1 << k1) + 1][c1][k1][k2], min(st[r1][c2 - (1 << k2) + 1][k1][k2], st[r2 - (1 << k1) + 1][c2 - (1 << k2) + 1][k1][k2])));\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.3 å€å¢STè¡¨æ±‚è§£LCAé—®é¢˜\n\nå€å¢ä¼˜åŒ–æ±‚$LCA$ï¼Œ$dfs$é¢„å¤„ç†ç¥–å…ˆä¿¡æ¯ï¼Œç„¶åæŸ¥è¯¢æ—¶å…ˆè·³åˆ°åŒä¸€é«˜åº¦ï¼Œå†ä¸€èµ·æš´åŠ›å‘ä¸Šè·³ã€‚æš´åŠ›å‘ä¸Šè·³å¿…é¡»ä»å¤§å‘å°æšä¸¾ã€‚é¢„å¤„ç†$O(nlogn)$ï¼Œå•æ¬¡æŸ¥è¯¢$O(n)$.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 9;\nvector<int> connects[maxn];\nint fa[maxn][21];\nint dep[maxn];\ninline void dfs(int u, int fas)\n{\n    dep[u] = dep[fas] + 1;\n    fa[u][0] = fas;\n    for (int j = 1; j <= 20; j++)\n    {\n        fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    }\n    for (auto v : connects[u])\n    {\n        if (v == fas)\n            continue;\n        dfs(v, u);\n    }\n    return;\n}\ninline int lca(int u, int v)\n{\n    if (dep[u] < dep[v])\n        swap(u, v);\n    int tmp = dep[u] - dep[v];\n    for (int j = 0; j <= 20; j++)\n    {\n        if ((tmp >> j) & 1)\n            u = fa[u][j];\n    }\n    if (u == v)\n        return u;\n    for (int j = 20; j >= 0; j--)\n    {\t\t\n        if (fa[u][j] != fa[v][j])\n        {\n            u = fa[u][j], v = fa[v][j];\n        }\n    }\n    return fa[u][0];\n}\nint main()\n{\n    int n, m, rt;\n    cin >> n >> m >> rt;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        connects[u].push_back(v);\n        connects[v].push_back(u);\n    }\n    dfs(rt, rt);\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.4 æ¬§æ‹‰åºSTè¡¨æ±‚LCAé—®é¢˜\n\né—®é¢˜è½¬åŒ–æˆ$dfs$éå†è·¯å¾„è®°å½•ä¸‹ç»“ç‚¹çš„$dfn$åºå·ä¸Š$RMQ$é—®é¢˜ï¼Œä¸¤ä¸ªèŠ‚ç‚¹çš„$lca$ä¸€å®šæ˜¯æ¬§æ‹‰åºéå†ä¸‹åºå·åŒºé—´å†…æ·±åº¦æœ€æµ…çš„ç»“ç‚¹ã€‚å¯ä»¥åšåˆ°$O(nlogn)$é¢„å¤„ç†ï¼Œå•æ¬¡è¯¢é—®$O(1)$.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 9;\nvector<int> connects[maxn];\nint st[maxn << 1][25];\nint dep[maxn];\nint pos[maxn];\nint logs[maxn << 1];\nvoid add_edge(int u, int v)\n{\n    connects[u].push_back(v);\n    connects[v].push_back(u);\n}\nint cnt = 0;\nvoid dfs1(int u, int fa)\n{\n    st[++cnt][0] = u;\n    dep[u] = dep[fa] + 1;\n    pos[u] = cnt;\n    for (auto v : connects[u])\n    {\n        if (v == fa)\n            continue;\n        dfs1(v, u);\n        st[++cnt][0] = u;//æ¬§æ‹‰åºè®°å½•\n    }\n    return;\n}\nvoid build_st()\n{\n    for (int j = 1; j < 25; j++)\n        for (int i = 1; i + (1 << j) - 1 <= cnt; i++)\n        {\n            int l = st[i][j - 1], r = st[i + (1 << (j - 1))][j - 1];//stç»´æŠ¤ç»“ç‚¹åºå·\n            if (dep[l] < dep[r])\n                st[i][j] = l;\n            else\n                st[i][j] = r;\n        }\n    logs[1] = 0;\n    for (int i = 2; i <= cnt; i++)\n    {\n        logs[i] = logs[i / 2] + 1;\n    }\n    return;\n}\nint lcas(int u, int v)\n{\n    int l = pos[u], r = pos[v];\n    if (l > r)\n        swap(l, r);\n    int k = logs[r - l + 1];\n    int ansl = st[l][k];\n    int ansr = st[r - (1 << k) + 1][k];\n    if (dep[ansl] < dep[ansr])\n        return ansl;\n    else\n        return ansr;\n}\nint main()\n{\n    int n, m, rt;\n    cin >> n >> m >> rt;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    dfs1(rt, rt);\n    build_st();\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lcas(u, v) << endl;\n    }\n    return 0;\n}\n```\n\n\n\n<div style=\"page-break-after: always;\"></div>\n\n## 4.å¹¶æŸ¥é›†(Disjoint Sets)\n\nå…³é”®è¯ï¼šåŒå±æ€§åˆ†ç±»\n\n### 4.1 å¸¦æƒå¹¶æŸ¥é›†\n\nç»´æŠ¤è·¯å¾„æƒå€¼ä¿¡æ¯ï¼Œå¸¸è§ç”¨è·¯å¾„å‹ç¼©å‡æ‘Šå¤æ‚åº¦ã€‚mergeæ—¶æä¸æ¸…å°±ç”»å‘é‡å›¾è¡¨ç¤ºï¼Œä¸€ä¸‹å°±æ‡‚ã€‚\n\n```cpp\nint getfather(int x)\n{\n    int fa = father[x];\n    if (x != father[x])\n    {\n        father[x] = getfather(father[x]);\n        val[x] += val[fa];\n        return father[x];\n    }\n    return x;\n}\nvoid merge(int x, int y, int value)\n{\n    int fx = getfather(x);\n    int fy = getfather(y);\n    father[fx] = fy;\n    val[fx] = value + val[y] - val[x];\n}\n```\n\n### 4.2 ç§ç±»å¹¶æŸ¥é›†\n\nä¸€ä¸ªç‚¹æ‹†æˆå¤šä¸ªç‚¹ç»´æŠ¤å¯¹ç«‹çŸ›ç›¾ç­‰ä¿¡æ¯ã€‚\n\n```cpp\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int maxn = 1e6 + 1;\nint father[maxn];\nint ran[maxn];\nint n;\nint getfather(int x)\n{\n    if (x == father[x])\n        return x;\n    return father[x] = getfather(father[x]);\n}\nvoid merge(int x, int y)\n{\n    int fx = getfather(x);\n    int fy = getfather(y);\n    father[fx]=fy;\n}\nvoid eat(int x, int y)\n{\n    merge(x, n + y);\n    merge(n + x, 2 * n + y);\n    merge(2 * n + x, y);\n}\nvoid same(int x, int y)\n{\n    merge(x, y);\n    merge(n + x, n + y);\n    merge(2 * n + x, 2 * n + y);\n}\nbool checkeat(int x, int y)\n{\n    return getfather(x) == getfather(y + n) || getfather(x) == getfather(y + 2 * n); // æŸ¥è¯¢æ•é£Ÿå’Œè¢«æ•é£Ÿå…³ç³»\n}\nbool checksame(int x, int y)\n{\n    return (getfather(x) == getfather(y)) || x == y;\n}\nvoid init(int n)\n{\n    for (int i = 1; i <= 3 * n; i++)\n    {\n        father[i] = i;\n    }\n}\n```\n\n### 4.3 å¯æŒä¹…åŒ–å¹¶æŸ¥é›†\n\nè§1.14\n\n<div style=\"page-break-after: always;\"></div>\n\n## 5.æ ‘çŠ¶æ•°ç»„(Fenwick Trees)\n\nå…³é”®è¯ï¼šäºŒè¿›åˆ¶æšä¸¾ï¼Œå‰ç¼€å’Œ\n\næ ‘çŠ¶æ•°ç»„ç»´æŠ¤ç±»ä¼¼å‰ç¼€å’Œçš„ä¸œè¥¿ã€‚æ ¸å¿ƒæ“ä½œä¸ºlowbitã€‚\n\n### 5.1 äºŒç»´æ ‘çŠ¶æ•°ç»„ï¼ˆæ¨¡æ¿ï¼Œå­çŸ©å½¢æ‰€æœ‰å…ƒç´ å’Œï¼‰\n\nä¸€ç»´çš„æ ‘çŠ¶æ•°ç»„éƒ½ä¼šå†™ã€‚ä¸‹é¢çš„æ˜¯äºŒç»´çš„ã€‚ç»´æŠ¤çŸ©å½¢å‰ç¼€å’Œ\n\n```cpp\n// é«˜ä½æ ‘çŠ¶æ•°ç»„ï¼Œæ²¡å•¥å¤§åŒºåˆ«ï¼Œå¼€å¤šä¸ª\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct Fenwick\n{\nprivate:\n    int n, m;\n    vector<vector<i64>> c;\n    int lowbit(int x) { return x & -x; }\n\npublic:\n    Fenwick(int n, int m) : n(n), m(m), c(n + 1, vector<i64>(m + 1, 0)) {}\n    Fenwick() : n(0), m(0) {}\n    void init(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        c.assign(n + 1, vector<i64>(m + 1, 0));\n    }\n    void add(int x, int y, i64 v)\n    {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = y; j <= m; j += lowbit(j))\n                c[i][j] += v;\n    }\n    i64 query(int x, int y)\n    {\n        i64 res = 0;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = y; j; j -= lowbit(j))\n                res += c[i][j];\n        return res;\n    }\n};\n```\n\n### 5.2 ç¦»çº¿äºŒç»´æ•°ç‚¹\n\næ±‚$[l,r]$å†…å°äºç­‰äº$x$çš„ç‚¹æœ‰å¤šå°‘ä¸ªã€‚\n\n```cpp\n// ç¦»çº¿äºŒç»´æ•°ç‚¹ï¼Œæ‰«æçº¿ç¦»çº¿ç‰ˆæœ¬\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 int\nstruct Fenwick\n{\nprivate:\n    int _n;\n    vector<i64> c;\n\npublic:\n    void init(int n)\n    {\n        _n = n;\n        c = vector<i64>(n + 1, 0);\n    }\n    void add(int x, i64 d)\n    {\n        for (; x <= _n; x += (x & -x))\n            c[x] += d;\n    }\n    i64 query(int x)\n    {\n        i64 res = 0;\n        for (; x; x -= (x & -x))\n            res += c[x];\n        return res;\n    }\n};\nFenwick fw;\nconst int maxn = 2e6 + 10;\nvector<pair<int, int>> mp[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n + 1);\n    int maxs = 0;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], maxs = max(maxs, a[i]);\n    vector<tuple<int, int, int>> query(q + 1);\n    vector<int> ans(q + 1);\n    for (int i = 1; i <= q; i++)\n    {\n        int l, r, x;\n        cin >> l >> r >> x;\n        query[i] = {l, r, x};\n        mp[r].push_back({i, 1});\n        mp[l - 1].push_back({i, -1});\n    }\n    fw.init(maxs + 100);\n    for (int i = 1; i <= n; i++)\n    {\n        fw.add(a[i], 1);\n        for (auto &j : mp[i])\n        {\n            ans[j.first] += j.second * fw.query(get<2>(query[j.first]));\n        }\n    }\n    for (int i = 1; i <= q; i++)\n        cout << ans[i] << '\\n';\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 6.å¹³è¡¡æ ‘ï¼ˆBindary Search AVL Treeï¼‰\n\nå…³é”®è¯ï¼šæœ‰åºåºåˆ—ï¼ŒåŠ¨æ€æ’å…¥ä¸åˆ é™¤ã€‚\n\n### 6.1 æ™®é€šå¹³è¡¡æ ‘\n\nè¯´å®è¯ï¼Œè£¸å¹³è¡¡æ ‘ç”¨çš„çœŸä¸å¤šï¼Œèƒ½ç”¨$set$ã€$multiset$ç­‰$STL$â€‹â€‹å®ç°çš„ä¸œè¥¿ä¸ºå•¥è¦è‡ªå·±å†™ã€‚\n\næ›´æ–°ï¼šéœ€è¦çŸ¥é“æ’åå°±åˆ«å°¼ç›æƒ³ä½ çš„multisetäº†ï¼Œèµ¶ç´§ç»™æˆ‘æ»šå»å†™$Treap$!\n\n***å¹³è¡¡æ ‘å¯æä¾›ä»¥ä¸‹æ“ä½œï¼š***\n\n1. æ’å…¥ä¸€ä¸ªæ•° $x$ã€‚\n2. åˆ é™¤ä¸€ä¸ªæ•° $x$ï¼ˆè‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œåº”åªåˆ é™¤ä¸€ä¸ªï¼‰ã€‚\n3. å®šä¹‰**æ’å**ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° $+1$ã€‚æŸ¥è¯¢ $x$ çš„æ’åã€‚\n4. æŸ¥è¯¢æ•°æ®ç»“æ„ä¸­æ’åä¸º $x$ çš„æ•°ã€‚\n5. æ±‚ $x$ çš„å‰é©±ï¼ˆå‰é©±å®šä¹‰ä¸ºå°äº $x$ï¼Œä¸”æœ€å¤§çš„æ•°ï¼‰ã€‚\n6. æ±‚ $x$ çš„åç»§ï¼ˆåç»§å®šä¹‰ä¸ºå¤§äº $x$ï¼Œä¸”æœ€å°çš„æ•°ï¼‰ã€‚\n\nå¯¹äºæ“ä½œ 3,5,6ï¼Œ**ä¸ä¿è¯**å½“å‰æ•°æ®ç»“æ„ä¸­å­˜åœ¨æ•° $x$ï¼Œ$1\\le n \\le 10^5$.\n\n#### 6.1.1 æ›¿ç½ªç¾Šæ ‘ï¼ˆScapeGoat Treeï¼‰\n\næ›¿ç½ªç¾Šæ ‘æ˜¯ä¸€ä¸ªå¾ˆæš´åŠ›çš„æ€æƒ³ï¼Œæ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°åŠ¨æ€æ£€æŸ¥æ’å…¥åæŸäº›èŠ‚ç‚¹æ˜¯å¦éœ€è¦æš´åŠ›è¿›è¡Œå¹³è¡¡é‡æ„ã€‚ä¸€èˆ¬é€‰æ‹©å¹³è¡¡å› å­$\\alpha=0.7-0.8$ã€‚å¦‚æœæŸä¸ªå­æ ‘çš„å·¦å„¿å­æ‰€ç®¡è¾–å­æ ‘å¤§å°å æ¯”ä¾‹è¶…è¿‡å¹³è¡¡å› å­å°±é‡æ„ã€‚é‡æ„å°±æ˜¯ä¸­åºéå†æš´åŠ›é‡æ„å³å¯ã€‚\n\nå¤æ‚åº¦å‡æ‘Š$O(nlogn)$ï¼Œæ ‘é«˜å‡æ‘Š$O(logn)$\n\nä¸‹é¢ç¤ºä¾‹ä¸­ï¼Œé‡å¤ç‚¹ç®—ä½œæ–°å¼€ç‚¹ï¼Œç‚¹æ€»æ•°ä¸å¾—è¶…è¿‡$1e5$çº§åˆ«ã€‚å¹³è¡¡æ ‘æ„å»ºæ—¶ï¼Œé»˜è®¤å·¦å„¿å­æƒå€¼å¿…é¡»ä¸¥æ ¼å°äºè‡ªèº«ï¼Œå³ç›¸åŒæƒå€¼ç»“ç‚¹å¿…å®šæ˜¯å…¨éƒ¨æŒ‚è½½äºå³å„¿å­ä¸Šã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (1 << 30);\ntypedef long long ll;\nconst int maxn = 1e6 + 5;\nvector<int> vec;\nstruct node\n{\n    int ls, rs, w; // å·¦å„¿å­ï¼Œæœ‰å„¿å­ï¼ŒèŠ‚ç‚¹æƒå€¼\n    bool exist;    // è¯¥èŠ‚ç‚¹æ‰€ä»£è¡¨å…ƒç´ æ˜¯å¦å­˜åœ¨\n    int sizx;      // è¯¥èŠ‚ç‚¹ä¸‹å±å­æ ‘å¤§å°\n    int fact;      // è¯¥èŠ‚ç‚¹ä¸‹å±å­æ ‘ä¸­å°šå­˜åœ¨å…ƒç´ ä¸ªæ•°\n} tr[maxn];\nint cnt, root;\nvoid pushup(int now) // ç»´æŠ¤èŠ‚ç‚¹ä¿¡æ¯\n{\n    tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;\n    tr[now].fact = tr[tr[now].ls].fact + tr[tr[now].rs].fact + 1;\n}\nvoid newnode(int &now, int w) // å¼€æ–°ç‚¹\n{\n    now = ++cnt;\n    tr[now].w = w, tr[now].sizx = tr[now].fact = 1;\n    tr[now].exist = true;\n}\nbool judge(int now) // åˆ¤æ–­æ˜¯å¦å¹³è¡¡\n{\n    if (max(tr[tr[now].ls].sizx, tr[tr[now].rs].sizx) > tr[now].sizx * 0.75)\n        return true;\n    if ((tr[now].sizx - tr[now].fact) > tr[now].sizx * 0.3)\n        return true;\n    return false;\n}\nvoid mds(int now) // ä¸­åºéå†\n{\n    if (!now)\n        return;\n    mds(tr[now].ls);\n    if (tr[now].exist)\n        vec.push_back(now);\n    mds(tr[now].rs);\n}\nvoid cre(int L, int R, int &now) // æ„é€ æ ‡å‡†å¹³è¡¡æ ‘\n{\n    if (L == R)\n    {\n        now = vec[L];\n        tr[now].ls = tr[now].rs = 0;\n        tr[now].sizx = tr[now].fact = 1;\n        return;\n    }\n    int mid = (L + R) >> 1;\n    while (L < mid && tr[vec[mid]].w == tr[vec[mid - 1]].w)\n        mid--;\n    now = vec[mid];\n    if (L < mid)\n        cre(L, mid - 1, tr[now].ls);\n    else\n        tr[now].ls = 0;\n    cre(mid + 1, R, tr[now].rs);\n    pushup(now);\n}\nvoid update(int now, int en) // ç»´æŠ¤çˆ¶è¾ˆèŠ‚ç‚¹\n{\n    if (!now)\n        return;\n    if (tr[now].w > tr[en].w)\n        update(tr[now].ls, en);\n    else\n        update(tr[now].rs, en);\n    tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;\n}\nvoid rebuild(int &now) // é‡æ„æ ‘\n{\n    vec.clear();\n    mds(now);\n    if (vec.empty())\n    {\n        now = 0;\n        return;\n    }\n    cre(0, vec.size() - 1, now);\n}\nvoid check(int &now, int en) // æ£€æŸ¥ï¼Œå¹¶é‡æ„å­æ ‘\n{\n    if (now == en)\n        return;\n    if (judge(now))\n    {\n        rebuild(now);\n        update(root, now);\n        return;\n    }\n    if (tr[en].w < tr[now].w)\n        check(tr[now].ls, en);\n    else\n        check(tr[now].rs, en);\n}\nvoid inser(int &now, int w) // æ’å…¥\n{\n    if (!now)\n    {\n        newnode(now, w);\n        check(root, now);\n        return;\n    }\n    tr[now].sizx++, tr[now].fact++;\n    if (w < tr[now].w)\n        inser(tr[now].ls, w);\n    else\n        inser(tr[now].rs, w);\n}\nvoid del(int now, int w) // åˆ é™¤\n{\n    if (tr[now].exist && tr[now].w == w)\n    {\n        tr[now].exist = false;\n        tr[now].fact--;\n        check(root, now);\n        return;\n    }\n    tr[now].fact--;\n    if (w < tr[now].w)\n        del(tr[now].ls, w);\n    else\n        del(tr[now].rs, w);\n}\nint getrank(int w) // æ±‚wçš„æ’å\n{\n    int now = root, rank = 1;\n    while (now)\n    {\n        if (w <= tr[now].w)\n            now = tr[now].ls;\n        else\n        {\n            rank += tr[now].exist + tr[tr[now].ls].fact, now = tr[now].rs;\n        }\n    }\n    return rank;\n}\nint getnum(int rank) // æ±‚æ’åä¸ºrankçš„æ ‘æ•°\n{\n    int now = root;\n    while (now)\n    {\n        if (tr[now].exist && tr[tr[now].ls].fact + tr[now].exist == rank)\n            break;\n        else if (rank <= tr[tr[now].ls].fact)\n            now = tr[now].ls;\n        else\n        {\n            rank -= tr[now].exist + tr[tr[now].ls].fact, now = tr[now].rs;\n        }\n    }\n    return tr[now].w;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int op, x;\n        cin >> op >> x;\n        switch (op)\n        {\n        case 1:\n            inser(root, x);\n            break;\n        case 2:\n            del(root, x);\n            break;\n        case 3:\n            cout << getrank(x) << endl;\n            break;\n        case 4:\n            cout << getnum(x) << endl;\n            break;\n        case 5:\n            cout << getnum(getrank(x) - 1) << endl;\n            break;\n        case 6:\n\n            cout << getnum(getrank(x + 1)) << endl;\n            break;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.2 æ ‘å †ï¼ˆTreapï¼‰\n\n$Treap=Tree+Heap$ï¼Œæ˜¯ä¸€ç§å¼±å¹³è¡¡æ€§è´¨çš„å¹³è¡¡æ ‘ï¼Œ***å‡æ‘Š***æ ‘æ·±åº¦$O(logn)$ã€‚\n\næ¯ä¸€ä¸ªæ ‘èŠ‚ç‚¹å¤šèµ‹å€¼ä¸€ä¸ª***éšæœº***æƒå€¼ï¼Œä½¿å¾—è¯¥æ ‘***æ—¢æ»¡è¶³å¹³è¡¡æ ‘æ€§è´¨***ï¼ˆ$val_{lson}<val_{rt}< val_{rson}$ï¼‰ï¼Œ***åˆæ»¡è¶³å †çš„æ€§è´¨***ï¼ˆ$w_{lson}<w_{rt},w_{rt}>w_{rson}$â€‹ï¼‰\n\nå¤æ‚åº¦æ­£ç¡®æ€§ç”±éšæœºæ•°ä¿è¯ã€‚\n\nå…³äºæ›´å¤šçš„Treapï¼Œè¯¦è§***6.2 ç¬›å¡å°”æ ‘***\n\n***æ­¤å¤„çš„ç¤ºä¾‹å› é¢˜ç›®ä¿è¯å‰é©±åç»§å¿…å®šå­˜åœ¨æ•…æ²¡æœ‰ç‰¹åˆ¤ï¼Œå¦‚æœå‰é©±åç»§ä¸å­˜åœ¨å¯¹åº”å‡½æ•°å¿…å®šå¡æ­»ï¼Œè§£å†³æ–¹æ¡ˆå‚è§6.3.1å¯æŒä¹…åŒ–Treapä¸­çš„è§£å†³æ–¹å¼ã€‚***\n\n##### 6.1.2.1 æœ‰æ—‹Treap\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nconst int inf = 0x3f3f3f3f;\nunsigned int seed;\nrandom_device rd;\nmt19937 ran;\nstruct Treap\n{\n    struct node\n    {\n        int val, rnd, lc, rc, size, num;\n    };\n    int cnt = 0;\n    node tr[MAXN];\n    void init()\n    {\n        cnt = 0;\n    }\n    int _rand()\n    {\n        ran.seed(rd());\n        return ran();\n    }\n    void pushup(int p)\n    {\n        tr[p].size = tr[tr[p].lc].size + tr[tr[p].rc].size + tr[p].num;\n    }\n    void right(int &k)\n    {\n        int tmp = tr[k].lc;\n        tr[k].lc = tr[tmp].rc;\n        tr[tmp].rc = k;\n        tr[tmp].size = tr[k].size;\n        pushup(k);\n        k = tmp;\n    }\n    void left(int &k)\n    {\n        int tmp = tr[k].rc;\n        tr[k].rc = tr[tmp].lc;\n        tr[tmp].lc = k;\n        tr[tmp].size = tr[k].size;\n        pushup(k);\n        k = tmp;\n    }\n    void insert(int &p, int x)\n    {\n        if (p == 0)\n        {\n            p = ++cnt;\n            tr[p].val = x;\n            tr[p].num = tr[p].size = 1;\n            tr[p].lc = tr[p].rc = 0;\n            tr[p].rnd = _rand();\n            return;\n        }\n        ++tr[p].size;\n        if (x == tr[p].val)\n            ++tr[p].num;\n        else if (x < tr[p].val)\n        {\n            insert(tr[p].lc, x);\n            if (tr[tr[p].lc].rnd < tr[p].rnd)\n                right(p);\n        }\n        else if (x > tr[p].val)\n        {\n            insert(tr[p].rc, x);\n            if (tr[tr[p].rc].rnd < tr[p].rnd)\n                left(p);\n        }\n    }\n    void del(int &p, int x)\n    {\n        if (p == 0)\n            return;\n        if (tr[p].val == x)\n        {\n            if (tr[p].num > 1)\n                --tr[p].num, --tr[p].size;\n            else\n            {\n                if (tr[p].lc == 0 || tr[p].rc == 0)\n                    p = tr[p].lc + tr[p].rc;\n                else if (tr[tr[p].lc].rnd < tr[tr[p].rc].rnd)\n                    right(p), del(p, x);\n                else if (tr[tr[p].lc].rnd > tr[tr[p].rc].rnd)\n                    left(p), del(p, x);\n            }\n        }\n        else if (tr[p].val < x)\n            --tr[p].size, del(tr[p].rc, x);\n        else\n            --tr[p].size, del(tr[p].lc, x);\n    }\n    int queryrnk(int &p, int x)\n    {\n        if (p == 0)\n            return 0;\n        else if (tr[p].val == x)\n            return tr[tr[p].lc].size;\n        else if (tr[p].val < x)\n            return tr[tr[p].lc].size + tr[p].num + queryrnk(tr[p].rc, x);\n        else\n            return queryrnk(tr[p].lc, x);\n    }\n    int querynum(int &p, int rnk)\n    {\n        if (p == 0)\n            return 0;\n        if (tr[tr[p].lc].size >= rnk)\n            return querynum(tr[p].lc, rnk);\n        rnk -= tr[tr[p].lc].size;\n        if (rnk <= tr[p].num)\n            return tr[p].val;\n        rnk -= tr[p].num;\n        return querynum(tr[p].rc, rnk);\n    }\n    int queryfront(int &p, int x)\n    {\n        if (p == 0)\n            return -inf;\n        if (tr[p].val < x)\n            return max(tr[p].val, queryfront(tr[p].rc, x));\n        else if (tr[p].val >= x)\n            return queryfront(tr[p].lc, x);\n    }\n    int queryback(int &p, int x)\n    {\n        if (p == 0)\n            return inf;\n        if (tr[p].val > x)\n            return min(tr[p].val, queryback(tr[p].lc, x));\n        else if (tr[p].val <= x)\n            return queryback(tr[p].rc, x);\n    }\n};\nint pos;\nTreap tr;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int m, k;\n    tr.init();\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d%d\", &m, &k);\n        if (m == 1)\n            tr.insert(pos, k);\n        else if (m == 2)\n            tr.del(pos, k);\n        else if (m == 3)\n            printf(\"%d\\n\", tr.queryrnk(pos, k) + 1);\n        else if (m == 4)\n            printf(\"%d\\n\", tr.querynum(pos, k));\n        else if (m == 5)\n            printf(\"%d\\n\", tr.queryfront(pos, k));\n        else if (m == 6)\n            printf(\"%d\\n\", tr.queryback(pos, k));\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n##### 6.1.2.2 æ— æ—‹Treapï¼ˆFHQ-Treap)\n\næ— æ—‹è½¬$Treap$â€‹â€‹é€šè¿‡æ ‘åˆ†è£‚å’Œåˆå¹¶å®ç°èŠ‚ç‚¹çš„æ·»åŠ ä»¥åŠåˆ é™¤ã€‚å¯ä»¥æ”¯æŒå›ºå®šåŒºé—´æ“ä½œï¼Œæ”¯æŒå¯æŒä¹…åŒ–æ“ä½œã€‚\n\n###### 6.1.2.2.1 å•ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå€¼ï¼Œç›¸åŒå€¼ä½¿ç”¨å¤šä¸ªèŠ‚ç‚¹ï¼Œå¯æ”¯æŒsplit_sz\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int w;\n        int val;\n        int sz;\n        node() : l(0), r(0), w(0), val(0), sz(0) {};\n        node(int val) : l(0), r(0), w(ran()), val(val), sz(1) {};\n    };\n    const static int maxn = 5e5 + 9;\n    node tree[maxn];\n    int root;\n    int tot = 0;\n    int newnode(int val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    inline void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n        return;\n    }\n    inline void split_val(const int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[rt].val <= val) // å¶å­æƒå€¼æ¯”ç›®æ ‡å€¼å°ï¼Œå¿…å®šå±äºå·¦ä¾§ã€‚\n        {\n            l = rt;\n            split_val(tree[rt].r, tree[rt].r, r, val);\n        }\n        else\n        {\n            r = rt;\n            split_val(tree[rt].l, l, tree[rt].l, val);\n        }\n        pushup(rt);\n    }\n    inline void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            l = rt;\n            split_sz(tree[rt].r, tree[rt].r, r, sz - (tree[tree[rt].l].sz + 1));\n        }\n        else\n        {\n            r = rt;\n            split_sz(tree[rt].l, l, tree[rt].l, sz);\n        }\n        pushup(rt);\n    }\n    inline void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        if (tree[l].w > tree[r].w) // å¤§æ ¹å †å½¢å¼ï¼Œå°æ ¹å †æ¢ä¸ªå·å°±è¡Œ\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n    }\n    inline void insert(int x)\n    {\n        int rt1, rt2;\n        split_val(root, rt1, rt2, x - 1);\n        merge(rt1, rt1, newnode(x));\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline void del(int val)\n    {\n        int x, y, z;\n        split_val(root, x, y, val);\n        split_val(x, x, z, val - 1);\n        merge(z, tree[z].l, tree[z].r);\n        merge(x, x, z);\n        merge(root, x, y);\n    }\n    inline int rnk(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        merge(root, x, y);\n        return ans;\n    }\n    inline int kth(int root, int k)\n    {\n        int x = root;\n        while (true)\n        {\n            if (k == tree[tree[x].l].sz + 1)\n                return tree[x].val;\n            if (k <= tree[tree[x].l].sz)\n                x = tree[x].l;\n            else\n                k -= tree[tree[x].l].sz + 1, x = tree[x].r;\n        }\n    }\n    inline int kth(int k)\n    {\n        return kth(root, k);\n    }\n    inline int pre(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = kth(x, tree[x].sz);\n        merge(root, x, y);\n        return ans;\n    }\n    inline int suf(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val);\n        int ans = kth(y, 1);\n        merge(root, x, y);\n        return ans;\n    }\n};\nTreap tr;\nsigned main()\n{\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int op, x;\n        cin >> op >> x;\n        if (op == 1)\n        {\n            tr.insert(x);\n        }\n        else if (op == 2)\n        {\n            tr.del(x);\n        }\n        else if (op == 3)\n        {\n            cout << tr.rnk(x) << endl;\n        }\n        else if (op == 4)\n        {\n            cout << tr.kth(x) << endl;\n        }\n        else if (op == 5)\n        {\n            cout << tr.pre(x) << endl;\n        }\n        else\n            cout << tr.suf(x) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n###### 6.1.2.2.2 å•ä¸ªèŠ‚ç‚¹æœ‰å¤šä¸ªå€¼ï¼Œç›¸åŒå€¼ä½¿ç”¨åŒä¸€ä¸ªä¸ªèŠ‚ç‚¹ï¼Œä¸æ”¯æŒsplit_sz\n\n```cpp\nrandom_device rd;\nmt19937 ran(rd());\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int val;\n        int sz;\n        int cnt;\n        int w;\n        node() : l(0), r(0), val(0), sz(0), cnt(0), w(0) {};\n        node(int val) : l(0), r(0), val(val), sz(1), cnt(1), w(ran()) {};\n    };\n    const static int N = 2e6 + 9;\n    int tot = 0;\n    int root = 0;\n    node tree[N];\n    int newnode(int val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + tree[rt].cnt;\n        return;\n    }\n    void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        if (tree[l].w > tree[r].w)\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n        return;\n    }\n    void split_val(const int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        if (tree[rt].val <= val)\n        {\n            l = rt;\n            split_val(tree[rt].r, tree[rt].r, r, val);\n        }\n        else\n        {\n            r = rt;\n            split_val(tree[rt].l, l, tree[rt].l, val);\n        }\n        pushup(rt);\n    }\n    inline void insert(int x)\n    {\n        int rt1, rt2, rt3;\n        split_val(root, rt1, rt2, x - 1);\n        split_val(rt2, rt2, rt3, x);\n        if (!rt2)\n            rt2 = newnode(x);\n        else\n            tree[rt2].cnt++, tree[rt2].sz++;\n        merge(rt2, rt2, rt3);\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline void del(int val)\n    {\n        int rt1, rt2, rt3;\n        split_val(root, rt1, rt2, val);\n        split_val(rt1, rt1, rt3, val - 1);\n        assert(rt3 != 0);\n        tree[rt3].cnt--, tree[rt3].sz--;\n        if (!tree[rt3].cnt)\n            merge(rt3, tree[rt3].l, tree[rt3].r);\n        merge(rt1, rt1, rt3);\n        merge(root, rt1, rt2);\n        return;\n    }\n    inline int rnk(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        merge(root, x, y);\n        return ans;\n    }\n    inline int kth(int root, int k)\n    {\n        int x = root;\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int kth(int k)\n    {\n        return kth(root, k);\n    }\n    inline int pre(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val - 1);\n        int ans = kth(x, tree[x].sz);\n        merge(root, x, y);\n        return ans;\n    }\n    inline int suf(int val)\n    {\n        int x, y;\n        split_val(root, x, y, val);\n        int ans = kth(y, 1);\n        merge(root, x, y);\n        return ans;\n    }\n};\nTreap tr;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.3 ä¼¸å±•æ ‘ï¼ˆSplay Treeï¼‰\n\né€šè¿‡ **$Splay$/ä¼¸å±•æ“ä½œ** ä¸æ–­å°†æŸä¸ªèŠ‚ç‚¹æ—‹è½¬åˆ°æ ¹èŠ‚ç‚¹ï¼Œä½¿å¾—æ•´æ£µæ ‘ä»ç„¶æ»¡è¶³äºŒå‰æŸ¥æ‰¾æ ‘çš„æ€§è´¨ï¼Œèƒ½å¤Ÿåœ¨å‡æ‘Š$O(logN)$â€‹â€‹æ—¶é—´å†…å®Œæˆæ’å…¥ï¼ŒæŸ¥æ‰¾å’Œåˆ é™¤æ“ä½œï¼Œå¹¶ä¸”ä¿æŒå¹³è¡¡è€Œä¸è‡³äºé€€åŒ–ä¸ºé“¾ã€‚\n\næ¯æ¬¡æ“ä½œä¹‹åï¼Œè¢«æ“ä½œæ•°å‡åœ¨æ ¹èŠ‚ç‚¹ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 100005;\nint rt, tot, fa[N], ch[N][2], val[N], cnt[N], sz[N];\nstruct Splay\n{\n    void maintain(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x]; }\n\n    bool get(int x) { return x == ch[fa[x]][1]; }\n\n    void clear(int x)\n    {\n        ch[x][0] = ch[x][1] = fa[x] = val[x] = sz[x] = cnt[x] = 0;\n    }\n\n    void rotate(int x)\n    {\n        int y = fa[x], z = fa[y], chk = get(x);\n        ch[y][chk] = ch[x][chk ^ 1];\n        if (ch[x][chk ^ 1])\n            fa[ch[x][chk ^ 1]] = y;\n        ch[x][chk ^ 1] = y;\n        fa[y] = x;\n        fa[x] = z;\n        if (z)\n            ch[z][y == ch[z][1]] = x;\n        maintain(y);\n        maintain(x);\n    }\n\n    void splay(int x, int goal = 0)\n    {\n        if (goal == 0)\n            rt = x;\n        while (fa[x] != goal)\n        {\n            int f = fa[x], g = fa[fa[x]];\n            if (g != goal)\n            {\n                if (get(f) == get(x))\n                    rotate(f);\n                else\n                    rotate(x);\n            }\n            rotate(x);\n        }\n    }\n\n    void ins(int k)\n    {\n        if (!rt)\n        {\n            val[++tot] = k;\n            cnt[tot]++;\n            rt = tot;\n            maintain(rt);\n            return;\n        }\n        int cur = rt, f = 0;\n        while (1)\n        {\n            if (val[cur] == k)\n            {\n                cnt[cur]++;\n                maintain(cur);\n                maintain(f);\n                splay(cur);\n                break;\n            }\n            f = cur;\n            cur = ch[cur][val[cur] < k];\n            if (!cur)\n            {\n                val[++tot] = k;\n                cnt[tot]++;\n                fa[tot] = f;\n                ch[f][val[f] < k] = tot;\n                maintain(tot);\n                maintain(f);\n                splay(tot);\n                break;\n            }\n        }\n    }\n\n    int rk(int k)\n    {\n        int res = 0, cur = rt;\n        while (1)\n        {\n            if (k < val[cur])\n            {\n                cur = ch[cur][0];\n            }\n            else\n            {\n                res += sz[ch[cur][0]];\n                if (!cur)\n                    return res + 1;\n                if (k == val[cur])\n                {\n                    splay(cur);\n                    return res + 1;\n                }\n                res += cnt[cur];\n                cur = ch[cur][1];\n            }\n        }\n    }\n\n    int kth(int k)\n    {\n        int cur = rt;\n        while (1)\n        {\n            if (ch[cur][0] && k <= sz[ch[cur][0]])\n            {\n                cur = ch[cur][0];\n            }\n            else\n            {\n                k -= cnt[cur] + sz[ch[cur][0]];\n                if (k <= 0)\n                {\n                    splay(cur);\n                    return val[cur];\n                }\n                cur = ch[cur][1];\n            }\n        }\n    }\n    // è¿”å›å‰é©±ç»“ç‚¹æ ¹ç¼–å·\n    int pre()\n    {\n        int cur = ch[rt][0];\n        if (!cur)\n            return cur;\n        while (ch[cur][1])\n            cur = ch[cur][1];\n        splay(cur);\n        return cur;\n    }\n    // è¿”å›åç»§ç»“ç‚¹æ ¹ç¼–å·\n    int nxt()\n    {\n        int cur = ch[rt][1];\n        if (!cur)\n            return cur;\n        while (ch[cur][0])\n            cur = ch[cur][0];\n        splay(cur);\n        return cur;\n    }\n\n    void del(int k)\n    {\n        rk(k);\n        if (cnt[rt] > 1)\n        {\n            cnt[rt]--;\n            maintain(rt);\n            return;\n        }\n        if (!ch[rt][0] && !ch[rt][1])\n        {\n            clear(rt);\n            rt = 0;\n            return;\n        }\n        if (!ch[rt][0])\n        {\n            int cur = rt;\n            rt = ch[rt][1];\n            fa[rt] = 0;\n            clear(cur);\n            return;\n        }\n        if (!ch[rt][1])\n        {\n            int cur = rt;\n            rt = ch[rt][0];\n            fa[rt] = 0;\n            clear(cur);\n            return;\n        }\n        int cur = rt;\n        int x = pre();\n        fa[ch[cur][1]] = x;\n        ch[x][1] = ch[cur][1];\n        clear(cur);\n        maintain(rt);\n    }\n} tree;\n\nint main()\n{\n    int n, opt, x;\n    for (scanf(\"%d\", &n); n; --n)\n    {\n        scanf(\"%d%d\", &opt, &x);\n        if (opt == 1)\n            tree.ins(x);\n        else if (opt == 2)\n            tree.del(x);\n        else if (opt == 3)\n            printf(\"%d\\n\", tree.rk(x));\n        else if (opt == 4)\n            printf(\"%d\\n\", tree.kth(x));\n        else if (opt == 5)\n            tree.ins(x), printf(\"%d\\n\", val[tree.pre()]), tree.del(x);\n        else\n            tree.ins(x), printf(\"%d\\n\", val[tree.nxt()]), tree.del(x);\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.2 æ–‡è‰ºå¹³è¡¡æ ‘\n\næ–‡è‰ºå¹³è¡¡æ ‘ï¼ŒæŒ‡å€ŸåŠ©å¹³è¡¡æ ‘ä¸­åºéå†æ˜¯ä»å°åˆ°å¤§çš„æ€§è´¨å°†å…¶ç•¥ä½œä¿®æ”¹ï¼Œç”¨äº***ç»´æŠ¤é«˜çº§åŒºé—´æ“ä½œ***è¡Œä¸ºï¼ˆä¾‹å¦‚ï¼Œ***ç»´æŠ¤åŒºé—´ $[l,r]$â€‹ ç¿»è½¬***ï¼‰ï¼Œä¸æ”¯æŒä¸€åˆ‡ä¼ ç»Ÿå¹³è¡¡æ ‘æ“ä½œã€‚\n\nè¯·å†™ä¸€ä¸ªç¨‹åºï¼Œè¦æ±‚ç»´æŠ¤ä¸€ä¸ªæ•°åˆ—ï¼Œæ”¯æŒä»¥ä¸‹ $6$ ç§æ“ä½œï¼š\n\n| ç¼–å· |     åç§°     |                             æ ¼å¼                             | è¯´æ˜                                                         |\n| :--: | :----------: | :----------------------------------------------------------: | :----------------------------------------------------------- |\n|  1   |     æ’å…¥     | $\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}$ | åœ¨å½“å‰æ•°åˆ—çš„ç¬¬ $posi$ ä¸ªæ•°å­—åæ’å…¥ $tot$ ä¸ªæ•°å­—ï¼š$c_1, c_2 \\cdots c_{tot}$ï¼›è‹¥åœ¨æ•°åˆ—é¦–æ’å…¥ï¼Œåˆ™ $posi$ ä¸º $0$ |\n|  2   |     åˆ é™¤     |             $\\operatorname{DELETE} \\ posi \\ tot$             | ä»å½“å‰æ•°åˆ—çš„ç¬¬ $posi$ ä¸ªæ•°å­—å¼€å§‹è¿ç»­åˆ é™¤ $tot$ ä¸ªæ•°å­—        |\n|  3   |     ä¿®æ”¹     |         $\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c$          | ä»å½“å‰æ•°åˆ—çš„ç¬¬ $posi$ ä¸ªæ•°å­—å¼€å§‹çš„è¿ç»­ $tot$ ä¸ªæ•°å­—ç»Ÿä¸€ä¿®æ”¹ä¸º $c$ |\n|  4   |     ç¿»è½¬     |            $\\operatorname{REVERSE} \\ posi \\ tot$             | å–å‡ºä»å½“å‰æ•°åˆ—çš„ç¬¬ $posi$ ä¸ªæ•°å­—å¼€å§‹çš„ $tot$ ä¸ªæ•°å­—ï¼Œç¿»è½¬åæ”¾å…¥åŸæ¥çš„ä½ç½® |\n|  5   |     æ±‚å’Œ     |            $\\operatorname{GET-SUM} \\ posi \\ tot$             | è®¡ç®—ä»å½“å‰æ•°åˆ—çš„ç¬¬ $posi$ ä¸ªæ•°å­—å¼€å§‹çš„ $tot$ ä¸ªæ•°å­—çš„å’Œå¹¶è¾“å‡º |\n|  6   | æ±‚æœ€å¤§å­åˆ—å’Œ |                   $\\operatorname{MAX-SUM}$                   | æ±‚å‡ºå½“å‰æ•°åˆ—ä¸­å’Œæœ€å¤§çš„ä¸€æ®µå­åˆ—ï¼Œå¹¶è¾“å‡ºæœ€å¤§å’Œ                 |\n\n- å¯¹äº $100\\%$ çš„æ•°æ®ï¼Œä»»ä½•æ—¶åˆ»æ•°åˆ—ä¸­æœ€å¤šå«æœ‰ $5 \\times 10^5$ ä¸ªæ•°ï¼Œä»»ä½•æ—¶åˆ»æ•°åˆ—ä¸­ä»»ä½•ä¸€ä¸ªæ•°å­—å‡åœ¨ $[-10^3, 10^3]$ å†…ï¼Œ$1 \\le M \\le 2 \\times 10^4$ï¼Œæ’å…¥çš„æ•°å­—æ€»æ•°ä¸è¶…è¿‡ $4 \\times 10^6$ã€‚\n\n#### 6.2.1 æ— æ—‹Treapå®ç°æ–‡è‰ºå¹³è¡¡æ ‘\n\næ‡’æ ‡è®°å’Œçº¿æ®µæ ‘çš„æƒ³æ³•ä¸€æ ·ï¼Œè¿™æ ·å¤„ç†ä¸å®¹æ˜“é”™ã€‚\n\nåˆ†è£‚è¦æŒ‰`size`ï¼Œäº¤æ¢æ˜¯æ•´ä¸ªå­æ ‘å†…çš„æ‰€æœ‰èŠ‚ç‚¹çš„$lson,rson$â€‹å…¨éƒ¨äº¤æ¢ï¼Œæ‰€ä»¥éœ€è¦æ‡’æ ‡è®°ã€‚äº¤æ¢å„¿å­å¹¶ä¸ä¼šå½±å“å †çš„æ€§è´¨ï¼Œæ‰€ä»¥ä¸éœ€è¦ç®¡ã€‚\n\næ›´å¤æ‚çš„æ‡’æ ‡è®°ä¸€å®šè¦ææ¸…æ¥šã€‚æä¸æ¸…æ¥šæ‡’æ ‡è®°æå…¶å®¹æ˜“é”™ä¸”ç›¸å½“éš¾ä»¥è°ƒè¯•ï¼ˆå› ä¸ºæ ‘ç»“æ„çš„éšæœºæ€§ï¼‰\n\nè¿™ä¸ªé¢˜æ ‡è®°çš„å‘ç‚¹å°±åœ¨äºå­æ®µé•¿åº¦éç©ºï¼Œå…¨è´Ÿæ•°å°±è¦è¾“å‡ºæœ€å¤§çš„é‚£ä¸ªè´Ÿæ•°ã€‚æ‰€ä»¥ç»´æŠ¤åŒºé—´ä¸­å€¼ï¼ˆåŒºé—´æœ€å¤§å­æ®µï¼‰çš„æ—¶å€™éœ€è¦é¢å¤–å¸¦ä¸€æ¬¡`tree[rt].val`ï¼Œè¯¦æƒ…è§æ‡’æ ‡è®°ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\n#define int long long\nstruct Treap\n{\n    struct node\n    {\n        int l, r;\n        int w;\n        int val;\n        int sz;\n        int lazytag;\n        int sum;\n        int maxsum;\n        int maxpresum;\n        int maxsufsum;\n        bool sametag;\n        int sames;\n        node() : l(0), r(0), w(0), val(0),\n                 sz(0), lazytag(0), sum(0), maxpresum(0), maxsufsum(0),\n                 sametag(0), sames(0), maxsum(0) {};\n        node(int val) : l(0), r(0), w(ran()), val(val),\n                        sz(1), lazytag(0), sum(val), maxpresum(max(val, 0ll)),\n                        maxsufsum(max(val, 0ll)), sametag(0), sames(0), maxsum(val) {};\n    };\n    const static int maxn = 5e5 + 9;\n    node tree[maxn];\n    int root;\n    queue<int> q;\n    inline void init()\n    {\n        for (int i = 1; i < maxn; i++)\n        {\n            q.push(i);\n        }\n    }\n    Treap() { init(); }\n    int newnode(int val)\n    {\n        int tot = q.front();\n        q.pop();\n        tree[tot] = node(val);\n        return tot;\n    }\n    void getrub(int rt)\n    {\n        if (!rt)\n            return;\n        getrub(tree[rt].l);\n        getrub(tree[rt].r);\n        q.push(rt);\n        tree[rt] = node();\n        return;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n\n        tree[rt].sum = tree[tree[rt].l].sum + tree[tree[rt].r].sum + tree[rt].val;\n\n        tree[rt].maxpresum = max(tree[tree[rt].l].maxpresum, tree[tree[rt].l].sum + tree[rt].val + tree[tree[rt].r].maxpresum);\n\n        tree[rt].maxsufsum = max(tree[tree[rt].r].maxsufsum, tree[tree[rt].r].sum + tree[rt].val + tree[tree[rt].l].maxsufsum);\n\n        tree[rt].maxsum = max(tree[rt].val, tree[tree[rt].l].maxsufsum + tree[rt].val + tree[tree[rt].r].maxpresum);\n\n        if (tree[rt].l)\n        {\n            tree[rt].maxsum = max(tree[rt].maxsum, tree[tree[rt].l].maxsum);\n        }\n        if (tree[rt].r)\n        {\n            tree[rt].maxsum = max(tree[rt].maxsum, tree[tree[rt].r].maxsum);\n        }\n\n        return;\n    }\n    void Reverse(int x)\n    {\n        if (!x)\n            return;\n        swap(tree[x].l, tree[x].r);\n        swap(tree[x].maxpresum, tree[x].maxsufsum);\n        tree[x].lazytag ^= 1;\n    }\n    void Cover(int rt, int ci)\n    {\n        tree[rt].val = tree[rt].sames = ci;\n        tree[rt].sum = tree[rt].sz * ci;\n        tree[rt].maxpresum = tree[rt].maxsufsum = max(0ll, tree[rt].sum);\n        tree[rt].maxsum = max(ci, tree[rt].sum);\n        tree[rt].sametag = 1;\n    }\n    void pushdown(int rt)\n    {\n        if (!rt)\n            return;\n        if (tree[rt].lazytag)\n        {\n            if (tree[rt].l)\n                Reverse(tree[rt].l);\n            if (tree[rt].r)\n                Reverse(tree[rt].r);\n            tree[rt].lazytag = 0;\n        }\n        if (tree[rt].sametag)\n        {\n            if (tree[rt].l)\n            {\n                Cover(tree[rt].l, tree[rt].sames);\n            }\n            if (tree[rt].r)\n            {\n                Cover(tree[rt].r, tree[rt].sames);\n            }\n            tree[rt].sametag = 0;\n            tree[rt].sames = 0;\n        }\n    }\n    void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        pushdown(rt);\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            l = rt;\n            split_sz(tree[rt].r, tree[rt].r, r, sz - (tree[tree[rt].l].sz + 1));\n        }\n        else\n        {\n            r = rt;\n            split_sz(tree[rt].l, l, tree[rt].l, sz);\n        }\n        pushup(rt);\n    }\n    void merge(int &rt, const int l, const int r)\n    {\n        if (!l || !r)\n        {\n            rt = l | r;\n            return;\n        }\n        pushdown(l);\n        pushdown(r);\n        if (tree[l].w > tree[r].w) // å¤§æ ¹å †å½¢å¼ï¼Œå°æ ¹å †æ¢ä¸ªå·å°±è¡Œ\n        {\n            rt = l;\n            merge(tree[rt].r, tree[rt].r, r);\n        }\n        else\n        {\n            rt = r;\n            merge(tree[rt].l, l, tree[rt].l);\n        }\n        pushup(rt);\n    }\n    void insert(int pos, vector<int> &a)\n    {\n        int rt1, rt2;\n        split_sz(root, rt1, rt2, pos);\n        for (auto j : a)\n        {\n            merge(rt1, rt1, newnode(j));\n        }\n        merge(root, rt1, rt2);\n    }\n    void del(int pos, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt1, rt3, pos + tot - 1);\n        split_sz(rt1, rt1, rt2, pos - 1);\n        getrub(rt2);\n        merge(root, rt1, rt3);\n    }\n    void reverse(int l, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt2, rt3, l + tot - 1);\n        split_sz(rt2, rt1, rt2, l - 1);\n        Reverse(rt2);\n        merge(rt2, rt1, rt2);\n        merge(root, rt2, rt3);\n    }\n    int getsum(int pos, int tot)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt1, rt3, pos + tot - 1);\n        split_sz(rt1, rt1, rt2, pos - 1);\n        int ans = tree[rt2].sum;\n        merge(rt1, rt1, rt2);\n        merge(root, rt1, rt3);\n        return ans;\n    }\n    int getmaxsum()\n    {\n        return tree[root].maxsum;\n    }\n    void make_same(int l, int tot, int c)\n    {\n        int rt1, rt2, rt3;\n        split_sz(root, rt2, rt3, l + tot - 1);\n        split_sz(rt2, rt1, rt2, l - 1);\n        Cover(rt2, c);\n        merge(rt2, rt1, rt2);\n        merge(root, rt2, rt3);\n    }\n    void print(int rt)\n    {\n        if (!rt)\n            return;\n        pushdown(rt);\n        print(tree[rt].l);\n        cout << tree[rt].val << \" \";\n        print(tree[rt].r);\n    }\n    void print()\n    {\n        print(root);\n        cout << endl;\n        return;\n    }\n};\nTreap tr;\nsigned main()\n{\n    // freopen(\"data.in\", \"r\", stdin);\n    // freopen(\"data.out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (auto &i : a)\n        cin >> i;\n    tr.insert(0, a);\n    while (m--)\n    {\n        string s;\n        cin >> s;\n        if (s == \"GET-SUM\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            cout << tr.getsum(pos, cnt) << endl;\n        }\n        else if (s == \"MAX-SUM\")\n        {\n            cout << tr.getmaxsum() << endl;\n        }\n        else if (s == \"INSERT\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            vector<int> b(cnt);\n            for (auto &j : b)\n                cin >> j;\n            tr.insert(pos, b);\n        }\n        else if (s == \"DELETE\")\n        {\n            int pos, cnt;\n            cin >> pos >> cnt;\n            tr.del(pos, cnt);\n        }\n        else if (s == \"MAKE-SAME\")\n        {\n            int pos, tot, c;\n            cin >> pos >> tot >> c;\n            tr.make_same(pos, tot, c);\n        }\n        else\n        {\n            int pos, tot;\n            cin >> pos >> tot;\n            tr.reverse(pos, tot);\n        }\n        // tr.print();\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.3 å¯æŒä¹…åŒ–å¹³è¡¡æ ‘\n\nå¦‚é¢˜ï¼Œå¯æŒä¹…åŒ–æ•°æ®ç»“æ„ã€‚\n\néœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œå¹³è¡¡æ ‘å¯æŒä¹…åŒ–æ¶ˆè€—æ— ç”¨å†…å­˜æ›´å¤§ï¼Œå»ºè®®ç©ºé—´å€æ•°`<<6`ä»¥ä¸Š\n\n#### 6.3.1 å¯æŒä¹…åŒ–æ— æ—‹Treap\n\nå’Œéå¯æŒä¹…åŒ–æ— æ—‹$Treap$â€‹â€‹å‡ ä¹æ²¡æœ‰åŒºåˆ«ï¼Œå°ç®€å•çš„å·®å¼‚å‡ºåœ¨`merge`å’Œ`split_val`å‡½æ•°ä¸Šï¼Œæ¯æ¬¡è¦åˆ†è£‚æˆ–è€…è¦åˆå¹¶çš„æ—¶å€™éƒ½å¿…é¡»æ–°å¼€ç»“ç‚¹ï¼Œå°†å¤åˆ¶ä¸€ä»½æ—§ç»“ç‚¹ï¼Œä»¥ä¿è¯åŸå…ˆç‰ˆæœ¬ä¸è¢«ç ´åã€‚\n\nç”¨äºè§£å†³éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œçš„æ•°æ®ç»“æ„ï¼ˆ **å¯¹äºå„ä¸ªä»¥å¾€çš„å†å²ç‰ˆæœ¬** ï¼‰ï¼š\n\n\n1ã€ æ’å…¥ $x$\n\n2ã€ åˆ é™¤ $x$ï¼ˆè‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œåº”åªåˆ é™¤ä¸€ä¸ªï¼Œ**å¦‚æœæ²¡æœ‰è¯·å¿½ç•¥è¯¥æ“ä½œ**ï¼‰\n\n\n3ã€ æŸ¥è¯¢ $x$ çš„æ’åï¼ˆæ’åå®šä¹‰ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° $+1$ï¼‰\n\n\n4ã€æŸ¥è¯¢æ’åä¸º $x$ çš„æ•°\n\n\n5ã€ æ±‚ $x$ çš„å‰é©±ï¼ˆå‰é©±å®šä¹‰ä¸ºå°äº $x$ï¼Œä¸”æœ€å¤§çš„æ•°ï¼Œ**å¦‚ä¸å­˜åœ¨è¾“å‡º** $-2^{31}+1$ ï¼‰\n\n6ã€æ±‚ $x$ çš„åç»§ï¼ˆåç»§å®šä¹‰ä¸ºå¤§äº $x$ï¼Œä¸”æœ€å°çš„æ•°ï¼Œ**å¦‚ä¸å­˜åœ¨è¾“å‡º** $2^{31}-1$ ï¼‰\n\n**å’ŒåŸæœ¬å¹³è¡¡æ ‘ä¸åŒçš„ä¸€ç‚¹æ˜¯ï¼Œæ¯ä¸€æ¬¡çš„ä»»ä½•æ“ä½œéƒ½æ˜¯åŸºäºæŸä¸€ä¸ªå†å²ç‰ˆæœ¬ï¼ŒåŒæ—¶ç”Ÿæˆä¸€ä¸ªæ–°çš„ç‰ˆæœ¬ã€‚ï¼ˆæ“ä½œ3, 4, 5, 6å³ä¿æŒåŸç‰ˆæœ¬æ— å˜åŒ–ï¼‰**\n\næ¯ä¸ªç‰ˆæœ¬çš„ç¼–å·å³ä¸ºæ“ä½œçš„åºå·ï¼ˆç‰ˆæœ¬$0$å³ä¸ºåˆå§‹çŠ¶æ€ï¼Œç©ºæ ‘ï¼‰\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼Œ $ 1 \\leq n \\leq 5 \\times  10^5 $ , $|x_i| \\leq {10}^9$ï¼Œ$0 \\le v_i < i$ï¼Œ$1\\le \\text{opt} \\le 6$ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\nstruct Persistant_Treap\n{\n    struct node\n    {\n        int l, r;\n        int val;\n        int sz;\n        int cnt;\n        int w;\n        node() { l = r = val = sz = cnt = w = 0; };\n        node(int val) : l(0), r(0), val(val), sz(1), cnt(1), w(ran()) {}\n    };\n    int tot = 0;\n    const static int maxn = 5e5 + 9;\n    node tree[maxn << 6];\n    int vers[maxn];\n    int ver = 0;\n    int newnode(int val)\n    {\n        ++tot;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[rt].cnt + tree[tree[rt].l].sz + tree[tree[rt].r].sz;\n        return;\n    }\n    int merge(const int l, const int r)\n    {\n        if (!l || !r)\n            return l | r;\n        int newrt;\n        if (tree[l].w > tree[r].w)\n        {\n            newrt = ++tot;\n            tree[newrt] = tree[l];\n            tree[newrt].r = merge(tree[newrt].r, r);\n        }\n        else\n        {\n            newrt = ++tot;\n            tree[newrt] = tree[r];\n            tree[newrt].l = merge(l, tree[newrt].l);\n        }\n        pushup(newrt);\n        return newrt;\n    }\n    void split_val(int rt, int &l, int &r, int val)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        int newrt;\n        if (tree[rt].val <= val)\n        {\n            l = ++tot;\n            tree[l] = tree[rt];\n            split_val(tree[rt].r, tree[l].r, r, val);\n            pushup(l);\n        }\n        else\n        {\n            r = ++tot;\n            tree[r] = tree[rt];\n            split_val(tree[rt].l, l, tree[r].l, val);\n            pushup(r);\n        }\n    }\n    inline void insert(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_val(vers[ver], rt1, rt2, val - 1);\n        split_val(rt2, rt2, rt3, val);\n        if (!rt2)\n            rt2 = newnode(val);\n        else\n            tree[rt2].cnt++, tree[rt2].sz++;\n        rt2 = merge(rt2, rt3);\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline void del(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_val(vers[ver], rt1, rt2, val);\n        split_val(rt1, rt1, rt3, val - 1);\n        if (!rt3)\n            return;\n        tree[rt3].cnt--, tree[rt3].sz--;\n        if (!tree[rt3].cnt)\n            rt3 = merge(tree[rt3].l, tree[rt3].r);\n        rt1 = merge(rt1, rt3);\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline int rnk(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val - 1);\n        int ans = tree[x].sz + 1;\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n    inline int kth(int v, int k) // ç‰ˆæœ¬è®¿é—®\n    {\n        vers[++ver] = vers[v];\n        int x = vers[ver];\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int _kth(int rt, int k) // æ ¹è®¿é—®ï¼Œprivate\n    {\n        int x = rt;\n        while (true)\n        {\n            if (k <= tree[tree[x].l].sz)\n            {\n                x = tree[x].l;\n            }\n            else if (k > tree[tree[x].l].sz + tree[x].cnt)\n            {\n                k -= (tree[tree[x].l].sz + tree[x].cnt);\n                x = tree[x].r;\n            }\n            else\n            {\n                return tree[x].val;\n            }\n        }\n    }\n    inline int pre(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val - 1);\n\n        int ans = -(INT_MAX);\n        if (x != 0)\n            ans = _kth(x, tree[x].sz);\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n    inline int suf(int v, int val)\n    {\n        vers[++ver] = vers[v];\n        int x, y;\n        split_val(vers[ver], x, y, val);\n        int ans = (INT_MAX);\n        if (y != 0)\n            ans = _kth(y, 1);\n        vers[ver] = merge(x, y);\n        return ans;\n    }\n};\nPersistant_Treap tr;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        int v, op, x;\n        cin >> v >> op >> x;\n        if (op == 1)\n        {\n            tr.insert(v, x);\n        }\n        else if (op == 2)\n        {\n            tr.del(v, x);\n        }\n        else if (op == 3)\n        {\n            cout << tr.rnk(v, x) << endl;\n        }\n        else if (op == 4)\n        {\n            cout << tr.kth(v, x) << endl;\n        }\n        else if (op == 5)\n        {\n            cout << tr.pre(v, x) << endl;\n        }\n        else\n            cout << tr.suf(v, x) << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.3.2 å¯æŒä¹…åŒ–æ–‡è‰ºå¹³è¡¡æ ‘\n\nç†è®ºä¸Šï¼Œæ–‡è‰ºå¹³è¡¡æ ‘å¯ä»¥å¹²äº†çº¿æ®µæ ‘æ‰€èƒ½å¹²çš„æ‰€æœ‰æ´»å„¿ï¼Œä½†æ˜¯å¸¸æ•°$SuperBig$ã€‚å…¶å­˜æ´»æ„ä¹‰ä¸»è¦åœ¨äºåŒºé—´ç¿»è½¬ã€‚\n\nç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œå…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼Œè¦æ±‚å¼ºåˆ¶åœ¨çº¿ï¼ˆ**å¯¹äºå„ä¸ªä»¥å¾€çš„å†å²ç‰ˆæœ¬**ï¼‰ï¼š\n\n1. åœ¨ç¬¬ $p$ ä¸ªæ•°åæ’å…¥æ•° $x$ã€‚\n2. åˆ é™¤ç¬¬ $p$ ä¸ªæ•°ã€‚\n3. ç¿»è½¬åŒºé—´ $[l,r]$ï¼Œä¾‹å¦‚åŸåºåˆ—æ˜¯ $\\{5,4,3,2,1\\}$ï¼Œç¿»è½¬åŒºé—´ $[2,4]$ åï¼Œç»“æœæ˜¯ $\\{5,2,3,4,1\\}$ã€‚\n4. æŸ¥è¯¢åŒºé—´ $[l,r]$ ä¸­æ‰€æœ‰æ•°çš„å’Œã€‚\n\n**å’ŒåŸæœ¬å¹³è¡¡æ ‘ä¸åŒçš„ä¸€ç‚¹æ˜¯ï¼Œæ¯ä¸€æ¬¡çš„ä»»ä½•æ“ä½œéƒ½æ˜¯åŸºäºæŸä¸€ä¸ªå†å²ç‰ˆæœ¬ï¼ŒåŒæ—¶ç”Ÿæˆä¸€ä¸ªæ–°çš„ç‰ˆæœ¬ï¼ˆæ“ä½œ $4$ å³ä¿æŒåŸç‰ˆæœ¬æ— å˜åŒ–ï¼‰ï¼Œæ–°ç‰ˆæœ¬å³ç¼–å·ä¸ºæ­¤æ¬¡æ“ä½œçš„åºå·ã€‚**\n\nemm,ç›¸å½“è´´å†…å­˜$(979MB/1GB)$ï¼Œçˆ†$\\color{red}MLE$â€‹å°±çœ‹ç€åŠå§ã€‚\n\næ³¨æ„ï¼Œpushdownçš„æ—¶å€™ä¹Ÿè¦æ–°å»ºç«‹æ‹·è´èŠ‚ç‚¹ï¼Œè®°ä½ï¼Œå¯æŒä¹…åŒ–æ•°æ®ç»“æ„ä¸Šåªè¦æ¶‰åŠåˆ°æ”¹å¿…é¡»è¦æ–°å»ºèŠ‚ç‚¹ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nrandom_device rd;\nmt19937 ran(rd());\n#define i64 long long\nstruct Persistant_literary_Treap\n{\nprivate:\n    struct node\n    {\n        int l, r;\n        int w;\n        i64 sum;\n        i64 val;\n        bool lazy;\n        int sz;\n        node() { l = r = w = sum = val = sz = lazy = 0; };\n        node(i64 val) : l(0), r(0), w(ran()), sum(val), val(val), sz(1), lazy(0) {}\n    };\n    const static int maxn = 2e5 + 9;\n    node tree[maxn << 7];\n    int vers[maxn], ver = 0;\n    int tot = 0;\n    int newnode(i64 val)\n    {\n        tot++;\n        tree[tot] = node(val);\n        return tot;\n    }\n    void pushdown(int rt)\n    {\n        if (!rt)\n            return;\n        if (!tree[rt].lazy)\n            return;\n        if (tree[rt].l) // åªè¦åŠ¨ç»“ç‚¹é‚£å¿…é¡»å…¨éƒ¨å¤‡ä»½å¯æŒä¹…åŒ–\n        {\n            int rl = ++tot;\n            tree[rl] = tree[tree[rt].l];\n            tree[rt].l = rl;\n        }\n        if (tree[rt].r)\n        {\n            int rr = ++tot;\n            tree[rr] = tree[tree[rt].r];\n            tree[rt].r = rr;\n        }\n        swap(tree[rt].l, tree[rt].r);\n        if (tree[rt].l)\n            tree[tree[rt].l].lazy ^= 1;\n        if (tree[rt].r)\n            tree[tree[rt].r].lazy ^= 1;\n        tree[rt].lazy = 0;\n        return;\n    }\n    void pushup(int rt)\n    {\n        tree[rt].sz = tree[tree[rt].l].sz + tree[tree[rt].r].sz + 1;\n        tree[rt].sum = tree[tree[rt].l].sum + tree[tree[rt].r].sum + tree[rt].val;\n        return;\n    }\n    int merge(int l, int r)\n    {\n        if (!l || !r)\n            return l | r;\n        int nowrt = 0;\n        pushdown(l);\n        pushdown(r);\n        if (tree[l].w > tree[r].w)\n        {\n            nowrt = ++tot;\n            tree[nowrt] = tree[l];\n            tree[nowrt].r = merge(tree[nowrt].r, r);\n            pushup(nowrt);\n        }\n        else\n        {\n            nowrt = ++tot;\n            tree[nowrt] = tree[r];\n            tree[nowrt].l = merge(l, tree[nowrt].l);\n            pushup(nowrt);\n        }\n        return nowrt;\n    }\n    void split_sz(const int rt, int &l, int &r, int sz)\n    {\n        if (!rt)\n        {\n            l = r = 0;\n            return;\n        }\n        pushdown(rt);\n        if (tree[tree[rt].l].sz + 1 <= sz)\n        {\n            int newrt = ++tot;\n            tree[newrt] = tree[rt];\n            l = newrt;\n            split_sz(tree[rt].r, tree[newrt].r, r, sz - (tree[tree[newrt].l].sz + 1));\n            pushup(l);\n        }\n        else\n        {\n            int newrt = ++tot;\n            tree[newrt] = tree[rt];\n            r = newrt;\n            split_sz(tree[rt].l, l, tree[newrt].l, sz);\n            pushup(r);\n        }\n        return;\n    }\n\npublic:\n    inline void insert(int v, int k, i64 val)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2;\n        split_sz(vers[ver], rt1, rt2, k);\n        rt1 = merge(rt1, newnode(val));\n        vers[ver] = merge(rt1, rt2);\n        return;\n    }\n    inline void del(int v, int k)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, k);\n        split_sz(rt1, rt1, rt2, k - 1);\n        vers[ver] = merge(rt1, rt3);\n        return;\n    }\n    inline i64 query(int v, int l, int r)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, r);\n        split_sz(rt1, rt1, rt2, l - 1);\n        i64 ans = tree[rt2].sum;\n        rt1 = merge(rt1, rt2);\n        vers[ver] = merge(rt1, rt3);\n        return ans;\n    }\n    inline void reverse(int v, int l, int r)\n    {\n        vers[++ver] = vers[v];\n        int rt1, rt2, rt3;\n        split_sz(vers[ver], rt1, rt3, r);\n        split_sz(rt1, rt1, rt2, l - 1);\n        tree[rt2].lazy ^= 1;\n        rt1 = merge(rt1, rt2);\n        vers[ver] = merge(rt1, rt3);\n        return;\n    }\n};\nPersistant_literary_Treap tr;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    i64 lastans = 0;\n    while (n--)\n    {\n        i64 v, op, p, x, l, r;\n        cin >> v >> op;\n        if (op == 1)\n        {\n            cin >> p >> x;\n            p ^= lastans;\n            x ^= lastans;\n            tr.insert(v, p, x);\n        }\n        else if (op == 2)\n        {\n            cin >> p;\n            p ^= lastans;\n            tr.del(v, p);\n        }\n        else if (op == 3)\n        {\n            cin >> l >> r;\n            l ^= lastans;\n            r ^= lastans;\n            tr.reverse(v, l, r);\n        }\n        else\n        {\n            cin >> l >> r;\n            l ^= lastans;\n            r ^= lastans;\n            lastans = tr.query(v, l, r);\n            cout << lastans << endl;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 7.æ ‘å¥—æ ‘\n\n### 7.1 çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘\n\nå…³é”®è¯ï¼šåŒºé—´å¤§å‹å¹³è¡¡æ ‘æ“ä½œã€‚\n\næ‚¨éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼ˆå¯å‚è€ƒé¢˜ç›®æ ‡é¢˜ï¼‰ï¼Œæ¥ç»´æŠ¤ä¸€ä¸ªæœ‰åºæ•°åˆ—ï¼Œå…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼š\n\n1. æŸ¥è¯¢ $k$ åœ¨åŒºé—´å†…çš„æ’å\n\n2. æŸ¥è¯¢åŒºé—´å†…æ’åä¸º $k$ çš„å€¼\n\n3. ä¿®æ”¹æŸä¸€ä½ç½®ä¸Šçš„æ•°å€¼\n\n4. æŸ¥è¯¢ $k$ åœ¨åŒºé—´å†…çš„å‰é©±ï¼ˆå‰é©±å®šä¹‰ä¸ºä¸¥æ ¼å°äº $x$ï¼Œä¸”æœ€å¤§çš„æ•°ï¼Œ**è‹¥ä¸å­˜åœ¨è¾“å‡º `-2147483647`**ï¼‰\n\n5. æŸ¥è¯¢ $k$ åœ¨åŒºé—´å†…çš„åç»§ï¼ˆåç»§å®šä¹‰ä¸ºä¸¥æ ¼å¤§äº $x$ï¼Œä¸”æœ€å°çš„æ•°ï¼Œ**è‹¥ä¸å­˜åœ¨è¾“å‡º `2147483647`**ï¼‰\n\n$1\\le n,m\\le5\\times 10^4$ï¼Œåºåˆ—ä¸­çš„å€¼åœ¨ä»»ä½•æ—¶åˆ» $\\in[0,10^8]$ã€‚\n\n**ï¼ˆç‰¹åˆ«æé†’ï¼šæ­¤æ•°æ®ä¸ä¿è¯æ“ä½œ 4ã€5 ä¸€å®šå­˜åœ¨ï¼Œæ•…è¯·åŠ¡å¿…è€ƒè™‘ä¸å­˜åœ¨çš„æƒ…å†µã€‚ï¼‰**\n\nåšæ³•ï¼š\n\næ¯ä¸ªçº¿æ®µæ ‘ç»“ç‚¹ç»´æŠ¤ä¸€ä¸ª$Treap$å¹³è¡¡æ ‘ï¼ŒåŒºé—´åˆå¹¶ç›´æ¥å¹³è¡¡æ ‘$Merge$â€‹æ‹¿ä¸‹ã€‚\n\n1. æŸ¥è¯¢æ’åï¼šçº¿æ®µæ ‘æŸ¥è¯¢ï¼ŒæŸ¥è¯¢æ¯ä¸ªå­åŒºé—´å†…$(k-1)$çš„æ’åå¹¶æ±‚å’Œï¼Œå¤æ‚åº¦$O(logN)$\n2. æŸ¥è¯¢æ’åä¸º$k$çš„æ•°ï¼šè¿™ä¸ªæ²¡åŠæ³•ç›´æ¥åŠ æ³•æ±‚ï¼Œéœ€è¦äºŒåˆ†+æ“ä½œ1åˆ¤æ–­ï¼Œå¤æ‚åº¦$O(log^2N)$\n3. ä¿®æ”¹ï¼šæ— è¯å¯è¯´ï¼Œå¤æ‚åº¦$O(logN)$ã€‚\n4. æŸ¥è¯¢å‰é©±ï¼šå„åŒºé—´æŸ¥è¯¢å‰é©±åå–$max$ï¼Œå¤æ‚åº¦$O(logN)$ã€‚\n5. æŸ¥è¯¢åç»§ï¼šå„åŒºé—´æŸ¥è¯¢åç»§åå–$min$ï¼Œå¤æ‚åº¦$O(logN)$.\n\nå¤æ‚åº¦ä¸Šç•Œ$O(Nlog^3N)$ã€‚å•çº¯ä¿®æ”¹+æŸ¥è¯¢ç¬¬$K$å°æ ‘çŠ¶ä¸»å¸­æ ‘å¯ä»¥$O(Nlog^2N)$å®ç°ã€‚\n\n### 7.2 æ ‘çŠ¶æ•°ç»„+çº¿æ®µæ ‘\n\nå…³é”®è¯ï¼šä¸»å¸­æ ‘å¼ºåŒ–ï¼Œå·®åˆ†åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘\n\næ ‘çŠ¶æ•°ç»„çš„å·®åˆ†æ€§è´¨ä½¿å¾—ä¸»å¸­æ ‘å¯ä»¥æ”¯æŒå¿«é€Ÿä¿®æ”¹ã€‚\n\nè§1.12\n\n<div style=\"page-break-after: always;\"></div>\n\n### *7.3 çº¿æ®µæ ‘å¥—çº¿æ®µæ ‘\n\nå…³é”®è¯ï¼šäºŒç»´åŒºé—´ä¿®æ”¹ã€åŒºé—´æŸ¥è¯¢ã€‚\n\nè§$OI-Wiki$æ‰‹å†Œï¼Œè¿‡äºåé—¨ã€‚\n\n## 8. é™æ€æ ‘ï¼ˆæ ‘ä¸Šå·®åˆ†ï¼›HLD/LLDï¼Œé‡é“¾å‰–åˆ†ã€é•¿é“¾å‰–åˆ†ï¼‰\n\nå…³é”®è¯ï¼šé™æ€æ ‘åŒºé—´æ“ä½œï¼Œé™æ€æ ‘åºåˆ—åŒ–æ“ä½œã€‚\n\n#### 8.1 æ ‘ä¸Šå·®åˆ†â€”â€”é™æ€æ ‘ï¼Œé™æ€æ ‘èŠ‚ç‚¹ä¿¡æ¯\n\næƒ³æ“ä½œã€æŸ¥è¯¢$u$åˆ°$v$èŠ‚ç‚¹çš„åŒºé—´å±æ€§ï¼Œå¯ä»¥é€šè¿‡æ ‘ä¸Šå·®åˆ†åˆ°æ ¹æ“ä½œå®ç°ï¼Œå³ç»“ç‚¹$u$å­˜å‚¨$u$åˆ°æ ¹çš„ä¿¡æ¯ï¼Œ$v$å­˜å‚¨$v$åˆ°æ ¹çš„ä¿¡æ¯ã€‚\n\næŸ¥è¯¢çš„æ—¶å€™ç›´æ¥æŸ¥è¯¢$u+v-lca_{u,v}-fa_{lca_{u,v}}$â€‹å³å¯ã€‚\n\n```cpp\n#include <bits/stdc++.h>//æ ‘ä¸Šå·®åˆ†ï¼Œæ ‘ä¸Šä¸€æ¡é“¾çš„åŒºé—´å’Œï¼Œfromï¼š[JLOI2014] æ¾é¼ çš„æ–°å®¶\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=3*1e5+10;\nint n,u,v,vis[N],a[N],b[N];\nint fa[N][40],dep[N];\nvector<int>edge[N];\nvoid dfs(int x,int f){//lcaé¢„å¤„ç†\n    dep[x]=dep[f]+1;\n    fa[x][0]=f;\n    for(auto i:edge[x])if(i!=f)dfs(i,x); \n}\nvoid sum(int x,int f){//ç»Ÿè®¡ç‚¹xçš„å€¼\n    a[x]=b[x];\n    for(auto i:edge[x]){\n        if(i!=f){\n            sum(i,x);//æ­¤æ—¶å·²ç»ç»Ÿè®¡äº†æ‰€æœ‰içš„å€¼äº†\n            a[x]+=a[i];\n        }\n    }\n}\nint lca(int x,int y){//lca\n    if(x==y)return x;\n    if(dep[x]<dep[y])swap(x,y);\n    for(int i=30;i>=0;i--)\n        if(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n    if(x==y)return x;\n    for(int i=30;i>=0;i--)\n        if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n    return fa[x][0];\n}\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>vis[i];\n    for(int i=1;i<=n-1;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int j=1;j<=30;j++)\n        for(int i=1;i<=n;i++)\n            fa[i][j]=fa[fa[i][j-1]][j-1];\n    for(int i=1;i<=n-1;i++){//ç‚¹å·®åˆ†,ä¸€ä¸ªç‚¹çš„å·®åˆ†æ•°ç»„çš„å€¼å°±æ˜¯è¿™ä¸ªç‚¹çš„å€¼-æ‰€æœ‰å…¶äº²å„¿å­çš„å€¼\n    //å¯¹vis[i],vis[i+1]è¿™ä¸¤ä¸ªç‚¹ä¹‹é—´åŠ ä¸€åªéœ€è¦å¦‚ä¸‹æ­¥éª¤ï¼ˆå››æ­¥ï¼‰ï¼Œæ“ä½œçš„æ˜¯å·®åˆ†æ•°ç»„\n        b[vis[i]]++;\n        b[vis[i+1]]++;\n        b[lca(vis[i],vis[i+1])]--;\n        b[fa[lca(vis[i],vis[i+1])][0]]--;\n    }\n    sum(1,0);//éå†æ•´æ£µæ ‘ï¼Œæ¨å‡ºåŸå§‹æƒå€¼\n    for(int i=2;i<=n;i++)a[vis[i]]--;//æœ¬é¢˜ä¾‹å¤–ï¼ˆå› ä¸ºæˆ‘ä»¬æŠŠæ—¢ä½œä¸ºèµ·ç‚¹åˆåšä¸ºç»ˆç‚¹çš„ç‚¹ç®—äº†ä¸¤æ¬¡ï¼Œç°åœ¨æŠŠè¿™äº›ç‚¹çš„æƒå€¼å‡ä¸€å³å¯ ï¼‰\n    for(int i=1;i<=n;i++)cout<<a[i]<<endl;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\nè¿˜æœ‰ä¸€ä¸ªæ ‘ä¸Šå¼‚æˆ–å·®åˆ†ï¼š\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define lowbit(x) (x&-x)\n#define endl '\\n'//äº¤äº’é¢˜å°±åˆ \nusing namespace std;\nconst int N=1e6+10;\nint n,q,u,v,idx,s,w;\nint tree[N],a[N],dfn[N],dep[N],fa[N][21],siz[N];\nvector<int>edge[N];\n/*è¦æ±‚è§£å†³è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼Œæ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ“ä½œï¼š\n1.uåˆ°vçš„è·¯å¾„ä¸Šæ‰€æœ‰å€¼å¼‚æˆ–ä¸Šk\n2.è¾“å‡ºuåˆ°vä¸Šæ‰€æœ‰ç‚¹çš„å€¼\nè§£æ³•ï¼š\næ ‘ä¸Šå¼‚æˆ–å·®åˆ†ï¼Œ1ç”±å¼‚æˆ–çš„æ€§è´¨å¯ä»¥è½¬åŒ–ä¸ºå››æ¡é“¾çš„æ“ä½œï¼Œu->1ï¼Œv->1ï¼Œk->1ï¼Œï¼ˆk-faï¼‰->1ï¼Œä½†æ˜¯å¯ä»¥ç®€åŒ–ï¼Œåˆ©ç”¨å¼‚æˆ–å·®åˆ†æ•°ç»„ï¼Œä¸€ä¸ªç‚¹çš„å€¼ä¸ºè¿™ä¸ªç‚¹å¼‚æˆ–å®ƒçš„æ‰€æœ‰å„¿å­èŠ‚ç‚¹ï¼Œè¿™æ ·åªéœ€è¦ä¿®æ”¹uï¼Œvï¼Œkï¼Œk-faå››ä¸ªç‚¹çš„å€¼å³å¯\n2å•ç‚¹æŸ¥è¯¢ï¼Œéš¾åº¦åœ¨äºå¦‚ä½•é€šè¿‡å¼‚æˆ–å·®åˆ†è¿˜åŸè¿™ä¸ªç‚¹çš„å€¼ï¼Œæ–¹æ³•å°±æ˜¯uå¼‚æˆ–ä»¥uä¸ºæ ¹çš„å­æ ‘çš„æ‰€æœ‰ç‚¹çš„å¼‚æˆ–å·®åˆ†æ•°ç»„ï¼Œåˆ©ç”¨dfsåºï¼Œå­æ ‘å†…çš„æ‰€æœ‰ç‚¹è¢«ç»´æŠ¤æˆäº†ä¸€ä¸ªåŒºé—´ï¼Œè¿™æ ·å°±å˜æˆäº†åŒºé—´å¼‚æˆ–ï¼Œå°±å¯ä»¥åˆ©ç”¨æ ‘çŠ¶æ•°ç»„å¿«é€Ÿç»´æŠ¤ï¼Œå¯¹dfsåºå»ºç«‹æ ‘çŠ¶æ•°ç»„å³å¯ã€‚\n//æ¶‰åŠçŸ¥è¯†ç‚¹ï¼šå¼‚æˆ–ã€æ ‘çŠ¶æ•°ç»„ã€dfsåºã€æ ‘ä¸Šå·®åˆ†ã€å¼‚æˆ–å‰ç¼€å’Œã€lca*/\nvoid dfs(int x,int f){\n    dep[x]=dep[f]+1;fa[x][0]=f;a[f]^=a[x],dfn[x]=++idx;\n    siz[x]=1;\n    for(auto i:edge[x]){\n        if(i!=f){\n            dfs(i,x);\n            siz[x]+=siz[i];\n        }\n    }\n}\nvoid add(int x,int k){//ç‚¹xåŠ ä¸Šk\n    while(x<=n){\n        tree[x]^=k;//ä¾æ¬¡ä¿®æ”¹æ¯ä¸ªè¦†ç›–æœ‰xçš„åŒºé—´çš„å€¼\n        x+=lowbit(x);\n    }\n}\nint sum(int x){//å¤„ç†0åˆ°xä¹‹é—´çš„å‰ç¼€å’Œ\n    int cnt=0;\n    while(x>0){\n        cnt^=tree[x];\n        x-=lowbit(x);\n    }\n    return cnt;\n}\nint lca(int x,int y){\n    if(dep[x]>dep[y]) swap(x,y);//yçš„æ·±åº¦å¤§ï¼Œdepå¤§\n    for (int i=20;i>=0;i-- ) \n        if(dep[x]<=dep[y]-(1<<i)) y=fa[y][i];\n    if(x==y) return x;\n    for (int i=20;i>=0;i-- ) \n        if(fa[x][i]!=fa[y][i]) \n            x=fa[x][i],y=fa[y][i];\n    return fa[x][0];\n}\nvoid change(int u,int v,int w){\n    int k=lca(u,v);\n    add(dfn[u],w);\n    add(dfn[v],w);\n    add(dfn[k],w);\n    if (fa[k][0]) add(dfn[fa[k][0]], w);\n}\nint get(int u){\n    return sum(dfn[u]+siz[u]-1)^sum(dfn[u]-1);\n}\nint check2(int u,int v){\n    vector<int>e;int flag=0;\n    if(dep[u]<dep[v])swap(u,v);\n    while(dep[u]>dep[v]){\n        e.push_back(get(u));\n        u=fa[u][0];\n    }\n    if(u==v)e.push_back(get(u));\n    else {\n        while(u!=v){\n            e.push_back(get(u));e.push_back(get(v));\n            u=fa[u][0];v=fa[v][0];\n        }\n        e.push_back(get(u));\n    }\n    sort(e.begin(),e.end());\n    for(int i=2;i<e.size();i++){\n        if(e[i-2]+e[i-1]>e[i])return 1;\n    }\n    return 0;\n}\nint find(int u,int v){\n    int k = lca(u, v);\n    if (dep[u] + dep[v] - 2 * dep[k] + 1 > 46) return 1;\n    else return check2(u,v);\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    for(int i=1;i<=n-1;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    for(int j=1;j<=20;j++)\n        for(int i=1;i<=n;i++)\n            fa[i][j]=fa[fa[i][j-1]][j-1];\n    for(int i=1;i<=n;i++)add(dfn[i],a[i]);\n    for(int i=1;i<=q;i++){\n        cin>>s;\n        if(s==1){\n            cin>>u>>v>>w;\n            change(u,v,w);\n        }\n        else {\n            cin>>u>>v;\n            cout<<find(u,v);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 8.2 é‡é“¾å‰–åˆ†â€”â€”é™æ€æ ‘ï¼ŒåŠ¨æ€æ ‘èŠ‚ç‚¹ä¿¡æ¯\n\nä¸€ç§ä»¥é“¾èŠ‚ç‚¹æ•°åˆ’åˆ†è½»é‡ä»¥å®ç°æ ‘èŠ‚ç‚¹ç¼–å·åŒ–ï¼Œå°†ä¹¦ä¸Šé—®é¢˜è½¬ç§»åˆ°åŒºé—´æ“ä½œå®ç°ã€‚\n\né‡é“¾å‰–åˆ†ä¿è¯æ¯ä¸€é¢—å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„ç¼–å·å¿…å®šæ˜¯ä¸€æ®µè¿ç»­çš„åºåˆ—$dfn$åºå·ã€‚\n\né‡é“¾å‰–åˆ†å¯ä»¥å°†æ ‘ä¸Šçš„ä»»æ„ä¸€æ¡è·¯å¾„åˆ’åˆ†æˆä¸è¶…è¿‡$logN$æ¡è¿ç»­çš„é“¾ï¼Œæ¯æ¡é“¾ä¸Šçš„ç‚¹æ·±åº¦äº’ä¸ç›¸åŒï¼ˆå³æ˜¯è‡ªåº•å‘ä¸Šçš„ä¸€æ¡é“¾ï¼Œé“¾ä¸Šæ‰€æœ‰ç‚¹çš„ $LCA$ ä¸ºé“¾çš„ä¸€ä¸ªç«¯ç‚¹)ã€‚\n\né‡é“¾å‰–åˆ†è¿˜èƒ½ä¿è¯åˆ’åˆ†å‡ºçš„æ¯æ¡é“¾ä¸Šçš„èŠ‚ç‚¹ DFS åºè¿ç»­ï¼Œå› æ­¤å¯ä»¥æ–¹ä¾¿åœ°ç”¨ä¸€äº›ç»´æŠ¤åºåˆ—çš„æ•°æ®ç»“æ„ï¼ˆå¦‚çº¿æ®µæ ‘ï¼‰æ¥ç»´æŠ¤æ ‘ä¸Šè·¯å¾„çš„ä¿¡æ¯ã€‚\n\né‡é“¾å‰–åˆ†å¤æ‚åº¦æ˜¯$O(n)$çš„ï¼Œä¸¤æ¬¡$dfs$å®ç°ï¼Œè·³é“¾æ±‚$lca$çš„å®ç°æ˜¯å•æ¬¡è¯¢é—®$O(logN)$â€‹çš„ã€‚å¯¹äºé«˜èŠ‚ç‚¹æ•°è€Œä½å¼ºåº¦è¯¢é—®ç›¸å½“å‹å¥½ã€‚\n\nè¿™é‡Œé»˜è®¤æ˜¯ä»$1$å¼€å§‹çš„\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn = 3e5 + 9;\nint father[maxn], sizes[maxn], hson[maxn], depth[maxn], top[maxn], ranks[maxn], dfn[maxn], cnt;\nint nxt[maxn << 1LL], head[maxn], to[maxn << 1LL], tot;\nvoid add(int u, int v)\n{\n    nxt[++tot] = head[u];\n    head[u] = tot;\n    to[tot] = v;\n}\nvoid add_edge(int u, int v)\n{\n    add(u, v);\n    add(v, u);\n}\nvoid dfs1(int pos)\n{\n    hson[pos] = -1;\n    sizes[pos] = 1;\n    for (int i = head[pos]; i; i = nxt[i])\n    {\n        if (!depth[to[i]])\n        {\n            depth[to[i]] = depth[pos] + 1;\n            father[to[i]] = pos;\n            dfs1(to[i]);\n            sizes[pos] += sizes[to[i]];\n            if (hson[pos] == -1 || sizes[to[i]] > sizes[hson[pos]])\n                hson[pos] = to[i];\n        }\n    }\n}\nvoid dfs2(int u, int tops)\n{\n    top[u] = tops;\n    dfn[u] = ++cnt;\n    ranks[cnt] = u;\n    if (hson[u] != -1)\n    {\n        dfs2(hson[u], tops);\n        for (int i = head[u]; i; i = nxt[i])\n        {\n            if (to[i] == father[u] || to[i] == hson[u])\n                continue;\n            dfs2(to[i], to[i]);\n        }\n    }\n}\nint n, m, r;\nint a[maxn];\nint lca(int u, int v)\n{\n    while (top[u] != top[v])\n    {\n        if (depth[top[u]] < depth[top[v]])\n            swap(u, v);\n        u = father[top[u]]; // æ‰€åœ¨é‡é“¾é¦–ä½çš„å‘ä¸Šè·³\n    }\n    return depth[u] < depth[v] ? u : v;\n}\nvoid init()\n{\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    depth[r] = 1;\n    dfs1(r);\n    dfs2(r, r);\n    // cout << \"finished build\" << endl;\n    // cout << \"root  is\" << dfn[1] << endl;\n    /*for (int i = 1; i <= n; i++)\n        cout << dfn[i] << \" \";\n    cout << endl;\n    for (int i = 1; i <= n; i++)\n        cout << ranks[i] << \" \";\n    cout << endl;\n    for (int i = 1; i <= n; i++)\n        cout << top[i] << \" \";\n        */\n    return;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 8.3é•¿é“¾å‰–åˆ†â€”â€”ä»…æ·±åº¦ç»´åº¦çº¿æ€§ä¼˜åŒ–åŠ¨æ€è§„åˆ’\n\né•¿é“¾å‰–åˆ†çš„å®ç°æ–¹å¼å’Œé‡é“¾å‰–åˆ†å¾ˆåƒï¼Œåªä¸è¿‡é‡å„¿å­è¢«å®šä¹‰ä¸ºäº†é“¾é•¿åº¦æœ€é•¿çš„é‚£ä¸€ä¸ªï¼Œszç»´æŠ¤çš„æ˜¯æ‰€å±æœ€é•¿é“¾çš„é•¿åº¦ã€‚\n\né•¿é“¾å‰–åˆ†è·³é“¾çš„æ—¶ç©ºå¤æ‚åº¦æœ€å¤§æ˜¯$O(N\\sqrt N)$çš„ï¼Œè¿™ä¸ªé“ç†æ˜¾è€Œæ˜“è§ã€‚\n\né•¿é“¾å‰–åˆ†å¯ä»¥åšåˆ°çº¿æ€§æ—¶é—´çš„ä¼˜åŒ–æ ‘ä¸Šå’Œæ·±åº¦æœ‰å…³çš„$dp$ã€‚é•¿é“¾å‰–åˆ†åï¼Œåœ¨ç»´æŠ¤ä¿¡æ¯çš„è¿‡ç¨‹ä¸­ï¼Œå…ˆ $O(1)$ ç»§æ‰¿é‡å„¿å­çš„ä¿¡æ¯ï¼Œå†æš´åŠ›åˆå¹¶å…¶ä½™è½»å„¿å­çš„ä¿¡æ¯ã€‚\n\nç¤ºä¾‹ï¼š\n\nç»™å®šä¸€æ£µä»¥ $1$ ä¸ºæ ¹ï¼Œ$n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ã€‚è®¾ $d(u,x)$ ä¸º $u$ å­æ ‘ä¸­åˆ° $u$ è·ç¦»ä¸º $x$ çš„èŠ‚ç‚¹æ•°ã€‚\n\nå¯¹äºæ¯ä¸ªç‚¹ï¼Œæ±‚ä¸€ä¸ªæœ€å°çš„ $k$ï¼Œä½¿å¾— $d(u,k)$ æœ€å¤§ã€‚$1â‰¤nâ‰¤10^6$\n\næ­£å¸¸åˆ†æçš„è¯ï¼Œè®¾$f_{u,i}$è¡¨ç¤ºåœ¨$u$å­æ ‘ä¸­è·ç¦»$u$è·ç¦»ä¸º$i$çš„èŠ‚ç‚¹æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹ç¨‹æœ‰ï¼š\n$$\nf_{u,i}=\\sum f_{v,i-1}\n$$\nçº¯æš´åŠ›è½¬ç§»ï¼Œæ·±åº¦ç»´åº¦æ˜¯$O(n)$ï¼Œæ€»å¤æ‚åº¦$O(n^2)$â€‹ï¼Œæ— æ³•æ‰¿å—ã€‚\n\nè€ƒè™‘æ ‘é“¾å‰–åˆ†ä¼˜åŒ–ï¼Œå¯¹äº$u$ï¼Œç›´æ¥ç»§æ‰¿å…¶é‡å„¿å­çš„$dp$æ•°ç»„ï¼Œå¹¶åœ¨æ•°ç»„å‰å¤´æ’å…¥ä¸€ä¸ª$1$å…ƒç´ è¡¨ç¤º$dp_{u,0}=1$ï¼ŒæŒ‡æ ¹èŠ‚ç‚¹è‡ªå·±ã€‚\n\nç„¶åå‰©ä¸‹çš„è½»å„¿å­çš„æš´åŠ›å‘é‡å„¿å­åˆå¹¶å°±å¯ä»¥äº†ã€‚æ—¶é—´å¤æ‚åº¦$O(2n)$â€‹ï¼Œçº¿æ€§é€šè¿‡ï¼Œå› ä¸ºæ¯ä¸ªå­æ ‘èŠ‚ç‚¹çš„vectoræœ€å¤šå­˜æ”¾æ·±åº¦å¤šä¸ªå…ƒç´ ï¼Œæ€»å…ƒç´ æ•°è™½å¤š$O(n)$ï¼Œè€Œä¸æ˜¯æš´åŠ›é‚£æ ·æ‰€æœ‰çš„å…¨éƒ¨å¼€ï¼Œæ²¡æœ‰çš„ä¹Ÿå¼€äº†ã€‚\n\nå…³äºç›´æ¥ç»§æ‰¿é‡å„¿å­ä¿¡æ¯ï¼Œä½¿ç”¨`vector`çš„`swap`å‡½æ•°æ˜¾ç„¶æ¯”å†™æŒ‡é’ˆæ›´ç®€å•æ˜“æ‡‚ã€‚\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std; \nconst int N=1e6+5;\nint n,x,y,cnt,hd[N],to[N<<1],nxt[N<<1],len[N],son[N],ans[N];\nvector<int>f[N];    //è¿™é‡Œçš„ vector æ˜¯å€’åºå­˜å‚¨çš„ï¼Œå› ä¸ºè¦åœ¨ç»§æ‰¿é‡å„¿å­çš„ä¿¡æ¯åï¼Œè¦å°†å½“å‰èŠ‚ç‚¹çš„ DP æ•°ç»„æœ€å‰é¢æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œè€Œ push_back çš„å¤æ‚åº¦ä¼˜äº pop_frontï¼Œå€’åºå­˜å‚¨å°±å¯ä»¥ç›´æ¥ä½¿ç”¨ push_back \nvoid add(int x,int y){\n    to[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;\n}\nint get(int x,int id){    //ç”±äº vector æ˜¯å€’åºå­˜å‚¨çš„ï¼Œæ­¤å¤„å°† vector æ­£åºå­˜å‚¨çš„ä½ç½®è½¬åŒ–ä¸ºå€’åºå­˜å‚¨çš„ä½ç½® \n    return len[x]-id-1;\n}\nvoid dfs1(int x,int fa){\n    for(int i=hd[x];i;i=nxt[i]){\n        int y=to[i];\n        if(y==fa) continue;\n        dfs1(y,x);\n        if(len[y]>len[son[x]]) son[x]=y;\n    }\n    len[x]=len[son[x]]+1;\n}\nvoid dfs2(int x,int fa){\n    if(son[x]) dfs2(son[x],x),swap(f[x],f[son[x]]),ans[x]=ans[son[x]]+1;    //ç»§æ‰¿é‡å„¿å­çš„ä¿¡æ¯ã€‚è¿™é‡Œçš„ç»§æ‰¿ç›´æ¥ç”¨ swap è€Œä¸æ˜¯å¤åˆ¶ï¼Œswap åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šéƒ½æ›´ä¼˜ï¼ˆswap äº¤æ¢ vector çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼‰ã€‚ \n    f[x].push_back(1);    //push_back çš„å¤æ‚åº¦ä¼˜äº pop_front\n    for(int i=hd[x];i;i=nxt[i]){\n        int y=to[i];\n        if(y==fa||y==son[x]) continue;\n        dfs2(y,x);\n        for(int j=1;j<=len[y];j++){\n            f[x][get(x,j)]+=f[y][get(y,j-1)];    //æš´åŠ›åˆå¹¶è½»å„¿å­çš„ä¿¡æ¯ \n            if(f[x][get(x,j)]>f[x][get(x,ans[x])]||(f[x][get(x,j)]==f[x][get(x,ans[x])]&&j<ans[x])) ans[x]=j;    //æ›´æ–°ç­”æ¡ˆ\n        }\n    }\n    if(f[x][get(x,ans[x])]==1) ans[x]=0;    //f[x][0]=1,f[x][ans[x]]=1ï¼Œ0 æ˜¾ç„¶æ›´ä¼˜\n}\nsigned main(){\n    scanf(\"%lld\",&n);\n    for(int i=1;i<n;i++){\n        scanf(\"%lld%lld\",&x,&y);\n        add(x,y),add(y,x);\n    }\n    dfs1(1,0),dfs2(1,0);\n    for(int i=1;i<=n;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 9. åŠ¨æ€æ ‘ ï¼ˆLCT/Link-Cut Treeï¼Œå®é“¾å‰–åˆ†ï¼‰\n\nå…³é”®è¯ï¼šåŠ¨æ€æ ‘ï¼Œä¿®æ”¹æ ‘ç»“æ„åæ ‘ä¸ŠåŒºé—´æ“ä½œã€åºåˆ—åŒ–æ“ä½œã€‚\n\n***æ³¨æ„ï¼Œåºåˆ—ä¸Šçš„è·³è·ƒåŒæ ·å¯ä»¥è§†ä½œä¸€æ£µæ ‘æ¥è§£å†³é—®é¢˜***\n\nç»´æŠ¤ä¸€ä¸ª **æ£®æ—**ï¼Œæ”¯æŒåˆ é™¤æŸæ¡è¾¹ï¼ŒåŠ å…¥æŸæ¡è¾¹ï¼Œå¹¶ä¿è¯åŠ è¾¹ï¼Œåˆ è¾¹ä¹‹åä»æ˜¯æ£®æ—ã€‚æˆ‘ä»¬è¦ç»´æŠ¤è¿™ä¸ªæ£®æ—çš„ä¸€äº›ä¿¡æ¯ã€‚\n\nä¸€èˆ¬çš„æ“ä½œæœ‰ä¸¤ç‚¹è¿é€šæ€§ï¼Œä¸¤ç‚¹è·¯å¾„æƒå€¼å’Œï¼Œè¿æ¥ä¸¤ç‚¹å’Œåˆ‡æ–­æŸæ¡è¾¹ã€ä¿®æ”¹ä¿¡æ¯ç­‰ã€‚\n\næ ¸å¿ƒæ€æƒ³æ˜¯æˆ‘è¦è°æˆ‘å°±æŠŠè°è½¬åˆ°å®é“¾ä¸Šé¢ï¼Œå…¶ä»–çš„éƒ½æ˜¯è™šé“¾ã€‚\n\n$LCT$çš„è¾…åŠ©æ ‘æ€§è´¨ï¼š\n\n1. è¾…åŠ©æ ‘ç”±å¤šæ£µ $Splay$ ç»„æˆï¼Œæ¯æ£µ $Splay$ ç»´æŠ¤åŸæ ‘ä¸­çš„ä¸€æ¡è·¯å¾„ï¼Œä¸”ä¸­åºéå†è¿™æ£µ $Splay$ å¾—åˆ°çš„ç‚¹åºåˆ—ï¼Œä»å‰åˆ°åå¯¹åº”åŸæ ‘ã€Œä»ä¸Šåˆ°ä¸‹ã€çš„ä¸€æ¡è·¯å¾„ã€‚\n2. åŸæ ‘æ¯ä¸ªèŠ‚ç‚¹ä¸è¾…åŠ©æ ‘çš„ $Splay$ èŠ‚ç‚¹ä¸€ä¸€å¯¹åº”ã€‚\n3. è¾…åŠ©æ ‘çš„å„æ£µ $Splay$ ä¹‹é—´å¹¶ä¸æ˜¯ç‹¬ç«‹çš„ã€‚æ¯æ£µ $Splay$ çš„æ ¹èŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹æœ¬åº”æ˜¯ç©ºï¼Œä½†åœ¨ $LCT$ ä¸­æ¯æ£µ $Splay$ çš„æ ¹èŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹æŒ‡å‘åŸæ ‘ä¸­ **è¿™æ¡é“¾** çš„çˆ¶äº²èŠ‚ç‚¹ï¼ˆå³é“¾æœ€é¡¶ç«¯çš„ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ï¼‰ã€‚è¿™ç±»çˆ¶äº²é“¾æ¥ä¸é€šå¸¸ $Splay$ çš„çˆ¶äº²é“¾æ¥åŒºåˆ«åœ¨äºå„¿å­è®¤çˆ¶äº²ï¼Œè€Œçˆ¶äº²ä¸è®¤å„¿å­ï¼Œå¯¹åº”åŸæ ‘çš„ä¸€æ¡ **è™šè¾¹**ã€‚å› æ­¤ï¼Œæ¯ä¸ªè¿é€šå—æ°å¥½æœ‰ä¸€ä¸ªç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ä¸ºç©ºã€‚\n4. ç”±äºè¾…åŠ©æ ‘çš„ä»¥ä¸Šæ€§è´¨ï¼Œæˆ‘ä»¬ç»´æŠ¤ä»»ä½•æ“ä½œéƒ½ä¸éœ€è¦ç»´æŠ¤åŸæ ‘ï¼Œè¾…åŠ©æ ‘å¯ä»¥åœ¨ä»»ä½•æƒ…å†µä¸‹æ‹¿å‡ºä¸€ä¸ªå”¯ä¸€çš„åŸæ ‘ï¼Œæˆ‘ä»¬åªéœ€è¦ç»´æŠ¤è¾…åŠ©æ ‘å³å¯ã€‚\n\nç¤ºä¾‹ï¼š\n\nç»™å®š $n$ ä¸ªç‚¹ä»¥åŠæ¯ä¸ªç‚¹çš„æƒå€¼ï¼Œè¦ä½ å¤„ç†æ¥ä¸‹æ¥çš„ $m$ ä¸ªæ“ä½œã€‚  \n\næ“ä½œæœ‰å››ç§ï¼Œæ“ä½œä» $0$ åˆ° $3$ ç¼–å·ã€‚ç‚¹ä» $1$ åˆ° $n$ ç¼–å·ã€‚\n\n\n- `0 x y` ä»£è¡¨è¯¢é—®ä» $x$ åˆ° $y$ çš„è·¯å¾„ä¸Šçš„ç‚¹çš„æƒå€¼çš„ $\\text{xor}$ å’Œã€‚ä¿è¯ $x$ åˆ° $y$ æ˜¯è”é€šçš„ã€‚\n- `1 x y` ä»£è¡¨è¿æ¥ $x$ åˆ° $y$ï¼Œè‹¥ $x$ åˆ° $y$ å·²ç»è”é€šåˆ™æ— éœ€è¿æ¥ã€‚\n- `2 x y` ä»£è¡¨åˆ é™¤è¾¹ $(x,y)$ï¼Œä¸ä¿è¯è¾¹ $(x,y)$ å­˜åœ¨ã€‚\n- `3 x y` ä»£è¡¨å°†ç‚¹ $x$ ä¸Šçš„æƒå€¼å˜æˆ $y$ã€‚\n\nä¿è¯ï¼š\n- $1 \\leq n \\leq 10^5$ï¼Œ$1 \\leq m \\leq 3 \\times 10^5$ï¼Œ$1 \\leq a_i \\leq 10^9$ã€‚\n- å¯¹äºæ“ä½œ $0, 1, 2$ï¼Œä¿è¯ $1 \\leq x, y \\leq n$ã€‚\n- å¯¹äºæ“ä½œ $3$ï¼Œä¿è¯ $1 \\leq x \\leq n$ï¼Œ$1 \\leq y \\leq 10^9$ã€‚\n\n```cpp\n// LCTï¼ŒåŠ¨æ€æ ‘ã€å®é“¾å‰–åˆ†\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node\n{\n    int ch[2];\n#define l ch[0]\n#define r ch[1]\n    int val = 0;\n    int sum = 0;\n    // int lazytag = 0;\n    // int sz = 1;\n    int revtag = 0;\n    int fa = 0;\n};\nconst int maxn = 5e5 + 9;\nnode tr[maxn];\nvoid reverse(int x)\n{\n    tr[x].revtag ^= 1;\n    return;\n}\nbool get(int x) // è·å–xæ˜¯çˆ¶äº²èŠ‚ç‚¹çš„å“ªä¸ªå„¿å­\n{\n    return tr[tr[x].fa].r == x;\n}\nbool isroot(int x) // åˆ¤æ–­xç»“ç‚¹æ˜¯å¦ä½œä¸ºä¸€æ£µåŠ¨æ€Splayçš„æ ¹\n{\n    return tr[tr[x].fa].l != x && tr[tr[x].fa].r != x;\n}\nvoid pushup(int rt) // æ›´æ–°ç»“ç‚¹ä¿¡æ¯\n{\n    // other pushups;\n    // tr[rt].sz = tr[tr[rt].l].sz + tr[tr[rt].r].sz + 1;\n    tr[rt].sum = tr[tr[rt].l].sum ^ tr[tr[rt].r].sum ^ tr[rt].val;\n    return;\n}\nvoid pushdown(int x) // æ ‘ä¸Šæ‡’æ ‡è®°ï¼Œæ–‡è‰ºå¹³è¡¡æ ‘æ ‡è®°æ˜¯åˆšéœ€æ±‚\n{\n    if (tr[x].revtag)\n    {\n        swap(tr[x].l, tr[x].r);\n        if (tr[x].l)\n            reverse(tr[x].l);\n        if (tr[x].r)\n            reverse(tr[x].r);\n        tr[x].revtag = 0;\n    }\n}\nvoid update(int x) // åŠ¨xä¹‹å‰ç»“ç®—xæ‰€åœ¨æ ¹çš„æ‰€æœ‰lazytag\n{\n    if (!isroot(x))\n    {\n        update(tr[x].fa);\n    }\n    pushdown(x);\n    return;\n}\nvoid rotate(int x)\n{\n    int y = tr[x].fa, z = tr[y].fa, k = get(x);\n    if (!isroot(y))\n        tr[z].ch[tr[z].r == y] = x;\n    // ä¸Šé¢è¿™å¥ä¸€å®šè¦å†™åœ¨å‰é¢ï¼Œæ™®é€šçš„ Splay æ˜¯ä¸ç”¨çš„ï¼Œå› ä¸º isRoot  (åé¢ä¼šè®²)\n    tr[x].fa = z;\n    tr[y].ch[k] = tr[x].ch[!k];\n    tr[tr[x].ch[!k]].fa = y;\n    tr[x].ch[!k] = y;\n    tr[y].fa = x;\n    pushup(y), pushup(x);\n}\nvoid Splay(int x) // ä¼¸å±•æ“ä½œï¼Œå°†ç»“ç‚¹ä¼¸å±•åˆ°æ ¹ã€‚\n{\n    update(x);\n    for (int fa; fa = tr[x].fa, !isroot(x); rotate(x))\n    {\n        if (!isroot(fa))\n            rotate(get(fa) == get(x) ? fa : x);\n    }\n}\nint access(int x) // æ‹‰ç›´ä»xåˆ°å½“å‰åŠ¨æ€æ ‘æ ¹èŠ‚ç‚¹çš„å®è¾¹è·¯å¾„ï¼Œè¿”å›è¯¥è·¯å¾„ç»ˆç‚¹çš„Splayçš„æ ¹ï¼ˆå³è·¯å¾„ç»ˆç‚¹ï¼‰\n{\n    int p;\n    for (p = 0; x; p = x, x = tr[x].fa)\n    {\n        Splay(x);\n        tr[x].r = p;\n        pushup(x);\n    }\n    return p;\n}\nvoid makeroot(int x) // æ¢æ ¹æ“ä½œï¼ŒæŒ‡å®šxç»“ç‚¹æˆä¸ºåŸæ ‘ï¼ˆéè¾…åŠ©æ ‘ï¼‰çš„æ€»æ ¹\n{\n    access(x);  // æ‹‰å‡ºxåˆ°å½“å‰æ ¹çš„è·¯å¾„ï¼Œxå¿…ç„¶æ˜¯æ­¤æ—¶æ‰€åœ¨Splayä¸­ä¸­åºéå†çš„æœ€åä¸€ä¸ªç‚¹\n    Splay(x);   // æ—‹æ ¹ï¼Œæ ¹æ®LCT-Splayå®šä¹‰ï¼Œè¿™æ£µSplayå¿…å®šæ²¡æœ‰å³å„¿å­\n    reverse(x); // ç›´æ¥ç¿»è½¬Splayï¼Œè¿«ä½¿å…¶æˆä¸ºå½“å‰Splayä¸­åºéå†ç¬¬ä¸€ä¸ªè®¿é—®çš„ç‚¹ï¼Œæˆä¸ºæ·±åº¦æœ€æµ…çš„æ ¹ï¼Œå®ç°äº†æ¢è·Ÿ\n    return;\n}\nint find(int p) // æ‰¾ç»“ç‚¹påœ¨åŸæ£®æ—æ‰€å±æ ‘ï¼ˆéè¾…åŠ©Splayæ£®æ—æ ‘ï¼‰çš„æ ‘æ ¹\n{\n    access(p);\n    Splay(p);\n    pushdown(p);\n    while (tr[p].l)\n        p = tr[p].l, pushdown(p);\n    Splay(p);\n    return p;\n}\nbool link(int x, int y) // è¿ä¸€æ¡x->yçš„è½»è¾¹\n{\n    makeroot(x);\n    if (find(y) == x)\n        return 0;\n    tr[x].fa = y;\n    return 1;\n}\nbool cut(int x, int y)\n{\n    makeroot(x);\n    if (find(y) != x || tr[y].fa != x || tr[y].l)\n        return 0;\n    tr[y].fa = tr[x].r = 0; // xåœ¨findroot(y)åè¢«è½¬åˆ°äº†æ ¹\n    pushup(x);\n    return 1;\n}\nvoid split(int x, int y) // åŠ¨æ€æ ‘ä¸­æ‹†å‡ºæ¥ä¸€æ¡x->yæŒ‡å®šè·¯å¾„ï¼Œä¿è¯è·¯å¾„ä¸Šéƒ½æ˜¯å®è¾¹,ä¿è¯yåœ¨æ ¹ã€‚\n{\n    makeroot(x);\n    access(y);\n    Splay(y);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        int v;\n        cin >> v;\n        tr[i].val = v;\n        tr[i].sum = v;\n    }\n    while (m--)\n    {\n        int op, x, y;\n        cin >> op >> x >> y;\n        if (op == 0)\n        {\n            split(x, y);\n            cout << tr[y].sum << endl;\n        }\n        else if (op == 1)\n        {\n            link(x, y);\n        }\n        else if (op == 2)\n        {\n            cut(x, y);\n        }\n        else\n        {\n            Splay(x); // èŠ‚ç‚¹ä¿®æ”¹è½¬åˆ°æ ¹å†æ”¹ï¼Œä¸ä¼šå½±å“å…¶ä»–ä¿¡æ¯\n            tr[x].val = y;\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 10. 01Trie\n\nå…³äºå­—å…¸æ ‘Trieçš„å†…å®¹ï¼Œè¯¦è§$Part\\ 2$.\n\n### 10.1 01Trie\n\n01å­—å…¸æ ‘ã€‚å†™æ³•å‚è§å¯æŒä¹…åŒ–ï¼Œæ²¡å•¥åŒºåˆ«ã€‚\n\n`tr[rt].cnt`å­˜å‚¨çš„æ˜¯ä»å½“å‰èŠ‚ç‚¹æ•°ä½å‡ºå‘è¿˜æœ‰å¤šå°‘ä¸ªæ•°å­—ï¼Œæ ¹èŠ‚ç‚¹å°±æ˜¯æ•°å­—çš„æ€»ä¸ªæ•°ã€‚\n\n### 10.2 å¯æŒä¹…åŒ–01Trie\n\nç»´æŠ¤åŒºé—´å¼‚æˆ–æœ€å¤§å€¼æˆ–è€…åŒºé—´ç¬¬$K$å¤§å€¼ã€‚åŒºé—´ç¬¬$K$å¤§å€¼ç±»ä¼¼äºä¸»å¸­æ ‘æ ‘ä¸ŠäºŒåˆ†ã€‚\n\nç¤ºä¾‹ï¼šï¼ˆåŒºé—´æœ€å¤§å€¼ï¼‰\n\nç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°åºåˆ— $\\{a\\}$ï¼Œåˆå§‹é•¿åº¦ä¸º $N$ã€‚  \n\næœ‰ $M$ ä¸ªæ“ä½œï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æ“ä½œç±»å‹ï¼š  \n\n1. `A x`ï¼šæ·»åŠ æ“ä½œï¼Œè¡¨ç¤ºåœ¨åºåˆ—æœ«å°¾æ·»åŠ ä¸€ä¸ªæ•° $x$ï¼Œåºåˆ—çš„é•¿åº¦ $N$ åŠ  $1$ã€‚  \n2. `Q l r x`ï¼šè¯¢é—®æ“ä½œï¼Œä½ éœ€è¦æ‰¾åˆ°ä¸€ä¸ªä½ç½® $p$ï¼Œæ»¡è¶³ $l \\le p \\le r$ï¼Œä½¿å¾—ï¼š$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ æœ€å¤§ï¼Œè¾“å‡ºæœ€å¤§å€¼ã€‚\n\n- å¯¹äºæ‰€æœ‰æµ‹è¯•ç‚¹ï¼Œ$1\\le N,M \\le 3\\times 10 ^ 5$ï¼Œ$0\\leq a_i\\leq 10 ^ 7$ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Present_Trie\n{\nprivate:\n    struct node\n    {\n        int nxt[2];\n        int cnt = 0;\n    };\n    vector<node> tr;\n    int tot = 0;\n    int n;\n\npublic:\n    void init(int n)\n    {\n        this->n = n;\n        tr.resize(n << 5);\n    }\n    int newroot()\n    {\n        return ++tot;\n    }\n    void insert(int rt1, int rt2, int x)\n    {\n        for (int i = 30; i >= 0; i--)\n        {\n            int bit = (x >> i) & 1;\n            if (bit)\n            {\n                if (!tr[rt2].nxt[1])\n                {\n                    tr[rt2].nxt[1] = ++tot;\n                }\n                tr[rt2].nxt[0] = tr[rt1].nxt[0];\n                rt1 = tr[rt1].nxt[1];\n                rt2 = tr[rt2].nxt[1];\n            }\n            else\n            {\n                if (!tr[rt2].nxt[0])\n                {\n                    tr[rt2].nxt[0] = ++tot;\n                }\n                tr[rt2].nxt[1] = tr[rt1].nxt[1];\n                rt1 = tr[rt1].nxt[0];\n                rt2 = tr[rt2].nxt[0];\n            }\n            tr[rt2].cnt = tr[rt1].cnt + 1;\n        }\n    }\n    int query(int rt1, int rt2, int x)\n    {\n        int ret = 0;\n        for (int i = 30; i >= 0; i--)\n        {\n            int bit = (x >> i) & 1;\n            if (tr[tr[rt2].nxt[bit ^ 1]].cnt - tr[tr[rt1].nxt[bit ^ 1]].cnt > 0)\n            {\n                ret |= (1 << i);\n                rt1 = tr[rt1].nxt[bit ^ 1];\n                rt2 = tr[rt2].nxt[bit ^ 1];\n            }\n            else\n            {\n                rt1 = tr[rt1].nxt[bit];\n                rt2 = tr[rt2].nxt[bit];\n            }\n        }\n        return ret;\n    }\n};\nPresent_Trie pt;\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> root(n + 1);\n    pt.init(1e6 + 9);\n    int calc = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        calc ^= x;\n        root[i] = pt.newroot();\n        pt.insert(root[i - 1], root[i], calc);\n    }\n    while (q--)\n    {\n        char c;\n        int l, r, x;\n        cin >> c;\n        if (c == 'Q')\n        {\n            cin >> l >> r >> x;\n            l--, r--;\n            if (l == 0)\n            {\n                cout << max(x ^ calc, pt.query(root[l], root[r], x ^ calc)) << endl;\n            }\n            else\n            {\n                cout << pt.query(root[l - 1], root[r], x ^ calc) << endl;\n            }\n        }\n        else if (c == 'A')\n        {\n            cin >> x;\n            calc ^= x;\n            root.emplace_back(pt.newroot());\n            n++;\n            pt.insert(root[n - 1], root[n], calc);\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 11.å•è°ƒæ ˆ\n\nå•è°ƒæ ˆï¼Œå¯ä»¥ç»´æŠ¤ä¸€ä¸ªå•è°ƒçš„åºåˆ—ï¼Œä½¿å¾—æ¯ä¸€ä¸ªå…ƒç´ è¿›æ ˆçš„æ—¶å€™ï¼Œæ‰€æœ‰æ¯”è¿™ä¸ªå…ƒç´ å°çš„æ ˆå†…å…ƒç´ å‡ä¼šè¢«å…¶æ¶ˆé™¤æˆ–è€…èåˆï¼Œæ¯”ä»–å¤§çš„æ ˆå†…å…ƒç´ ä¸ä¼šä¸å…¶æ¶ˆé™¤æˆ–è€…èåˆã€‚æœ€å…¸å‹çš„ä¾‹å­å°±æ˜¯ç»´æŠ¤æŸä¸ªæ•°æœ€å·¦ä¾§å’Œæœ€å³ä¾§ç¬¬ä¸€ä¸ªæ¯”å…¶å¤§çš„æ•°ã€‚ä½†æ˜¯å•è°ƒæ ˆå¹¶ä¸å±€é™äºæ­¤ï¼š\n\nç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $m$ çš„æ•°ç»„ $b$ ã€‚æ‚¨å¯ä»¥æ‰§è¡Œä»¥ä¸‹ä»»æ„æ¬¡æ“ä½œï¼ˆå¯èƒ½æ˜¯é›¶æ¬¡ï¼‰ï¼š\n\n- é€‰æ‹©ä¸¤ä¸ªä¸åŒçš„ç´¢å¼• $i$ å’Œ $j$ ï¼Œå…¶ä¸­ $\\bf{1\\le i < j\\le m}$ å’Œ $b_i$ ä¸ºå¶æ•°ï¼Œå°† $b_i$ é™¤ä»¥ $2$ ï¼Œå¹¶å°† $b_j$ ä¹˜ä»¥ $2$ ã€‚\n\næ‚¨çš„ä»»åŠ¡æ˜¯åœ¨æ‰§è¡Œä»»æ„æ•°é‡çš„æ­¤ç±»æ“ä½œåæœ€å¤§åŒ–æ•°ç»„çš„æ€»å’Œã€‚ç”±äºå®ƒå¯èƒ½å¾ˆå¤§ï¼Œè¯·è¾“å‡ºæ­¤æ€»å’Œæ¨¡æ•° $10^9+7$ ã€‚\n\nç”±äºè¿™é“é¢˜å¤ªç®€å•äº†ï¼Œç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ $a$ ï¼Œä½ éœ€è¦å¯¹ $a$ çš„æ¯ä¸ªå‰ç¼€è¿›è¡Œæ±‚è§£ã€‚\n\næ¢å¥è¯è¯´ï¼Œè¡¨ç¤ºåœ¨æ‰§è¡Œä»»æ„æ•°é‡çš„ $f(b)$ ç­‰è¿ç®—å $b$ çš„æœ€å¤§å’Œï¼Œä½ éœ€è¦åˆ†åˆ«è¾“å‡º $f([a_1])$ ã€ $f([a_1,a_2])$ ã€ $\\ldots$ ã€ $f([a_1,a_2,\\ldots,a_n])$ æ¨¡æ•° $10^9+7$ ã€‚\n\nä¸éš¾è€ƒè™‘åˆ°æ¯ä¸ªæ•°æ–°åŠ è¿›åºåˆ—çš„æ—¶å€™ï¼Œæ‰€æœ‰æ¯”è¿™ä¸ªæ•°å°çš„åº•æ•°ï¼ˆé™¤å°½2ä»¥åçš„æ•°ï¼‰æ‰€åŒ…å«2çš„ä¸ªæ•°éƒ½è¦åŠ åˆ°æ–°æ•°å­—ä¸Šã€‚å¾ˆåƒä¸€ä¸ªçº¿æ®µæ ‘åŒºé—´æŸ¥ï¼Œä½†æ˜¯è¿™ä¼šå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼š\n\næ ·ä¾‹ï¼š 18 2 7\n\næ–°åŠ å…¥çš„7æ˜¾ç„¶æŸ¥ä¸åˆ°9åº•ä¸Šçš„ä¸€ä¸ª2ï¼Œä½†æ˜¯14å¯ä»¥æŸ¥åˆ°ã€‚çº¿æ®µæ ‘æœ€åå¤æ‚åº¦æ˜¯$nlog^2n$çš„ã€‚ï¼ˆå®é™…ä¸Šæ ¹æ®è¿ç®—ç‰¹æ€§åˆ†æï¼Œèƒ½å¤Ÿå¡æ»¡$log^2n$å•æ¬¡è¯¢é—®çš„æƒ…å†µæœ€å¤šåªæœ‰$logn$æ¬¡ï¼Œæ‰€ä»¥çœŸå®å®é™…å¤æ‚åº¦ä¸º$nlogn+log^3n\\rightarrow nlogn$çš„å¤æ‚åº¦ï¼‰\n\næ‰€ä»¥ï¼Œæ¯”å½“å‰æ•°å°çš„å‡å¯ä»¥åˆå¹¶ï¼Œæ¯”å½“å‰æ•°å¤§çš„å‡æ— æ³•åˆå¹¶ï¼Œç¬¦åˆå•è°ƒæ ˆå®šä¹‰ï¼š\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    mint tmpsum = 0;\n    vector<i64> a(n + 1);\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    stack<pair<i64, i64>> st;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = 0;\n        while (a[i] % 2 == 0)\n        {\n            k++;\n            a[i] >>= 1;\n        }\n        while (!st.empty() && (k >= 30 || (a[i] << k) > st.top().first))\n        {\n            auto [num, cnt] = st.top();\n            st.pop();\n            tmpsum -= power(mint(2), cnt) * num;\n            tmpsum += num;\n            k += cnt;\n        }\n        st.push({a[i], k});\n        tmpsum += mint(a[i]) * power(mint(2), k);\n        cout << tmpsum << \" \";\n    }\n    cout << endl;\n    return;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 2. æ•°å­¦\n\n### 0. Modint.h\n\n```cpp\n#ifndef __MODINT_H__\n\n#define __MODINT_H__\n\nusing i64 = long long;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nnamespace Modint\n{\n    template <class T>\n    constexpr T power(T a, i64 b)\n    {\n        T res = 1;\n        for (; b; b /= 2, a *= a)\n        {\n            if (b % 2)\n            {\n                res *= a;\n            }\n        }\n        return res;\n    }\n\n    constexpr i64 mul(i64 a, i64 b, i64 p)\n    {\n        i64 res = a * b - (i64)(1.L * a * b / p) * p;\n        res %= p;\n        if (res < 0)\n        {\n            res += p;\n        }\n        return res;\n    }\n    /*\n     * @brief æ¨¡è¿ç®—ï¼ˆi64ï¼‰ï¼Œjianglyç‰ˆæœ¬ï¼Œæ”¯æŒåŠ¨æ€æ¨¡æ•°æ”¹å˜\n     * @param P æ¨¡æ•°ï¼Œä»…æ”¯æŒè´¨æ•°ã€‚å¦‚æœé€‰æ‹©åŠ¨æ€å®šä¹‰æ¨¡æ•°ï¼ŒP=0ï¼Œä¸”å¿…é¡»è°ƒç”¨setModå‡½æ•°è®¾ç½®æ¨¡æ•°ã€‚é»˜è®¤ä¸º1e18+9\n     */\n    template <i64 P>\n    struct MLong\n    {\n        i64 x;\n        constexpr MLong() : x{} {}\n        constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n\n        static i64 Mod;\n        constexpr static i64 getMod()\n        {\n            if (P > 0)\n            {\n                return P;\n            }\n            else\n            {\n                return Mod;\n            }\n        }\n        constexpr static void setMod(i64 Mod_)\n        {\n            Mod = Mod_;\n        }\n        constexpr i64 norm(i64 x) const\n        {\n            if (x < 0)\n            {\n                x += getMod();\n            }\n            if (x >= getMod())\n            {\n                x -= getMod();\n            }\n            return x;\n        }\n        constexpr i64 val() const\n        {\n            return x;\n        }\n        explicit constexpr operator i64() const\n        {\n            return x;\n        }\n        constexpr MLong operator-() const\n        {\n            MLong res;\n            res.x = norm(getMod() - x);\n            return res;\n        }\n        constexpr MLong inv() const\n        {\n            assert(x != 0);\n            return power(*this, getMod() - 2);\n        }\n        constexpr MLong &operator*=(MLong rhs) &\n        {\n            x = mul(x, rhs.x, getMod());\n            return *this;\n        }\n        constexpr MLong &operator+=(MLong rhs) &\n        {\n            x = norm(x + rhs.x);\n            return *this;\n        }\n        constexpr MLong &operator-=(MLong rhs) &\n        {\n            x = norm(x - rhs.x);\n            return *this;\n        }\n        constexpr MLong &operator/=(MLong rhs) &\n        {\n            return *this *= rhs.inv();\n        }\n        friend constexpr MLong operator*(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res *= rhs;\n            return res;\n        }\n        friend constexpr MLong operator+(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res += rhs;\n            return res;\n        }\n        friend constexpr MLong operator-(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res -= rhs;\n            return res;\n        }\n        friend constexpr MLong operator/(MLong lhs, MLong rhs)\n        {\n            MLong res = lhs;\n            res /= rhs;\n            return res;\n        }\n        friend constexpr std::istream &operator>>(std::istream &is, MLong &a)\n        {\n            i64 v;\n            is >> v;\n            a = MLong(v);\n            return is;\n        }\n        friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a)\n        {\n            return os << a.val();\n        }\n        friend constexpr bool operator==(MLong lhs, MLong rhs)\n        {\n            return lhs.val() == rhs.val();\n        }\n        friend constexpr bool operator!=(MLong lhs, MLong rhs)\n        {\n            return lhs.val() != rhs.val();\n        }\n    };\n\n    template <>\n    i64 MLong<0LL>::Mod = (i64)(1E18) + 9;\n\n    /*template <i64 V, i64 P>\n    constexpr MLong<P> CInv = MLong<P>(V).inv();*/\n\n    /*\n     * @brief æ¨¡è¿ç®—ï¼ˆintï¼‰ï¼Œjianglyç‰ˆæœ¬ï¼Œæ”¯æŒåŠ¨æ€æ¨¡æ•°æ”¹å˜\n     * @param P æ¨¡æ•°ï¼Œä»…æ”¯æŒè´¨æ•°ã€‚å¦‚æœé€‰æ‹©åŠ¨æ€å®šä¹‰æ¨¡æ•°ï¼ŒP=0ï¼Œä¸”å¿…é¡»è°ƒç”¨setModå‡½æ•°è®¾ç½®æ¨¡æ•°ã€‚é»˜è®¤ä¸º998244353\n     */\n    template <int P>\n    struct MInt\n    {\n        int x;\n        constexpr MInt() : x{} {}\n        constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n\n        static int Mod;\n        constexpr static int getMod()\n        {\n            if (P > 0)\n            {\n                return P;\n            }\n            else\n            {\n                return Mod;\n            }\n        }\n        constexpr static void setMod(int Mod_)\n        {\n            Mod = Mod_;\n        }\n        constexpr int norm(int x) const\n        {\n            if (x < 0)\n            {\n                x += getMod();\n            }\n            if (x >= getMod())\n            {\n                x -= getMod();\n            }\n            return x;\n        }\n        constexpr int val() const\n        {\n            return x;\n        }\n        explicit constexpr operator int() const\n        {\n            return x;\n        }\n        constexpr MInt operator-() const\n        {\n            MInt res;\n            res.x = norm(getMod() - x);\n            return res;\n        }\n        constexpr MInt inv() const\n        {\n            assert(x != 0);\n            return power(*this, getMod() - 2);\n        }\n        constexpr MInt &operator*=(MInt rhs) &\n        {\n            x = 1LL * x * rhs.x % getMod();\n            return *this;\n        }\n        constexpr MInt &operator+=(MInt rhs) &\n        {\n            x = norm(x + rhs.x);\n            return *this;\n        }\n        constexpr MInt &operator-=(MInt rhs) &\n        {\n            x = norm(x - rhs.x);\n            return *this;\n        }\n        constexpr MInt &operator/=(MInt rhs) &\n        {\n            return *this *= rhs.inv();\n        }\n        friend constexpr MInt operator*(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res *= rhs;\n            return res;\n        }\n        friend constexpr MInt operator+(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res += rhs;\n            return res;\n        }\n        friend constexpr MInt operator-(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res -= rhs;\n            return res;\n        }\n        friend constexpr MInt operator/(MInt lhs, MInt rhs)\n        {\n            MInt res = lhs;\n            res /= rhs;\n            return res;\n        }\n        friend constexpr std::istream &operator>>(std::istream &is, MInt &a)\n        {\n            i64 v;\n            is >> v;\n            a = MInt(v);\n            return is;\n        }\n        friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a)\n        {\n            return os << a.val();\n        }\n        friend constexpr bool operator==(MInt lhs, MInt rhs)\n        {\n            return lhs.val() == rhs.val();\n        }\n        friend constexpr bool operator!=(MInt lhs, MInt rhs)\n        {\n            return lhs.val() != rhs.val();\n        }\n    };\n\n    template <>\n    int MInt<0>::Mod = 998244353;\n\n    // é€†å…ƒ\n    template <int V, int P>\n    constexpr MInt<P> CInv = MInt<P>(V).inv();\n    /*\n     * @brief é˜¶ä¹˜ç±»(é€‚é…Jianglyæ¨¡æ¿ï¼‰ï¼Œæ”¯æŒè®¡ç®—ç»„åˆæ•°ï¼Œæ’åˆ—æ•°ç­‰æ“ä½œï¼Œå¤æ‚åº¦O(n),é…å¥—jianglyç‰ˆæœ¬çš„æ¨¡è¿ç®—ç±»\n     * @brief å°æ•°æ®æ—¶éœ€è¦ç»„åˆæ•°å»ºè®®ä½¿ç”¨ç»„åˆæ•°è¡¨ï¼ˆæ¨è¾‰ä¸‰è§’ï¼‰ï¼Œå¤§æ•°æ®æ—¶éœ€è¦ç»„åˆæ•°å»ºè®®ä½¿ç”¨Lucaså®šç†\n     * @param MOD æ¨¡æ•°ï¼Œä¸€èˆ¬å–è´¨æ•°ï¼Œéƒ¨åˆ†åˆæ•°æƒ…å†µä¸‹å¯èƒ½æ²¡æœ‰é€†å…ƒã€‚\n     * @note æ”¯æŒè®¡ç®—ç»„åˆæ•°ï¼Œå¯ä»¥ä½¿ç”¨C(n,k)è®¡ç®—ç»„åˆæ•°ã€‚\n     * @note æ”¯æŒè®¡ç®—æ’åˆ—æ•°ï¼Œå¯ä»¥ä½¿ç”¨A(n,k)è®¡ç®—æ’åˆ—æ•°ã€‚\n     */\n    template <class T>\n    struct Fact\n    {\n        std::vector<T> fact, factinv;\n        const int n;\n        Fact(const int &_n) : n(_n), fact(_n + 1, 1), factinv(_n + 1)\n        {\n            for (int i = 1; i <= n; ++i)\n                fact[i] = fact[i - 1] * i;\n            factinv[n] = fact[n].inv();\n            for (int i = n; i; --i)\n                factinv[i - 1] = factinv[i] * i;\n        }\n        T C(const int &n, const int &k)\n        {\n            if (n < 0 || k < 0 || n < k)\n                return 0;\n            return fact[n] * factinv[k] * factinv[n - k];\n        }\n        T A(const int &n, const int &k)\n        {\n            if (n < 0 || k < 0 || n < k)\n                return 0;\n            return fact[n] * factinv[n - k];\n        }\n    };\n};\n\n#endif //__MODINT_H__\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1. æ•°è®ºç›¸å…³\n\n#### 1.1 å¤§è´¨æ•°åˆ¤å®šï¼ˆMiller-Rabinç´ æ€§æµ‹è¯•ï¼‰\n\nä»¥$O(logN)$å¤æ‚åº¦ï¼Œä»¥è¾ƒé«˜æ­£ç¡®æ€§åˆ¤å®šè´¨æ•°ã€‚\n\n```cpp\n#define i64 long long\n    i64 mul(i64 a, i64 b, i64 m)\n    {\n        return static_cast<__int128>(a) * b % m;\n    }\n    i64 power(i64 a, i64 b, i64 m)\n    {\n        i64 res = 1 % m;\n        for (; b; b >>= 1, a = mul(a, a, m))\n            if (b & 1)\n                res = mul(res, a, m);\n        return res;\n    }\n    /* @brief Miller-Rabin ç´ æ€§æµ‹è¯•,æ—¶é—´å¤æ‚åº¦ä¸º O(log n)\n     * @param n å¾…æµ‹è¯•çš„æ•°ï¼Œä¸å¤§äº 1e18\n     * @return true ä¸ºç´ æ•°ï¼Œfalse ä¸ºåˆæ•°*/\n    bool isprime(i64 n)\n    {\n        if (n < 2)\n            return false;\n        static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n        int s = __builtin_ctzll(n - 1);\n        i64 d = (n - 1) >> s;\n        for (auto a : A)\n        {\n            if (a == n)\n                return true;\n            i64 x = power(a, d, n);\n            if (x == 1 || x == n - 1)\n                continue;\n            bool ok = false;\n            for (int i = 0; i < s - 1; ++i)\n            {\n                x = mul(x, x, n);\n                if (x == n - 1)\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n        return true;\n    }\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.2 è´¨å› æ•°åˆ†è§£\n\n##### 1.2.1  å°æ•°å­—è´¨å› æ•°åˆ†è§£\n\nä»¥$O(N\\sqrt N)$å¤æ‚åº¦åˆ†è§£è´¨å› æ•°ã€‚\n\n```cpp\nvector<int> breakdown(int N) {\n  vector<int> result;\n  for (int i = 2; i * i <= N; i++) {\n    if (N % i == 0) {  // å¦‚æœ i èƒ½å¤Ÿæ•´é™¤ Nï¼Œè¯´æ˜ i ä¸º N çš„ä¸€ä¸ªè´¨å› å­ã€‚\n      while (N % i == 0) N /= i;\n      result.push_back(i);\n    }\n  }\n  if (N != 1) {  // è¯´æ˜å†ç»è¿‡æ“ä½œä¹‹å N ç•™ä¸‹äº†ä¸€ä¸ªç´ æ•°\n    result.push_back(N);\n  }\n  return result;\n}\n```\n\n##### 1.2.2 å¤§è´¨æ•°è´¨å› æ•°åˆ†è§£ï¼ˆPollar-Rhoç®—æ³•ï¼‰\n\nä»¥æœŸæœ›å¤æ‚åº¦$O(N^{\\frac{1}{4}})$å¤æ‚åº¦åˆ†è§£è´¨å› æ•°ã€‚\n\n```cpp\nnamespace Prime\n{\nusing i64=long long;\n    i64 mul(i64 a, i64 b, i64 m)\n    {\n        return static_cast<__int128>(a) * b % m;\n    }\n    i64 power(i64 a, i64 b, i64 m)\n    {\n        i64 res = 1 % m;\n        for (; b; b >>= 1, a = mul(a, a, m))\n            if (b & 1)\n                res = mul(res, a, m);\n        return res;\n    }\n    /* @brief Miller-Rabin ç´ æ€§æµ‹è¯•,æ—¶é—´å¤æ‚åº¦ä¸º O(log n)\n     * @param n å¾…æµ‹è¯•çš„æ•°ï¼Œä¸å¤§äº 1e18\n     * @return true ä¸ºç´ æ•°ï¼Œfalse ä¸ºåˆæ•°\n     */\n    bool isprime(i64 n)\n    {\n        if (n < 2)\n            return false;\n        static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n        int s = __builtin_ctzll(n - 1);\n        i64 d = (n - 1) >> s;\n        for (auto a : A)\n        {\n            if (a == n)\n                return true;\n            i64 x = power(a, d, n);\n            if (x == 1 || x == n - 1)\n                continue;\n            bool ok = false;\n            for (int i = 0; i < s - 1; ++i)\n            {\n                x = mul(x, x, n);\n                if (x == n - 1)\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n        return true;\n    }\n    /* @brief ç´ å› å­åˆ†è§£ï¼ˆPollard-Rho ç®—æ³•ï¼‰,æ—¶é—´å¤æ‚åº¦æœŸæœ›ä¸º O(n^(1/4))ï¼Œæœ€åä¸º O(n^(1/2))ï¼Œæœ¬å‡½æ•°å¤æ‚åº¦å¸¦æ’åºï¼Œå…·ä½“å¤æ‚åº¦å¾…å®šï¼Œå¯ä¼°ç®—ä¸ºäºšçº¿æ€§\n     * @param n å¾…åˆ†è§£çš„æ•°ï¼Œä¸å¤§äº 1e18\n     * @return ä¸€ä¸ª vectorï¼ŒåŒ…å«äº† n çš„æ‰€æœ‰ç´ å› å­ï¼ŒæŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—ï¼ŒåŒ…æ‹¬é‡å¤çš„\n     */\n    std::vector<i64> factorize(i64 n)\n    {\n        std::vector<i64> p;\n        std::function<void(i64)> f = [&](i64 n)\n        {\n            if (n <= 10000)\n            {\n                for (int i = 2; i * i <= n; ++i)\n                    for (; n % i == 0; n /= i)\n                        p.push_back(i);\n                if (n > 1)\n                    p.push_back(n);\n                return;\n            }\n            if (isprime(n))\n            {\n                p.push_back(n);\n                return;\n            }\n            auto g = [&](i64 x)\n            {\n                return (mul(x, x, n) + 1) % n;\n            };\n            i64 x0 = 2;\n            while (true)\n            {\n                i64 x = x0;\n                i64 y = x0;\n                i64 d = 1;\n                i64 power = 1, lam = 0;\n                i64 v = 1;\n                while (d == 1)\n                {\n                    y = g(y);\n                    ++lam;\n                    v = mul(v, std::abs(x - y), n);\n                    if (lam % 127 == 0)\n                    {\n                        d = std::gcd(v, n);\n                        v = 1;\n                    }\n\n                    if (power == lam)\n                    {\n                        x = y;\n                        power *= 2;\n                        lam = 0;\n                        d = std::gcd(v, n);\n                        v = 1;\n                    }\n                }\n                if (d != n)\n                {\n                    f(d);\n                    f(n / d);\n                    return;\n                }\n                ++x0;\n            }\n        };\n        f(n);\n        std::sort(p.begin(), p.end());\n        return p;\n    }\n    /*\n     * @brief ç´ å› å­åˆ†è§£ï¼ˆPollard-Rho ç®—æ³•ï¼‰\n     * @param n å¾…åˆ†è§£çš„æ•°ï¼Œä¸å¤§äº 1e18\n     * @return ä¸€ä¸ª vectorï¼ŒåŒ…å«äº† n çš„æ‰€æœ‰ç´ å› å­ï¼ŒæŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—ï¼Œfirst ä¸ºç´ å› å­ï¼Œsecond ä¸ºæŒ‡æ•°\n     */\n    std::vector<std::pair<i64, i64>> factorize_pairs(i64 n)\n    {\n        std::vector<i64> p = factorize(n);\n        std::vector<std::pair<i64, i64>> res;\n        for (auto i : p)\n        {\n            if (res.empty() || res.back().first != i)\n                res.emplace_back(i, 1);\n            else\n                res.back().second++;\n        }\n        return res;\n    }\n    void dfs(int p, i64 n, std::vector<std::pair<i64, i64>> &ps, std::vector<i64> &ds)\n    {\n        if (p == ps.size())\n        {\n            if (n > 1)\n            {\n                ds.push_back(n);\n            }\n            return;\n        }\n        for (i64 i = 0; i <= ps[p].second; i++)\n        {\n            dfs(p + 1, n, ps, ds);\n            n *= ps[p].first;\n        }\n        return;\n    }\n    /*\n     * @brief å› æ•°é›†åˆ(ä¸å«1,Pollard-Rho ç®—æ³•è´¨å› æ•°åˆ†è§£)\n     * @param n å¾…è€ƒå¯Ÿçš„æ•°ï¼Œä¸å¤§äº 1e18\n     * @return ä¸€ä¸ª vectorï¼ŒåŒ…å«äº† n çš„å› å­ï¼ŒæŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—ã€‚ä¸å«1ã€‚\n     */\n    std::vector<i64> getd(i64 n)\n    {\n        std::vector<std::pair<i64, i64>> p = factorize_pairs(n);\n        std::vector<i64> d;\n        dfs(0, 1, p, d);\n        std::sort(d.begin(), d.end());\n        return d;\n    }\n\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.3 åŸºäºå€¼åŸŸå¤„ç†çš„å¿«é€ŸGCD\n\nä½ éœ€è¦è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š\n\nä»¥$O(1)$çš„å•æ¬¡è¯¢é—®å¤æ‚åº¦ã€$O(n)$çš„æ€»æ—¶é—´å¤æ‚åº¦å›ç­”$\\forall x,y\\in[1,n],gcd(x,y)=?$\n\næ“ä½œæ–¹æ³•ï¼š\n\nå°†ä»»æ„$x$åˆ†è§£æˆä¸‰ä¸ªæ•°çš„ä¹˜ç§¯$a\\times b\\times c$ï¼Œåˆ™æ˜¾ç„¶$a,b,c\\le \\sqrt n$.\n\nè€ƒè™‘çº¿ç­›ï¼Œè‹¥ $x$ ä¸ºè´¨æ•°ï¼Œæ˜¾ç„¶ $(1,1,x)$å®ƒçš„ä¸€ä¸ªåˆ†è§£ï¼›\n\nè‹¥ $x$ ä¸ºåˆæ•°ï¼Œè®¾ $p$ æ˜¯ $x$ çš„æœ€å°è´¨å› å­ï¼Œ $(a_0,b_0,c_0)$ æ˜¯ $\\frac{x}{p}$ çš„ä¸€ä¸ªåˆ†è§£ï¼›\n\nåˆ™æ˜¾ç„¶æœ‰$(a_0p,b_0,c_0)$æ’åºåæ˜¯ä¸€ä¸ªä»å°åˆ°å¤§çš„åˆ†è§£ã€‚\n\nè‹¥æ±‚$gcd(x,y)$ï¼Œè®¾$x=a\\times b\\times c$. å‹’ä»¤$p_1=y,r_1=gcd(a,p_1)$â€‹.\n\nå‹’ä»¤$p_2=\\frac{p_1}{r_1}$ï¼Œ$r_2=gcd(b,p_2)$ï¼›$p_3=\\frac{p_2}{r_2}$ï¼Œ$r_3=gcd(c,p_3)$.\n\nåˆ™æœ‰$gcd(x,y)=r_1r_2r_3.$\n\nåŸç†ä¸º$gcd(x,y)=rgcd(x/r,y/r)\\quad iff\\quad r|x,r|y$\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e6 + 1;\nconst int maxn = 5001;\nvector<array<int, 3>> v(INF + 10);\nbool vis[INF + 10];\nint prime[INF + 10];\nvoid euler()\n{\n    v[1] = {1, 1, 1};\n    for (int i = 2; i <= INF; i++)\n    {\n        if (!vis[i])\n        {\n            vis[i] = 1;\n            prime[++prime[0]] = i;\n            v[i] = {1, 1, i};\n        }\n        for (int j = 1; j <= prime[0] && i * prime[j] <= INF; j++)\n        {\n            int k = i * prime[j];\n            vis[k] = 1;\n            v[k] = {v[i][0] * prime[j], v[i][1], v[i][2]};\n            sort(v[k].begin(), v[k].end());\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nint gcds[1010][1010];\nvoid init()\n{\n    gcds[0][0] = 0;\n    for (int i = 1; i <= 1000; i++)\n    {\n        gcds[i][0] = gcds[0][i] = i;\n        for (int j = 1; j <= i; j++)\n        {\n            gcds[i][j] = gcds[j][i] = gcds[j][i % j];\n        }\n    }\n}\nint Gcd(int a, int b)\n{\n    int ret = 1;\n    for (int i = 0, r; i < 3; i++)\n    {\n        if (v[a][i] > 1e3)\n        {\n            if (b % v[a][i])\n                r = 1;\n            else\n                r = v[a][i];\n        }\n        else\n            r = gcds[v[a][i]][b % v[a][i]];\n        b /= r;\n        ret = ret * r;\n    }\n    return ret;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.4 æ‰©å±•æ¬§å‡ é‡Œå¾—å®šç†\n\nå¯æ±‚å‡ºæ–¹ç¨‹$ax+by=gcd(a,b)$çš„ä¸€ç»„ç‰¹è§£ã€‚è¯¥æ–¹ç¨‹é€šè§£ä¸ºï¼š\n$$\n\\left\\{\n\\begin{aligned}\nx=x^{'}+k\\frac{b}{gcd(a,b)}&\\\\\n\\\\&,k\\in Z\\\\\ny=y^{'}-k\\frac{a}{gcd(a,b)}\\\\\n\\end{aligned}\n\\right.\n$$\nå–æœ€å°çš„éè´Ÿè§£ï¼Œ`x=(x%s+s)%s`ã€‚\n\n```cpp\nvoid exgcd(int a, int b, int &x, int &y)\n{\n    if (b == 0)\n    {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.5 ç§¯æ€§å‡½æ•°çº¿æ€§ç­›ï¼ˆæ¬§æ‹‰å‡½æ•°ç­›ï¼‰\n\nå¦‚æœä¸€ä¸ªç§¯æ€§å‡½æ•°èƒ½å¤Ÿæ»¡è¶³ä»¥ä¸‹ä¸‰æ¡æ€§è´¨ï¼š\n\n1. $f(p)å¯O(1)æŸ¥è¯¢$\n2. è‹¥$gcd(n,m)=1$ï¼Œåˆ™$\\varphi(nm)=\\varphi(n)\\varphi(m)$\n3. è‹¥$n\\mid m$,åˆ™$\\varphi(nm)å¯ç§¯æ€§è½¬ç§»$ï¼ˆå³é€’æ¨å…¬å¼åªå«æœ‰ä¹˜æ³•ï¼‰\n\nåˆ™å‡å¯ä½¿ç”¨çº¿æ€§ç­›å®ç°çº¿æ€§æ±‚è§£ã€‚\n\n***ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•°ï¼š***\n\n```cpp\nint prime[maxn];\nbool vis[maxn];//åˆå§‹0ï¼Œæ ‡è®°åˆæ•°\nint phi[maxn];\nvoid euler(int n)\n{\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i])prime[++prime[0]]=i,phi[i]=i-1;\\\\æ€§è´¨1\n        for(int j=1;j<=prime[0]&&i*prime[j]<=n;j++)\n        {\n            vis[i*prime[j]]=true;\\\\ç­›å»åˆæ•°\n            if(i%prime[j]==0)\n            {\n                phi[i*prime[j]]=prime[j]*phi[i];\\\\æ€§è´¨3\n                break;\n            }\n            phi[i*prime[j]]=phi[prime[j]]*phi[i];\\\\æ€§è´¨2\n        }\n    }\n}\n```\n\n***å› æ•°ä¸ªæ•°ç­›ï¼š***\n\n```cpp\nstruct pre\n{\n    int n;\n    vector<int> d;\n    vector<int> num;\n    vector<bool> vis;\n    vector<int> prime;\n    void init(int _n)\n    {\n        n = _n;\n        d.resize(n + 1);\n        num.resize(n + 1);\n        vis.resize(n + 1);\n    }\n    void did()\n    {\n        d[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            if (!vis[i])\n            {\n                prime.push_back(i);\n                d[i] = 2;\n                num[i] = 1;\n            }\n            for (int j = 0; j < prime.size() && i * prime[j] <= n; j++)\n            {\n                vis[i * prime[j]] = 1;\n                if (i % prime[j] == 0)\n                {\n                    num[i * prime[j]] = num[i] + 1;\n                    d[i * prime[j]] = d[i] / (num[i * prime[j]]) * (num[i * prime[j]] + 1);\n                    break;\n                }\n                num[i * prime[j]] = 1;\n                d[i * prime[j]] = d[i] * 2;\n            }\n        }\n    }\n    int qs(int x)\n    {\n        return d[x];\n    }\n};\n```\n\nè‹¥å‡½æ•°$f(n)$æ»¡è¶³$f(1)=1$ä¸”$\\forall x,y\\in N^*,gcd(x,y)=1$éƒ½æœ‰$f(xy)=f(x)f(y)$ï¼Œåˆ™$f(n)$â€‹ä¸ºç§¯æ€§å‡½æ•°ã€‚\n\nç‰¹åˆ«çš„ï¼Œè‹¥$\\forall x,y\\in N^*$éƒ½æœ‰$f(xy)=f(x)f(y)$â€‹â€‹â€‹,åˆ™ç§°ä½œå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚\n\nè‹¥$f(x)$å’Œ$g(x)$å‡ä¸ºç§¯æ€§å‡½æ•°ï¼Œé‚£ä¹ˆä¸‹åˆ—å‡½æ•°ä¹Ÿç§°ä½œç§¯æ€§å‡½æ•°ï¼š\n$$\n\\begin{align}\n&h(x)=f(x^p)\\\\\n&h(x)=f^p(x)\\\\\n&h(x)=f(x)g(x)\\\\\n&h(x)=\\sum_{d\\mid x}f(d)g(\\frac{x}{d})\\\\\n\\end{align}\n$$\nè®¾è´¨å› æ•°åˆ†è§£$x=\\prod_{i=1}^{n}p_i^{k_i}$ï¼Œåˆ™\n\nè‹¥$F(x)$ä¸ºç§¯æ€§å‡½æ•°ï¼Œåˆ™$F(x)=\\prod_{i=1}^{n}f(p_i^k)$\n\nè‹¥$F(x)$ä¸ºå®Œå…¨ç§¯æ€§å‡½æ•°ï¼Œåˆ™$F(x)=\\prod_{i=1}^{n}f(p_i^k)=\\prod_{i=1}^{n}f^k(p_i)$â€‹\n\nï¼ˆå› ä¸ºè´¨æ•°å’Œå…¶è‡ªå·±çš„$gcd$â€‹å¹¶ä¸æ˜¯1è€Œæ˜¯å…¶æœ¬èº«ï¼‰\n\nå¸¸è§ç§¯æ€§å‡½æ•°:\n\n1. æ¬§æ‹‰å‡½æ•°$\\varphi(n)=\\sum_{i=1}^{n}[gcd(i,n)=1]$.\n\n2. é™¤æ•°å‡½æ•°$\\sigma_k(n)=\\sum_{d\\mid n}d^k,k\\in N.$\n\n   ï¼ˆç‰¹åˆ«çš„ï¼Œ$\\sigma_0(n)$åˆè®°ä½œ$d(n)$ï¼Œè¡¨ç¤ºé™¤æ•°çš„ä¸ªæ•°ã€‚$\\sigma_1(n)$åˆè®°ä½œ$\\sigma(n)$â€‹â€‹ï¼Œè¡¨ç¤ºå› æ•°å’Œï¼‰\n\näºŒè€…å‡ä¸ºéå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚\n\n3. è«æ¯”ä¹Œæ–¯å‡½æ•°\n\n$$\n\\begin{align}\\mu(n)=\\left\\{\n\\begin{aligned}\n&\\quad \\ -1\\qquad \\quad \\ \\ iff\\ \\ n\\ is\\ a\\ prime \\\\\n&\\qquad 0\\qquad \\qquad n^{'}\\;mod\\;p1=0\\\\\n&-\\mu(n^{'})\\qquad \\quad otherwise\n\\end{aligned}\n\\right.\n&,n=p_1\\cdot n^{'}\n\\end{align}\n$$\n\n4. æ¬§æ‹‰å‡½æ•°$\\varphi(n)=\\sum_{i=1}^{n}[gcd(i,n)=1]$\n\n   é€šè§£å…¬å¼\n\n$$\n\\varphi(x)=x\\prod_{i=1}^{n}(1-\\frac{1}{p_i})\\,\\,\\,\\,,\\,\\,\\,x=\\prod_{i=1}^{n}p_i^{k_i}\n$$\n   æ€§è´¨\n1. $\\varphi(p)=p-1$\n2. $\\varphi(p^k)=p^{k-1}\\varphi(p)$\n3. è‹¥$gcd(n,m)=1$ï¼Œåˆ™$\\varphi(nm)=\\varphi(n)\\varphi(m)$\n4. è‹¥$n\\mid m$,åˆ™$\\varphi(nm)=n\\varphi(m)$â€‹\n\nä»”ç»†è§‚å¯Ÿä¸éš¾å‘ç°2æ˜¯4çš„å­é›†å…³ç³»ï¼Œæ•…æ€§è´¨1ã€3ã€4ç§°ä½œæ¬§æ‹‰å‡½æ•°ä¸‰æ€§è´¨ï¼Œç®€ç§°æ¬§æ‹‰å‡½æ•°æ€§ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.6 è£´èœ€å®šç†\n\n$$\n\\begin{aligned}\n&è®¾ä¸å…¨ä¸º0çš„æ•´æ•°a,bï¼Œå¯¹äºä»»æ„æ•´æ•°x,yæœ‰\\\\\n\\\\\n&\\qquad gcd(a,b)|(ax+by)\\\\\n\\\\\n&ä¸”ä¸€å®šå­˜åœ¨æ•´æ•°è§£x_0,y_0ä½¿å¾—ä¸‹åˆ—æ–¹ç¨‹æˆç«‹\\\\\n\\\\\n&\\qquad ax_0+by_0=gcd(a,b)\n\\end{aligned}\n$$\n\n\n\nä¸Šè¿°æƒ…å½¢å¯ä»¥æ¨å¹¿åˆ°ä»»æ„å¤šå˜é‡ã€‚\n\n#### 1.7 æ‰©å±•æ¬§æ‹‰å®šç†\n\n$$\na^b\\equiv \n\\left \\{\n\\begin{aligned}\n&a^{b\\ mod\\ \\varphi(m)}\\qquad \\qquad gcd(a,m)=1\\\\\n&a^b \\qquad\\qquad\\qquad\\quad\\ gcd(a,m)\\neq1,b<\\varphi(m)\\\\\n&a^{(b\\ mod\\ \\varphi(m))+\\varphi(m)} \\quad \\ gcd(a,m)\\neq1,b\\geq\\varphi(m)\n\\end{aligned}\n\\right.\\quad (mod\\ m)\n$$\n\n\n\n#### 1.8 ä¹˜æ³•é€†å…ƒ\n\nçº¿æ€§é€†å…ƒï¼š\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod;\nconst int maxn = 6e6 + 9;\nint inv[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a;\n    cin >> a >> mod;\n    inv[1] = 1;\n    cout << 1 << endl;\n    for (int i = 2; i <= a; i++)\n    {\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n        cout << inv[i] << endl;\n    }\n}\n```\n\nå¿«é€Ÿå¹‚é€†å…ƒï¼ˆè´¹é©¬å°å®šç†ï¼‰ï¼š\n$$\nå¯¹äºä»»æ„æ­£æ•´æ•°aï¼Œ\\exists pæ»¡è¶³gcd(a,p)=1,åˆ™å¿…ç„¶æœ‰ä»¥ä¸‹åŒä½™å¼æˆç«‹:\\\\\na^{p-1} \\equiv1\\ (mod \\; n)\n$$\n\n```cpp\nquickpow(a,mod-2);\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.9 ä¸­å›½å‰©ä½™å®šç†\n\nç»™å®š $n$ ç»„éè´Ÿæ•´æ•° $a_i, b_i$ ï¼Œæ±‚è§£å…³äº $x$ çš„æ–¹ç¨‹ç»„çš„æœ€å°éè´Ÿæ•´æ•°è§£ã€‚\n$$\n\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}\n$$\nå¯¹äº $100 \\%$ çš„æ•°æ®ï¼Œ$1 \\le n \\le {10}^5$ï¼Œ$1 \\le b_i,a_i \\le {10}^{12}$ï¼Œä¿è¯æ‰€æœ‰ $a_i$ çš„æœ€å°å…¬å€æ•°ä¸è¶…è¿‡ ${10}^{18}$ã€‚ä¸ä¿è¯$b$ä¸ºè´¨æ•°\n\n**è¯·æ³¨æ„ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­è¿›è¡Œä¹˜æ³•è¿ç®—æ—¶ç»“æœå¯èƒ½æœ‰æº¢å‡ºçš„é£é™©ã€‚**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint quickmul(int a, int b, int mod)\n{\n    while (a < 0)\n        a += mod;\n    while (b < 0)\n        b += mod;\n    if (a < b)\n        swap(a, b);\n    int e = 0;\n    while (b)\n    {\n        if (b & 1)\n            (e += a) %= mod;\n        (a <<= 1) %= mod;\n        b >>= 1;\n    }\n    return e;\n}\nvoid exgcd(int a, int b, int &x, int &y)\n{\n    if (b == 0)\n    {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n}\nconst int maxn = 500001;\nint a[maxn], m[maxn]; // å¯¹må–æ¨¡ä½™æ•°æ˜¯a\nint n;\nint ExCRT()\n{\n    int mod = m[1], ans = a[1];\n    for (int i = 2; i <= n; i++)\n    {\n        int b1 = mod, b2 = m[i], c = __gcd(b1, b2), minus = (a[i] - ans % b2 + b2) % b2;\n        if (minus % c != 0)\n            return -1;\n        b1 /= c, b2 /= c, minus /= c;\n        int x, y;\n        exgcd(b1, b2, x, y);\n        x = quickmul(x, minus, b2);\n        ans += x * mod;\n        mod *= b2;\n        ans = (ans % mod + mod) % mod;\n    }\n    return ans;\n}\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> m[i] >> a[i];\n    }\n    cout << ExCRT() << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.10 ç¦»æ•£å¯¹æ•°\n\n##### 1.10.1 åŸæ ¹\n\næ»¡è¶³$a^n\\equiv 1\\ (mod \\ m),gcd(a,m)=1$çš„æœ€å°æ­£æ•´æ•°$n$å­˜åœ¨ï¼Œç§°$n$ä¸º$a$çš„é˜¶ï¼Œè®°ä½œ$\\delta_m(a)$ã€‚\n\nç»™å®š$m$ï¼Œè‹¥$gcd(g,m)=1$ä¸”$\\delta_m(g)=\\varphi(m)$ï¼Œåˆ™ç§°$g$ä¸º$m$çš„ä¸€ä¸ªåŸæ ¹ï¼ˆå¾ªç¯ç¾¤çš„ç”Ÿæˆå…ƒï¼‰ã€‚\n\nè¯¦ç»†è§$OI-Wiki$\n\n##### 1.10.2 ç¦»æ•£å¯¹æ•°\n\nå®šä¹‰$a^x\\equiv b\\ (mod\\ m)$ï¼Œ$a$ä¸º$m$çš„ä¸€ä¸ªåŸæ ¹æ—¶ï¼Œè®°$x=ind_ab$ï¼Œç§°ä½œ$b$å…³äº$m$çš„ç¦»æ•£å¯¹æ•°ã€‚\n\n##### 1.10.3 ExBSGSç®—æ³•\n\nç»™å®š $a,p,b$ï¼Œæ±‚æ»¡è¶³ $a^xâ‰¡b \\pmod p$ çš„æœ€å°è‡ªç„¶æ•° $x$ ã€‚å¦‚æœæ— è§£ï¼Œè¾“å‡º `No Solution`ï¼Œå¦åˆ™è¾“å‡ºæœ€å°è‡ªç„¶æ•°è§£ã€‚\n\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼Œ$1\\le a,p,bâ‰¤10^9$ æˆ– $a=p=b=0$ã€‚$\\sum \\sqrt p\\le 5\\times 10^6$â€‹ã€‚\n\nåŸç†ï¼šæåˆ°å’ŒBSGSç®—æ³•ä¸€è‡´ï¼Œé€šè¿‡$a \\equiv b \\ (mod\\ c) \\iff a\\times d\\equiv b\\times d\\ (mod\\ c\\times d)$\n\næ¯æ¬¡åœ¨ä¸¤è¾¹é™¤ä»¥ $d=gcd(a,p)$ï¼Œå¾—åˆ°$\\frac{a}{d}\\times a^{x-1}\\equiv\\frac{b}{d}\\ (mod\\ \\frac{p}{d})$\n\né‡å¤æ‰§è¡Œè¯¥è¯­æ®µï¼Œç›´åˆ°$gcd(a,p)=1$ ä¸ºæ­¢ã€‚\n\nç„¶åä¸Š$BSGS$æ ¹å·æš´åŠ›åˆ†æ²»ç®—ï¼Œå¤æ‚åº¦$O(\\sqrt {\\varphi(p)})$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int BSGS(int a, int n, int p, int ad = 1) // ad*(a^x)=n(mod p)\n{\n    unordered_map<int, int> mp;\n    int m = ceil(sqrt(p));\n    int s = 1;\n    for (int i = 0; i < m; i++, s = 1ll * s * a % p)\n        mp[1ll * s * n % p] = i;\n    for (int i = 0, tmp = s, s = ad; i <= m; i++, s = 1ll * s * tmp % p)\n        if (mp.find(s) != mp.end())\n            if (1ll * i * m - mp[s] >= 0)\n                return 1ll * i * m - mp[s];\n    return -1;\n}\ninline int exBSGS(int a, int n, int p)\n{\n    a %= p;\n    n %= p;\n    if (n == 1 || p == 1)\n        return 0;\n    int cnt = 0;\n    int d, ad = 1;\n    while ((d = gcd(a, p)) ^ 1)\n    {\n        if (n % d)\n            return -1;\n        cnt++;\n        n /= d;\n        p /= d;\n        ad = (1ll * ad * a / d) % p;\n        if (ad == n)\n            return cnt;\n    }\n    int ans = BSGS(a, n, p, ad);\n    if (ans == -1)\n        return -1;\n    return ans + cnt;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, p, n;\n    while (cin >> a >> p >> n)\n    {\n        if (!a && !p && !n)\n            break;\n        int ans = exBSGS(a, n, p);\n        if (~ans)\n            cout << ans << \"\\n\";\n        else\n            cout << \"No Solution\" << \"\\n\";\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.11 äºŒæ¬¡å‰©ä½™ï¼ˆå¥‡ç´ æ•°ï¼‰\n\nç»™å‡º $N,p$ï¼Œæ±‚è§£æ–¹ç¨‹ \n\n$$\nx^2 \\equiv N \\pmod{p}\n$$\n\nå¤šç»„æ•°æ®ï¼Œ**ä¸”ä¿è¯ $p$ æ˜¯å¥‡ç´ æ•°ã€‚**\n\nè¾“å‡ºå…± $T$ è¡Œã€‚\n\nå¯¹äºæ¯ä¸€è¡Œè¾“å‡ºï¼Œè‹¥æœ‰è§£ï¼Œåˆ™æŒ‰ $\\bmod ~p$ åé€’å¢çš„é¡ºåºè¾“å‡ºåœ¨ $\\bmod~ p$ æ„ä¹‰ä¸‹çš„å…¨éƒ¨è§£ï¼›è‹¥ä¸¤è§£ç›¸åŒï¼Œåªè¾“å‡ºå…¶ä¸­ä¸€ä¸ªï¼›è‹¥æ— è§£ï¼Œåˆ™è¾“å‡º `Hola!` ã€‚\n\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼Œ$1\\leq T\\leq 10^4,0\\le N, p\\leq 10^9+9$â€‹ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nrandom_device rd;\nmt19937 ran(rd());\nstruct num\n{\n    ll x; // å®éƒ¨\n    ll y; // è™šéƒ¨(å³è™šæ•°å•ä½âˆšwçš„ç³»æ•°)\n};\n\nll t, w, n, p;\n\nnum mul(num a, num b, ll p)\n{ // å¤æ•°ä¹˜æ³•\n    num res;\n    res.x = ((a.x * b.x % p + a.y * b.y % p * w % p) % p + p) % p; // x = a.x*b.x + a.y*b.y*w\n    res.y = ((a.x * b.y % p + a.y * b.x % p) % p + p) % p;         // y = a.x*b.y + a.y*b.x\n    return res;\n}\nll qpow_r(ll a, ll b, ll p)\n{ // å®æ•°å¿«é€Ÿå¹‚\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = res * a % p;\n        a = a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\nll qpow_i(num a, ll b, ll p)\n{ // å¤æ•°å¿«é€Ÿå¹‚\n    num res = {1, 0};\n    while (b)\n    {\n        if (b & 1)\n            res = mul(res, a, p);\n        a = mul(a, a, p);\n        b >>= 1;\n    }\n    return res.x % p; // åªç”¨è¿”å›å®æ•°éƒ¨åˆ†ï¼Œå› ä¸ºè™šæ•°éƒ¨åˆ†æ²¡äº†\n}\nll cipolla(ll n, ll p)\n{\n    n %= p;\n    if (qpow_r(n, (p - 1) / 2, p) == -1 + p)\n        return -1; // æ®æ¬§æ‹‰å‡†åˆ™åˆ¤å®šæ˜¯å¦æœ‰è§£\n    ll a;\n    while (1)\n    { // æ‰¾å‡ºä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„a\n        a = ran() % p;\n        w = (((a * a) % p - n) % p + p) % p; // w = a^2 - nï¼Œè™šæ•°å•ä½çš„å¹³æ–¹\n        if (qpow_r(w, (p - 1) / 2, p) == -1 + p)\n            break;\n    }\n    num x = {a, 1};\n    return qpow_i(x, (p + 1) / 2, p);\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> p;\n        if (!n)\n        {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        ll ans1 = cipolla(n, p), ans2 = -ans1 + p; // å¦ä¸€ä¸ªè§£å°±æ˜¯å…¶ç›¸åæ•°\n        if (ans1 == -1)\n            cout << \"Hola!\\n\";\n        else\n        {\n            if (ans1 > ans2)\n                swap(ans1, ans2);\n            if (ans1 == ans2)\n                cout << ans1 << \"\\n\";\n            else\n                cout << ans1 << \" \" << ans2 << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 1.12 æ•°è®ºåˆ†å—\n\nä»¥æœŸæœ›å¤æ‚åº¦$O(\\sqrt x)$çš„å¤æ‚åº¦æ±‚è§£$F(x)=\\sum_{i=1}^ng(\\lfloor\\frac{x}i\\rfloor)$ã€‚\n\nåˆ†å—ç†è®ºï¼šå¦‚æœ$\\lfloor\\frac{x}{i}\\rfloor=\\lfloor\\frac{x}{j}\\rfloor$ï¼Œåˆ™æœ‰è¯¥å—çš„åˆ†å—åŒºé—´ä¸º$\\large [i,\\lfloor\\frac{x}{\\lfloor\\frac{x}{i}\\rfloor}\\rfloor]$â€‹\n\nåŸç†ï¼š$\\lfloor\\frac{x}{ab}\\rfloor=\\lfloor\\frac{\\lfloor\\frac{x}{a}\\rfloor}{b}\\rfloor$\n\n```cpp\nlong long H(int n) {\n  long long res = 0;  // å‚¨å­˜ç»“æœ\n  int l = 1, r;       // å—å·¦ç«¯ç‚¹ä¸å³ç«¯ç‚¹\n  while (l <= n) {\n    r = n / (n / l);  // è®¡ç®—å½“å‰å—çš„å³ç«¯ç‚¹\n    // ç´¯åŠ è¿™ä¸€å—çš„è´¡çŒ®åˆ°ç»“æœä¸­ã€‚ä¹˜ä¸Š 1LL é˜²æ­¢æº¢å‡º\n    res += 1LL * (r - l + 1) * (n / l);\n    l = r + 1;  // å·¦ç«¯ç‚¹ç§»åˆ°ä¸‹ä¸€å—\n  }\n  return res;\n}\n```\n\nå¦‚æœæ˜¯å‘ä¸Šå–æ•´åˆ†å—$F(x)=\\sum_{i=1}^ng(\\lceil\\frac{x}i\\rceil)$ï¼Œåˆ™æœ‰å¦‚æœ$\\lceil\\frac{x}{i}\\rceil=\\lceil\\frac{x}{j}\\rceil$ï¼Œåˆ™æœ‰è¯¥å—çš„åˆ†å—åŒºé—´ä¸º$\\large [i,\\lceil\\frac{x}{\\lceil\\frac{x-1}{i}\\rceil}\\rceil]$ã€‚æ³¨æ„ç‰¹æ®Šå¤„ç†$i\\ge x$çš„æƒ…å†µï¼Œæ­¤æ—¶åˆ†å—å³ç«¯ç‚¹åˆ†æ¯ä¸º$0$.æ³¨æ„å³è¾¹ç•Œçš„å†™æ³•ã€‚\n\n```cpp\nauto calc = [&](auto self, int x) -> i64\n    {\n        if (mp.count(x))\n            return mp[x];\n        i64 res = 0;\n        int i = 2;\n        while (i <= n)\n        {\n            int invr = (x - 1) / i;\n            int r = n;\n            if (invr != 0)                  // åˆ†å—é˜²0\n                r = min(r, (x - 1) / invr); // æ³¨æ„åˆ†å—å€¼åŸŸä¸è¦è¶…è¿‡ä½ æ±‚å’Œå¼çš„ä¸Šç•Œ\n            res = (res + (r - i + 1) * self(self, (x + i - 1) / i) % mod) % mod;\n            i = r + 1;\n        }\n        res = (res * inv) % mod;\n        res = (res + n * inv % mod) % mod;\n        return mp[x] = res;\n    };\n```\n\n\n\n\n\n### 2. çº¿æ€§ä»£æ•°ç›¸å…³\n\n#### 2.1 çŸ©é˜µå¿«é€Ÿå¹‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nconst int mod = 1e9 + 7;\nusing mint = MInt<mod>;\nvector<vector<mint>> operator*(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n    vector<vector<mint>> c(a.size(), vector<mint>(a.size(), 0));\n    int n = a.size();\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            for (int k = 0; k < n; k++)\n            {\n                c[i][j] += (a[i][k] * b[k][j]);\n            }\n        }\n    }\n    return c;\n}\nvoid solve()\n{\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<vector<mint>> E(n, vector<mint>(n, 0));\n    vector<vector<mint>> A = E;\n    for (int i = 0; i < n; i++)\n        E[i][i] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> A[i][j];\n        }\n    }\n    while (k)\n    {\n        if (k & 1)\n            E = E * A;\n        A = A * A;\n        k >>= 1;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << E[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    // cin >> t;\n    // while (t--)\n    solve();\n}\n```\n\n#### 2.2 çŸ©é˜µæ•°åˆ—é€’æ¨\n\nå¯¹æ•°åˆ—é€’æ¨å¼å­åˆ—çŸ©é˜µæ–¹ç¨‹å°±è¡Œã€‚æœ€è‘—åçš„å°±æ˜¯feibonacciæ•°åˆ—ï¼š\n$$\n\\pmatrix{f_n\\\\f_{n-1}} =\\pmatrix{1\\ 1\\\\1 \\ 0}\\pmatrix{f_{ n-1}\\\\f_{n-2}}\n$$\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.3 çŸ©é˜µæ±‚é€†/é«˜æ–¯æ¶ˆå…ƒ(ä»…å¯æ±‚å”¯ä¸€è§£)\n\næ±‚çŸ©é˜µçš„é€†çŸ©é˜µï¼Œæ— è§£åˆ¤å®šçŸ©é˜µéæ»¡ç§©çŸ©é˜µï¼Œç­‰ä»·äºè§£çº¿æ€§æ–¹ç¨‹ç»„ã€‚ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•å³å¯ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\n#define endl '\\n'\nconst int P = 1e9 + 7;\nint power(int a, int b, int mod)\n{\n    int res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = (1ll * res * a) % mod;\n        a = (1ll * a * a) % mod;\n        b >>= 1;\n    }\n    return res % mod;\n}\nstd::vector<int> gauss(std::vector<std::vector<int>> a, std::vector<int> b)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (a[r][i] == 0)\n            ++r;\n        std::swap(a[i], a[r]);\n        std::swap(b[i], b[r]);\n        int inv = power(a[i][i], P - 2, P);\n        for (int j = i; j < n; ++j)\n            a[i][j] = 1ll * a[i][j] * inv % P;\n        b[i] = 1ll * b[i] * inv % P;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            int x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] = (a[j][k] + 1ll * (P - x) * a[i][k]) % P;\n            b[j] = (b[j] + 1ll * (P - x) * b[i]) % P;\n        }\n    }\n    return b;\n}\n/**   é«˜æ–¯æ¶ˆå…ƒæ³•ï¼ˆgaussian eliminationï¼‰ã€ä¹…è¿œã€‘\n *    2020-12-02: https://www.codechef.com/viewsolution/39942900\n **/\nstd::vector<double> gauss(std::vector<std::vector<double>> a, std::vector<double> b, int &rank)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (r < n && a[r][i] == 0)\n            ++r;\n        if (r == n)\n            return b;\n        std::swap(a[i], a[r]);\n        std::swap(b[i], b[r]);\n        double x = a[i][i];\n        rank++;\n        for (int j = i; j < n; ++j)\n            a[i][j] /= x;\n        b[i] /= x;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] -= a[i][k] * x;\n            b[j] -= b[i] * x;\n        }\n    }\n    return b;\n}\nvector<vector<int>> invmatrix(vector<vector<int>> a, vector<vector<int>> b, int &rank)\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n    {\n        int r = i;\n        while (r < n && a[r][i] == 0)\n            ++r;\n        if (r == n)\n            break;\n        rank++;\n        swap(a[i], a[r]);\n        swap(b[i], b[r]);\n        int inv = power(a[i][i], P - 2, P);\n        for (int j = i; j < n; ++j)\n            a[i][j] = 1ll * a[i][j] * inv % P;\n        for (int k = 0; k < n; k++)\n            b[i][k] = 1ll * b[i][k] * inv % P;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i == j)\n                continue;\n            int x = a[j][i];\n            for (int k = i; k < n; ++k)\n                a[j][k] = (a[j][k] + 1ll * (P - x) * a[i][k]) % P;\n            for (int k = 0; k < n; k++)\n                b[j][k] = (b[j][k] + 1ll * (P - x) * b[i][k]) % P;\n        }\n    }\n    return b;\n}\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    vector<vector<int>> E(n, vector<int>(n));\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> a[i][j];\n            if (i == j)\n                E[i][j] = 1;\n        }\n    }\n    vector<vector<int>> A;\n    int rk = 0;\n    A = invmatrix(a, E, rk);\n    if (rk != n)\n    {\n        cout << \"No Solution\" << endl;\n        return;\n    }\n\n    for (auto &i : A)\n    {\n        for (auto &j : i)\n        {\n            cout << j << \" \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    // int t;\n    // cin >> t;\n    // while (t--)\n    solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.4 çº¿æ€§åŸº\n\nä¸éš¾å‘ç°ï¼ŒæŒ‰ä½Bitwise Xorè¿ç®—æ˜¯ä¸€ä¸ªé’ˆå¯¹MOD2å‰©ä½™ç³»å‘é‡ç©ºé—´åŠ æ³•è¿ç®—ï¼Œæ•…å­˜åœ¨ä»£æ•°çº¿æ€§åŸºã€‚\n\nçº¿æ€§ç©ºé—´$<Z_2^n,bitwise\\ Xor,bitwise\\ And>$ä¸ºåŸŸç©ºé—´ã€‚\n\næˆ‘ä»¬å¯ä»¥åˆ©ç”¨å¼‚æˆ–çº¿æ€§åŸºå®ç°ï¼š\n\n1. åˆ¤æ–­ä¸€ä¸ªæ•°èƒ½å¦è¡¨ç¤ºæˆæŸæ•°é›†å­é›†çš„å¼‚æˆ–å’Œï¼ˆå·²æœ‰é›†åˆå…ƒç´ æ˜¯å¦èƒ½å¤Ÿæ„é€ å‡º0ï¼‰ï¼›\n\n2. æ±‚ä¸€ä¸ªæ•°è¡¨ç¤ºæˆæŸæ•°é›†å­é›†å¼‚æˆ–å’Œçš„æ–¹æ¡ˆæ•°ï¼›\n\n3. æ±‚æŸæ•°é›†å­é›†çš„æœ€å¤§/æœ€å°/ç¬¬$k$å¤§/ç¬¬$k$â€‹å°å¼‚æˆ–å’Œï¼›\n\n   å¦‚æœè¯´ï¼Œçº¿æ€§åŸºä¸­å¼‚æˆ–çš„æœ€å¤§æ•°ï¼ˆçš„äºŒè¿›åˆ¶å½¢å¼ï¼‰æ˜¯ä¸€ä¸² **è¿ç»­çš„ï¼Œæ²¡æœ‰å¸¦åç»­$0$** çš„$1$ï¼Œé‚£ç›¸ä¿¡èªæ˜çš„ä½ ä¸€å®šä¼šæ±‚ç¬¬$k$å¤§ï¼Œå› ä¸ºç¬¬$k$å¤§å…¶å®å°±æ˜¯$k$ã€‚\n\n   ç°åœ¨ç›¸å½“äºå‘Šè¯‰ä½ åœ¨è¿™ä¸€ä¸²$1$ä¸­å¤¹äº†å¾ˆå¤š$0$ï¼Œé—®ä½ ç¬¬$k$å¤§æ˜¯å¤šå°‘ã€‚é‚£ä¹ˆä½ å…¶å®å¯ä»¥ä¸ç”¨ç®¡ä¸­é—´çš„$0$ï¼ŒæŠŠ$k$çš„äºŒè¿›åˆ¶å½¢å¼å¼„å‡ºæ¥ï¼Œç„¶åæŠŠä¸­é—´çœç•¥$0$ç»™æ’å›å»å°±å¥½äº†ã€‚ï¼ˆå› ä¸ºæœ€å¤§å€¼ä½æ˜¯$0$çš„åœ°æ–¹ä¸€è¾ˆå­ä¸å¯èƒ½å‡º$1$ï¼‰\n   è§£é‡Šä¸€ä¸‹å°±ç›¸å½“äºæŠŠçº¿æ€§åŸºå¼‚æˆ–åå‡ºæ¥çš„æœ€å¤§å€¼é‡Œçš„æ‰€æœ‰$1$éƒ½ç»™æŒ¤åˆ°æœ€åï¼Œç„¶åæ±‚å‡ºç¬¬$k$å¤§ï¼Œå†æŠŠä½ å¼„èµ°çš„0ç»™ä¸¢å›å»ã€‚\n\n   $eg:$å¼‚æˆ–åæœ€å¤§å€¼ä¸º$101100110_2$ï¼Œé—®ç¬¬$20$å¤§\n\n   æŒ¤åˆ°åé¢å»åæˆ$11111_2$ï¼Œç¬¬$k$å¤§æ˜¯$10100_2$ï¼ŒæŠŠ$0$æ’å›å»æˆä¸º$100100000_2$ï¼Œç¬¬20å¤§ä¾¿æ˜¯$100100000_2$\n\n4. æ±‚ä¸€ä¸ªæ•°åœ¨æŸæ•°é›†å­é›†å¼‚æˆ–å’Œä¸­çš„æ’åã€‚\n\nçº¿æ€§åŸºçš„ç‹¬ç«‹æ€§å†³å®šäº†ä¸€ç»„å¼‚æˆ–ä¸º0çš„æ•°æ— è®ºä»¥ä»€ä¹ˆé¡ºåºæ’å…¥æœ€ç»ˆçº¿æ€§åŸºéƒ½ä¸ä¼šå…è®¸è¿™nä¸ªæ•°åŒæ—¶æ’å…¥çº¿æ€§åŸºä¸­ï¼Œæ‰€ä»¥å’Œçº¿æ€§åŸºç›¸å…³çš„è´ªå¿ƒç›´æ¥å¯¹æƒå€¼æ’åºåæŒ‰é¡ºåºæ’å…¥çº¿æ€§åŸºå°±å¯ä»¥äº†ã€‚\n\næ³¨æ„ï¼Œçº¿æ€§åŸºçš„æ’å…¥æ˜¯å¯é‡å¤è´¡çŒ®çš„ï¼Œæ‰€ä»¥æ”¯æŒæ ‘ä¸Šå€å¢$RMQ$ï¼Œæ€æƒ³å‚è€ƒæ ‘ä¸Šå€å¢lcaæŸ¥è¯¢å’Œåºåˆ—åŒºé—´æœ€å¤§å€¼æŸ¥è¯¢ã€‚çº¿æ€§åŸºçš„æå¤§æ— å…³æ€§ä¿è¯ä»»æ„ä¸€ç»„çº¿æ€§åŸºæœ€å¤šæ˜¯$logn$â€‹çº§åˆ«çš„ï¼Œæ”¯æŒæš´åŠ›åˆå¹¶ã€‚å¯ä»¥å€ŸåŠ©æ ‘ä¸Šå€å¢å®ç°æ ‘ä¸ŠæŸ¥è¯¢é—®é¢˜ã€‚\n\næ±‚$x\\rightarrow y$è·¯å¾„ä¸Šçš„æœ€å¤§å¼‚æˆ–å’Œï¼Œåªéœ€è¦å››æ®µå½©è‰²å¼§çº¿æ®µæ‰€ä»£è¡¨çš„å€å¢çº¿æ€§åŸºåˆå¹¶å³å¯ï¼Œè¿™æ˜¯$O(log^2n)$çš„å•æ¬¡è¯¢é—®ã€‚æ±‚$lca$æ–¹å¼çš„å€å¢è·³æ˜¯$O(log^3n)$çš„ã€‚\n\n![image-20241030231917971](C:\\Users\\æ ¾æ´¥\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241030231917971.png)\n\n```cpp\nstruct LineBase\n{\nprivate:\n    const static int MN = 62;\n    i64 a[MN + 1], tmp[MN + 1];\n    bool flag; // çº¿æ€§åŸºä¸­æ˜¯å¦æœ‰é‡å¤æ’å…¥çš„å…ƒç´ \n\npublic:\n    void insert(i64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                {\n                    a[i] = x;\n                    return;\n                }\n                else\n                    x ^= a[i];\n        flag = true;\n    }\n    bool check(i64 x) // æŸ¥çœ‹å½“å‰çº¿æ€§åŸºä¸­èƒ½å¦è¡¨ç¤ºå‡ºæ¥è¿™ä¸ªæ•°(æ˜¯å¦å·²æ’å…¥)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                    return false;\n                else\n                    x ^= a[i];\n        return true;\n    }\n    i64 qmax(i64 res = 0)\n    {\n        for (int i = MN; ~i; i--)\n            res = max(res, res ^ a[i]);\n        return res;\n    }\n    i64 qmin()\n    {\n        if (flag) // çº¿æ€§åŸºæœ‰è¯•å›¾æ’å…¥è¿‡ç›¸åŒçš„æ•°ï¼Œæœ€å°å€¼ä¸º0\n            return 0;\n        for (int i = 0; i <= MN; i++)\n            if (a[i])\n                return a[i];\n    }\n    i64 query(i64 k) // çº¿æ€§åŸºä¸‹ç¬¬kå°\n    {\n        i64 res = 0;\n        int cnt = 0;\n        k -= flag; // çº¿æ€§åŸºæœ‰è¯•å›¾æ’å…¥è¿‡ç›¸åŒçš„æ•°ï¼Œæœ€å°å€¼ä¸º0\n        if (!k)\n            return 0;\n        for (int i = 0; i <= MN; i++)\n        {\n            for (int j = i - 1; ~j; j--)\n                if (a[i] & (1ll << j))\n                    a[i] ^= a[j];\n            if (a[i])\n                tmp[cnt++] = a[i];\n        } // çº¿æ€§åŸºé‡æ„\n        if (k >= (1ll << cnt))\n            return -1;\n        for (int i = 0; i < cnt; i++)\n            if (k & (1ll << i))\n                res ^= tmp[i];\n        return res;\n    }\n};\nLineBase lb;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\næ ‘ä¸Šå€å¢æŸ¥è¯¢è·¯å¾„max\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nusing u64 = unsigned long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nstruct LineBase\n{\nprivate:\n    const static int MN = 60;\n    array<u64, MN + 1> a;\n    bool flag;\n    friend LineBase merge(LineBase a, LineBase b);\n\npublic:\n    LineBase()\n    {\n        a.fill(0);\n    }\n    void ins(u64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                {\n                    a[i] = x;\n                    return;\n                }\n                else\n                    x ^= a[i];\n        flag = true;\n    }\n    bool check(u64 x)\n    {\n        for (int i = MN; ~i; i--)\n            if (x & (1ll << i))\n                if (!a[i])\n                    return false;\n                else\n                    x ^= a[i];\n        return true;\n    }\n    u64 qmax(u64 res = 0)\n    {\n        for (int i = MN; ~i; i--)\n            res = max(res, res ^ a[i]);\n        return res;\n    }\n    u64 qmin()\n    {\n        if (flag)\n            return 0;\n        for (int i = 0; i <= MN; i++)\n            if (a[i])\n                return a[i];\n    }\n\n    void merge(LineBase b)\n    {\n        for (int i = 0; i < b.MN; i++)\n        {\n            this->ins(b.a[i]);\n        }\n    }\n};\nLineBase merge(LineBase a, LineBase b)\n{\n    LineBase c = a;\n    for (int i = 0; i < b.MN; i++)\n    {\n        c.ins(b.a[i]);\n    }\n    return c;\n}\nstruct node\n{\n    int fa;\n    LineBase lb;\n};\nconst int maxn = 2e4 + 9;\nnode st[maxn][16];\nvector<int> con[maxn];\nvector<int> dep;\nvector<u64> num;\nvoid add_edge(int u, int v)\n{\n    con[u].push_back(v);\n    con[v].push_back(u);\n}\nvoid dfs(int u, int fa)\n{\n    st[u][0].fa = fa;\n    dep[u] = dep[fa] + 1;\n    st[u][0].lb.ins(num[u]);\n    st[u][0].lb.ins(num[fa]);\n    for (int j = 1; j <= 15; j++)\n    {\n        st[u][j].fa = st[st[u][j - 1].fa][j - 1].fa;\n        st[u][j].lb = merge(st[u][j - 1].lb, st[st[u][j - 1].fa][j - 1].lb);\n    }\n    for (auto v : con[u])\n    {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n    }\n    return;\n}\npair<int, LineBase> lca(int u, int v)\n{\n    if (dep[u] < dep[v])\n        swap(u, v);\n    int tmp = dep[u] - dep[v];\n    LineBase ans;\n    ans.ins(num[u]), ans.ins(num[v]);\n    for (int j = 0; j <= 15; j++)\n    {\n        if ((tmp >> j) & 1)\n            ans.merge(st[u][j].lb), u = st[u][j].fa;\n    }\n    if (u == v)\n        return {u, ans};\n    for (int j = 15; j >= 0; j--)\n    {\n        if (st[u][j].fa != st[v][j].fa)\n        {\n            ans.merge(st[u][j].lb);\n            ans.merge(st[v][j].lb);\n            u = st[u][j].fa, v = st[v][j].fa;\n        }\n    }\n    ans.merge(st[u][0].lb);\n    ans.merge(st[v][0].lb);\n    return {st[u][0].fa, ans};\n}\n\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    num.assign(n + 1, 0);\n    dep.assign(n + 1, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> num[i];\n    }\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    dfs(1, 1);\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v).second.qmax() << endl;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.5 äºŒè¿›åˆ¶çŸ©é˜µç±»Matrix.h\n\nè¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªåä¸º `matrix_Z2_base` çš„æ¨¡æ¿ç±»ï¼Œå®ƒç”¨äºè¡¨ç¤ºå’Œæ“ä½œ$<Z_2^n,xor,and>$çº¿æ€§ç©ºé—´çš„çŸ©é˜µã€‚å…ƒç´ åªæœ‰0å’Œ1ï¼Œè¿ç®—åœ¨$mod2$æ•°åŸŸä¸‹ã€‚\n\n1. **æ„é€ å‡½æ•°**ï¼š\n   \n   - `matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false)`ï¼šåˆ›å»ºä¸€ä¸ªå¤§å°ä¸º nÃ—m çš„çŸ©é˜µï¼Œå…¶ä¸­ `n` æ˜¯è¡Œæ•°ï¼Œ`m` æ˜¯åˆ—æ•°ã€‚`init_diagonal` å’Œ `init_off_diagonal` å‚æ•°ç”¨äºåˆå§‹åŒ–å¯¹è§’çº¿å’Œéå¯¹è§’çº¿å…ƒç´ ã€‚å¦‚æœ `init_diagonal` ä¸º `true`ï¼Œåˆ™å¯¹è§’çº¿å…ƒç´ è¢«åˆå§‹åŒ–ä¸º 1ï¼Œå¦åˆ™ä¸º 0ã€‚éå¯¹è§’çº¿å…ƒç´ çš„åˆå§‹åŒ–ç”± `init_off_diagonal` æ§åˆ¶ã€‚\n   \n2. **è®¿é—®æ“ä½œç¬¦**ï¼š\n   - `std::bitset<SZ> &operator[](int i)`ï¼šè¿”å›ç¬¬ `i` è¡Œçš„å¼•ç”¨ã€‚\n   - `const std::bitset<SZ> &operator[](int i) const`ï¼šè¿”å›ç¬¬ `i` è¡Œçš„å¸¸é‡å¼•ç”¨ã€‚\n\n3. **åˆ‡ç‰‡æ“ä½œ**ï¼š\n   - `matrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr)`ï¼šåœ¨åŸåœ°ä¿®æ”¹çŸ©é˜µï¼Œè¿”å›å·¦ä¸Šè§’ä¸º `(il, jl)`ï¼Œå³ä¸‹è§’ä¸º `(ir, jr)` çš„å­çŸ©é˜µã€‚\n   - `matrix_Z2_base slice(int il, int ir, int jl, int jr) const`ï¼šè¿”å›å·¦ä¸Šè§’ä¸º `(il, jl)`ï¼Œå³ä¸‹è§’ä¸º `(ir, jr)` çš„å­çŸ©é˜µçš„å‰¯æœ¬ã€‚\n\n4. **è¡Œåˆ‡ç‰‡å’Œåˆ—åˆ‡ç‰‡**ï¼š\n   - `matrix_Z2_base &inplace_row_slice(int il, int ir)`ï¼šåœ¨åŸåœ°ä¿®æ”¹çŸ©é˜µï¼Œè¿”å›è¡Œåˆ‡ç‰‡å­çŸ©é˜µã€‚\n   - `matrix_Z2_base row_slice(int il, int ir) const`ï¼šè¿”å›è¡Œåˆ‡ç‰‡å­çŸ©é˜µçš„å‰¯æœ¬ã€‚\n   - `matrix_Z2_base &inplace_column_slice(int jl, int jr)`ï¼šåœ¨åŸåœ°ä¿®æ”¹çŸ©é˜µï¼Œè¿”å›åˆ—åˆ‡ç‰‡å­çŸ©é˜µã€‚\n   - `matrix_Z2_base column_slice(int jl, int jr) const`ï¼šè¿”å›åˆ—åˆ‡ç‰‡å­çŸ©é˜µçš„å‰¯æœ¬ã€‚\n\n5. **æ¯”è¾ƒæ“ä½œç¬¦**ï¼š\n   - `bool operator==(const matrix_Z2_base &a) const`ï¼šæ¯”è¾ƒä¸¤ä¸ªçŸ©é˜µæ˜¯å¦ç›¸ç­‰ã€‚\n   - `bool operator!=(const matrix_Z2_base &a) const`ï¼šæ¯”è¾ƒä¸¤ä¸ªçŸ©é˜µæ˜¯å¦ä¸ç›¸ç­‰ã€‚\n\n6. **çŸ©é˜µåŠ æ³•å’Œå‡æ³•**ï¼š\n   - `matrix_Z2_base &operator+=(const matrix_Z2_base &M)`ï¼šåŸåœ°çŸ©é˜µåŠ æ³•ã€‚\n   - `matrix_Z2_base operator+(const matrix_Z2_base &M) const`ï¼šè¿”å›ä¸¤ä¸ªçŸ©é˜µç›¸åŠ çš„ç»“æœã€‚\n   - `matrix_Z2_base &operator-=(const matrix_Z2_base &M)`ï¼šåŸåœ°çŸ©é˜µå‡æ³•ã€‚\n   - `matrix_Z2_base operator-(const matrix_Z2_base &M) const`ï¼šè¿”å›ä¸¤ä¸ªçŸ©é˜µç›¸å‡çš„ç»“æœã€‚\n\n7. **çŸ©é˜µä¹˜æ³•**ï¼š\n   - `matrix_Z2_base &operator*=(const matrix_Z2_base &a)`ï¼šåŸåœ°çŸ©é˜µä¹˜æ³•ã€‚\n   - `matrix_Z2_base operator*(const matrix_Z2_base &a) const`ï¼šè¿”å›ä¸¤ä¸ªçŸ©é˜µç›¸ä¹˜çš„ç»“æœã€‚\n\n8. **çŸ©é˜µä¹˜ä»¥å¸¸æ•°**ï¼š\n   - `matrix_Z2_base &operator*=(bool c)`ï¼šå°†çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ ä¹˜ä»¥å¸ƒå°”å¸¸æ•° `c`ã€‚\n   - `matrix_Z2_base operator*(bool c) const`ï¼šè¿”å›ä¹˜ä»¥å¸¸æ•°åçš„çŸ©é˜µã€‚\n\n9. **çŸ©é˜µä¹˜æ–¹**ï¼š\n   - `matrix_Z2_base &inplace_power(T e)`ï¼šåŸåœ°è®¡ç®—çŸ©é˜µçš„ `e` æ¬¡å¹‚ã€‚\n   - `matrix_Z2_base power(T e) const`ï¼šè¿”å›çŸ©é˜µçš„ `e` æ¬¡å¹‚ã€‚\n\n10. **çŸ©é˜µè½¬ç½®**ï¼š\n    - `matrix_Z2_base &inplace_transpose()`ï¼šåŸåœ°è½¬ç½®çŸ©é˜µã€‚\n    - `matrix_Z2_base transpose() const`ï¼šè¿”å›çŸ©é˜µçš„è½¬ç½®ã€‚\n\n11. **çŸ©é˜µä¹˜ä»¥è¡Œå‘é‡**ï¼š\n    - `std::vector<int> operator*(const std::bitset<SZ> &v) const`ï¼šå°†çŸ©é˜µä¹˜ä»¥è¡Œå‘é‡ `v`ã€‚\n\n12. **è¡Œé˜¶æ¢¯å½¢å¼å’Œè¡Œåˆ—å¼ã€ç§©**ï¼š\n    - `tuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1)`ï¼šåŸåœ°è®¡ç®—çŸ©é˜µçš„è¡Œé˜¶æ¢¯å½¢å¼ï¼Œå¹¶è¿”å›è¡Œåˆ—å¼å’Œç§©ã€‚\n    - `tuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const`ï¼šè¿”å›çŸ©é˜µçš„è¡Œé˜¶æ¢¯å½¢å¼ï¼Œå¹¶è¿”å›è¡Œåˆ—å¼å’Œç§©ã€‚\n\n13. **çŸ©é˜µé€†**ï¼š\n    - `optional<matrix_Z2_base> inverse() const`ï¼šè¿”å›çŸ©é˜µçš„é€†ï¼Œå¦‚æœçŸ©é˜µä¸å¯é€†ï¼Œåˆ™è¿”å›ç©ºã€‚\n\n14. **è¡Œåˆ—å¼**ï¼š\n    - `bool determinant() const`ï¼šè¿”å›çŸ©é˜µçš„è¡Œåˆ—å¼æ˜¯å¦ä¸º 1ã€‚\n\n15. **ç§©**ï¼š\n    - `int rank() const`ï¼šè¿”å›çŸ©é˜µçš„ç§©ã€‚\n\n16. **çº¿æ€§æ–¹ç¨‹ç»„çš„è§£**ï¼š\n    - `optional<std::bitset<SZ>> find_a_solution() const`ï¼šè¿”å›çŸ©é˜µæ‰€ä»£è¡¨çš„çº¿æ€§æ–¹ç¨‹ç»„çš„ä¸€ä¸ªè§£ã€‚\n\n      è§£å¤šè§£$n$å…ƒ$n$å¼çº¿æ€§æ–¹ç¨‹ç»„ç¤ºä¾‹ï¼š\n    \n      ```cpp\n      for (auto s = 0; s < n; ++s)\n      {\n          matrix_Z2 M(n + 1, n + 1);//ç¬¬nè¡Œè¡¨ç¤ºä¸»å…ƒéƒ½æœ‰è°ï¼Œç¬¬nåˆ—æ˜¯æ–¹ç¨‹å¢å¹¿åˆ—ï¼Œè¡¨ç¤ºå„çº¿æ€§æ–¹ç¨‹ç»“æœã€‚\n          for (auto u = 0; u < n; ++u)\n          {\n              for (auto v = 0; v < n; ++v)\n              {\n                  if (adjm[u] >> v & 1)\n                  {\n                      M[v][u] = 1;//åŸé¢˜æ˜¯ä¸ªå›¾è®ºï¼Œæ ¹æ®è¾¹åˆ—çš„çŸ©é˜µæ–¹ç¨‹\n                  }\n              }\n              M[n][u] = u == s;//æ ‡è®°ä¸»å…ƒï¼Œè¡¨ç¤ºç¬¬sä¸ªå…ƒç´ çš„è§£å¿…é¡»æ˜¯1ï¼Œç»™å‡ºæ¥çš„å¤šç»„è§£å¿…å®šçº¿æ€§æ— å…³\n          }\n          M[n][n] = 1;\n          if (auto resptr = M.find_a_solution())\n          {\n              auto pick = *resptr;\n              for (auto u = 0; u < n; ++u)\n              {\n                  if (pick[u])\n                  {\n                      res[u] |= 1LL << s;\n                  }\n              }\n          }\n          else\n          {\n              cout << \"No\\n\";\n              return 0;\n          }\n      }\n      ```\n    \n      \n    \n17. **è¾“å‡ºæ“ä½œç¬¦**ï¼š\n    \n    - `friend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a)`ï¼šè¾“å‡ºçŸ©é˜µåˆ°æµã€‚\n    \n18. **çŸ©é˜µä¹˜ä»¥å¸¸æ•°ï¼ˆå¤–éƒ¨ï¼‰**ï¼š\n    - `matrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M)`ï¼šè¿”å›ä¹˜ä»¥å¸¸æ•°åçš„çŸ©é˜µã€‚\n\n19. **è¡Œå‘é‡ä¹˜ä»¥çŸ©é˜µ**ï¼š\n    - `std::bitset<SZ> operator*(const std::vector<int> &v, const matrix_Z2_base<SZ> &a)`ï¼šå°†è¡Œå‘é‡ `v` ä¹˜ä»¥çŸ©é˜µ `a`ã€‚\n\n```cpp\n#ifndef __MATRIX_H__\n#define __MATRIX_H__\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n *@brief äºŒè¿›åˆ¶çŸ©é˜µç±»\n *@note è¯¥ç±»æ”¯æŒçŸ©é˜µçš„åŠ å‡ä¹˜ï¼Œæ±‚é€†ï¼Œæ±‚è¡Œåˆ—å¼ï¼Œæ±‚ç§©ï¼Œæ±‚è¡Œé˜¶æ¢¯å½¢å¼ï¼Œæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ç­‰æ“ä½œ\n *@tparam SZ çŸ©é˜µåˆ—å‘é‡çš„ä½æ•°ï¼Œå³çŸ©é˜µçš„åˆ—æ•°ï¼Œç”¨äºåˆå§‹åŒ–bitsetçš„ä½æ•°\n */\ntemplate <size_t SZ>\nstruct matrix_Z2_base\n{\n    int n, m;\n    std::vector<std::bitset<SZ>> data;\n    std::bitset<SZ> &operator[](int i)\n    {\n        assert(0 <= i && i < n);\n        return data[i];\n    }\n    const std::bitset<SZ> &operator[](int i) const\n    {\n        assert(0 <= i && i < n);\n        return data[i];\n    }\n    matrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr)\n    {\n        assert(0 <= il && il <= ir && ir <= n);\n        assert(0 <= jl && jl <= jr && jr <= m);\n        n = ir - il, m = jr - jl;\n        if (il > 0)\n            for (auto i = 0; i < n; ++i)\n                swap(data[i], data[il + i]);\n        data.resize(n);\n        for (auto &row : data)\n            row = row << SZ - jr >> jl;\n        return *this;\n    }\n    /*\n     *@brief è¿”å›ä¸€ä¸ªå­çŸ©é˜µ\n     *@param il å·¦ä¸Šè§’è¡Œåæ ‡\n     *@param ir å³ä¸‹è§’è¡Œåæ ‡\n     *@param jl å·¦ä¸Šè§’åˆ—åæ ‡\n     *@param jr å³ä¸‹è§’åˆ—åæ ‡\n     *@return è¿”å›ä¸€ä¸ªå­çŸ©é˜µ\n     */\n    matrix_Z2_base slice(int il, int ir, int jl, int jr) const\n    {\n        return matrix_Z2_base(*this).inplace_slice(il, ir, jl, jr);\n    }\n    matrix_Z2_base &inplace_row_slice(int il, int ir)\n    {\n        assert(0 <= il && il <= ir && ir <= n);\n        n = ir - il;\n        if (il > 0)\n            for (auto i = 0; i < n; ++i)\n                swap(data[i], data[il + i]);\n        data.resize(n);\n        return *this;\n    }\n    /*\n     *@brief è¿”å›ä¸€ä¸ªè¡Œåˆ‡ç‰‡å­çŸ©é˜µ\n     *@param il å·¦ä¸Šè§’è¡Œåæ ‡\n     *@param ir å³ä¸‹è§’è¡Œåæ ‡\n     *@return è¿”å›ä¸€ä¸ªè¡Œåˆ‡ç‰‡å­çŸ©é˜µ\n     */\n    matrix_Z2_base row_slice(int il, int ir) const\n    {\n        return matrix_Z2_base(*this).inplace_row_slice(il, ir);\n    }\n    matrix_Z2_base &inplace_column_slice(int jl, int jr)\n    {\n        assert(0 <= jl && jl <= jr && jr <= m);\n        m = jr - jl;\n        for (auto &row : data)\n            row = row << SZ - jr >> jl;\n        return *this;\n    }\n    /*\n     *@brief è¿”å›ä¸€ä¸ªåˆ—åˆ‡ç‰‡å­çŸ©é˜µ\n     *@param jl å·¦ä¸Šè§’åˆ—åæ ‡\n     *@param jr å³ä¸‹è§’åˆ—åæ ‡\n     *@return è¿”å›ä¸€ä¸ªåˆ—åˆ‡ç‰‡å­çŸ©é˜µ\n     */\n    matrix_Z2_base column_slice(int jl, int jr) const\n    {\n        return matrix_Z2_base(*this).inplace_column_slice(jl, jr);\n    }\n    // çŸ©é˜µç›¸ç­‰\n    bool operator==(const matrix_Z2_base &a) const\n    {\n        assert(n == a.n && m == a.m);\n        return data == a.data;\n    }\n    // çŸ©é˜µä¸ç­‰\n    bool operator!=(const matrix_Z2_base &a) const\n    {\n        assert(n == a.n && m == a.m);\n        return data != a.data;\n    }\n    // çŸ©é˜µç›¸åŠ \n    matrix_Z2_base &operator+=(const matrix_Z2_base &M)\n    {\n        assert(n == M.n && m == M.m);\n        for (auto i = 0; i < n; ++i)\n            data[i] ^= M[i];\n        return *this;\n    }\n    // çŸ©é˜µç›¸åŠ \n    matrix_Z2_base operator+(const matrix_Z2_base &M) const\n    {\n        return matrix_Z2_base(*this) += M;\n    }\n    // çŸ©é˜µç›¸å‡\n    matrix_Z2_base &operator-=(const matrix_Z2_base &M)\n    {\n        assert(n == M.n && m == M.m);\n        for (auto i = 0; i < n; ++i)\n            data[i] ^= M[i];\n        return *this;\n    }\n    // çŸ©é˜µç›¸å‡\n    matrix_Z2_base operator-(const matrix_Z2_base &M) const\n    {\n        return matrix_Z2_base(*this) -= M;\n    }\n    // çŸ©é˜µç›¸ä¹˜\n    matrix_Z2_base &operator*=(const matrix_Z2_base &a)\n    {\n        assert(m == a.n);\n        int l = a.m;\n        matrix_Z2_base res(n, l);\n        std::vector<std::bitset<SZ>> temp(l);\n        for (auto i = 0; i < l; ++i)\n            for (auto j = 0; j < m; ++j)\n                temp[i][j] = a[j][i];\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < l; ++j)\n                res[i][j] = (data[i] & temp[j]).count() & 1;\n        return *this = res;\n    }\n    // çŸ©é˜µç›¸ä¹˜\n    matrix_Z2_base operator*(const matrix_Z2_base &a) const\n    {\n        return matrix_Z2_base(*this) *= a;\n    }\n    // çŸ©é˜µä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°\n    matrix_Z2_base &operator*=(bool c)\n    {\n        if (!c)\n            for (auto &v : *this)\n                v.reset();\n        return *this;\n    }\n    // çŸ©é˜µä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°\n    matrix_Z2_base operator*(bool c) const\n    {\n        return matrix_Z2_base(*this) *= c;\n    }\n    // çŸ©é˜µä¹˜æ–¹\n    template <class T, typename enable_if<is_integral<T>::value>::type * = nullptr>\n    matrix_Z2_base &inplace_power(T e)\n    {\n        assert(n == m);\n        matrix_Z2_base res(n, n, true);\n        for (; e; *this *= *this, e >>= 1)\n            if (e & 1)\n                res *= *this;\n        return *this = res;\n    }\n    // çŸ©é˜µä¹˜æ–¹\n    template <class T>\n    matrix_Z2_base power(T e) const\n    {\n        return matrix_Z2_base(*this).inplace_power(e);\n    }\n    // çŸ©é˜µè½¬ç½®\n    matrix_Z2_base &inplace_transpose()\n    {\n        assert(n == m);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = i + 1; j < n; ++j)\n                swap(data[i][j], data[j][i]);\n        return *this;\n    }\n    // çŸ©é˜µè½¬ç½®\n    matrix_Z2_base transpose() const\n    {\n        if (n == m)\n            return matrix_Z2_base(*this).inplace_transpose();\n        matrix_Z2_base res(m, n);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < m; ++j)\n                res[j][i] = data[i][j];\n        return res;\n    }\n    /*\n     *@brief çŸ©é˜µä¹˜ä»¥ä¸€ä¸ªè¡Œå‘é‡\n     *@param v è¡Œå‘é‡\n     *@return è¿”å›ä¸€ä¸ªè¡Œå‘é‡\n     *@note è¡Œå‘é‡å¿…é¡»åœ¨çŸ©é˜µå·¦ä¹˜ï¼Œæ—¶é—´å¤æ‚åº¦O(n * m / w)\n     */\n    std::vector<int> operator*(const std::bitset<SZ> &v) const\n    {\n        std::vector<int> res(n);\n        for (auto i = 0; i < n; ++i)\n            res[i] = (data[i] & v).count() & 1;\n        return res;\n    }\n    // O(n * m * up_to / w)\n    // Returns {REF matrix, determinant, rank}\n\n    /*\n     *@brief çŸ©é˜µçš„è¡Œé˜¶æ¢¯å½¢å¼\n     *@param up_to è¡Œé˜¶æ¢¯å½¢å¼çš„è¡Œæ•°ï¼Œå¸¦å‚æ•°çš„æƒ…å†µä¸‹åªè®¡ç®—å‰up_to=m-1åˆ—å‘é‡çš„è¡Œé˜¶æ¢¯å½¢å¼ï¼Œç”¨äºè§£çº¿æ€§æ–¹ç¨‹ç»„\n     *@return è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯è¡Œé˜¶æ¢¯å½¢å¼çš„çŸ©é˜µï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯è¡Œåˆ—å¼ï¼Œç¬¬ä¸‰ä¸ªå…ƒç´ æ˜¯ç§©\n     *@note æ—¶é—´å¤æ‚åº¦O(n * m * up_to / w),å¦‚æœè¦è§£å¤šè§£çº¿æ€§æ–¹ç¨‹ç»„ï¼Œå¦‚æœæƒ³å›ºå®šç¬¬kä¸ªè‡ªç”±å˜é‡ï¼Œéœ€è¦å¯¹ä¼ å…¥çŸ©é˜µçš„a_{n,k}ç½®1,åŒæ—¶å¢å¹¿å‘é‡çš„å¯¹åº”ä½a_{n,n}ä¹Ÿå¿…é¡»ç½®1ï¼Œç„¶åè°ƒç”¨è¯¥å‡½æ•°ã€‚\n     *@note å®é™…ä¸Šç­‰ä»·äºæ–°æ·»äº†ä¸€ç»„çº¿æ€§æ–¹ç¨‹ï¼Œå³a_{n,k} * x_k = a_{n,n}ã€‚\n     */\n    tuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1)\n    {\n        if (n == 0)\n            return {*this, true, 0};\n        if (!~up_to)\n            up_to = m;\n        bool det = true;\n        int rank = 0;\n        for (auto j = 0; j < up_to; ++j)\n        {\n            int pivot = -1;\n            for (auto i = rank; i < n; ++i)\n                if (data[i][j])\n                {\n                    pivot = i;\n                    break;\n                }\n            if (!~pivot)\n            {\n                det = false;\n                continue;\n            }\n            if (rank != pivot)\n                swap(data[rank], data[pivot]);\n            for (auto i = rank + 1; i < n; ++i)\n                if (data[i][j])\n                    data[i] ^= data[rank];\n            ++rank;\n            if (rank == n)\n                break;\n        }\n        return {*this, det, rank};\n    }\n    // O(n * m * up_to / w)\n    // Returns {REF matrix, determinant, rank}\n    /*\n     *@brief çŸ©é˜µçš„è¡Œé˜¶æ¢¯å½¢å¼\n     *@param up_to è¡Œé˜¶æ¢¯å½¢å¼çš„è¡Œæ•°\n     *@return è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯è¡Œé˜¶æ¢¯å½¢å¼çš„çŸ©é˜µï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯è¡Œåˆ—å¼ï¼Œç¬¬ä¸‰ä¸ªå…ƒç´ æ˜¯ç§©\n     *@note æ—¶é—´å¤æ‚åº¦O(n * m * up_to / w)ã€‚è§£å¤šè§£çº¿æ€§æ–¹ç¨‹ç»„æ—¶ï¼Œå¦‚æœæƒ³å›ºå®šç¬¬kä¸ªè‡ªç”±å˜é‡ï¼Œéœ€è¦å¯¹ä¼ å…¥çŸ©é˜µçš„a_{n,k}ç½®1,åŒæ—¶å¢å¹¿å‘é‡çš„å¯¹åº”ä½a_{n,n}ä¹Ÿå¿…é¡»ç½®1ï¼Œç„¶åè°ƒç”¨è¯¥å‡½æ•°ã€‚\n     *@note å®é™…ä¸Šç­‰ä»·äºæ–°æ·»äº†ä¸€ç»„çº¿æ€§æ–¹ç¨‹ï¼Œå³a_{n,k} * x_k = a_{n,n}ã€‚\n     */\n    tuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const\n    {\n        return matrix_Z2_base(*this).inplace_REF(up_to);\n    }\n    // O(n * m * min(n, m) / w)\n    /*\n     *@brief çŸ©é˜µçš„é€†\n     *@return è¿”å›ä¸€ä¸ªå¯é€‰çš„çŸ©é˜µï¼Œè¡¨ç¤ºçŸ©é˜µçš„é€†\n     */\n    optional<matrix_Z2_base> inverse() const\n    {\n        assert(n == m);\n        std::vector<std::bitset<SZ>> a(data), res(n);\n        for (auto i = 0; i < n; ++i)\n            res[i].set(i);\n        for (auto j = 0; j < n; ++j)\n        {\n            int pivot = -1;\n            for (auto i = j; i < n; ++i)\n                if (a[i][j])\n                {\n                    pivot = i;\n                    break;\n                }\n            if (!~pivot)\n                return {};\n            swap(a[j], a[pivot]), swap(res[j], res[pivot]);\n            for (auto i = 0; i < n; ++i)\n                if (i != j && a[i][j])\n                    a[i] ^= a[j], res[i] ^= res[j];\n        }\n        swap(*this, res);\n        return true;\n    }\n    /*\n     *@brief çŸ©é˜µçš„è¡Œåˆ—å¼\n     *@return è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œåˆ—å¼æ˜¯å¦ä¸º1\n     */\n    bool determinant() const\n    {\n        assert(n == m);\n        matrix_Z2_base a(data);\n        for (auto i = 0; i < n; ++i)\n        {\n            for (auto j = i + 1; j < n; ++j)\n                if (a[j][i])\n                {\n                    if (a[i][i])\n                        a[j] ^= a[i];\n                    else\n                        swap(a[i], a[j]);\n                }\n            if (!a[i][i])\n                return false;\n        }\n        return true;\n    }\n    // O(n^3 / w)\n    /*\n     *@brief çŸ©é˜µçš„ç§©\n     *@return è¿”å›ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºçŸ©é˜µçš„ç§©\n     *@note æ—¶é—´å¤æ‚åº¦O(n^3 / w)\n     */\n    int rank() const\n    {\n        return get<2>(REF());\n    }\n    // Regarding the matrix as a system of linear equations by separating first m-1 columns, find a solution of the linear equation.\n    // O(n * m^2 / w)\n    /*\n     *@brief çŸ©é˜µæ‰€ä»£è¡¨çš„çº¿æ€§æ–¹ç¨‹ç»„çš„ä¸€ä¸ªè§£\n     *@return è¿”å›ä¸€ä¸ªå¯é€‰çš„ä½é›†ï¼Œè¡¨ç¤ºçŸ©é˜µçš„ä¸€ä¸ªè§£\n     *@note æ—¶é—´å¤æ‚åº¦O(n * m^2 / w),è¯¥çŸ©é˜µæ‰€ä»£è¡¨çš„çº¿æ€§æ–¹ç¨‹ç»„ç³»æ•°çŸ©é˜µä¸ºä½m-1ä½ï¼Œå¸¸æ•°é¡¹ä¸ºç¬¬mä½ï¼Œè¡¨ç¤ºn*(m-1)çš„å¢å¹¿çŸ©é˜µã€‚\n     *@note æ—¶é—´å¤æ‚åº¦O(n * m * up_to / w),å¦‚æœè¦è§£å¤šè§£çº¿æ€§æ–¹ç¨‹ç»„ï¼Œå¦‚æœæƒ³å›ºå®šç¬¬kä¸ªè‡ªç”±å˜é‡ï¼Œéœ€è¦å¯¹ä¼ å…¥çŸ©é˜µçš„a_{n,k}ç½®1,åŒæ—¶å¢å¹¿å‘é‡çš„å¯¹åº”ä½a_{n,n}ä¹Ÿå¿…é¡»ç½®1ï¼Œç„¶åè°ƒç”¨è¯¥å‡½æ•°ã€‚\n     *@note å®é™…ä¸Šç­‰ä»·äºæ–°æ·»äº†ä¸€ç»„çº¿æ€§æ–¹ç¨‹ï¼Œå³a_{n,k} * x_k = a_{n,n}ã€‚\n     */\n    optional<std::bitset<SZ>> find_a_solution() const\n    {\n        assert(m >= 1);\n        auto [ref, _, rank] = REF(m - 1);\n        for (auto i = rank; i < n; ++i)\n            if (ref[i][m - 1])\n                return {};\n        std::bitset<SZ> res;\n        for (auto i = rank - 1; i >= 0; --i)\n        {\n            int pivot = ref[i]._Find_first();\n            assert(pivot < m - 1);\n            res[pivot] = ref[i][m - 1] ^ (ref[i] & res).count() & 1;\n        }\n        return res;\n    }\n    template <class output_stream>\n    friend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a)\n    {\n        out << \"\\n\";\n        for (auto i = 0; i < a.n; ++i)\n        {\n            for (auto j = 0; j < a.m; ++j)\n                out << bool(a[i][j]);\n            out << \"\\n\";\n        }\n        return out;\n    }\n    /*\n     *@brief æ„é€ å‡½æ•°\n     *@param n è¡Œæ•°\n     *@param m åˆ—æ•°\n     *@param init_diagonal å¯¹è§’çº¿æ˜¯å¦åˆå§‹åŒ–\n     *@param init_off_diagonal éå¯¹è§’çº¿æ˜¯å¦åˆå§‹åŒ–\n     */\n    matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false) : n(n), m(m), data(n)\n    {\n        assert(m <= SZ);\n        for (auto i = 0; i < n; ++i)\n            for (auto j = 0; j < m; ++j)\n                data[i][j] = i == j ? init_diagonal : init_off_diagonal;\n    }\n    /*\n     *@brief æ„é€ å‡½æ•°\n     *@param n è¡Œæ•°\n     *@param m åˆ—æ•°\n     *@param a çŸ©é˜µ\n     */\n    matrix_Z2_base(int n, int m, const std::vector<std::bitset<SZ>> &a) : n(n), m(m), data(a) {}\n};\n/*\n *@brief çŸ©é˜µä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°\n *@param c å¸¸æ•°\n *@param M çŸ©é˜µ\n *@return è¿”å›ä¸€ä¸ªçŸ©é˜µ\n */\ntemplate <size_t SZ>\nmatrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M)\n{\n    if (!c)\n        for (auto &v : M)\n            v.reset();\n    return M;\n}\n// Multiply a row std::vector v on the left\n/*\n *@brief è¡Œå‘é‡ä¹˜ä»¥çŸ©é˜µ\n *@param v è¡Œå‘é‡\n *@param a çŸ©é˜µ\n *@return è¿”å›ä¸€ä¸ªè¡Œå‘é‡\n */\ntemplate <size_t SZ>\nstd::bitset<SZ> operator*(const std::vector<int> &v, const matrix_Z2_base<SZ> &a)\n{\n    assert(a.n == (int)v.size());\n    std::bitset<SZ> res;\n    for (auto i = 0; i < a.n; ++i)\n        if (v[i])\n            res ^= a[i];\n    return res;\n}\n\n#endif\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3. å¤šé¡¹å¼ç›¸å…³\n\nå…³é”®è¯ï¼šå·ç§¯ä¼˜åŒ–ã€‚åŠ¨æ€è§„åˆ’ä¼˜åŒ–ã€‚\n\n#### 3.1 å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFTTï¼‰/å¤šé¡¹å¼ä¹˜æ³•\n\nç»™å®šä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ $F(x)$ï¼Œå’Œä¸€ä¸ª $m$ æ¬¡å¤šé¡¹å¼ $G(x)$ã€‚\n\nè¯·æ±‚å‡º $F(x)$ å’Œ $G(x)$ çš„å·ç§¯ï¼Œä»ä½æ¬¡æ–¹é¡¹åˆ°é«˜æ¬¡æ–¹é¡¹ç»™å‡ºç³»æ•°ã€‚\n\nä¿è¯è¾“å…¥ä¸­çš„ç³»æ•°å¤§äºç­‰äº $0$ ä¸”å°äºç­‰äº $9$ã€‚\n\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼š$1 \\le n, m \\leq {10}^6$â€‹â€‹ã€‚\n\n$FTT$ç­‰ä¸‹åˆ—ä¸€ç³»åˆ—å¿«é€Ÿå˜æ¢çš„æœ¬è´¨éƒ½æ˜¯é€‰æ‹©å‡ºæ¥$2^w=n$ä¸ªå¤šé¡¹å¼ç‚¹å€¼ï¼Œç”¨è¿™ç»„ç‚¹å€¼å‘é‡çš„è¿ç®—å»æ›¿ä»£å¤šé¡¹å¼çš„è¿ç®—ã€‚\n\n```cpp\n#include <bits/stdc++.h>\n#include <math.h>\nusing namespace std;\nusing d32 = double;\n#define endl '\\n'\nconst d32 PI = 3.14159265358979323846;\nvoid fft(vector<complex<d32>> &a)\n{\n    int n = a.size();\n    if (n == 1)\n        return;\n    vector<complex<d32>> a0(n / 2), a1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        a0[i] = a[i * 2];\n        a1[i] = a[i * 2 + 1];\n    }\n    fft(a0);\n    fft(a1);\n    d32 ang = 2 * PI / n;\n    complex<d32> w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; i < n / 2; i++)\n    {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n / 2] = a0[i] - w * a1[i];\n        w *= wn;\n    }\n}\nvector<d32> mul(vector<d32> a, vector<d32> b)\n{\n    int n = 1;\n    while (n < a.size() + b.size())\n        n *= 2;\n    a.resize(n);\n    b.resize(n);\n    vector<complex<d32>> A(a.begin(), a.end()), B(b.begin(), b.end());\n    fft(A);\n    fft(B);\n    for (int i = 0; i < n; i++)\n        A[i] *= B[i];\n    for (int i = 0; i < n; i++)\n        A[i] = conj(A[i]);//é€†å˜æ¢å‰æ±‚å€’æ•°ã€‚\n    fft(A);\n    vector<d32> res(n);\n    for (int i = 0; i < n; i++)\n        res[i] = round(A[i].real() / n);\n    return res;\n}\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<d32> a(n + 1), b(m + 1);\n    for (int i = 0; i <= n; i++)\n        cin >> a[i];\n    for (int i = 0; i <= m; i++)\n        cin >> b[i];\n    vector<d32> res = mul(a, b);\n    for (int i = 0; i <= n + m; i++)\n        cout << (long long)res[i] << \" \";\n    cout << endl;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\nè¿˜æœ‰ä¸€ç§å†™æ³•ï¼š\n\n```cpp\nusing d32 = double;\n#define endl '\\n'\nconst d32 PI = 3.14159265358979323846;\nvoid fft(vector<complex<double>> &f, int op)\n{\n    int n = f.size();\n    if (n == 1)\n        return;\n    vector<complex<double>> f0(n / 2), f1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        f0[i] = f[i * 2];\n        f1[i] = f[i * 2 + 1];\n    }\n    fft(f0, op);\n    fft(f1, op);\n    complex<double> cur(1, 0), step(cos(2 * PI / n), sin(2 * PI * op / n));\n    for (int k = 0; k < n / 2; ++k)\n    {\n        complex<double> tmp = cur * f1[k];\n        f[k] = f0[k] + tmp;\n        f[k + n / 2] = f0[k] - tmp;\n        cur *= step;\n    }\n    return;\n}\nvector<d32> mul(vector<d32> &a, vector<d32> &b)\n{\n    int n = 1;\n    while (n < a.size() + b.size())\n        n *= 2;\n    a.resize(n);\n    b.resize(n);\n    vector<complex<d32>> A(a.begin(), a.end()), B(b.begin(), b.end());\n    fft(A, 1);\n    fft(B, 1);\n    for (int i = 0; i < n; i++)\n        A[i] *= B[i];\n    fft(A, -1);\n    vector<d32> res(n);\n    for (int i = 0; i < n; i++)\n        res[i] = round(A[i].real() / n);\n    return res;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.2 å¿«é€Ÿæ•°è®ºå˜æ¢ï¼ˆNTTï¼‰/å¤šé¡¹å¼ä¹˜æ³•\n\n```cpp\nconstexpr int P = 998244353;\n\nint power(int a, int b)\n{\n    int res = 1;\n    for (; b; b /= 2, a = 1LL * a * a % P)\n    {\n        if (b % 2)\n        {\n            res = 1LL * res * a % P;\n        }\n    }\n    return res;\n}\n\nstd::vector<int> rev, roots{0, 1};\n\nvoid dft(std::vector<int> &a)\n{\n    int n = a.size();\n    if (int(rev.size()) != n)\n    {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n        {\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (rev[i] < i)\n        {\n            std::swap(a[i], a[rev[i]]);\n        }\n    }\n    if (roots.size() < n)\n    {\n        int k = __builtin_ctz(roots.size());\n        roots.resize(n);\n        while ((1 << k) < n)\n        {\n            int e = power(31, 1 << (__builtin_ctz(P - 1) - k - 1));\n            for (int i = 1 << (k - 1); i < (1 << k); i++)\n            {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = 1LL * roots[i] * e % P;\n            }\n            k++;\n        }\n    }\n\n    for (int k = 1; k < n; k *= 2)\n    {\n        for (int i = 0; i < n; i += 2 * k)\n        {\n            for (int j = 0; j < k; j++)\n            {\n                int u = a[i + j];\n                int v = 1LL * a[i + j + k] * roots[k + j] % P;\n                a[i + j] = (u + v) % P;\n                a[i + j + k] = (u - v + P) % P;\n            }\n        }\n    }\n}\n\nvoid idft(std::vector<int> &a)\n{\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    int inv = power(n, P - 2);\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = 1LL * a[i] * inv % P;\n    }\n}\n\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b)\n{\n    int n = 1, tot = a.size() + b.size() - 1;\n    while (n < tot)\n    {\n        n *= 2;\n    }\n    if (tot < 128)\n    {\n        std::vector<int> c(a.size() + b.size() - 1);\n        for (int i = 0; i < a.size(); i++)\n        {\n            for (int j = 0; j < b.size(); j++)\n            {\n                c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;\n            }\n        }\n        return c;\n    }\n    a.resize(n);\n    b.resize(n);\n    dft(a);\n    dft(b);\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = 1LL * a[i] * b[i] % P;\n    }\n    idft(a);\n    a.resize(tot);\n    return a;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.3 å¿«é€Ÿè«æ¯”ä¹Œæ–¯å˜æ¢/å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢ï¼ˆFMT/FWTï¼‰\n\nç»™å®šé•¿åº¦ä¸º $2^n$ ä¸¤ä¸ªåºåˆ— $A,B$ï¼Œè®¾ \n\n$$C_i=\\sum_{j\\oplus k = i}A_j \\times B_k$$\n\nåˆ†åˆ«å½“ $\\oplus$ æ˜¯ $or, and, xor$ æ—¶æ±‚å‡º $C$â€‹â€‹ã€‚ç§°ä½œæˆ–ã€ä¸ã€å¼‚æˆ–å·ç§¯ã€‚**è¯·åŒºåˆ†ä»–ä»¬ä¸å¯¹åº”ä¹˜æ³•çš„åŒºåˆ«ã€‚**\n\nå·ç§¯åŸç†ï¼š$FMT$æ˜¯å­é›†è¿ç®—ï¼Œ$FWT$æ˜¯$x\\circ y=popcount(x\\&y)\\%2$â€‹\n\n$FMT_{and}(A)_i=\\sum_{i\\&j=i}a_j$\n\n$FMT_{or}(A)_i=\\sum_{i|j=i}a_j$\n\n$FMT_{xor}(A)_i=\\sum_{i\\circ j=0}a_j-\\sum_{i\\circ j=1}a_j$\n\næ³¨æ„ï¼Œé’ˆå¯¹å¼‚æˆ–çš„å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢æ˜¯çº¿æ€§å˜æ¢çš„ï¼Œå³$FWT(c\\cdot A+B)=c\\cdot FWT(A)+FWT(B)$â€‹\n\nå¯¹æ•°ç»„$F(x)=x^0$ï¼ˆå³åªæœ‰$a[0]=1$ï¼Œå…¶ä½™ä½ç½®å…¨ä¸º$0$ï¼‰çš„å¿«é€Ÿ$FWT$åæ‰€å¾—åºåˆ—å…¨ä¸º$1$ã€‚\n\nå¯¹æ•°ç»„$F(x)=x^t$ï¼ˆå³åªæœ‰$a[t]=1$ï¼Œå…¶ä½™ä½ç½®å…¨ä¸º$0$ï¼‰çš„å¿«é€Ÿ$FWT$åæ‰€å¾—åºåˆ—å…¨ä¸º$1$æˆ–è€…$-1$ï¼ˆæ˜¾ç„¶ï¼‰\n\n```cpp\nstd::vector<int> fwt_and(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[j + k] = (1ll * a[j + k] + a[i + j + k]) % mod;\n    return a;\n}\nstd::vector<int> ifwt_and(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[j + k] = (1ll * a[j + k] - a[i + j + k] + mod) % mod;\n    return a;\n}\nstd::vector<int> fwt_or(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[i + j + k] = (1ll * a[j + k] + a[i + j + k]) % mod;\n    return a;\n}\nstd::vector<int> ifwt_or(vector<int> a)\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n                a[i + j + k] = (1ll * a[i + j + k] - a[j + k] + mod) % mod;\n    return a;\n}\nstd::vector<int> fwt_xor(vector<int> a) // å¼‚æˆ–\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (1ll * x + y) % mod;\n                a[i + j + k] = (1ll * x - y + mod) % mod;\n            }\n    return a;\n}\nstd::vector<int> ifwt_xor(vector<int> a)\n{\n    int inv_2 = 499122177;\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (1ll * x + y) * inv_2 % mod;\n                a[i + j + k] = (1ll * x - y + mod) % mod * inv_2 % mod;\n            }\n    return a;\n}\n\nstd::vector<int> fwt_not(std::vector<int> a) // åŒæˆ–\n{\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[i + j + k] = (1ll * x + y) % mod;\n                a[j + k] = (1ll * x - y + mod) % mod;\n            }\n    return a;\n}\nstd::vector<int> ifwt_not(std::vector<int> a)\n{\n    int inv_2 = 499122177;\n    int n = a.size();\n    for (int i = 1; i < n; i <<= 1)\n        for (int j = 0; j < n; j += i << 1)\n            for (int k = 0; k < i; k++)\n            {\n                int x = a[j + k], y = a[i + j + k];\n                a[i + j + k] = (1ll * x + y) * inv_2 % mod;\n                a[j + k] = (1ll * x - y + mod) % mod * inv_2 % mod;\n            }\n    return a;\n}\nstd::vector<int> FWT(std::vector<int> a, std::vector<int> b, vector<int> (*f)(vector<int>), vector<int> (*g)(vector<int>))\n{\n    int n = a.size();\n    assert((n & (n - 1)) == 0); // næ˜¯2çš„å¹‚\n    a = f(a);\n    b = f(b);\n    for (int i = 0; i < n; i++)\n        a[i] = 1ll * a[i] * b[i] % mod;\n    return g(a);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.4 åˆ†æ²»NTTï¼ˆNTT+CQDï¼‰\n\nç»™å®šåºåˆ— $g_{1\\dots n - 1}$ï¼Œæ±‚åºåˆ— $f_{0\\dots n - 1}$ã€‚\n\nå…¶ä¸­ $f_i=\\sum_{j=1}^if_{i-j}g_j$ï¼Œè¾¹ç•Œä¸º $f_0=1$ã€‚\n\nç­”æ¡ˆå¯¹ $998244353$ å–æ¨¡ã€‚\n\n$2\\leq n\\leq 10^5$ï¼Œ$0\\leq g_i<998244353$â€‹ã€‚\n\nåˆ©ç”¨CDQåˆ†æ²»çš„æ€æƒ³ï¼Œå…ˆè§£å†³å·¦åŠéƒ¨åˆ†ï¼Œå†è§£å†³å·¦åŠéƒ¨åˆ†å¯¹å³åŠéƒ¨åˆ†çš„è´¡çŒ®ã€‚\n\nè®¾å½“å‰è®¡ç®—åŒºé—´ä¸º$[l,r]$ï¼Œæ­¤æ—¶å…ˆ$CDQ$å·²ç»è®¡ç®—å‡ºäº†$f[l,\\ldots,mid]$ï¼Œè€ƒè™‘å…¶å¯¹$f[mid+1,\\ldots,r]$çš„è´¡çŒ®ã€‚\n\nå¯¹äº$f_k(k\\ge mid+1)$è€Œè¨€ï¼Œå‰åŠéƒ¨åˆ†æ‰€é€ æˆçš„è´¡çŒ®ä¸º$\\sum_{i+j=k,i\\le mid}f_ig_{k-i}$\n\nä¹Ÿå°±æ˜¯è¯´ï¼Œéœ€è¦å°†$f[l,mid]$å’Œ$g(0,r-l)$å·ç§¯å·èµ·æ¥ï¼Œå¯¹ååŠéƒ¨åˆ†è¿›è¡Œè´¡çŒ®ã€‚\n\næ‰€ä»¥ç®—å‡ºå‰åŠéƒ¨åˆ†åï¼Œå°†$f[l,\\ldots,mid]$ææˆä¸€ä¸ªå¤šé¡¹å¼ï¼Œå·ç§¯$NTT$â€‹è®¡ç®—è´¡çŒ®ï¼ŒåŠ åœ¨åé¢ï¼Œç„¶åé€’å½’ååŠéƒ¨åˆ†ã€‚\n\nå¤æ‚åº¦$O(nlog^2n)$\n\nï¼ˆæœ¬ä¾‹é¢˜ä¹Ÿå¯åˆ©ç”¨ç”Ÿæˆå‡½æ•°æ“çºµåºåˆ—ï¼Œå¤šé¡¹å¼æ±‚é€†è§£å†³ï¼Œå¤æ‚åº¦$O(nlogn)$ ï¼‰\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nconstexpr int P = 998244353;\n\nint power(int a, int b)\n{\n    int res = 1;\n    for (; b; b /= 2, a = 1LL * a * a % P)\n    {\n        if (b % 2)\n        {\n            res = 1LL * res * a % P;\n        }\n    }\n    return res;\n}\n\nstd::vector<int> rev, roots{0, 1};\n\nvoid dft(std::vector<int> &a)\n{\n   //è§NTT\n}\n\nvoid idft(std::vector<int> &a)\n{\n    //è§NTT\n}\n\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b)\n{\n   //è§NTT\n}\nvector<int> f, g;\nvoid cdq(int l, int r)\n{\n    if (l == r)\n    {\n        if (!l)\n            f[l] = 1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    cdq(l, mid);\n    vector<int> a(mid - l + 1), b(r - l + 1);\n    for (int i = l; i <= mid; i++)\n        a[i - l] = f[i];\n    for (int i = 0; i <= r - l; i++)\n        b[i] = g[i];\n    a = mul(a, b);\n    for (int i = mid + 1; i <= r; i++)\n        f[i] = (f[i] + a[i - l]) % P;\n    cdq(mid + 1, r);\n    return;\n}\nvoid solve()\n{\n    int n;\n    cin >> n;\n    f.resize(n);\n    g.resize(n);\n    for (int i = 1; i < n; i++)\n    {\n        cin >> g[i];\n    }\n    g[0] = 0;\n    cdq(0, n - 1);\n    for (int i = 0; i < n; i++)\n    {\n        cout << f[i] << \" \";\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.5 Poly.h, with NTT&Modint.h\n\n```cpp\n/**   å¤šé¡¹å¼ç›¸å…³ï¼ˆPoly, with. MInt & MLongï¼‰\n *    2023-09-20: https://atcoder.jp/contests/arc163/submissions/45737810\n *    2024-07-28: https://codeforces.com/contest/1991/submission/273204889\n **/\n#ifndef __POLYS_H__\n#define __POLYS_H__\n#include <bits/stdc++.h>\n#include <icpc-model/Modint.h>\nusing namespace Modint;\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\nusing i64 = long long;\nstd::vector<int> rev;\ntemplate <int P>\nstd::vector<MInt<P>> roots{0, 1};\n\ntemplate <int P>\nconstexpr MInt<P> findPrimitiveRoot()\n{\n    MInt<P> i = 2;\n    int k = __builtin_ctz(P - 1);\n    while (true)\n    {\n        if (power(i, (P - 1) / 2) != 1)\n        {\n            break;\n        }\n        i += 1;\n    }\n    return power(i, (P - 1) >> k);\n}\n\ntemplate <int P>\nconstexpr MInt<P> primitiveRoot = findPrimitiveRoot<P>();\n\ntemplate <>\nconstexpr MInt<998244353> primitiveRoot<998244353>{31};\n\ntemplate <int P>\nconstexpr void dft(std::vector<MInt<P>> &a)\n{\n    int n = a.size();\n\n    if (int(rev.size()) != n)\n    {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n        {\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        if (rev[i] < i)\n        {\n            std::swap(a[i], a[rev[i]]);\n        }\n    }\n    if (roots<P>.size() < n)\n    {\n        int k = __builtin_ctz(roots<P>.size());\n        roots<P>.resize(n);\n        while ((1 << k) < n)\n        {\n            auto e = power(primitiveRoot<P>, 1 << (__builtin_ctz(P - 1) - k - 1));\n            for (int i = 1 << (k - 1); i < (1 << k); i++)\n            {\n                roots<P>[2 * i] = roots<P>[i];\n                roots<P>[2 * i + 1] = roots<P>[i] * e;\n            }\n            k++;\n        }\n    }\n    for (int k = 1; k < n; k *= 2)\n    {\n        for (int i = 0; i < n; i += 2 * k)\n        {\n            for (int j = 0; j < k; j++)\n            {\n                MInt<P> u = a[i + j];\n                MInt<P> v = a[i + j + k] * roots<P>[k + j];\n                a[i + j] = u + v;\n                a[i + j + k] = u - v;\n            }\n        }\n    }\n}\n\ntemplate <int P>\nconstexpr void idft(std::vector<MInt<P>> &a)\n{\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    MInt<P> inv = (1 - P) / n;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] *= inv;\n    }\n}\n\ntemplate <int P = 998244353>\nstruct Poly : public std::vector<MInt<P>>\n{\n    using Value = MInt<P>;\n\n    Poly() : std::vector<Value>() {}\n    explicit constexpr Poly(int n) : std::vector<Value>(n) {}\n\n    explicit constexpr Poly(const std::vector<Value> &a) : std::vector<Value>(a) {}\n    constexpr Poly(const std::initializer_list<Value> &a) : std::vector<Value>(a) {}\n\n    template <class InputIt, class = std::_RequireInputIter<InputIt>>\n    explicit constexpr Poly(InputIt first, InputIt last) : std::vector<Value>(first, last) {}\n    /*\n    @brief é€šè¿‡å‡½æ•°ç”Ÿæˆå¤šé¡¹å¼\n    @param n ç”Ÿæˆçš„å¤šé¡¹å¼çš„é•¿åº¦\n    @param f ç”Ÿæˆå¤šé¡¹å¼çš„å‡½æ•°\n    */\n    template <class F>\n    explicit constexpr Poly(int n, F f) : std::vector<Value>(n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            (*this)[i] = f(i);\n        }\n    }\n    /*\n    @brief å¤šé¡¹å¼ä½ç§»\n    @param k ä½ç§»çš„è·ç¦»ï¼Œæ­£æ•°è¡¨ç¤ºå„é¡¹ä¹˜ä»¥ x^kï¼Œè´Ÿæ•°è¡¨ç¤ºå„é¡¹é™¤ä»¥ x^k\n    @return ä½ç§»åçš„å¤šé¡¹å¼\n    */\n    constexpr Poly shift(int k) const\n    {\n        if (k >= 0)\n        {\n            auto b = *this;\n            b.insert(b.begin(), k, 0);\n            return b;\n        }\n        else if (this->size() <= -k)\n        {\n            return Poly();\n        }\n        else\n        {\n            return Poly(this->begin() + (-k), this->end());\n        }\n    }\n    // å¤šé¡¹å¼é‡å¡‘ï¼Œå°†å¤šé¡¹å¼çš„é•¿åº¦è°ƒæ•´ä¸º k\n    constexpr Poly trunc(int k) const\n    {\n        Poly f = *this;\n        f.resize(k);\n        return f;\n    }\n    // å¤šé¡¹å¼åŠ æ³•\n    constexpr friend Poly operator+(const Poly &a, const Poly &b)\n    {\n        Poly res(std::max(a.size(), b.size()));\n        for (int i = 0; i < a.size(); i++)\n        {\n            res[i] += a[i];\n        }\n        for (int i = 0; i < b.size(); i++)\n        {\n            res[i] += b[i];\n        }\n        return res;\n    }\n    // å¤šé¡¹å¼å‡æ³•\n    constexpr friend Poly operator-(const Poly &a, const Poly &b)\n    {\n        Poly res(std::max(a.size(), b.size()));\n        for (int i = 0; i < a.size(); i++)\n        {\n            res[i] += a[i];\n        }\n        for (int i = 0; i < b.size(); i++)\n        {\n            res[i] -= b[i];\n        }\n        return res;\n    }\n    // å¤šé¡¹å¼å–è´Ÿ\n    constexpr friend Poly operator-(const Poly &a)\n    {\n        std::vector<Value> res(a.size());\n        for (int i = 0; i < int(res.size()); i++)\n        {\n            res[i] = -a[i];\n        }\n        return Poly(res);\n    }\n    // å¤šé¡¹å¼ä¹˜æ³•ï¼ŒNTTå¿«é€Ÿæ•°è®ºå˜æ¢\n    constexpr friend Poly operator*(Poly a, Poly b)\n    {\n        if (a.size() == 0 || b.size() == 0)\n        {\n            return Poly();\n        }\n        if (a.size() < b.size())\n        {\n            std::swap(a, b);\n        }\n        int n = 1, tot = a.size() + b.size() - 1;\n        while (n < tot)\n        {\n            n *= 2;\n        }\n        if (((P - 1) & (n - 1)) != 0 || b.size() < 128)\n        {\n            Poly c(a.size() + b.size() - 1);\n            for (int i = 0; i < a.size(); i++)\n            {\n                for (int j = 0; j < b.size(); j++)\n                {\n                    c[i + j] += a[i] * b[j];\n                }\n            }\n            return c;\n        }\n        a.resize(n);\n        b.resize(n);\n        dft(a);\n        dft(b);\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] *= b[i];\n        }\n        idft(a);\n        a.resize(tot);\n        return a;\n    }\n    constexpr friend Poly operator*(Value a, Poly b)\n    {\n        for (int i = 0; i < int(b.size()); i++)\n        {\n            b[i] *= a;\n        }\n        return b;\n    }\n    constexpr friend Poly operator*(Poly a, Value b)\n    {\n        for (int i = 0; i < int(a.size()); i++)\n        {\n            a[i] *= b;\n        }\n        return a;\n    }\n    constexpr friend Poly operator/(Poly a, Value b)\n    {\n        for (int i = 0; i < int(a.size()); i++)\n        {\n            a[i] /= b;\n        }\n        return a;\n    }\n    constexpr Poly &operator+=(Poly b)\n    {\n        return (*this) = (*this) + b;\n    }\n    constexpr Poly &operator-=(Poly b)\n    {\n        return (*this) = (*this) - b;\n    }\n    constexpr Poly &operator*=(Poly b)\n    {\n        return (*this) = (*this) * b;\n    }\n    constexpr Poly &operator*=(Value b)\n    {\n        return (*this) = (*this) * b;\n    }\n    constexpr Poly &operator/=(Value b)\n    {\n        return (*this) = (*this) / b;\n    }\n    // å¤šé¡¹å¼æ±‚å¯¼\n    constexpr Poly deriv() const\n    {\n        if (this->empty())\n        {\n            return Poly();\n        }\n        Poly res(this->size() - 1);\n        for (int i = 0; i < this->size() - 1; ++i)\n        {\n            res[i] = (i + 1) * (*this)[i + 1];\n        }\n        return res;\n    }\n    // å¤šé¡¹å¼ç§¯åˆ†\n    constexpr Poly integr() const\n    {\n        Poly res(this->size() + 1);\n        for (int i = 0; i < this->size(); ++i)\n        {\n            res[i + 1] = (*this)[i] / (i + 1);\n        }\n        return res;\n    }\n    // å¤šé¡¹å¼æ±‚é€†ï¼Œä¸­é—´mä¸ºæ¨¡å¤šé¡¹å¼é•¿åº¦ï¼Œå³ mod x^m\n    constexpr Poly inv(int m) const\n    {\n        Poly x{(*this)[0].inv()};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x * (Poly{2} - trunc(k) * x)).trunc(k);\n        }\n        return x.trunc(m);\n    }\n    // å¤šé¡¹å¼æ±‚lnx\n    constexpr Poly log(int m) const\n    {\n        return (deriv() * inv(m)).integr().trunc(m);\n    }\n    // å¤šé¡¹å¼æ±‚e^x\n    constexpr Poly exp(int m) const\n    {\n        Poly x{1};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x * (Poly{1} - x.log(k) + trunc(k))).trunc(k);\n        }\n        return x.trunc(m);\n    }\n    // å¤šé¡¹å¼å¿«é€Ÿå¹‚\n    constexpr Poly pow(int k, int m) const\n    {\n        int i = 0;\n        while (i < this->size() && (*this)[i] == 0)\n        {\n            i++;\n        }\n        if (i == this->size() || 1LL * i * k >= m)\n        {\n            return Poly(m);\n        }\n        Value v = (*this)[i];\n        auto f = shift(-i) * v.inv();\n        return (f.log(m - i * k) * k).exp(m - i * k).shift(i * k) * power(v, k);\n    }\n    // å¤šé¡¹å¼å¼€æ ¹\n    constexpr Poly sqrt(int m) const\n    {\n        Poly x{1};\n        int k = 1;\n        while (k < m)\n        {\n            k *= 2;\n            x = (x + (trunc(k) * x.inv(k)).trunc(k)) * CInv<2, P>;\n        }\n        return x.trunc(m);\n    }\n    // å¤šé¡¹å¼è½¬ç½®ä¹˜æ³•ï¼Œè®¡ç®—F(x)*G(1/x)çš„ç»“æœï¼ŒæŠ¹æ‰è´Ÿæ¬¡æ–¹é¡¹\n    constexpr Poly mulT(Poly b) const\n    {\n        if (b.size() == 0)\n        {\n            return Poly();\n        }\n        int n = b.size();\n        std::reverse(b.begin(), b.end());\n        return ((*this) * b).shift(-(n - 1));\n    }\n    // å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼\n    constexpr std::vector<Value> eval(std::vector<Value> x) const\n    {\n        if (this->size() == 0)\n        {\n            return std::vector<Value>(x.size(), 0);\n        }\n        const int n = std::max(x.size(), this->size());\n        std::vector<Poly> q(4 * n);\n        std::vector<Value> ans(x.size());\n        x.resize(n);\n        std::function<void(int, int, int)> build = [&](int p, int l, int r)\n        {\n            if (r - l == 1)\n            {\n                q[p] = Poly{1, -x[l]};\n            }\n            else\n            {\n                int m = (l + r) / 2;\n                build(2 * p, l, m);\n                build(2 * p + 1, m, r);\n                q[p] = q[2 * p] * q[2 * p + 1];\n            }\n        };\n        build(1, 0, n);\n        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num)\n        {\n            if (r - l == 1)\n            {\n                if (l < int(ans.size()))\n                {\n                    ans[l] = num[0];\n                }\n            }\n            else\n            {\n                int m = (l + r) / 2;\n                work(2 * p, l, m, num.mulT(q[2 * p + 1]).trunc(m - l));\n                work(2 * p + 1, m, r, num.mulT(q[2 * p]).trunc(r - m));\n            }\n        };\n        work(1, 0, n, mulT(q[1].inv(n)));\n        return ans;\n    }\n};\n\ntemplate <int P = 998244353>\nPoly<P> berlekampMassey(const Poly<P> &s)\n{\n    Poly<P> c;\n    Poly<P> oldC;\n    int f = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        auto delta = s[i];\n        for (int j = 1; j <= c.size(); j++)\n        {\n            delta -= c[j - 1] * s[i - j];\n        }\n        if (delta == 0)\n        {\n            continue;\n        }\n        if (f == -1)\n        {\n            c.resize(i + 1);\n            f = i;\n        }\n        else\n        {\n            auto d = oldC;\n            d *= -1;\n            d.insert(d.begin(), 1);\n            MInt<P> df1 = 0;\n            for (int j = 1; j <= d.size(); j++)\n            {\n                df1 += d[j - 1] * s[f + 1 - j];\n            }\n            assert(df1 != 0);\n            auto coef = delta / df1;\n            d *= coef;\n            Poly<P> zeros(i - f - 1);\n            zeros.insert(zeros.end(), d.begin(), d.end());\n            d = zeros;\n            auto temp = c;\n            c += d;\n            if (i - temp.size() > f - oldC.size())\n            {\n                oldC = temp;\n                f = i;\n            }\n        }\n    }\n    c *= -1;\n    c.insert(c.begin(), 1);\n    return c;\n}\n\ntemplate <int P = 998244353>\nMInt<P> linearRecurrence(Poly<P> p, Poly<P> q, i64 n)\n{\n    int m = q.size() - 1;\n    while (n > 0)\n    {\n        auto newq = q;\n        for (int i = 1; i <= m; i += 2)\n        {\n            newq[i] *= -1;\n        }\n        auto newp = p * newq;\n        newq = q * newq;\n        for (int i = 0; i < m; i++)\n        {\n            p[i] = newp[i * 2 + n % 2];\n        }\n        for (int i = 0; i <= m; i++)\n        {\n            q[i] = newq[i * 2];\n        }\n        n /= 2;\n    }\n    return p[0] / q[0];\n}\n\nstruct Comb\n{\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n\n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb()\n    {\n        init(n);\n    }\n\n    void init(int m)\n    {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n)\n            return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n\n        for (int i = n + 1; i <= m; i++)\n        {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--)\n        {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n\n    Z fac(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m)\n    {\n        if (m > n)\n            init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m)\n    {\n        if (n < m || m < 0)\n            return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nPoly<P> get(int n, int m)\n{\n    if (m == 0)\n    {\n        return Poly(n + 1);\n    }\n    if (m % 2 == 1)\n    {\n        auto f = get(n, m - 1);\n        Z p = 1;\n        for (int i = 0; i <= n; i++)\n        {\n            f[n - i] += comb.binom(n, i) * p;\n            p *= m;\n        }\n        return f;\n    }\n    auto f = get(n, m / 2);\n    auto fm = f;\n    for (int i = 0; i <= n; i++)\n    {\n        fm[i] *= comb.fac(i);\n    }\n    Poly pw(n + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        pw[i] = pw[i - 1] * (m / 2);\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        pw[i] *= comb.invfac(i);\n    }\n    fm = fm.mulT(pw);\n    for (int i = 0; i <= n; i++)\n    {\n        fm[i] *= comb.invfac(i);\n    }\n    return f + fm;\n}\n#endif\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.6 å¤šé¡¹å¼æ±‚é€†\n\nç»™å®šä¸€ä¸ªå¤šé¡¹å¼ $F(x)$ ï¼Œè¯·æ±‚å‡ºä¸€ä¸ªå¤šé¡¹å¼ $G(x)$ï¼Œ æ»¡è¶³ $F(x) * G(x) \\equiv 1 \\pmod{x^n}$ã€‚ç³»æ•°å¯¹ $998244353$ å–æ¨¡ã€‚\n\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼Œ$1 \\leq n \\leq 10^5$ï¼Œ$ 0 \\leq a_i \\leq 10^9$â€‹ã€‚\n\nå·¥ä½œåŸç†ï¼š\n\næˆ‘ä»¬ä¸å¦¨å‡è®¾ï¼Œ$n=2^k$,$k\\in N$ã€‚\n\nè‹¥$n=1$ï¼Œåˆ™$A(x)Ã—B(x)â‰¡a_0Ã—b_0â‰¡1(mod\\  x^1)$,å…¶ä¸­$a_0$ï¼Œ$b_0$è¡¨ç¤ºå¤šé¡¹å¼$A$å’Œå¤šé¡¹å¼$B$çš„å¸¸æ•°é¡¹ã€‚\n\nè‹¥éœ€è¦æ±‚å‡º$b_0$ï¼Œç›´æ¥ç”¨è´¹é©¬å°å®šç†æ±‚å‡º$a_0$çš„ä¹˜æ³•é€†å…ƒå³å¯ã€‚\n\nå½“$n>1$æ—¶ï¼š\n\næˆ‘ä»¬å‡è®¾åœ¨æ¨¡$x^{\\frac{n}{2}}$çš„æ„ä¹‰ä¸‹$A(x)$çš„é€†å…ƒ$B^â€²(x)$æˆ‘ä»¬å·²ç»æ±‚å¾—ã€‚\n\nä¾æ®å®šä¹‰ï¼Œåˆ™æœ‰\n\n$A(x)B^â€²(x)â‰¡1(mod\\  x^{\\frac{n}{2}})$ (1)\n\nå¯¹(1)å¼è¿›è¡Œç§»é¡¹å¾—\n\n$A(x)B^â€²(x)âˆ’1â‰¡0(mod\\ x^{\\frac{n}{2}})$ (2)\n\nç„¶åå¯¹(2)å¼ç­‰å·ä¸¤è¾¹å¹³æ–¹ï¼Œå¾—\n\n$A^2(x)B^{â€²2}(x)âˆ’2A(x)B^â€²(x)+1â‰¡0(mod\\  x^n)$ (3)\n\nå°†å¸¸æ•°é¡¹ç§»åŠ¨åˆ°ç­‰å¼å³ä¾§ï¼Œå¾—\n\n$A^2(x)B^{â€²2}(x)âˆ’2A(x)B^â€²(x)â‰¡âˆ’1(mod\\  x^n)$ (4)\n\nå°†ç­‰å¼ä¸¤è¾¹å»ç›¸åæ•°ï¼Œå¾—\n\n$2A(x)B^â€²(x)âˆ’A^2(x)B^{â€²2}(x)â‰¡1(mod\\  x^n)$ (5)\n\nä¸‹é¢è€ƒè™‘å›æˆ‘ä»¬éœ€è¦æ±‚çš„å¤šé¡¹å¼$B(x)$ï¼Œä¾æ®å®šä¹‰ï¼Œå…¶æ»¡è¶³\n\n$A(x)B(x)â‰¡1(mod\\ x^n)$ (6)\n\nå°†(5)âˆ’(6)å¹¶ç§»é¡¹ï¼Œå¾—\n\n$A(x)B(x)â‰¡2A(x)B^â€²(x)âˆ’A^2(x)B^{â€²2}(x)(mod\\  x^n)$ (7)\n\nç­‰å¼ä¸¤è¾¹çº¦å»$A(x)$ï¼Œå¾—\n\n$B(x)â‰¡2Bâ€²(x)âˆ’A(x)B^{â€²2}(x)(mod\\  x^n)$ (8)\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &i : a)\n        cin >> i;\n    Poly<P> A(a);\n    Poly<P> invA = A.inv(n);\n    for (auto &i : invA)\n    {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.7 å¤šé¡¹å¼é™¤æ³•\n\n***ä¸¥æ ¼æ³¨æ„ï¼šå¤šé¡¹å¼é™¤æ³•ä¸å¯ä»¥æ‹¿æ¥åšé«˜ç²¾åº¦é™¤æ³•ï¼å› ä¸ºå¤šé¡¹å¼é™¤æ³•åšäº†å–ä½™æ•°çš„æ“ä½œï¼ç›¸å½“äºæ‰£äº†é¡¹çš„ç³»æ•°ï¼***\n\nç»™å®šä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ $F(x)$ å’Œä¸€ä¸ª $m$ æ¬¡å¤šé¡¹å¼  $G(x)$ ï¼Œè¯·æ±‚å‡ºå¤šé¡¹å¼ $Q(x)$, $R(x)$ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š\n\n - $Q(x)$ æ¬¡æ•°ä¸º $n-m$ï¼Œ$R(x)$ æ¬¡æ•°å°äº $m$\n - $F(x) = Q(x)  G(x) + R(x)$\n\næ‰€æœ‰çš„è¿ç®—åœ¨æ¨¡ $998244353$ æ„ä¹‰ä¸‹è¿›è¡Œã€‚   \n\nå¦‚æœ $R(x)$ ä¸è¶³ $m-1$ æ¬¡ï¼Œå¤šä½™çš„é¡¹ç³»æ•°è¡¥ $0$ã€‚\n\nå¯¹äºæ‰€æœ‰æ•°æ®ï¼Œ$1 \\le m < n \\le 10^5$ï¼Œç»™å‡ºçš„ç³»æ•°å‡å±äº $[0, 998244353) \\cap \\mathbb{Z}$ã€‚\n\n$N$æ¬¡å¤šé¡¹å¼$A(x)$çš„ç³»æ•°$vector$è¿›è¡Œä¸€æ¬¡$reverse$åè¡¨ç¤ºçš„æ˜¯$A(\\frac{1}{x})x^N$çš„ç³»æ•°ã€‚\n\næ•…æ±‚å¤šé¡¹å¼é™¤æ³•$A(x)=B(x)C(x)+D(x)$æ—¶ï¼Œè€ƒè™‘$x^NA(\\frac{1}{x})=x^MB(\\frac{1}{x})x^{N-M}C(\\frac{1}{x})+D(\\frac{1}{x})$\n\nå¤šé¡¹å¼å¯¹$x^{N-M+1}$æ±‚æ¨¡ï¼Œ$D(x)$æ¶ˆå¤±ï¼Œæœ‰$x^{N-M}C(\\frac{1}{x})\\equiv \\frac{A^{'}(x)}{B^{'}(x)}$\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<Z> a(n + 1), b(k + 1);\n    for (auto &i : a)\n        cin >> i;\n    for (auto &i : b)\n        cin >> i;\n    Poly<P> A(a), B(b);\n    reverse(A.begin(), A.end());\n    reverse(B.begin(), B.end());\n    A.resize(n - k + 1);\n    B.resize(n - k + 1);\n    Poly<P> C = A * (B.inv(n - k + 1));\n    C.resize(n - k + 1);\n    reverse(C.begin(), C.end());\n    for (auto &i : C)\n        cout << i << \" \";\n    cout << endl;\n    Poly<P> D = Poly<P>(a) - Poly<P>(b) * C;\n    D.resize(k);\n    for (auto &i : D)\n        cout << i << \" \";\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.8 å¤šé¡¹å¼å¯¹æ•°\n\næ±‚ä¸ªå¯¼å†ç§¯åˆ†å°±è¡Œã€‚\n\nç»™å®šå¤šé¡¹å¼$A(x)$ï¼Œæ±‚$B(x)$ä½¿å¾—$B(x)\\equiv lnA(x)\\ (mod\\ x^n)$ï¼Œä¿è¯$a_0=1$\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &x : a)\n        cin >> x;\n    Poly<P> p(a);\n    auto b = p.log(n);\n    for (auto x : b)\n        cout << x << ' ';\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.9 å¤šé¡¹å¼è‡ªç„¶æŒ‡æ•°\n\nç»™å®šå¤šé¡¹å¼$A(x)$ï¼Œæ±‚$B(x)$ä½¿å¾—$B(x)\\equiv e^{A(x)}\\ (mod\\ x^n)$ï¼Œä¿è¯$a_0=0$â€‹\n\nå‡½æ•°æ±‚å¯¼ï¼Œç‰›é¡¿è¿­ä»£æ³•ã€‚\n\nå…ˆä»ç‰›é¡¿è¿­ä»£è®²èµ·ã€‚ \n\nå·²çŸ¥å¤šé¡¹å¼å‡½æ•°$G(z)$ï¼Œæ±‚å¤šé¡¹å¼å‡½æ•°$F(x)$æ»¡è¶³ $$G(F(x))\\equiv0 \\pmod{x^n}$$ \n\nè€ƒè™‘ç”¨è¿­ä»£æ±‚è§£ï¼Œå‡è®¾æˆ‘ä»¬å·²ç»æ±‚å¾—$F_0(x)$æ»¡è¶³ $$G(F_0(x))\\equiv0\\pmod{x^{\\left\\lceil\\frac{n}{2}\\right\\rceil}}$$ \n\nå°†å‡½æ•°$G$åœ¨$z=F_0(x)$å¤„è¿›è¡Œæ³°å‹’å±•å¼€ $$G(F(x))=\\sum_{i=1}^{\\infty}\\frac{G^i(F_0(x))}{i!}(F(x)-F_0(x))^i$$ ,å…¶ä¸­$G^i$ä¸º$G$çš„$i$é˜¶å¯¼å‡½æ•°. \n\nå–å‰ä¸¤é¡¹ $$G(F(x))\\equiv G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))\\pmod{x^n}$$ \n\nè€ƒè™‘åˆ°$G(F(x))\\equiv 0\\pmod{x^n}$ $$F(x)\\equiv F_0(x)-\\frac{G(F_0(x))}{G'(F_0(x))}\\pmod{x^n}$$ \n\nè¾¹ç•Œæ¡ä»¶å³$f[0]=e^{a_0}$ï¼Œå‘ä¸Šè¿­ä»£å³å¯. \n\nå›åˆ°æœ¬é¢˜ï¼Œè€ƒè™‘åˆ° $$B(x)\\equiv e^{A(x)}\\pmod{x^n}$$ \n\nå³ $$\\ln B(x)-A(x)\\equiv0\\pmod{x^n}$$ \n\näºæ˜¯ä»¤ $$G(B(x))\\equiv\\ln B(x)-A(x)\\pmod{x^n}$$ \n\nç”±äº$A(x)$ä¸ºå¸¸æ•°ï¼Œ $$G'(B(x))=B^{-1}(x)$$ ï¼Œå¥—ç‰›é¡¿è¿­ä»£ $$B(x)\\equiv B_0(x)(1-\\ln B_0(x)+A(x))\\pmod{x^n}$$\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<Z> a(n);\n    for (auto &x : a)\n        cin >> x;\n    Poly<P> p(a);\n    auto b = p.exp(n);\n    for (auto x : b)\n        cout << x << ' ';\n    cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.10 å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼\n\nåŸç†ä¸ä¼šï¼ŒæŠ„å°±è¡Œã€‚\n\nç»™å®šä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ $f(x)$ ï¼Œç°åœ¨è¯·ä½ å¯¹äº $i \\in [1,m]$ ï¼Œæ±‚å‡º $f(a_i)$ ã€‚***æ³¨æ„æ˜¯$n$æ¬¡ï¼Œæ„å‘³ç€æœ‰$n+1$é¡¹***ã€‚\n\n$n,m \\in [1,64000]$ï¼Œ$a_i,[x^i]f(x) \\in [0,998244352]$ ã€‚\n\n$[x^i]f(x)$ è¡¨ç¤º $f(x)$ çš„ $i$â€‹ æ¬¡é¡¹ç³»æ•°ã€‚\n\n```cpp\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    Poly<P> f(n + 1);\n    for (auto &v : f)\n    {\n        cin >> v;\n    }\n    vector<Z> x(m);\n    for (auto &v : x)\n    {\n        cin >> v;\n    }\n    auto fx = f.eval(x);\n    for (auto v : fx)\n    {\n        cout << v << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.11 å¤šé¡¹å¼å¿«é€Ÿæ’å€¼/æ‹‰æ ¼æœ—æ—¥å¿«é€Ÿæ’å€¼\n\nä»¥ä¸‹é»˜è®¤$mid=\\lfloor\\frac{l+r}{2}\\rfloor$\n\nç”±æ‹‰æ ¼æœ—æ—¥å·®å€¼å…¬å¼$\\large F(x)=\\sum_{i=1}^n y_i\\prod_{j\\neq i}\\frac{x-x_j}{x_i-x_j}$åŒ–ç®€å¾—åˆ°\n$$\n\\large F(x)=\\sum_{i=1}^n \\frac{y_i}{\\prod_{j\\neq i}(x_i-x_j)}\\prod_{j\\neq i}(x-x_j)\n$$\nè®¾$\\large \\delta(x)=\\prod_{i=1}^n(x-x_i)$ï¼Œåˆ™æ˜¾ç„¶æœ‰æ´›å¿…è¾¾æ³•åˆ™ä¸‹ï¼Œ$\\large \\prod_{j\\neq i}(x_i-x_j)=\\lim_{x\\to x_i}\\frac{\\delta(x)}{x-x_i}=\\delta'(x_i)$\n\nå¯¹$\\delta(x)$åˆ†æ²»$NTT$ï¼ˆç±»ä¼¼å¿«é€Ÿå¹‚é‚£ç§å°±è¡Œäº†ï¼‰ï¼Œæ±‚å¯¼åå¤šç‚¹æ±‚å€¼å¾—åˆ°$\\delta'(x_i)$.\n\næ¥ä¸‹æ¥ç»§ç»­æ­£å®—åˆ†æ²»$NTT$å³å¯ï¼Œè®¾$G_{l,r}(x)=\\prod_{i=l}^r(x-x_i)$ï¼Œ$H_{l,r}$ä¸º$(x_l,y_l),\\cdots,(x_r,y_r)$æ’å‡ºæ¥çš„å¤šé¡¹å¼ï¼Œå³$\\sum_{i=l}^r \\frac{y_i}{\\delta'(x_i)}\\prod_{j\\neq i,l\\le j\\le r}(x-x_j)$ï¼Œåˆ™æœ‰\n$$\nG_{l,r}=G_{l,mid}\\ \\cdot\\ G_{mid+1,r}\\\\\nH_{l,r}=H_{l,mid}\\ \\cdot G_{mid+1,r}\\ +\\ H_{mid+1,r}\\ \\cdot\\ G_{l,mid}\n$$\n\n\nåˆ†æ²»$NTT$å³å¯ã€‚å¤æ‚åº¦$O(nlog^2n)$\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.12 äºŒç»´å·ç§¯\n\n$$\n\\large s_{i,j}=\\sum_{x_1\\circ x_2=i,y_1*y_2=j}a_{x_1,y_1}\\times b_{x_2,y_2}\n$$\n\nåˆ†5æ­¥ï¼š\n\n1.å¯¹$a$å’Œ$b$çš„æ¯ä¸€è¡Œåšæ™®é€š$DFT$æˆ–å¯¹åº”$FWT$\n\n2.å¯¹$a$å’Œ$b$çš„æ¯ä¸€åˆ—åšæ™®é€š$DFT/FWT$\n\n3.æ–°å»ºçŸ©é˜µ$s$ï¼Œ$s_{i,j}=a_{i,j}b_{i,j}$\n\n4.å¯¹$s$çš„æ¯ä¸€**åˆ—**åšæ™®é€š$IDFT/IFWT$(åˆ«å¿˜äº†åšå®Œä¹‹åä¹˜ä¸Šæ¯åˆ—é•¿åº¦çš„é€†å…ƒ)\n\n5.å¯¹$s$çš„æ¯ä¸€**è¡Œ**åšæ™®é€š$IDFT/IFWT$(åˆ«å¿˜äº†åšå®Œä¹‹åä¹˜ä¸Šæ¯è¡Œé•¿åº¦çš„é€†å…ƒ)\n\nç„¶å$s$å°±æ˜¯è¦æ±‚çš„ç»“æœäº†ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 3.13 æ™®é€šç”Ÿæˆå‡½æ•°æ“ä½œ\n\næ™®é€šç”Ÿæˆå‡½æ•°æ“ä½œç»„åˆæ•°å­¦è®¡æ•°é—®é¢˜ã€‚\n\nä¸¾ä¸€ä¸ªä¾‹å­ï¼š\n\nä¸€ä¸ªé•¿åº¦ä¸º$n$çš„æ•°åˆ—ï¼Œä»ä¸­å–å‡º$s$ä¸ªæ•°ï¼Œè¦æ±‚å¼‚æˆ–ç»“æœä¸º$k$çš„æ–¹æ¡ˆæ•°ã€‚\n\næ“çºµç”Ÿæˆå‡½æ•°ï¼š\n$$\nF(x,y)=\\prod_{i=1}^n(1+x^{a_i}y)\n$$\nè¿™é‡Œ$x$ä¸ºå¼‚æˆ–å·ç§¯ï¼Œ$y$ä¸ºæ­£å·ç§¯ã€‚\n\nåˆ™ç­”æ¡ˆä¸º$[x^{k}y^s]F(x,y)$ï¼Œå³å¯¹åº”é¡¹ç³»æ•°ã€‚ä¸€èˆ¬ä¸ä¼šæœ‰äºŒç»´çš„æƒ…å†µï¼ŒäºŒç»´æ˜¾ç„¶æ— æ³•ç¡®å®šå•ä½æ ¹ï¼Œä¸€èˆ¬æ˜¯éœ€è¦æš´åŠ›å·ç§¯çš„ã€‚æœ¬ç”Ÿæˆå‡½æ•°åŸé¢˜$ABC367G$ä¸­$y$æ˜¯ä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡$100$â€‹çš„å¾ªç¯å·ç§¯ï¼Œé—®é¢˜åªåœ¨å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢ä¸Šã€‚\n\nè€ƒè™‘å¯¹$1+x^{a_i}y$è¿›è¡Œå¿«é€Ÿæ²ƒå°”ä»€ç‚¹å€¼å˜æ¢ï¼Œè®°å˜æ¢åçš„ç‚¹å€¼åºåˆ—ä¸º$FWT(x^{a_i})=\\{g_{a_i}^{w}\\}$ï¼Œåˆ™ç”±äºå°†$y$äºæ­¤ç»´åº¦è§†ä½œå¸¸æ•°ï¼Œç”±äºæ²ƒå°”ä»€å˜æ¢çº¿æ€§æ€§æœ‰$FWT(1+x^{a_i}y)=\\{1+g_{a_i}^{w}y\\}$â€‹.\n\nç”±äºæ²ƒå°”ä»€å˜æ¢ç‰¹æ€§ï¼Œå¹‚æ¬¡å‡½æ•°$x^n$çš„æ²ƒå°”ä»€å˜æ¢åºåˆ—åªæœ‰$1$å’Œ$-1$ä¸¤ç§æƒ…å†µï¼Œæ‰€ä»¥æ²ƒå°”ä»€åºåˆ—å¯¹åº”ä½ç½®ç‚¹å€¼ç›¸ä¹˜åæœ‰$FWT(F(x,y))_w=[y^0]\\prod_{i=1}^n(1+y)^{c_w}(1-y)^{n-c_w}$ï¼Œå…¶ä¸­$c_w$ä¸º$FWT(x_{a_i})_w$ä¸º$1$çš„$i$çš„æ•°é‡ã€‚å…³äº$c_w$æ˜¾ç„¶æœ‰$c_w+(n-c_w)\\times(-1)=\\sum_{i=1}^nh_{a_i}^w$ï¼Œç­‰å¼å³è¾¹å¯ä»¥ç”±$\\sum_{i=1}^nx^{a_i}$å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢å¾—åˆ°ï¼ˆ$FWT$çº¿æ€§æ€§ï¼‰\n\nç”±äº$y$â€‹ç»´åº¦å¾ˆå°ï¼Œæš´åŠ›å·ç§¯å·å‡ºæ¥ï¼Œæœ€åå¿«é€Ÿæ²ƒå°”ä»€é€†å˜æ¢åå°±æ˜¯ç»“æœå¤šé¡¹å¼ï¼Œç›´æ¥é”ç»“æœå°±è¡Œäº†ã€‚\n\n```cpp\nvector<int> f, a, b, finalans;\nvector<vector<int>> presum, presum2;\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    f.assign(1 << 20, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        f[x]++;\n    }\n    a = fwt_xor(f);\n    for (int i = 0; i < (1 << 20); i++)\n    {\n        a[i] = ((n + a[i]) % mod * (499122177)) % mod;\n    }\n    // æš´åŠ›é¢„å¤„ç†å¾ªç¯å·ç§¯(1+y)^a ä»¥åŠ(1-y)^a\n    presum.assign(n + 1, vector<int>(m + 1)), presum2 = presum;\n    presum[0][0] = presum2[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            presum[i][j] = (presum[i][j] + presum[i - 1][j]) % mod;                              //(1+y)\n            presum[i][(j + 1) % m] = (presum[i][(j + 1) % m] + presum[i - 1][j]) % mod;          //(1+y)\n            presum2[i][j] = (presum2[i][j] + presum2[i - 1][j]) % mod;                           //(1-y)\n            presum2[i][(j + 1) % m] = (presum2[i][(j + 1) % m] - presum2[i - 1][j] + mod) % mod; //(1-y)\n        }\n    }\n    finalans.assign(1 << 20, 0);\n    for (int i = 0; i < (1 << 20); i++) // å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢ç¬¬iä½çš„å€¼\n    {                                   //(1+y)^(a[i])*(1-y)^(n-a[i])\n                                        // æ±‚y^0ï¼Œå³y^mé¡¹\n        for (int j = 0; j < m; j++)\n        {\n            finalans[i] = (finalans[i] + (presum[a[i]][j] * presum2[n - a[i]][(m - j) % m] % mod)) % mod;\n        }\n    }\n    b = ifwt_xor(finalans);\n    i64 ans = 0;\n    for (int i = 0; i < (1 << 20); i++)\n    {\n        ans = (ans + b[i] * power(i, k) % mod) % mod;\n    }\n    cout << ans << endl;\n}\n```\n\nå…¶ä»–è§$OI-Wiki$\n\n#### 3.14 æŒ‡æ•°ç”Ÿæˆå‡½æ•°æ“ä½œ\n\næ“çºµæ’åˆ—æ•°å­¦è®¡æ•°é—®é¢˜ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n### 4. è®¡ç®—å‡ ä½•ç›¸å…³\n\n#### 4.1 å¹³é¢å‡ ä½•ï¼ˆwith Complex)\n\n```cpp\n/**   å¹³é¢å‡ ä½•ï¼ˆwith. complexï¼‰\n *    2023-09-04: https://qoj.ac/submission/164445\n**/\nusing Point = std::complex<long double>;\n\n#define x real\n#define y imag\n\nlong double dot(const Point &a, const Point &b) {\n    return (std::conj(a) * b).x();\n}\n\nlong double cross(const Point &a, const Point &b) {\n    return (std::conj(a) * b).y();\n}\n\nlong double length(const Point &a) {\n    return std::sqrt(dot(a, a));\n}\n\nlong double dist(const Point &a, const Point &b) {\n    return length(a - b);\n}\n\nlong double get(const Point &a, const Point &b, const Point &c, const Point &d) {\n    auto e = a + (b - a) * cross(c - a, d - a) / cross(b - a, d - c);\n    return dist(d, e);\n}\n```\n\n#### 4.2 äºŒç»´å‡¸åŒ…+æ—‹è½¬å¡å£³ï¼ˆå‡¸åŒ…ç›´å¾„ï¼‰\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// #define DEBUG 1\n#define i64 long long\n#define d32 double\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e6 + 9;\nstruct node\n{\n    i64 x, y;\n    bool operator<(const node &a) const\n    {\n        return x == a.x ? y < a.y : x < a.x;\n    }\n    bool operator==(const node &a) const\n    {\n        return x == a.x && y == a.y;\n    }\n    node operator-(const node &a) const\n    {\n        return {x - a.x, y - a.y};\n    }\n    i64 operator*(const node &a) const\n    {\n        return x * a.y - y * a.x;\n    }\n    i64 operator^(const node &a) const\n    {\n        return x * a.x + y * a.y;\n    }\n    node operator+(const node &a) const\n    {\n        return {x + a.x, y + a.y};\n    }\n    friend d32 dis(node a, node b)\n    {\n        return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    friend i64 dis2(node a, node b)\n    {\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n};\nint stk[N], tp = 0;\nbool used[N];\n\n//è¿”å›çš„vector0ä½ç©ºå‡ºï¼Œæœ€åä¸€ä½ä¸ºç¬¬ä¸€ä¸ªç‚¹\nvector<node> get_convex(node p[], int n)\n{\n    // stk[] æ˜¯æ•´å‹ï¼Œå­˜çš„æ˜¯ä¸‹æ ‡\n    // p[] å­˜å‚¨å‘é‡æˆ–ç‚¹\n    // h[] å­˜å‚¨å‡¸åŒ…ä¸Šçš„ç‚¹\n    // used[] æ ‡è®°æ˜¯å¦åœ¨å‡¸åŒ…ä¸Š\n    // tp æ ˆé¡¶æŒ‡é’ˆ\n    tp = 0; // åˆå§‹åŒ–æ ˆ\n            // æ ‡è®°æ˜¯å¦åœ¨å‡¸åŒ…ä¸Š\n    for (int i = 1; i <= n; i++)\n    {\n        used[i] = 0;\n    }\n    std::sort(p + 1, p + 1 + n); // å¯¹ç‚¹è¿›è¡Œæ’åº\n    stk[++tp] = 1;\n    // æ ˆå†…æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¸”ä¸æ›´æ–° usedï¼Œä½¿å¾— 1 åœ¨æœ€åå°é—­å‡¸åŒ…æ—¶ä¹Ÿå¯¹å•è°ƒæ ˆæ›´æ–°\n    for (int i = 2; i <= n; ++i)\n    {\n        while (tp >= 2 // ä¸‹ä¸€è¡Œ * æ“ä½œç¬¦è¢«é‡è½½ä¸ºå‰ç§¯\n               && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n            used[stk[tp--]] = 0;\n        used[i] = 1; // used è¡¨ç¤ºåœ¨å‡¸å£³ä¸Š\n        stk[++tp] = i;\n    }\n    int tmp = tp; // tmp è¡¨ç¤ºä¸‹å‡¸å£³å¤§å°\n    for (int i = n - 1; i > 0; --i)\n        if (!used[i])\n        {\n            // â†“æ±‚ä¸Šå‡¸å£³æ—¶ä¸å½±å“ä¸‹å‡¸å£³\n            while (tp > tmp && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n                used[stk[tp--]] = 0;\n            used[i] = 1;\n            stk[++tp] = i;\n        }\n    vector<node> h;\n    h.push_back({-INF, -INF});    // ä» 1 å¼€å§‹å­˜å‚¨å‡¸åŒ…ä¸Šçš„ç‚¹\n    for (int i = 1; i <= tp; ++i) // å¤åˆ¶åˆ°æ–°æ•°ç»„ä¸­å»\n        h.push_back(p[stk[i]]);\n    int ans = tp - 1;\n    return h;\n}\nbool is[N];\n// æ±‚å‡¸åŒ…ç›´å¾„ï¼Œè¿”å›ç›´å¾„çš„å¹³æ–¹\ni64 get_longest(vector<node> sta)\n{\n#ifdef DEBUG\n    cout << \"-------------------DEBUG-------------------\" << endl;\n    cout << \"points in convex hull:\" << endl;\n    for (auto i : sta)\n    {\n        cout << i.x << \" \" << i.y << endl;\n    }\n    cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n    i64 mx = 0;               // æ±‚å‡¸åŒ…ç›´å¾„\n    int top = sta.size() - 1; // å°†å‡¸åŒ…ä¸Šçš„èŠ‚ç‚¹ç¼–å·å­˜åœ¨æ ˆé‡Œï¼Œç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªèŠ‚ç‚¹ç¼–å·ç›¸åŒ\n    int j = 3;\n    if (top < 4)\n    {\n        mx = dis2(sta[1], sta[2]);\n        return mx;\n    }\n    for (int i = 1; i < top; i++)\n    {\n        while ((sta[i + 1] - sta[i]) * (sta[j] - sta[i + 1]) <= (sta[i + 1] - sta[i]) * (sta[j % top + 1] - sta[i + 1]))\n        {\n#ifdef DEBUG\n            cout << \"-------------------DEBUG-------------------\" << endl;\n            cout << \"i=\" << i << \" j=\" << j << endl;\n            cout << \"sta[i]=\" << sta[i].x << \" \" << sta[i].y << endl;\n            cout << \"sta[i+1]=\" << sta[i + 1].x << \" \" << sta[i + 1].y << endl;\n            cout << \"sta[j]=\" << sta[j].x << \" \" << sta[j].y << endl;\n            cout << \"sta[j%top+1]=\" << sta[j % top + 1].x << \" \" << sta[j % top + 1].y << endl;\n            cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n            j = j % top + 1;\n        }\n#ifdef DEBUG\n        cout << \"-------------------DEBUG-------------------\" << endl;\n        cout << \"mx=\" << mx << endl;\n        cout << \"dis2(sta[\" << i << \"],sta[\" << j << \"])=\" << dis2(sta[i], sta[j]) << endl;\n        cout << \"dis2(sta[\" << i + 1 << \"],sta[\" << j << \"])=\" << dis2(sta[i + 1], sta[j]) << endl;\n        cout << \"-------------------DEBUG-------------------\" << endl;\n#endif\n        mx = max(mx, max(dis2(sta[i], sta[j]), dis2(sta[i + 1], sta[j])));\n    }\n    return mx;\n}\nnode a[N + 1], b[N + 1];\nvoid solve()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i].x >> a[i].y;\n    }\n    vector<node> h = get_convex(a, n);\n    int cnt = h.size() - 2;\n    d32 C = 0;\n    for (int i = 1; i <= cnt; i++)\n    {\n        C += dis(h[i], h[i + 1]);\n    }\n\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> b[i].x >> b[i].y;\n    }\n    h.clear();\n    h = get_convex(b, n);\n    d32 D = sqrtl(get_longest(h));\n    // cout << C << endl;\n    cout << fixed << setprecision(10) << C + 2 * M_PI * D << endl;\n    return;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5. ç»„åˆæ•°å­¦ç›¸å…³\n\n#### 5.1 ç»„åˆæ•°æ¨è¾‰ä¸‰è§’+çº¿æ€§é€’æ¨é€†å…ƒ\n\n```cpp\n#include<iostream>\n\nusing namespace std;\nint n,m;\nint f[1005][1005];\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n    {\n        f[i][i]=1;\n        f[i][0]=1;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            f[i][j]=f[i-1][j]+f[i-1][j-1];\n    cout<<f[n][m];\n    return 0;\n}\n\n```\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod;\nconst int maxn = 6e6 + 9;\nint inv[maxn];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a;\n    cin >> a >> mod;\n    inv[1] = 1;\n    cout << 1 << endl;\n    for (int i = 2; i <= a; i++)\n    {\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n        cout << inv[i] << endl;\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 5.2 å¢å¡æ–¯å®šç†/æ‰©å±•å¢å¡æ–¯å®šç†\n\n$$\nC_n^{m}\\ mod\\ p=C_{\\lfloor \\frac{n}{p}\\rfloor}^{\\lfloor \\frac{m}{p}\\rfloor}\\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p}\\ mod \\ p\n$$\n\nå¼ºåˆ¶è¦æ±‚$p$ä¸ºè´¨æ•°ã€‚å¤æ‚åº¦$O(p+Tlogn)$\n\n```cpp\nlong long C(long long n,long long m,long long mod)\n{\n    if(m>n&&n==0)return 0;\n    if(m==0)return 1;\n    return ((frac[n]*invq[m]%mod)*invq[n-m])%mod;\n}\n//é˜¶ä¹˜çš„å€¼å’Œé€†å…ƒé¢„å¤„ç†æ˜¯çº¿æ€§çš„é€’æ¨\nlong long Lucas(long long n, long long m, long long p)\n{\n    if (m == 0)\n        return 1;\n    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;\n}\n```\n\nå¯¹äºæ‰©å±•å¢å¡æ–¯å®šç†ï¼Œä¸å†è¦æ±‚$p$å¿…é¡»æ˜¯è´¨æ•°ï¼ŒåŸç†è§$OI-Wiki$ã€‚æ³¨æ„ï¼Œå•æ¬¡è¯¢é—®$O(plogp)$å¤æ‚åº¦ï¼ŒåŸºæœ¬ä¸å¯èƒ½æ”¯æŒå¤§é‡æ¬¡æ•°è¯¢é—®ã€‚æ¨¡æ¿ä¹Ÿæ˜¯ä»…æ”¯æŒæŸ¥è¯¢ä¸€æ¬¡çš„ã€‚\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <climits>\n#include <cmath>\nusing namespace std;\nnamespace ExLucas\n{\n    const int N = 1e6;\n    typedef long long ll;\n    ll n, m, p;\n    inline ll power(ll a, ll b, const ll p = LLONG_MAX)\n    {\n        ll ans = 1;\n        while (b)\n        {\n            if (b & 1)\n                ans = ans * a % p;\n            a = a * a % p;\n            b >>= 1;\n        }\n        return ans;\n    }\n    ll fac(const ll n, const ll p, const ll pk)\n    {\n        if (!n)\n            return 1;\n        ll ans = 1;\n        for (int i = 1; i < pk; i++)\n            if (i % p)\n                ans = ans * i % pk;\n        ans = power(ans, n / pk, pk);\n        for (int i = 1; i <= n % pk; i++)\n            if (i % p)\n                ans = ans * i % pk;\n        return ans * fac(n / p, p, pk) % pk;\n    }\n    ll exgcd(const ll a, const ll b, ll &x, ll &y)\n    {\n        if (!b)\n        {\n            x = 1, y = 0;\n            return a;\n        }\n        ll xx, yy, g = exgcd(b, a % b, xx, yy);\n        x = yy;\n        y = xx - a / b * yy;\n        return g;\n    }\n    ll inv(const ll a, const ll p)\n    {\n        ll x, y;\n        exgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n    ll C(const ll n, const ll m, const ll p, const ll pk)\n    {\n        if (n < m)\n            return 0;\n        ll f1 = fac(n, p, pk), f2 = fac(m, p, pk), f3 = fac(n - m, p, pk), cnt = 0;\n        for (ll i = n; i; i /= p)\n            cnt += i / p;\n        for (ll i = m; i; i /= p)\n            cnt -= i / p;\n        for (ll i = n - m; i; i /= p)\n            cnt -= i / p;\n        return f1 * inv(f2, pk) % pk * inv(f3, pk) % pk * power(p, cnt, pk) % pk;\n    }\n    ll a[N], c[N];\n    int cnt;\n    inline ll CRT()\n    {\n        ll M = 1, ans = 0;\n        for (int i = 0; i < cnt; i++)\n            M *= c[i];\n        for (int i = 0; i < cnt; i++)\n            ans = (ans + a[i] * (M / c[i]) % M * inv(M / c[i], c[i]) % M) % M;\n        return ans;\n    }\n    ll exlucas(const ll n, const ll m, ll p)\n    {\n        ll tmp = sqrt(p);\n        for (int i = 2; p > 1 && i <= tmp; i++)\n        {\n            ll tmp = 1;\n            while (p % i == 0)\n                p /= i, tmp *= i;\n            if (tmp > 1)\n                a[cnt] = C(n, m, i, tmp), c[cnt++] = tmp;\n        }\n        if (p > 1)\n            a[cnt] = C(n, m, p, p), c[cnt++] = p;\n        return CRT();\n    }\n    int work()\n    {\n        ios::sync_with_stdio(false);\n        cin >> n >> m >> p;\n        cout << exlucas(n, m, p);\n        return 0;\n    }\n}\nint main()\n{\n    return zyt::work();\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 5.3 $Catlan$æ•°ä¸$Fibonacci$æ•°åˆ—\n\n$H_n=\\frac{2n!}{n+1},n\\ge 2$ï¼Œç»´æŠ¤ä¸€ç§ç»å¯¹å¤§äºç­‰äºçš„å…³ç³»ï¼Œæ¯”å¦‚å›ºå®šå…¥æ ˆé¡ºåºï¼Œæœ‰å¤šå°‘ç§å‡ºæ ˆé¡ºåºï¼ˆä¿è¯æ ˆå†…å…ƒç´ æ•°é‡ä¸€å®šå¤§äºç­‰äºæ€»å‡ºæ ˆå…ƒç´ æ•°é‡ï¼‰â€‹\n\næ•°åˆ—çš®äºšè¯ºå‘¨æœŸä¸è¶…è¿‡$6k$ï¼Œ$k$â€‹ä¸ºæ¨¡æ•°ã€‚å¼ºè¡Œè§£å‘¨æœŸå¯ä»¥è€ƒè™‘çŸ©é˜µåŸæ ¹è®¡ç®—ï¼Œå› ä¸ºçŸ©é˜µ$mod$$p$æœ€å°å‘¨æœŸæ˜¯çš®äºšè¯ºå‘¨æœŸï¼Œæ‰€ä»¥æ ¹å·å¼€$\\sqrt {6k+1}$.\n\n```cpp\n#include <bits/stdc++.h>\n#define umap unordered_map\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstring S;\nll MOD;\n\nconst int L = 2;\nconst ull BASE = 13331;\nstruct Matrix {\n    ll M[L+1][L+1];\n    ll *operator[](int p) {\n        return M[p];\n    }\n    void clear() {\n        memset(M, 0, sizeof M);\n    }\n    void reset() {\n        clear();\n        for (int i = 1; i <= L; i++)\n            M[i][i] = 1;\n    }\n    Matrix friend operator*(Matrix A, Matrix B) {\n        Matrix C; C.clear();\n        for (int i = 1; i <= L; i++)\n            for (int k = 1; k <= L; k++)\n                for (int j = 1; j <= L; j++)\n                    (C[i][j] += A[i][k] * B[k][j] % MOD) %= MOD;\n        return C;\n    }\n    ull hs() { // hash\n        ull ret = 0;\n        for (int i = 1; i <= L; i++)\n            for (int j = 1; j <= L; j++)\n                ret = ret * BASE + M[i][j];\n        return ret;\n    }\n\n};\nMatrix qpow(Matrix A, ll b) {\n    Matrix Ret; Ret.reset();\n    while (b) {\n        if (b & 1)\n            Ret = Ret * A;\n        A = A * A;\n        b >>= 1;\n    }\n    return Ret;\n}\n\nll BSGS(Matrix A, Matrix B) {\n    umap<ull, ll> mp;\n    ll t = sqrt(MOD * 6) + 1;\n    Matrix Cur; Cur.reset();\n    for (ll i = 1; i <= t; i++) {\n        mp[(Cur * B).hs()] = i-1;\n        Cur = A * Cur;\n    }\n    Matrix Cur2 = Cur;\n    for (ll i = 1; i <= t; i++) {\n        if (mp.find(Cur2.hs()) != mp.end())\n            return i * t - mp[Cur2.hs()];\n        Cur2 = Cur * Cur2;\n    }\n    return -1;\n}\n\nMatrix A, I;\nvoid init() {\n    A[1][1] = 1; A[1][2] = 1;\n    A[2][1] = 1; A[2][2] = 0;\n\n    I[1][1] = 1; I[1][2] = 0;\n    I[2][1] = 0; I[2][2] = 1;\n}\n\nll fib(ll n) {\n    if (n == 0)\n        return 0;\n    return qpow(A, n-1)[1][1];\n}\n\nint main() { ios::sync_with_stdio(0); cin.tie(0);\n    cin >> S >> MOD;\n    if (MOD == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    init();\n    ll pi = BSGS(A, I);\n    ll n = 0;\n    for (auto c : S)\n        n = (n * 10 + (c - '0')) % pi;\n    cout << fib(n) << endl;\n    return 0;\n}\n```\n\n\n\næŸ¥$OI-Wiki$â€‹\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6. ä½è¿ç®—ç›¸å…³æŠ€å·§æ‚è°ˆ\n\n1. å¼‚æˆ–æ˜¯ç‰¹æ®Šçš„çŸ©é˜µåŠ æ³•ï¼Œåœ¨$<Z_2^n,xor,and>$ä¸‹ã€‚\n2. è¿ç»­ä»$1$åˆ°$n$çš„å¼‚æˆ–å’Œæ˜¯æœ‰è§„å¾‹çš„ï¼Œå¯¹äºæ¨¡$4$å‰©ä½™ä¸‹æœ‰ä½™$1$å¾—$1$ï¼Œä½™$2$å¾—$n+1$ï¼Œä½™$3$å¾—$0$ï¼Œä½™$0$å¾—$n$â€‹.\n3. åŒºé—´å¼‚æˆ–å’Œå¯è¡¨ç¤ºä¸¤ä¸ªå‰ç¼€å¼‚æˆ–çš„å¼‚æˆ–å’Œã€‚\n4. å¸¦é€’å½’å½¢å¼çš„$f(x)=f(\\frac{x}{3})$ç­‰ä¹‹ç±»çš„å…³æ³¨ä½è¿ç®—è¿›åˆ¶è¡¨ç¤ºè§„å¾‹ã€‚\n5. $a+b=2(a\\&b)+(a\\oplus b)$\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 3. æ‚é¡¹æŠ€å·§\n\n### 3.1 æ™®é€šè«é˜Ÿ\n\nå‡è®¾$n=m$,é‚£ä¹ˆå¯¹äºåºåˆ—ä¸Šçš„åŒºé—´è¯¢é—®é—®é¢˜,å¦‚æœä»$[l,r]$çš„ç­”æ¡ˆèƒ½å¤Ÿ$O(1)$æ‰©å±•åˆ°$[l-1,r],[l+1,r],[l,r+1],[l,r-1]$ï¼ˆå³ä¸$[l,r]$ç›¸é‚»çš„åŒºé—´ï¼‰çš„ç­”æ¡ˆ,é‚£ä¹ˆå¯ä»¥åœ¨$O(n\\sqrt n)$â€‹çš„å¤æ‚åº¦å†…æ±‚å‡ºæ‰€æœ‰è¯¢é—®çš„ç­”æ¡ˆã€‚\n\nè«é˜Ÿéœ€è¦ç›¸å½“ç‰›é€¼çš„å¡å¸¸ï¼ŒåŸºæœ¬ä¸Šç¦ç”¨ä¸€åˆ‡$mapSTL$ï¼Œå®åœ¨å¿…è¦éœ€è¦æ‰‹æ“å“ˆå¸Œè¡¨ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define i64 long long\nint block; // è«é˜Ÿåˆ†å—å¤§å°\nstruct node\n{\n    int l, r, id;\n    bool operator<(const node &x) const\n    {\n        if (l / block != x.l / block)\n            return l < x.l;\n        // æ³¨æ„ä¸‹é¢ä¸¤è¡Œä¸èƒ½å†™å°äºï¼ˆå¤§äºï¼‰ç­‰äºï¼Œå¦åˆ™ä¼šå‡ºé”™ï¼ˆè¯¦è§ä¸‹é¢çš„å°ç»†èŠ‚ï¼‰\n        if ((l / block) & 1)\n            return r < x.r;\n        return r > x.r;\n    }\n};\nint sum = 0;\nconst int maxn = 2e5 + 9;\nconst int inf = 1e6 + 9;\nint mp[inf];\nint a[maxn];\nvoid add(int pos)\n{\n    if (mp[a[pos]])\n        sum--;\n    else\n        sum++;\n    mp[a[pos]] ^= 1;\n}\nvoid del(int pos)\n{\n    if (mp[a[pos]])\n        sum--;\n    else\n        sum++;\n    mp[a[pos]] ^= 1;\n}\nint n;\nvoid solve()\n{\n    sum = 0;\n    int n, q;\n    cin >> n >> q;\n    block = sqrt(n);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        mp[a[i]] = 0;\n    }\n    vector<node> qs;\n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        qs.push_back({l, r, i});\n    }\n    vector<int> ans(q);\n    sort(qs.begin(), qs.end());\n    int l = 1, r = 0;\n    for (int i = 0; i < q; i++)//è«é˜Ÿç®—æ³•çµé­‚\n    {\n        while (l > qs[i].l)\n            add(--l);\n        while (r < qs[i].r)\n            add(++r);\n        while (l < qs[i].l)\n            del(l++);\n        while (r > qs[i].r)\n            del(r--);\n        ans[qs[i].id] = sum;\n    }\n    for (int i = 0; i < q; i++)\n    {\n        if (ans[i])\n        {\n            cout << \"NO\" << endl;\n        }\n        else\n            cout << \"YES\" << endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.2 å¸¦ä¿®æ”¹è«é˜Ÿ\n\næ™®é€šè«é˜Ÿç®—æ³•ä¸æ”¯æŒä¿®æ”¹ï¼Œéœ€è¦å¸¦ä¿®æ”¹çš„è«é˜Ÿã€‚å¸¦ä¿®æ”¹è«é˜Ÿå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯åŠ ä¸Šäº†ä¸€ä¸ªæ—¶é—´æˆ³ç»´åº¦ï¼Œå˜æˆäº†å¤šç»´è«é˜Ÿã€‚\n\nç„¶åè·³æ—¶é—´æˆ³å°±è¡Œäº†ï¼Œæ”¹å°‘äº†å°±å¤šæ”¹ï¼Œæ”¹å¤šäº†å°±æ”¹å›å»ã€‚\n\næ³¨æ„ï¼Œå¸¦ä¿®æ”¹è«é˜Ÿå¸¸æ•°è¾ƒå¤§ï¼Œåˆ†å—$n^{\\frac{2}{3}}$ï¼Œæ—¶é—´å¤æ‚åº¦$O(n^{\\frac{5}{3}})$ï¼Œä¸è¦å¸¦å¥‡å¶æ’åºâ€‹\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\nint block;\nstruct qnode\n{\n    int l, r, id, t;\n    bool operator<(const qnode &x) const\n    {\n        if (l / block != x.l / block)\n            return l < x.l;\n        if (r / block != x.r / block)\n            return r < x.r;\n        return t < x.t;\n    };\n};\nvector<array<int, 2>> upd(1);\nvector<int> mp(1e7);\nint sum = 0;\nvoid add(int x)\n{\n    mp[x]++;\n    if (mp[x] == 1)\n        sum++;\n}\nvoid del(int x)\n{\n    mp[x]--;\n    if (mp[x] == 0)\n        sum--;\n}\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    block = pow(n, 2.0 / 3);\n    vector<qnode> query;\n    for (int i = 0, cnt = 0; i < q; i++)\n    {\n        char op;\n        cin >> op;\n        if (op == 'Q')\n        {\n            int l, r;\n            cin >> l >> r;\n            query.emplace_back((qnode){l - 1, r - 1, cnt, upd.size() - 1});\n            cnt++;\n        }\n        else\n        {\n            int x, y;\n            cin >> x >> y;\n            upd.push_back({x - 1, y});\n        }\n    }\n    vector<int> ans(query.size());\n    sort(query.begin(), query.end());\n    int l = 0, r = -1, t = 0;\n    stack<array<int, 2>> stk;\n    for (auto &i : query)\n    {\n        while (l > i.l)\n            add(a[--l]);\n        while (r < i.r)\n            add(a[++r]);\n        while (l < i.l)\n            del(a[l++]);\n        while (r > i.r)\n            del(a[r--]);\n        while (t < i.t)\n        {\n            t++;\n            if (l <= upd[t][0] && upd[t][0] <= r)\n            {\n                del(a[upd[t][0]]);\n                add(upd[t][1]);\n            }\n            stk.push({upd[t][0], a[upd[t][0]]});\n            a[upd[t][0]] = upd[t][1];\n        }\n        while (t > i.t)\n        {\n            if (l <= upd[t][0] && upd[t][0] <= r)\n            {\n                del(a[upd[t][0]]);\n                add(stk.top()[1]);\n            }\n            a[upd[t][0]] = stk.top()[1];\n            stk.pop();\n            t--;\n        }\n        ans[i.id] = sum;\n    }\n    for (auto i : ans)\n        cout << i << endl;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3.3 æ ‘ä¸Šè«é˜Ÿ\n\nç»™å®šä¸€ä¸ª$n$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªæ•´æ•°ï¼Œé—®$u$åˆ°$v$çš„è·¯å¾„ä¸Šæœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•´æ•°ã€‚\n\nè½¬æˆæ¬§æ‹‰åºåŒºé—´é—®é¢˜ã€‚\n\nå…·ä½“åšæ³•ï¼šè®¾æ¯ä¸ªç‚¹çš„ç¼–å·$a$é¦–æ¬¡å‡ºç°çš„ä½ç½®$first[a]$ï¼Œæœ€åå‡ºç°çš„ä½ç½®ä¸º$last[a]$ï¼Œé‚£ä¹ˆå¯¹äºè·¯å¾„$xâ†’y$ï¼Œè®¾$first[x]\\le first[y]$ï¼ˆä¸æ»¡è¶³åˆ™`swap`ï¼Œè¿™ä¸ªæ“ä½œçš„æ„ä¹‰åœ¨äºï¼Œå¦‚æœ$x$ã€$y$åœ¨ä¸€æ¡é“¾ä¸Šï¼Œåˆ™$x$ä¸€å®šæ˜¯$y$çš„ç¥–å…ˆæˆ–ç­‰äº$y$ï¼‰ï¼Œå¦‚æœ$lca(x,y)=x$ï¼Œåˆ™ç›´æ¥æŠŠ$[first[x],first[y]]$çš„åŒºé—´æ‰¯è¿‡æ¥ç”¨ï¼Œåä¹‹ä½¿ç”¨$[last[x],first[y]]$åŒºé—´ï¼Œä½†è¿™ä¸ªåŒºé—´å†…ä¸åŒ…å«$x$å’Œ$y$çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ŒæŸ¥è¯¢çš„æ—¶å€™åŠ ä¸Šå³å¯ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 4. å›¾è®º\n\n## 1. æœ€çŸ­è·¯\n\næœ€çŸ­è·¯ï¼Œå›¾ä¸Šé—®é¢˜ï¼Œåˆ†å±‚å›¾æœ€çŸ­è·¯ï¼Œæœ€çŸ­è·¯å½¢å¼ä¼˜åŒ–$dp$â€‹.\n\næœ€çŸ­è·¯å…·æœ‰ç±»ä¼¼$dp$çš„æœ€ä¼˜å­ç»“æ„æ€§è´¨ï¼Œåˆ¤å®šä¸€æ¡è¾¹$(u,v)$å±äºæœ€çŸ­è·¯$i\\to j$çš„ä¸€æ¡è¾¹ï¼Œå½“ä¸”ä»…å½“$dis_{i,u}+w+dis_{v,j}=dis_{i,j}$\n\n### 1.1 Dijkstra\n\nç¨€ç–å›¾å †ä¼˜åŒ–ï¼Œå¤æ‚åº¦$O((n+m)logn)$ï¼Œåªèƒ½å¤„ç†å®Œå…¨æ­£è¾¹æƒå›¾ã€‚å¦‚æœæœ‰è´Ÿè¾¹æƒéœ€è¦å‚è€ƒè´¹ç”¨æµä¸­å¯¹å¶$Dijkstra$ï¼Œä½¿ç”¨åŠ¿èƒ½å‡½æ•°è¿›è¡Œè¯„ä¼°ã€‚\n\n```cpp\n//mlogn\n#include<bits/stdc++.h>//å¤„ç†å®Œå…¨æ­£æƒæœ‰å‘å›¾ï¼Œå¯ä»¥æœ‰ç¯\n//å°†ç»“ç‚¹åˆ†ä¸ºä¸¤ç±»ï¼Œä¸æ–­æ¾å¼›ï¼Œä½†æ³¨æ„ç¡®å®šä¸€ä¸ªèŠ‚ç‚¹åæˆ‘ä»¬ä¾¿ä¸å†è¿›è¡Œæ›´æ–°è¿™ä¸ªèŠ‚ç‚¹äº†ï¼ˆæ‰€ä»¥è¿™æ˜¯dijçš„çŸ­è§†æ€§ï¼‰ï¼Œæ‰€ä»¥æ— æ³•å¤„ç†è´Ÿæƒï¼Œå› ä¸ºè´Ÿæƒå¯èƒ½ä¼šæ›´æ–°æˆ‘ä»¬å·²åŠ å…¥çš„èŠ‚ç‚¹ã€‚\nusing namespace std;\nconst int N=1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,s,u,v,sum;\nstruct node{\n    int to,val;\n};\nvector<vector<node> >edge;\nint dis[N],vis[N];\nvoid dijkstra(){\n    memset(dis,inf,sizeof(dis));//åˆå§‹åŒ–\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;//å°æ ¹å †å¯åŠ¨\n    q.push({0,s});//è·ç¦»åœ¨å‰ï¼Œç‚¹åœ¨åï¼Œå› ä¸ºpairé»˜è®¤å…ˆæ’å‰é¢çš„\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second]){\n            if(dis[j.to]>dis[k.second]+j.val){\n                dis[j.to]=min(dis[j.to],dis[k.second]+j.val);\n                q.push({dis[j.to],j.to});\n            }\n        } \n        //å¯¹æ‰€æœ‰ç›¸é‚»é¡¶ç‚¹è¿›è¡Œæ¾å¼›ï¼Œdisæ˜¯åˆ°æºç‚¹çš„è·ç¦»\n    }\n}\nint main(){\n    cin>>n>>m>>s;\n    edge.resize(n+1);\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        edge[u].push_back({v,sum});\n    }\n    dijkstra();\n    for(int i=1;i<=n;i++){\n        if(!vis[i])cout<<(1<<31)-1<<\" \";//è¯´æ˜ä¸ç›¸è¿\n        else cout<<dis[i]<<\" \";\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.2  Floyed\n\nä»¥$O(n^3)$çš„æ–¹å¼æš´åŠ›é¢„å¤„ç†æ‰€æœ‰çš„æœ€çŸ­è·¯ï¼Œæœ¬è´¨æ˜¯è¿é€šçŸ©é˜µçš„ä¼ é€’é—­åŒ…ã€‚é€‚åˆæ•°æ®èŒƒå›´æå°çš„å¤§é‡çš„æœ€çŸ­è·¯è¯¢é—®æ“ä½œã€‚æ›¾ç»åœ¨$Atcoder$â€‹å‡ºç°è¿‡ã€‚\n\næš´åŠ›æšä¸¾é¡ºåºåƒä¸‡åˆ«åäº†ã€‚\n\n```cpp\ncin>>n>>m>>s;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(i!=j)a[i][j]=inf;//åˆå§‹åŒ–\n            else a[i][j]=0;\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        a[u][v]=min(a[u][v],sum);//åº”ä»˜é‡è¾¹\n    }\n    for(int k=1;k<=n;k++)//å…ˆæšä¸¾æ¯ä¸ªä¸­é—´ç‚¹ï¼Œæ¥æ›´æ–°iï¼Œjï¼Œå¿…é¡»å…ˆè¿™ä¹ˆåš\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);//æ ¸å¿ƒè¿‡ç¨‹ï¼šå€ŸåŠ©æ¯ä¸ªä¸­é—´ç‚¹è¿›è¡Œæ¾å¼›æ“ä½œ\n    for(int i=1;i<=n;i++){\n        if(a[s][i]==inf)cout<<(1<<31)-1<<\" \";//è¯´æ˜ä¸ç›¸è¿\n        else cout<<a[s][i]<<\" \";\n}\n```\n\n### 1.3  SPFA/Bellman-Ford\n\nå…³äº$SPFA$â€”â€”ä»–æ­»äº†ã€‚\n\næç«¯æ¡ä»¶ä¸‹ä¼šè¢«èŠèŠ±å›¾å¡æˆ$O(nm)$çš„ç®—æ³•ã€‚å¯ä»¥ç”¨äºæ™®é€‚æ€§çš„å¸¦è´Ÿè¾¹æƒçš„å›¾ï¼Œå¯ä»¥æ£€æµ‹è´Ÿç¯ã€‚\n\n```cpp\nbool spfa()\n{\n    memset(dis, inf, sizeof(dis)); // åˆå§‹åŒ–\n    memset(cnt, 0, sizeof(cnt));   // è´Ÿç¯è®¡æ•°å™¨\n    dis[s] = 0;\n    vis[s] = 1; // æ³¨æ„ visæ•°ç»„ä»£è¡¨åœ¨ä¸åœ¨é˜Ÿåˆ—ä¸­ï¼Œåœ¨è¿™é‡Œç‚¹æ˜¯å¯ä»¥é‡å¤å…¥é˜Ÿçš„\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0; // å–å‡ºé˜Ÿåˆ—ä¸­çš„å…ƒç´ ï¼Œæ•…visä¸º0\n        for (auto i : edge[u])\n        {\n            if (dis[i.to] > dis[u] + i.val)\n            {\n                cnt[i.to]++;\n                if (cnt[i.to] > n)\n                    return 0;\n                dis[i.to] = dis[u] + i.val;\n                if (vis[i.to] == 0)\n                {\n                    vis[i.to] = 1;\n                    q.push(i.to);\n                }\n            }\n        }\n    }\n    return 1;\n}\n```\n\nåˆ¤æ–­è´Ÿç¯æ–¹å¼ï¼šå½“ä¸€ä¸ªç‚¹è¢«æ¾å¼›äº†è¶…è¿‡$n$æ¬¡ï¼Œæ„å‘³ç€å…¶ä¸­ä¸€å®šæœ‰ç»è¿‡å®ƒçš„è´Ÿç¯ã€‚\n<div style=\"page-break-after: always;\"></div>\n\n### 1.4 å·®åˆ†çº¦æŸ\n\n$x_r-x_l\\le c\\iff addEdge(l,r,c)$ï¼Œ$x_r-x_l\\ge c\\iff addEdge(r,l,-c)$\n\nè·‘æœ€çŸ­è·¯æ±‚å¯è¡Œè§£å³å¯ï¼Œä½¿ç”¨$Spfa$è·‘æœ€çŸ­è·¯ã€‚æœ‰è´Ÿç¯åˆ™æ— è§£ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<vector<array<int, 2>>> con;\nvoid addedge(int x, int y, int z)\n{\n    con[x].push_back({y, z});\n}\nvector<int> dist, vis, tot;\nint n, m;\nbool spfa(vector<int> &dist, int st)\n{\n    dist.assign(n + 1, LONG_LONG_MIN / 2);\n    vis.assign(n + 1, 0);\n    tot.assign(n + 1, 0);\n    queue<int> q;\n    dist[0] = 0;\n    vis[0] = 1;\n    q.push(0);\n    while (!q.empty())\n    { // åˆ¤è´Ÿç¯ï¼Œçœ‹ä¸Šé¢çš„\n        int cur = q.front();\n        q.pop();\n        vis[cur] = 0;\n        for (auto [v, w] : con[cur])\n            if (dist[cur] + w > dist[v])\n            {\n                dist[v] = dist[cur] + w;\n                if (!vis[v])\n                {\n                    vis[v] = 1;\n                    q.push(v);\n                    tot[v]++;\n                    if (tot[v] >= n)\n                    {\n                        return 0;\n                    }\n                }\n            }\n    }\n    return 1;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> m;\n    con.assign(n + 1, vector<array<int, 2>>());\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        addedge(u, v, w);\n        addedge(v, u, -w);\n    }\n    for (int i = 1; i <= n; i++)\n        addedge(0, i, 0);\n    spfa(dist, 0);\n    for (int i = 1; i <= n; i++)\n        cout << dist[i] << ' ';\n    cout << '\\n';\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 1.5 åˆ†å±‚å›¾æœ€çŸ­è·¯\n\nå¯¹äºç‰¹å®šçš„ä¸€äº›é™åˆ¶æ¡ä»¶ï¼Œå¯ä»¥é€šè¿‡æ‹†åˆ†åˆ†å±‚å›¾ï¼Œç”¨ä¸åŒå›¾å±‚è¡¨ç¤ºä¸åŒçš„çŠ¶æ€ã€‚\n\n#### ç¤ºä¾‹1ï¼š$k$æ¬¡æœºä¼šä¸æ¶ˆè€—èŠ±è´¹é€šè¿‡æŸæ¡è¾¹çš„æœ€çŸ­è·¯\n\n```cpp\n#include<bits/stdc++.h>//è§£å†³é—®é¢˜ï¼šæˆ‘ä»¬æœ‰kæ¬¡æœºä¼š0ä»£ä»·çš„é€šè¿‡æŸæ¡è·¯ä¸‹çš„æœ€çŸ­è·¯\n//åˆ†å±‚å›¾ï¼šå½“æˆ‘ä»¬ä½¿ç”¨ä¸€æ¬¡æœºä¼šæ—¶ï¼Œç›¸å½“äºæˆ‘ä»¬è¿›å…¥ä¸‹ä¸€å¼ å›¾\nusing namespace std;\nconst int N=2*1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> P;\nint n,m,k,s,t,u,v,sum;\nvector<P>edge[N];\nint dis[N],vis[N];\nvoid dijkstra(){//å¸¸è§„ä¸å¿…å†è¯´\n    memset(dis,inf,sizeof(dis));\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;\n    q.push({0,s});\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second])dis[j.first]=min(dis[j.first],dis[k.second]+j.second),q.push({dis[j.first],j.first});\n    }\n}\nint main(){\n    cin>>n>>m>>k>>s>>t;\n    s++;t++;\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        u++;v++;\n        edge[u].push_back({v,sum});//åŸå§‹å±‚\n        edge[v].push_back({u,sum});\n        for(int j=1;j<=k;j++){//ä¸€å…±æœ‰k+1å±‚ï¼ŒæŸä¸ªç‚¹åœ¨æ¯ä¸ªå±‚sï¼Œs+n,s+2n,...,s+kn\n            edge[u+j*n].push_back({v+j*n,sum});//æ¯ä¸ªå±‚éƒ½æ˜¯ä¸€æ ·çš„\n            edge[v+j*n].push_back({u+j*n,sum});\n            edge[v+(j-1)*n].push_back({u+j*n,0});//ä½¿ç”¨ç‰¹æƒï¼šå³æ¢å±‚\n            edge[u+(j-1)*n].push_back({v+j*n,0});\n        }\n    }\n    for(int i=1;i<=k;i++)edge[t+(i-1)*n].push_back({t+i*n,0});//æŠŠç»ˆç‚¹ä»ä¸Šåˆ°å°è¿èµ·æ¥ï¼Œè¿™æ ·å³ä½¿æ²¡æœ‰ç”¨å®Œnæ¬¡æœºä¼šæˆ‘ä»¬ä¹Ÿæ˜¯ä»t+nkä¸­è¯»ç­”æ¡ˆ\n    dijkstra();//æ­£å¸¸è·‘æœ€çŸ­è·¯\n    printf(\"%d\",dis[t+k*n]);\n}\n\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### ç¤ºä¾‹2ï¼šåœ°é“æ¢ä¹˜é—®é¢˜\n\n```cpp\n//ååœ°é“é—®é¢˜ï¼šä¸€å…±mæ¡çº¿è·¯ï¼Œnä¸ªåœ°é“ç«™ï¼Œæœ‰æ¢ä¹˜ç­‰é—®é¢˜ï¼Œé‚£å°±å»ºm+1*nä¸ªç‚¹ï¼Œåœ¨5e5å·¦å³ï¼Œå› ä¸ºæ¯å±‚å›¾ä¹‹é—´çš„è¾¹æƒä¸åŒæ‰€ä»¥è¦æŠŠç«™ç‚¹æ‹†å¼€æˆmä¸ªï¼Œå†å»ºç«‹è™šå±‚è¿æ¥ä¸åŒå±‚ä»£è¡¨æ¨¡æ‹Ÿæ¢ä¹˜çš„è¿‡ç¨‹\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N = 510000,INF = 0x3f3f3f3f;  //æ³¨æ„æ•°æ®èŒƒå›´\ntypedef pair<int,int> P;\nint n,m,s,t;\nstruct node{\n    int to,val;\n};\nvector<node>edge[N];\nint dis[N],vis[N];\nvoid add(int u,int v,int w) //åŠ è¾¹å‡½æ•°\n{\n    //cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    edge[u].push_back({v,w});\n}\n\nvoid dijkstra(int s){\n    memset(dis,INF,sizeof(dis));//åˆå§‹åŒ–\n    dis[s]=0;\n    priority_queue<P,vector<P>,greater<P>>q;//å°æ ¹å †å¯åŠ¨\n    q.push({0,s});//è·ç¦»åœ¨å‰ï¼Œç‚¹åœ¨åï¼Œå› ä¸ºpairé»˜è®¤å…ˆæ’å‰é¢çš„\n    while(!q.empty()){\n        P k=q.top();q.pop();\n        if(vis[k.second])continue;\n        vis[k.second]=1;\n        for(auto j:edge[k.second]){\n            if(dis[j.to]>dis[k.second]+j.val){\n                //if(j.to==8)cout<<k.second<<\" \"<<dis[k.second]<<endl;\n                dis[j.to]=min(dis[j.to],dis[k.second]+j.val);\n                q.push({dis[j.to],j.to});\n            }\n        } \n    }\n}\nint main()\n{\n    int price,ad,num,pre,cur;\n    cin >> n >> m >> s >> t;\n    for(int i = 1;i <= m;i++)\n    {\n        cin >> price >> ad >> num;\n        for(int j = 0;j <num;j++)\n        {\n            cin >> cur;\n            if(j){\n                add((i-1)*n+pre,(i-1)*n+cur,ad);    \n                add((i-1)*n+cur,(i-1)*n+pre,ad);\n            }\n            add((i-1)*n+cur,n*m+cur,0);\n            add(n*m+cur,(i-1)*n+cur,price); \n            pre = cur;  \n        }\n    }\n    dijkstra(n*m+s);    \n    if(dis[n*m+t] == INF)   \n        cout << -1 << endl;\n    else\n        cout << dis[n*m+t] << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### ç¤ºä¾‹3ï¼šä¸€äº›ç›¸ç±»ä¼¼çš„ç§»åŠ¨æ–¹å¼é›†åˆåˆ°ä¸€èµ·ï¼ˆ2023æ¾³é—¨åŒºåŸŸèµ›ï¼‰\n\né¢˜æ„æ¦‚æ‹¬ï¼š\n\næœ‰ä¸€ä¸ª$n$ä¸ªèŠ‚ç‚¹çš„ç¯ï¼Œç¼–å·$0\\to n-1$. ä½ åˆå§‹åœ¨$i$å·èŠ‚ç‚¹ã€‚ç»™ä¸€ä¸ªé•¿åº¦ä¸º$n$çš„æ•°ç»„$a$ã€‚ä½ æ¯ä¸€æ¬¡å¯ä»¥è¿›è¡Œä»¥ä¸‹æ“ä½œï¼š\n\n1. ä»$i$ç«‹å³ä¼ é€ï¼š$i\\to (a_i+i)\\pmod{n}$\n2. ä¿®æ”¹å½“å‰$a_i$ï¼š$a_i\\to a_i+1$\n\nç»™å®šä¸€ä¸ª$x$ï¼Œè¯¢é—®æœ€å°‘ç»è¿‡å¤šå°‘æ¬¡æ“ä½œèƒ½å¤Ÿä»$0$åˆ°è¾¾$x$.\n\nè¿™é‡Œè¦çœ‹ä½ æ€ä¹ˆçœ‹å¾…è¿™ä¸ªä¿®æ”¹ã€‚åœ¨$i$å¯¹$a_i$åŠ $1$ç­‰ä»·äºç›´æ¥è·³åˆ°$a_i+i$ååˆèŠ±è´¹ä¸€æ¬¡æœºä¼šå‘åèµ°ã€‚å› ä¸ºä½ æ°¸è¿œä¸å¯èƒ½èµ°å›å¤´è·¯ï¼Œå°±æ˜¯ç¬¬äºŒæ¬¡ç»è¿‡$i$è¿™ä¸ªç‚¹ï¼Œæ‰€ä»¥è¿™ä¸ªæŠ½è±¡æ˜¯åˆç†çš„ã€‚è€Œæˆ‘ä»¬åˆä¸å¯èƒ½ç›´æ¥åœ¨åŸå›¾ä¸ŠæŠŠæ‰€æœ‰çš„ç‚¹å…¨éƒ¨ç›´æ¥ä¸²èµ·æ¥ã€‚\n\næ‰€ä»¥å¼€ä¸€ä¸ªåˆ†å±‚å›¾ï¼Œé¢å¤–æ–°å»ºç«‹ä¸€ä¸ªæœ‰å‘ç¯æ¨¡æ‹Ÿåè·³è·ƒè¿™ä¸ªæ“ä½œï¼Œç„¶åä¸€æ¬¡æ“ä½œ$1$å°±ä»åŸå›¾çš„$i$å‘ç¯ä¸Šçš„$i+a_i$è¿è¾¹ã€‚ç¯ä¸Šçš„ç‚¹å‘åŸå›¾çš„è‡ªå·±è¿ä¸€æ¡ä»£ä»·ä¸º0çš„å•å‘æœ‰å‘è¾¹ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2. ç½‘ç»œæµ\n\nè§£å†³ç½‘ç»œæµæ¨¡å‹é—®é¢˜ã€‚\n\n### 2.1 MaxFlow.h\n\nJianglyæœ€æ–°æœ€å¤§æµæ¨¡æ¿ï¼Œç‚¹ç¼–å·ä»0å¼€å§‹ã€‚è´¹ç”¨æµåŒç†ã€‚\n\n```cpp\ntemplate <class T>\nstruct MaxFlow\n{\n    struct _Edge\n    {\n        int to;\n        T cap;\n        _Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n\n    int n;\n    std::vector<_Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n\n    MaxFlow() {}\n    MaxFlow(int n)\n    {\n        init(n);\n    }\n\n    void init(int n)\n    {\n        this->n = n;\n        e.clear();\n        g.assign(n, {});\n        cur.resize(n);\n        h.resize(n);\n    }\n\n    bool bfs(int s, int t)\n    {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty())\n        {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u])\n            {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1)\n                {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                    {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n\n    T dfs(int u, int t, T f)\n    {\n        if (u == t)\n        {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i)\n        {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1)\n            {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0)\n                {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c)\n    {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T flow(int s, int t)\n    {\n        T ans = 0;\n        while (bfs(s, t))\n        {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n\n    std::vector<bool> minCut()\n    {\n        std::vector<bool> c(n);\n        for (int i = 0; i < n; i++)\n        {\n            c[i] = (h[i] != -1);\n        }\n        return c;\n    }\n\n    struct Edge\n    {\n        int from;\n        int to;\n        T cap;\n        T flow;\n    };\n    std::vector<Edge> edges()\n    {\n        std::vector<Edge> a;\n        for (int i = 0; i < e.size(); i += 2)\n        {\n            Edge x;\n            x.from = e[i + 1].to;\n            x.to = e[i].to;\n            x.cap = e[i].cap + e[i + 1].cap;\n            x.flow = e[i + 1].cap;\n            a.push_back(x);\n        }\n        return a;\n    }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 MinCostFlow.h\n\næ”¯æŒè´Ÿæ•°è´¹ç”¨ï¼Œä¸æ”¯æŒè´Ÿæ•°æµé‡ã€‚\n\n```cpp\n/*\n *@brief è´¹ç”¨æµï¼ˆJianglyï¼‰\n *@note æ—¶é—´å¤æ‚åº¦O(F(n+m)log(n+m)),F(n+m)è¡¨ç¤ºæµé‡å’Œï¼Œnè¡¨ç¤ºç‚¹æ•°ï¼Œmè¡¨ç¤ºè¾¹æ•°\n *@note ç©ºé—´å¤æ‚åº¦O(n+m)\n *@tparam Cap æµé‡æ•°æ®ç±»å‹\n *@tparam Cost è´¹ç”¨æ•°æ®ç±»å‹\n *@note  å¤æ‚åº¦ä¼°ç®—å¯åŒæœ€å¤§æµï¼Œç‚¹æ•°ä¸è¶…è¿‡2000ï¼Œæœ€åä¸Šç•Œä¼°ç®—O(n^3)åˆ°O(n^4)ï¼ŒåŸºæœ¬ä¸ä¼šTLE\n */\ntemplate <class T>\nstruct MinCostFlow\n{\n    struct _Edge\n    {\n        int to;\n        T cap;\n        T cost;\n        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}\n    };\n    int n;\n    std::vector<_Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<T> h, dis;\n    std::vector<int> pre;\n    bool dijkstra(int s, int t)\n    {\n        dis.assign(n, std::numeric_limits<T>::max());\n        pre.assign(n, -1);\n        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> que;\n        dis[s] = 0;\n        que.emplace(0, s);\n        while (!que.empty())\n        {\n            T d = que.top().first;\n            int u = que.top().second;\n            que.pop();\n            if (dis[u] != d)\n            {\n                continue;\n            }\n            for (int i : g[u])\n            {\n                int v = e[i].to;\n                T cap = e[i].cap;\n                T cost = e[i].cost;\n                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost)\n                {\n                    dis[v] = d + h[u] - h[v] + cost;\n                    pre[v] = i;\n                    que.emplace(dis[v], v);\n                }\n            }\n        }\n        return dis[t] != std::numeric_limits<T>::max();\n    }\n    MinCostFlow() {}\n    MinCostFlow(int n_)\n    {\n        init(n_);\n    }\n    void init(int n_)\n    {\n        n = n_;\n        e.clear();\n        g.assign(n, {});\n    }\n    void addEdge(int u, int v, T cap, T cost)\n    {\n        g[u].push_back(e.size());\n        e.emplace_back(v, cap, cost);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0, -cost);\n    }\n    std::pair<T, T> flow(int s, int t)\n    {\n        T flow = 0;\n        T cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t))\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                h[i] += dis[i];\n            }\n            T aug = std::numeric_limits<int>::max();\n            for (int i = t; i != s; i = e[pre[i] ^ 1].to)\n            {\n                aug = std::min(aug, e[pre[i]].cap);\n            }\n            for (int i = t; i != s; i = e[pre[i] ^ 1].to)\n            {\n                e[pre[i]].cap -= aug;\n                e[pre[i] ^ 1].cap += aug;\n            }\n            flow += aug;\n            cost += aug * h[t];\n        }\n        return std::make_pair(flow, cost);\n    }\n    struct Edge\n    {\n        int from;\n        int to;\n        T cap;\n        T cost;\n        T flow;\n    };\n    std::vector<Edge> edges()\n    {\n        std::vector<Edge> a;\n        for (int i = 0; i < e.size(); i += 2)\n        {\n            Edge x;\n            x.from = e[i + 1].to;\n            x.to = e[i].to;\n            x.cap = e[i].cap + e[i + 1].cap;\n            x.cost = e[i].cost;\n            x.flow = e[i + 1].cap;\n            a.push_back(x);\n        }\n        return a;\n    }\n};\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.3 Dinic (æœ±)\n\n```cpp\n// ç†è®ºä¸Šç•Œä¸ºn2mï¼Œå¤„ç†1e4-1e5çš„æ•°æ®\n// ä¸‰ä¸ªä¼˜åŒ–ï¼šå¤šè·¯å¢å¹¿ï¼Œå½“å‰å¼§ï¼Œç‚¸ç‚¹\n// å°‘åšå‡ æ¬¡bfsï¼Œä¸€æ¬¡dfsè¿›è¡Œå¤šæ¬¡å¢å¹¿\n// å»ºå›¾æ—¶ä¸ç”¨è€ƒè™‘ç‚¹çš„å˜åŒ–ï¼Œè¿‡ç¨‹ä¸­æ²¡æœ‰ç”¨åˆ°ç‚¹æ•°è¿™ä¸ªä¿¡æ¯ï¼Œåªéœ€æŠŠè¾¹å»ºå‡ºæ¥å°±èƒ½è·‘\n// å¤šæµ‹çš„æ—¶å€™è®°å¾—æ¸…ç©ºe[0]\n// æ£€æŸ¥è¿™æ¡è¾¹æ˜¯ä¸æ˜¯æ»¡æµï¼šæ˜¯çš„è¯è¿™æ¡è¾¹çš„lenå˜æˆ0ï¼ˆæ²¡æœ‰å‰©ä½™æµé‡ï¼‰\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], cur[N];\nbool bfs() // bfsåˆ†å±‚\n{\n    memset(dep, -1, sizeof dep);\n    queue<int> q;\n    q.push(S);\n    dep[S] = 0;\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i = i + 1)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1 && e[t][i].len) // å¦‚æœè¿™ä¸ªç‚¹æ²¡æœ‰è¢«å®šä¹‰å±‚æ¬¡ï¼Œä¸”è¿˜æœ‰å‰©ä½™æµé‡\n            {\n                dep[ed] = dep[t] + 1;\n                q.push(ed);\n            }\n        }\n    }\n    memset(cur, 0, sizeof(cur));\n    if (dep[T] == -1)\n        return 0;\n    else\n        return 1;\n}\nint dfs(int st, int limit) // limitæœ€å¤§å¯å¢åŠ çš„æµé‡\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // å®šä¹‰å½“å‰èŠ‚ç‚¹çš„æµé‡,å¤šè·¯å¢å¹¿ä¼˜åŒ–ï¼Œæ‰¾æ»¡å½“å‰èƒ½æ‰¾çš„limitæµé‡ä¸Šç•Œ\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // å½“å‰å¼§ä¼˜åŒ–ï¼Œå¦‚æœä¸€ä¸ªç‚¹æœ‰å¾ˆå¤šå‡ºè¾¹ï¼Œæœ‰äº›å‡ºè¾¹å¯èƒ½æ— æ³•å†æ¨æµäº†ï¼Œæˆ‘ä»¬å°±è®°å½•ç¬¬ä¸€æ¡å¯ä»¥æ¨æµçš„è¾¹\n    {\n        cur[st] = i; // å½“å‰å¼§ä¼˜åŒ–\n        int ed = e[st][i].ed;\n        if (dep[ed] == dep[st] + 1 && e[st][i].len) // è¿™æ¡è¾¹èƒ½æ¨ä¸”ï¼Œæ·±åº¦ä¸ºæ›´æ·±ä¸€å±‚ï¼ˆä¸ºäº†æ‰¾æœ€çŸ­çš„å¢å¹¿è·¯ï¼‰\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // æ˜¯ä¸ºäº†é™åˆ¶åé¢ç‚¹çš„æµé‡ä¸èƒ½å¤§äºlimit-nowflow\n            if (t)                                               // èµ°ä¸‹å»èƒ½æ¨æµ\n            {\n                e[st][i].len -= t;           // å‡å»ç›¸åº”çš„\n                e[ed][e[st][i].id].len += t; // åè¾¹+ç›¸åº”çš„\n                nowflow += t;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    }\n    if (!nowflow)\n        dep[st] = -1; // å¦‚æœè¿™ä¸ªç‚¹ä¸èƒ½å»¶ç”³ï¼Œé‚£å°±åˆ æ‰è¿™ä¸ªç‚¹ï¼ˆç‚¸ç‚¹ä¼˜åŒ–ï¼‰\n    return nowflow;   // ä¼šè¿”å›æœ¬æ¬¡bfsï¼ˆï¼‰åæ‰€æœ‰å¢å¹¿è·¯èƒ½åŠ çš„æœ€å¤šæµé‡\n}\nint dinic()\n{\n    int r = 0;\n    while (bfs())\n        r += dfs(S, INF);\n    return r;\n}\nvoid add(int u, int v, int w)\n{ // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // å»ºè¾¹\n    e[v].push_back((edge){u, 0, sti});\n}\nsigned main()\n{\n    cin >> n >> m >> S >> T;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        add(u, v, w);\n    }\n    cout << dinic();\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.4 ISAP (æœ±)\n\n```cpp\n// ç†è®ºä¸Šç•Œä¸ºn2mï¼Œå¤„ç†1e4-1e5çš„æ•°æ®\n// åªåšä¸€æ¬¡bfs\n// å»ºå›¾æ—¶æ³¨æ„nçš„æ”¹å˜ï¼Œè¿è¡Œè¿‡ç¨‹ä¸­æœ‰è·Ÿç‚¹æ•°ç›¸å…³\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], gap[N], cur[N];\nvoid bfs() // bfsåˆ†å±‚\n{\n    memset(dep, -1, sizeof dep);\n    memset(gap, 0, sizeof(gap));\n    queue<int> q;\n    q.push(T);\n    dep[T] = 0; // Tä¸ºå±‚æ•°ä¸º0çš„ç‚¹\n    gap[0] = 1; // å±‚æ•°ä¸º0çš„ç‚¹æœ‰ä¸€ä¸ª\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i++)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1) // å¦‚æœè¿™ä¸ªç‚¹æ²¡æœ‰è¢«å®šä¹‰å±‚æ¬¡å°±è€ƒè™‘ï¼ˆåœ¨è¿™é‡Œä¸åœ¨ä¹è¿™æ¡è¾¹çš„æµé‡æ˜¯å¦ä¸º0ï¼åªè´Ÿè´£åˆ†å±‚)\n            {\n                dep[ed] = dep[t] + 1;\n                gap[dep[ed]]++;\n                q.push(ed);\n            }\n        }\n    }\n    return;\n}\nint dfs(int st, int limit) // limitæœ€å¤§å¯å¢åŠ çš„æµé‡\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // å®šä¹‰å½“å‰èŠ‚ç‚¹çš„æµé‡,å¤šè·¯å¢å¹¿ä¼˜åŒ–ï¼Œæ‰¾æ»¡å½“å‰èƒ½æ‰¾çš„limitæµé‡ä¸Šç•Œ\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // å½“å‰å¼§ä¼˜åŒ–ï¼Œå¦‚æœä¸€ä¸ªç‚¹æœ‰å¾ˆå¤šå‡ºè¾¹ï¼Œæœ‰äº›å‡ºè¾¹å¯èƒ½æ— æ³•å†æ¨æµäº†ï¼Œæˆ‘ä»¬å°±è®°å½•ç¬¬ä¸€æ¡å¯ä»¥æ¨æµçš„è¾¹\n    {\n        cur[st] = i; // å½“å‰å¼§ä¼˜åŒ–\n        int ed = e[st][i].ed;\n        if (dep[ed] + 1 == dep[st] && e[st][i].len) // è¿™æ¡è¾¹èƒ½æ¨ä¸”ï¼Œæ·±åº¦ä¸ºæ›´æ·±ä¸€å±‚ï¼ˆä¸ºäº†æ‰¾æœ€çŸ­çš„å¢å¹¿è·¯ï¼‰\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // æ˜¯ä¸ºäº†é™åˆ¶åé¢ç‚¹çš„æµé‡ä¸èƒ½å¤§äºlimit-nowflow\n            if (t)                                               // èµ°ä¸‹å»èƒ½æ¨æµ\n            {\n                e[st][i].len -= t;           // å‡å»ç›¸åº”çš„\n                e[ed][e[st][i].id].len += t; // åè¾¹+ç›¸åº”çš„\n                nowflow += t;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    } // åˆ°è¿™è¯´æ˜è¿™ä¸ªç‚¹è¿˜æœ‰å‰©ä½™æµé‡ï¼Œå±‚æ•°å°±+1\n    --gap[dep[st]];\n    if (gap[dep[st]] == 0)\n        dep[S] = n + 1; // å‡ºç°æ–­å±‚ï¼Œæ— æ³•åˆ°è¾¾täº†ï¼Œç›´æ¥ç»“æŸ\n    dep[st]++;          // å±‚++\n    gap[dep[st]]++;\n    return nowflow; // ä¼šè¿”å›æœ¬æ¬¡bfsï¼ˆï¼‰åæ‰€æœ‰å¢å¹¿è·¯èƒ½åŠ çš„æœ€å¤šæµé‡\n}\nint ISAP()\n{\n    int flow = 0;\n    bfs();\n    while (dep[S] < n)\n    {\n        memset(cur, 0, sizeof(cur)); // æ¯ä¸€æ¬¡å¼€å§‹dfså‰éƒ½è¦æ³¨æ„curæ•°ç»„çš„æ¸…ç©ºï¼ä¸dinicä¸åŒï¼Œå› ä¸ºè¿™é‡Œåªéœ€è¦ä¸€æ¬¡bfs\n        flow += dfs(S, INF);         // åˆå§‹æµé‡ä¸ºæ— ç©·å¤§\n    }\n    return flow;\n}\nvoid add(int u, int v, int w)\n{ // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // å»ºè¾¹\n    e[v].push_back((edge){u, 0, sti});\n}\nsigned main()\n{\n    cin >> n >> m >> S >> T;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        int sti = e[u].size();\n        int edi = e[v].size();\n        e[u].push_back((edge){v, w, edi}); // å»ºè¾¹\n        e[v].push_back((edge){u, 0, sti});\n    }\n    cout << ISAP();\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.5 é¢„æµæ¨è¿›ï¼ˆAmiyaCastï¼‰\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define pii make_pair\nconst ll inf = 1145141919810;\nusing namespace std;\nint n, m, s, t;\nstruct Dinic\n{\n    int tp, s, t, n, m;\n    struct Edge\n    {\n        int u, v;\n        ll cap;\n    };\n    vector<ll> dis;\n    vector<int> cur, que;\n    vector<vector<int>> v;\n    vector<Edge> e, _e;\n    Dinic(int _n, int _s, int _t)\n    {\n        n = _n, s = _s, t = _t;\n        dis.resize(_n + 1), cur.resize(_n + 1), que.resize(_n + 1),\n            v.resize(n + 1);\n    }\n    void add(int x, int y, ll w) { _e.push_back({x, y, w}); }\n    void Add(int x, int y, int flw)\n    {\n        e.push_back(Edge{x, y, flw}), e.push_back(Edge{y, x, 0});\n        v[x].push_back(e.size() - 2);\n    }\n    int bfs()\n    {\n        dis.assign(n + 1, inf);\n        int l = 1, r = 1;\n        que[1] = s, dis[s] = 0;\n        while (l <= r)\n        {\n            int p = que[l++], to;\n            for (int i : v[p])\n                if (e[i].cap && dis[to = e[i].v] >= inf)\n                    dis[to] = dis[p] + 1, que[++r] = to;\n        }\n        return dis[t] < inf;\n    }\n    int dfs(int p, ll a)\n    {\n        if (p == t || !a)\n            return a;\n        int sf = 0, flw;\n        for (int &i = cur[p], to; i < (int)v[p].size(); ++i)\n        {\n            Edge &E = e[v[p][i]];\n            if (dis[to = E.v] == dis[p] + 1 && (flw = dfs(to, min(a,\n                                                                  E.cap))))\n            {\n                E.cap -= flw;\n                e[v[p][i] ^ 1].cap += flw;\n                a -= flw;\n                sf += flw;\n                if (!a)\n                    break;\n            }\n        }\n        return sf;\n    }\n    ll dinic(int tp = 1)\n    {\n        this->tp = tp;\n        int flw = 0;\n        while (bfs())\n            cur.assign(n + 1, 0), flw += dfs(s, inf);\n        return flw;\n    }\n    ll get_ans()\n    {\n        ll ans = 0;\n        m = _e.size();\n        sort(_e.begin(), _e.end(), [](Edge a, Edge b)\n             { return a.cap >\n                      b.cap; });\n        for (int rp = 0; rp <= 1; ++rp)\n            for (int p = 1 << 30, i = 0; p; p /=\n                                            2)\n            {\n                for (; i < m && _e[i].cap >= p; ++i)\n                    if (rp)\n                        v[_e[i].v].push_back(i * 2 + 1);\n                    else\n                        Add(_e[i].u, _e[i].v, _e[i].cap);\n                ans += dinic(rp);\n            }\n        return ans;\n    }\n};\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m >> s >> t;\n    Dinic d(n, s, t);\n    for (int i = 0; i < m; i++)\n    {\n        int x, y;\n        ll w;\n        cin >> x >> y >> w;\n        d.add(x, y, w);\n    }\n    cout << d.get_ans() << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.6 æœ€å°è´¹ç”¨æœ€å¤§æµï¼ˆæœ±ï¼‰\n\n```cpp\n//ç†è®ºä¸Šç•Œä¸ºn2mï¼Œå¤„ç†1e4-1e5çš„æ•°æ®\n//æ¯æ¡è¾¹æµè¿‡å»å¤šäº†ä¸€ä¸ªæˆæœ¬\n//bfsæ¢æˆäº†spfaè·‘æœ€çŸ­è·¯å³å¯,0å·ç‚¹å¾—ç©ºå‡ºæ¥\n//æœ€å¤§è´¹ç”¨æœ€å¤§æµï¼šå»ºè¾¹æ—¶æŠŠcåç€å»ºï¼Œç…§æ ·è·‘æ¿å­ï¼Œæœ€åç­”æ¡ˆä¹Ÿåè¿‡æ¥å°±è¡Œï¼Œç±»ä¼¼æœ€é•¿è·¯\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n    int cost;\n};\nvector <edge> e[N];\nint n, m, S, T;\nint dep[N], dis[N], vis[N],ans ,res;\nbool spfa(){\n    memset(dis,0x3f,sizeof(dis));//åˆå§‹åŒ–\n    memset(vis,0,sizeof(vis));\n    dis[T]=0;\n    vis[T]=1;//visæ•°ç»„ä»£è¡¨åœ¨ä¸åœ¨é˜Ÿåˆ—ä¸­\n    deque<int>q;q.push_back(T);\n    while(!q.empty()){\n        int u=q.front();q.pop_front();\n        vis[u]=0;//å–å‡ºé˜Ÿåˆ—ä¸­çš„å…ƒç´ ï¼Œæ•…visä¸º0\n        for (int i = 0; i < e[u].size(); i++){\n            int ed = e[u][i].ed;\n            if (e[ed][e[u][i].id].len && dis[ed]>dis[u]-e[u][i].cost){//å–åå‘è¾¹æ˜¯å› ä¸ºæˆ‘ä»¬è¦ä¿è¯æ­£æµï¼Œä½†æ˜¯SPFAæ˜¯å€’ç€è·‘çš„ï¼Œæ‰€ä»¥è¯´æˆ‘ä»¬è¦æ±‚e[u][i]çš„å¯¹åº”åå‘è¾¹æ˜¯æ­£çš„ï¼Œ\n                dis[ed]=dis[u]-e[u][i].cost;\n                if (!vis[ed]){\n                    vis[ed]=true;\n                    if (q.empty() || dis[ed]>=dis[q.front()])q.push_back(ed);//ä¸€ä¸ªlisä¼˜åŒ–spfaçš„\n                        else q.push_front(ed);\n                }\n            }\n        }\n    }\n    return dis[S]<dis[0];\n}\nint dfs(int st, int limit){\n    vis[st]=1;\n    if (st == T||limit==0)\n        return limit;\n    int nowflow=0;//å®šä¹‰å½“å‰èŠ‚ç‚¹çš„æµé‡\n    for (int i = 0; i < e[st].size(); i = i + 1){\n        int ed = e[st][i].ed;\n        if (dis[ed] == dis[st] - e[st][i].cost && e[st][i].len&&!vis[ed])//è¿™æ¡è¾¹èƒ½æ¨ä¸”ï¼Œæ·±åº¦ä¸ºæ›´æ·±ä¸€å±‚ï¼Œä¸”æ²¡èµ°è¿‡\n        {\n            int t = dfs(ed, min(e[st][i].len, limit-nowflow));//æ˜¯ä¸ºäº†é™åˆ¶åé¢ç‚¹çš„æµé‡ä¸èƒ½å¤§äºlimit-nowflow\n            if (t)//èµ°ä¸‹å»èƒ½æ¨æµ\n            {\n                res+=t*e[st][i].cost;//ç»Ÿè®¡ç­”æ¡ˆï¼Œç»è¿‡è¿™ä¸€æ¡è¾¹\n                e[st][i].len -= t;\n                e[ed][e[st][i].id].len += t;\n                nowflow+=t;\n                if(nowflow==limit)return nowflow;\n            }\n\n        }\n    }\n    if(!nowflow)dep[st]=-1;//å¦‚æœè¿™ä¸ªç‚¹ä¸èƒ½å»¶ç”³ï¼Œé‚£å°±åˆ æ‰è¿™ä¸ªç‚¹ï¼ˆç‚¸ç‚¹ä¼˜åŒ–ï¼‰\n    return nowflow;//ä¼šè¿”å›æœ¬æ¬¡bfsï¼ˆï¼‰åæ‰€æœ‰å¢å¹¿è·¯èƒ½åŠ çš„æœ€å¤šæµé‡\n}\nvoid dinic(){\n    while(spfa()){\n        vis[T]=1;\n        while(vis[T]){//å¦‚æœdfså®Œå·²ç»èµ°ä¸åˆ°täº†é‚£è¯´æ˜è¿™ä¸€è½®ç»“æŸ\n            memset(vis,0,sizeof vis);\n            ans+=dfs(S,INF);\n        }\n    }\n}\nvoid add(int u,int v,int w,int c){\n    //cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi, c});//å»ºè¾¹\n    e[v].push_back((edge){u, 0, sti, -c});\n}\nsigned main(){\n    cin>>n>>m>>S>>T;\n    for (int i = 1; i <= m; i++){\n        int u,v,w,c;\n        cin >> u >> v >> w >> c;\n        int sti = e[u].size();\n        int edi = e[v].size();\n        e[u].push_back((edge){v, w, edi, c});//å»ºè¾¹\n        e[v].push_back((edge){u, 0, sti, -c});\n    }\n    dinic();\n    cout<<ans<<\" \"<<res;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.7 ç½‘ç»œæµç»“è®º\n\n#### 2.7.1 äºŒåˆ†å›¾åšå¼ˆ\n\näºŒåˆ†å›¾åšå¼ˆï¼Œç»™å‡ºä¸€å¼ äºŒåˆ†å›¾å’Œèµ·å§‹ç‚¹ Hï¼ŒA å’Œ Bè½®æµæ“ä½œï¼Œæ¯æ¬¡åªèƒ½é€‰ä¸ä¸Šä¸ªè¢«é€‰æ‹©çš„ç‚¹ï¼ˆç¬¬ä¸€å›åˆåˆ™æ˜¯ç‚¹ Hï¼‰ç›¸é‚»çš„ç‚¹ï¼Œä¸”ä¸èƒ½é€‰æ‹©å·²é€‰æ‹©è¿‡çš„ç‚¹ï¼Œæ— æ³•é€‰ç‚¹çš„äººè¾“æ‰ã€‚\n\nå…·ä½“æ¥è¯´ï¼Œå°±æ˜¯æ‰€æœ‰çš„çŠ¶æ€å¯ä»¥è¢«åˆ†ä¸ºä¸¤ç±»ï¼Œæ¯æ¬¡æ“ä½œå¿…å®šæ˜¯ä»ä¸€ä¸ªçŠ¶æ€åˆ°å¦ä¸€ç±»çŠ¶æ€ï¼Œä¸èƒ½æ“ä½œçš„äººè¾“\n\nåšæ³•ï¼Œå¦‚æœäºŒåˆ†å›¾çš„æ‰€æœ‰æœ€å¤§åŒ¹é…éƒ½ç»è¿‡Hï¼Œé‚£ä¹ˆå…ˆæ‰‹å¿…èƒœï¼Œå¦åˆ™å¿…è´¥\n\nå»ºå›¾ååˆ¤æ–­Hæ˜¯ä¸æ˜¯å¿…é¡»ç‚¹å³å¯ï¼ˆè·‘ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡ä¸å¸¦Hç‚¹ï¼Œè·‘ä¸€æ¬¡ï¼Œå†å¸¦ä¸ŠHç‚¹ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æœ‰æ–°å¢æµé‡ï¼Œè‹¥æœ‰åˆ™æ˜¯å¿…é¡»ç‚¹ï¼Œå…ˆæ‰‹å¿…èƒœï¼Œå¦åˆ™å¿…è´¥ï¼‰\n\n```cpp\nvoid solve(){\n    cin>>m>>n>>s;\n    for (int i = 0; i < N; i++)e[i].clear();\n    memset(sp,0,sizeof(sp));\n    int M=a[m];S=M+1;T=M+2;\n    for (int i = 1; i <= n; i++) {\n        int x ;cin>>x; sp[x] = 1;//ç¦æ­¢è®¿é—®çš„çŠ¶æ€\n    }\n    for(int i = 0; i < M; i++) {//æ¯ä¸ªçŠ¶æ€\n        if(sp[i]) continue;\n        if(odd[i] == odd[s]) {\n            calc(i);//içš„åç»§çŠ¶æ€è¿è¾¹\n            if (i != s) add(S, i, 1);//èµ·ç‚¹å…ˆä¸è¿\n        }\n        else {\n            add(i, T, 1);   \n        }\n    }\n    dinic();//å¦‚ä½•åˆ¤æ–­è¿™ä¸ªç‚¹æ˜¯ä¸æ˜¯æœ€å¤§åŒ¹é…çš„å¿…é¡»ç‚¹ï¼Ÿå…ˆä¸åŠ è¿™ä¸ªç‚¹è·‘ä¸€æ¬¡ï¼Œå†åŠ ä¸Šè·‘ä¸€æ¬¡ï¼Œçœ‹èƒ½ä¸èƒ½æœ‰æ–°æµå³å¯\n    add(S, s, 1);\n    if(dinic())\n        cout<<\"Alice\"<<endl;\n    else \n        cout<<\"Bob\"<<endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.2 æœ€å°è·¯å¾„è¦†ç›–ä¸ååºé›†åˆDilworthå®šç†\n\n##### 2.7.2.1 æœ€å°è·¯å¾„è¦†ç›–\n\næœ€å°è·¯å¾„è¦†ç›–é—®é¢˜æ˜¯æŒ‡ç”¨æœ€å°‘çš„**ä¸ç›¸äº¤**è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„è¦†ç›–æ•´ä¸ªæœ‰å‘å›¾çš„æ‰€æœ‰ç‚¹ã€‚\n\næœ¬è´¨æ˜¯äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…ã€‚\n\nç›®æ ‡æ˜¯è¦†ç›–æ‰€æœ‰çš„ç‚¹ï¼Œè¿™äº›è·¯å¾„ä¸è¦æ±‚éå¾—å…±ç”¨èµ·ç‚¹å’Œç»ˆç‚¹ã€‚åˆå§‹è€ƒè™‘æ¯ä¸ªç‚¹éƒ½è¢«ä¸€æ¡è‡ªç¯å”¯ä¸€è¦†ç›–ï¼Œé‚£ä¹ˆä¸€æ¡è¾¹è¿é€šä¸¤ä¸ªç‚¹å°±æ„å‘³ç€è¿™æ¡è¾¹åŒæ—¶è¦†ç›–äº†è¿™ä¸¤ä¸ªç‚¹ï¼ŒåŒæ—¶å› ä¸ºä¸ç›¸äº¤è·¯å¾„çš„å±æ€§ç¡®ä¿äº†å¦‚æœç‚¹$A$è¿å‘äº†ç‚¹$B$ï¼Œé‚£ä¹ˆä¸€å®šä¸ä¼šå†æœ‰ç‚¹$A$è¿å‘ä»»ä½•ä¸€ä¸ªç‚¹ã€‚ç¡®ä¿ä¸€ä¸ªç‚¹åªè¿æ¥ä¸€æ¡å‡ºè¾¹ï¼Œå°±æ˜¯äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…é—®é¢˜ã€‚å»ºå›¾è·‘æœ€å¤§åŒ¹é…åæ‰¾å‡ºæœ€å¤§å¯åŒ–ç®€æ•°é‡ï¼Œç»“æœå°±æ˜¯$n-$æœ€å¤§æµã€‚\n\n**ç¤ºä¾‹1ï¼šï¼ˆæ¨¡æ¿é¢˜)**\n\nç»™å®šæœ‰å‘å›¾ $G=(V,E)$ ã€‚è®¾ $P$ æ˜¯ $G$ çš„ä¸€ä¸ªç®€å•è·¯ï¼ˆé¡¶ç‚¹ä¸ç›¸äº¤ï¼‰çš„é›†åˆã€‚å¦‚æœ $V$ ä¸­æ¯ä¸ªå®šç‚¹æ°å¥½åœ¨ $P$ çš„ä¸€æ¡è·¯ä¸Šï¼Œåˆ™ç§° $P$ æ˜¯ $G$ çš„ä¸€ä¸ªè·¯å¾„è¦†ç›–ã€‚$P$ ä¸­è·¯å¾„å¯ä»¥ä» $V$ çš„ä»»ä½•ä¸€ä¸ªå®šç‚¹å¼€å§‹ï¼Œé•¿åº¦ä¹Ÿæ˜¯ä»»æ„çš„ï¼Œç‰¹åˆ«åœ°ï¼Œå¯ä»¥ä¸º $0$ã€‚$G$ çš„æœ€å°è·¯å¾„è¦†ç›–æ˜¯ $G$ æ‰€å«è·¯å¾„æ¡æ•°æœ€å°‘çš„è·¯å¾„è¦†ç›–ã€‚è®¾è®¡ä¸€ä¸ªæœ‰æ•ˆç®—æ³•æ±‚ä¸€ä¸ª DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰$G$ çš„æœ€å°è·¯å¾„è¦†ç›–ã€‚\n\n**è¾“å…¥æ ¼å¼**\n\nç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•° $n$ å’Œ $m$ã€‚$n$ æ˜¯ç»™å®š DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰$G$ çš„é¡¶ç‚¹æ•°ï¼Œ$m$ æ˜¯ $G$ çš„è¾¹æ•°ã€‚æ¥ä¸‹æ¥çš„ $m$ è¡Œï¼Œæ¯è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•° $i$ å’Œ $j$ è¡¨ç¤ºä¸€æ¡æœ‰å‘è¾¹ $(i,j)$ã€‚\n\n**è¾“å‡ºæ ¼å¼**\n\nä»ç¬¬ä¸€è¡Œå¼€å§‹ï¼Œæ¯è¡Œè¾“å‡ºä¸€æ¡è·¯å¾„ã€‚æ–‡ä»¶çš„æœ€åä¸€è¡Œæ˜¯æœ€å°‘è·¯å¾„æ•°ã€‚\n\nå¯¹äº $100\\%$ çš„æ•°æ®ï¼Œ$1\\leq n\\leq 150$ï¼Œ$1\\leq m\\leq 6000$â€‹â€‹ã€‚\n\nè®°å½•è·¯å¾„åœ¨dfsä¸­ç»´æŠ¤ä¸€ä¸ªnxtæ•°ç»„è¡¨ç¤ºè¿™ä¸ªç‚¹çš„ä¸‹ä¸€ä¸ªã€‚\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 10010, M = 200010, INF = 1e15;\nstruct edge\n{\n    int ed;\n    int len;\n    int id;\n};\nvector<edge> e[N];\nint n, m, S, T;\nint dep[N], cur[N], p[N], net[N], d[N];\nbool bfs() // bfsåˆ†å±‚\n{\n    memset(dep, -1, sizeof dep);\n    queue<int> q;\n    q.push(S);\n    dep[S] = 0;\n    while (!q.empty())\n    {\n        int t = q.front();\n        q.pop();\n        for (int i = 0; i < e[t].size(); i = i + 1)\n        {\n            int ed = e[t][i].ed;\n            if (dep[ed] == -1 && e[t][i].len) // å¦‚æœè¿™ä¸ªç‚¹æ²¡æœ‰è¢«å®šä¹‰å±‚æ¬¡ï¼Œä¸”è¿˜æœ‰å‰©ä½™æµé‡\n            {\n                dep[ed] = dep[t] + 1;\n                q.push(ed);\n            }\n        }\n    }\n    memset(cur, 0, sizeof(cur));\n    if (dep[T] == -1)\n        return 0;\n    else\n        return 1;\n}\nint dfs(int st, int limit) // limitæœ€å¤§å¯å¢åŠ çš„æµé‡\n{\n    if (st == T)\n        return limit;\n    int nowflow = 0;                                   // å®šä¹‰å½“å‰èŠ‚ç‚¹çš„æµé‡,å¤šè·¯å¢å¹¿ä¼˜åŒ–ï¼Œæ‰¾æ»¡å½“å‰èƒ½æ‰¾çš„limitæµé‡ä¸Šç•Œ\n    for (int i = cur[st]; i < e[st].size(); i = i + 1) // å½“å‰å¼§ä¼˜åŒ–ï¼Œå¦‚æœä¸€ä¸ªç‚¹æœ‰å¾ˆå¤šå‡ºè¾¹ï¼Œæœ‰äº›å‡ºè¾¹å¯èƒ½æ— æ³•å†æ¨æµäº†ï¼Œæˆ‘ä»¬å°±è®°å½•ç¬¬ä¸€æ¡å¯ä»¥æ¨æµçš„è¾¹\n    {\n        cur[st] = i; // å½“å‰å¼§ä¼˜åŒ–\n        int ed = e[st][i].ed;\n        if (dep[ed] == dep[st] + 1 && e[st][i].len) // è¿™æ¡è¾¹èƒ½æ¨ä¸”ï¼Œæ·±åº¦ä¸ºæ›´æ·±ä¸€å±‚ï¼ˆä¸ºäº†æ‰¾æœ€çŸ­çš„å¢å¹¿è·¯ï¼‰\n        {\n            int t = dfs(ed, min(e[st][i].len, limit - nowflow)); // æ˜¯ä¸ºäº†é™åˆ¶åé¢ç‚¹çš„æµé‡ä¸èƒ½å¤§äºlimit-nowflow\n            if (t)                                               // èµ°ä¸‹å»èƒ½æ¨æµ\n            {\n                e[st][i].len -= t;           // å‡å»ç›¸åº”çš„\n                e[ed][e[st][i].id].len += t; // åè¾¹+ç›¸åº”çš„\n                nowflow += t;\n                if (t)\n                    net[st] = ed - n;\n                if (nowflow == limit)\n                    return nowflow;\n            }\n        }\n    }\n    if (!nowflow)\n        dep[st] = -1; // å¦‚æœè¿™ä¸ªç‚¹ä¸èƒ½å»¶ç”³ï¼Œé‚£å°±åˆ æ‰è¿™ä¸ªç‚¹ï¼ˆç‚¸ç‚¹ä¼˜åŒ–ï¼‰\n    return nowflow;   // ä¼šè¿”å›æœ¬æ¬¡bfsï¼ˆï¼‰åæ‰€æœ‰å¢å¹¿è·¯èƒ½åŠ çš„æœ€å¤šæµé‡\n}\nint dinic()\n{\n    int r = 0;\n    while (bfs())\n        r += dfs(S, INF);\n    return r;\n}\nvoid add(int u, int v, int w)\n{\n    // cout<<u<<\" \"<<v<<\" \"<<w<<endl;\n    int sti = e[u].size();\n    int edi = e[v].size();\n    e[u].push_back((edge){v, w, edi}); // å»ºè¾¹\n    e[v].push_back((edge){u, 0, sti});\n}\nvoid print(int x)\n{\n    printf(\"%d \", x);\n    if (net[x] > 0)\n        print(net[x]);\n}\nsigned main()\n{\n    cin >> n >> m;\n    S = 0;\n    T = 2 * n + 1;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add(u, v + n, 1);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        add(S, i, 1);\n        add(i + n, T, 1);\n    }\n    int maxflow = dinic();\n    for (int i = 1; i <= n; i++)\n        if (net[i])\n            d[net[i]]++;\n    for (int i = 1; i <= n; i++)\n        if (!d[i])\n            print(i), cout << endl;\n    cout << n - maxflow;\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n##### 2.7.2.2 Dilworthå®šç†\n\næ ¹æ®$Dilworth$å®šç†ï¼Œååºé›†åˆçš„**æœ€é•¿é“¾é•¿åº¦**ç­‰äºå…¶**æœ€å°çš„åé“¾è¦†ç›–**ã€‚\n\n**é“¾**ï¼šä¸€æ¡é“¾æ˜¯ä¸€äº›**ç‚¹çš„é›†åˆ**ï¼Œç‚¹é›†ä¸­ä»»æ„ä¸¤ä¸ªç‚¹$u$å’Œ$v$ï¼Œæ»¡è¶³$u$èƒ½åˆ°è¾¾$v$æˆ–æ˜¯$v$èƒ½åˆ°è¾¾$u$ï¼ˆå­˜åœ¨ååºå…³ç³»ï¼‰ï¼Œåˆ™ç§°è¯¥ç‚¹é›†ä¸ºä¸€æ¡é“¾ã€‚\n\n**åé“¾**ï¼šä¸€æ¡åé“¾æ˜¯ä¸€äº›**ç‚¹çš„é›†åˆ**ï¼Œç‚¹é›†ä¸­ä»»æ„ä¸¤ä¸ªç‚¹$u$å’Œ$v$ï¼Œæ»¡è¶³$u$ä¸èƒ½åˆ°è¾¾$v$å¹¶ä¸”$v$ä¸èƒ½åˆ°è¾¾$u$â€‹ï¼Œåˆ™ç§°è¯¥ç‚¹é›†ä¸ºä¸€æ¡åé“¾ã€‚\n\n**æœ€å°é“¾è¦†ç›–**æ˜¯æŒ‡åœ¨æœ‰å‘å›¾ä¸­ç”¨**å¯ä»¥ç›¸äº¤**çš„è‹¥å¹²æ¡è·¯å¾„è¦†ç›–æ•´ä¸ªå›¾ä¸”è·¯å¾„æ•°æœ€å°‘ã€‚\n\n**æ±‚å‡ºæœ‰å‘å›¾çš„ä¼ é€’é—­åŒ…ä¹‹åå³å¯æŒ‰ç…§ç¤ºä¾‹ä¸€ä¸ç›¸äº¤è·¯å¾„æ±‚è§£ï¼ŒäºŒåˆ†å›¾æœ€å¤§åŒ¹é…å³å¯ã€‚**\n\nå¦‚æœæœ‰å‘å›¾æ˜¯ä¸€ä¸ª**å®Œå¤‡**çš„**ååºé›†åˆå“ˆæ–¯å›¾**ï¼ˆå³å…¶ä¼ é€’é—­åŒ…ç­‰äºè‡ªèº«ï¼‰ï¼Œåˆ™**æœ€å°é“¾è¦†ç›–ç­‰ä»·äºæœ€å°è·¯å¾„è¦†ç›–**ã€‚æ­¤æ—¶ï¼Œ$Dilworth$å®šç†å¯é‡æ–°è¡¨è¿°ä¸º**æœ€å¤§é“¾é•¿åº¦ç­‰äºæœ€å°çš„åé“¾åˆ’åˆ†**ã€‚\n\n**ç¤ºä¾‹1ï¼šABC237Ex Hakata**\n\næˆ‘ä»¬æœ‰ä¸€ä¸ªç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² $S$ ã€‚Bob æ¯å¤©éƒ½åœ¨æ€è€ƒå›æ–‡ã€‚ä»–å†³å®šä» $S$ ä¸­é€‰æ‹©ä¸€äº›å›æ–‡å­ä¸²å¹¶å‘Šè¯‰ Annaã€‚\n\nå¦‚æœ Bob å‘Šè¯‰çš„å›æ–‡ä¹‹ä¸€æ˜¯å¦ä¸€ä¸ªå›æ–‡çš„å­ä¸²ï¼ŒAnna ä¼šç”Ÿæ°”ã€‚Bob å¯ä»¥é€‰æ‹©æœ€å¤šå¤šå°‘ä¸ªå›æ–‡è€Œä¸ä¼šè®© Anna ç”Ÿæ°”ï¼Ÿ\n\n$N\\le 300$\n\næ˜¾ç„¶ï¼ŒåŒ…å«æ˜¯ä¸€ä¸ªååºå…³ç³»ã€‚æˆ‘ä»¬è¦æ±‚è§£çš„æ˜¯**æœ€é•¿çš„äº’ç›¸ä¸åŒ…å«çš„å›æ–‡ä¸²åºåˆ—é•¿åº¦**ï¼Œå®é™…ä¸Šå°±æ˜¯**æœ€é•¿çš„åé“¾é•¿åº¦**ã€‚\n\n$Dilworth$å®šç†è½¬**æœ€å°çš„åé“¾è¦†ç›–**ã€‚ç”±äºæˆ‘ä»¬èƒ½å¤Ÿå»ºç«‹å‡ºå®Œå¤‡çš„ååºå“ˆæ–¯å›¾ï¼ˆå®é™…ä¸Šéƒ½å¯ä»¥ï¼‰ï¼Œåˆè½¬**æœ€å°åé“¾åˆ’åˆ†**ï¼Œå³**æœ€å°è·¯å¾„è¦†ç›–**ã€‚\n\næ±‚äºŒåˆ†å›¾æœ€å¤§åŒ¹é…ï¼Œå‚è€ƒç¤ºä¾‹1ï¼Œä½œå·®å³å¯ã€‚\n\n```cpp\nvoid solve()\n{\n    string s;\n    cin >> s;\n    vector<string> pali;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 1; i + j <= s.size(); j++)\n        {\n            string t = s.substr(i, j);\n            string r = t;\n            reverse(r.begin(), r.end());\n            if (t == r)\n            {\n                pali.push_back(t);\n            }\n        }\n    }\n    sort(pali.begin(), pali.end());\n    pali.erase(unique(pali.begin(), pali.end()), pali.end());\n    int sz = pali.size();\n    MaxFlow<int> mf(2 * sz + 10);\n    const int S = 2 * sz, T = 2 * sz + 1;\n    for (int i = 0; i < sz; i++)\n    {\n        mf.addEdge(S, i, 1);\n        mf.addEdge(sz + i, T, 1);\n    }\n    for (int i = 0; i < sz; i++)\n    {\n        for (int j = 0; j < sz; j++)\n        {\n            if (i == j)\n                continue;\n            if (pali[i].find(pali[j]) != string::npos)\n            {\n                mf.addEdge(i, sz + j, 1);\n            }\n        }\n    }\n    cout << sz - mf.flow(S, T) << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.3 æœ€å¤§æµæœ€å°å‰²å®šç†\n\næœ€å¤§æµ=æœ€å°å‰²ã€‚\n\nå‰²é›†å¥½æ¯”æ˜¯ä¸€ä¸ªææ€–åˆ†å­ æŠŠä½ å®¶å’Œè‡ªæ¥æ°´å‚ä¹‹é—´çš„æ°´ç®¡ç½‘ç»œç æ–­äº†ä¸€äº› ç„¶åè‡ªæ¥æ°´å‚æ— è®ºæ€ä¹ˆæ”¾æ°´ æ°´éƒ½åªèƒ½ä»æ°´ç®¡æ–­å£å“—å“—æµèµ°äº† ä½ å®¶å°±åœæ°´äº† å‰²çš„å¤§å°åº”è¯¥æ˜¯ææ€–åˆ†å­åº”è¯¥å…³å¿ƒçš„äº‹ æ¯•ç«Ÿç»†ç®¡å­å¥½å‰²ä¸€äº› è€Œæœ€å°å‰²èŠ±çš„åŠ›æ°”æœ€å°\n\nç½‘ç»œçš„æœ€å¤§æµç­‰äºæœ€å°å‰² \n\nå…·ä½“çš„è¯æ˜åˆ†ä¸‰éƒ¨åˆ† \n\n1. ä»»æ„ä¸€ä¸ªæµéƒ½å°äºç­‰äºä»»æ„ä¸€ä¸ªå‰²ã€‚\n\nè¿™ä¸ªå¾ˆå¥½ç†è§£ï¼Œè‡ªæ¥æ°´å…¬å¸éšä¾¿ç»™ä½ å®¶é€šç‚¹æ°´æ„æˆä¸€ä¸ªæµï¼Œææ€–åˆ†å­éšä¾¿ç å‡ åˆ€ï¼Œç å‡ºä¸€ä¸ªå‰²ï¼Œç”±äºå®¹é‡é™åˆ¶ï¼Œæ¯ä¸€æ ¹çš„è¢«ç çš„æ°´ç®¡å­æµå‡ºçš„æ°´æµé‡éƒ½å°äºç®¡å­çš„å®¹é‡ï¼Œæ¯ä¸€æ ¹è¢«ç çš„æ°´ç®¡çš„æ°´æœ¬æ¥éƒ½è¦åˆ°ä½ å®¶çš„ï¼Œç°åœ¨æµåˆ°å¤–é¢ï¼ŒåŠ èµ·æ¥å¾—åˆ°çš„æµé‡è¿˜æ˜¯ç­‰äºåŸæ¥çš„æµã€‚ç®¡å­çš„å®¹é‡åŠ èµ·æ¥å°±æ˜¯å‰²ï¼Œæ‰€ä»¥æµå°äºç­‰äºå‰²ã€‚ç”±äºä¸Šé¢çš„æµå’Œå‰²éƒ½æ˜¯ä»»æ„æ„é€ çš„ï¼Œæ‰€ä»¥ä»»æ„ä¸€ä¸ªæµå°äºä»»æ„ä¸€ä¸ªå‰²ã€‚\n\n2. æ„é€ å‡ºä¸€ä¸ªæµç­‰äºä¸€ä¸ªå‰²ã€‚\n\nå½“è¾¾åˆ°æœ€å¤§æµæ—¶ï¼Œæ ¹æ®å¢å¹¿è·¯å®šç†ï¼Œæ®‹ç•™ç½‘ç»œä¸­$s$åˆ°$t$å·²ç»æ²¡æœ‰é€šè·¯äº†ï¼Œå¦åˆ™è¿˜èƒ½ç»§ç»­å¢å¹¿ã€‚æˆ‘ä»¬æŠŠ$s$èƒ½åˆ°çš„çš„ç‚¹é›†è®¾ä¸º$S$ï¼Œä¸èƒ½åˆ°çš„ç‚¹é›†ä¸º$T$ï¼Œæ„é€ å‡ºä¸€ä¸ªå‰²é›†$C[S,T]$ï¼Œ$S$åˆ°$T$çš„è¾¹å¿…ç„¶æ»¡æµï¼Œå¦åˆ™å°±èƒ½ç»§ç»­å¢å¹¿ï¼Œè¿™äº›æ»¡æµè¾¹çš„æµé‡å’Œå°±æ˜¯å½“å‰çš„æµå³æœ€å¤§æµã€‚æŠŠè¿™äº›æ»¡æµè¾¹ä½œä¸ºå‰²ï¼Œå°±æ„é€ å‡ºäº†ä¸€ä¸ªå’Œæœ€å¤§æµç›¸ç­‰çš„å‰²ã€‚\n\n3. æœ€å¤§æµç­‰äºæœ€å°å‰²ã€‚\n\n\nè®¾ç›¸ç­‰çš„æµå’Œå‰²åˆ†åˆ«ä¸º$F_m$å’Œ$C_m$ï¼Œåˆ™å› ä¸ºä»»æ„ä¸€ä¸ªæµå°äºç­‰äºä»»æ„ä¸€ä¸ªå‰²ï¼Œä»»æ„$Fâ‰¤Fm=Cmâ‰¤$ä»»æ„$C$ ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.4 æœ€å¤§æƒé—­åˆå­å›¾\n\næœ€å¤§æƒé—­åˆå­å›¾ï¼šç»™å®šä¸€ä¸ªæœ‰å‘å›¾, é¡¶ç‚¹å¸¦æƒå€¼. ä½ å¯ä»¥é€‰ä¸­ä¸€äº›é¡¶ç‚¹, è¦æ±‚å½“é€‰ä¸­ä¸€ä¸ªç‚¹ $u$ çš„æ—¶å€™, è‹¥å­˜åœ¨è¾¹ $u\\rightarrow v$ åˆ™ $v$â€‹ ä¹Ÿå¿…é¡»é€‰ä¸­. æœ€å¤§åŒ–é€‰ä¸­çš„ç‚¹çš„æ€»æƒå€¼.\n\nå»ºæ¨¡ï¼šè´Ÿç‚¹æƒç‚¹å‘é‡ç‚¹è¿è¾¹ï¼Œæºç‚¹å‘æ­£ç‚¹æƒç‚¹è¿è¾¹ï¼Œå›¾ä¸­åŸå…ˆçš„ç‚¹è¿æ— ç©·å¤§è¾¹ï¼Œè·‘æœ€å°å‰²å³å¯ï¼Œæœ€ç»ˆç»“æœå°±æ˜¯æ‰€æœ‰æ­£ç‚¹æƒä¹‹å’Œ$-$æœ€å°å‰²ã€‚\n\nç¤ºä¾‹ï¼š**CFedu171 Best Subsequence**\n\nç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ $$a$$ ï¼Œå¤§å°ä¸º $n$ ã€‚\n\næˆ‘ä»¬å°†æ•°ç»„çš„å€¼å®šä¹‰ä¸ºå…¶å¤§å°å‡å»æ•°ç»„æ‰€æœ‰å…ƒç´ æŒ‰ä½æˆ–ä¸­çš„è®¾ç½®ä½æ•°ã€‚\n\nä¾‹å¦‚ï¼Œå¯¹äºæ•°ç»„ $[1, 0, 1, 2]$ ï¼ŒæŒ‰ä½æˆ–ä¸º $3$ (åŒ…å« $2$ ä¸ªè®¾ç½®ä½)ï¼Œæ•°ç»„çš„å€¼ä¸º $$4-2=2$$ ã€‚\n\næ‚¨çš„ä»»åŠ¡æ˜¯è®¡ç®—ç»™å®šæ•°ç»„çš„æŸä¸ªå­åºåˆ—çš„æœ€å¤§å¯èƒ½å€¼ã€‚\n\næ˜¾ç„¶æ˜¯æœ€å¤§æƒé—­åˆå­å›¾é—®é¢˜ï¼Œæˆ–è€…å¯ä»¥ç†è§£ä¸ºäºŒè€…é€‰å…¶ä¸€é—®é¢˜ã€‚è¯¥ç‚¹è¦è¢«é€‰æ‹©ï¼Œè¿™äº›ä½ç½®éƒ½è¦è¢«æ‰£1.\n\n```cpp\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<i64> a(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    MaxFlow<i64> f;\n    int sz = n + 60 + 2;\n    f.init(sz);\n    const int s = n + 60, t = n + 60 + 1;\n    for (int i = 0; i < n; i++)\n    {\n        f.addEdge(s, i, 1);\n        for (int j = 59; j >= 0; j--)\n        {\n            if ((a[i] >> j) & 1)\n            {\n                f.addEdge(i, n + j, 1);\n            }\n        }\n    }\n    for (int j = 59; j >= 0; j--)\n    {\n        f.addEdge(n + j, t, 1);\n    }\n    i64 ans = f.flow(s, t);\n    cout << n - ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.5  äºŒè€…é€‰å…¶ä¸€é—®é¢˜\n\nå°†è‹¥å¹²å…ƒç´ $e_1,e_2,â€¦,e_n$åˆ’åˆ†åˆ°ä¸¤ä¸ªé›†åˆ$A,B$ä¸­ã€‚å¯¹äºå…ƒç´ $e_i$,å®ƒè¢«åˆ’åˆ†åˆ°$A$æˆ–$B$ä¸­åˆ†åˆ«èƒ½è·å¾—ä¸€ä¸ª$a_{e_i}$æˆ–$b_{e_i}$çš„åˆ†å€¼ã€‚é™¤æ­¤ä¹‹å¤–,è¿˜ç»™å‡ºè‹¥å¹²ä¸ªç»„åˆ$C_i\\in E$,å½“ç»„åˆä¸­çš„å…ƒç´ è¢«åŒæ—¶åˆ’åˆ†åˆ°$A$æˆ–$B$æ—¶,å¯ä»¥è·å¾—é¢å¤–çš„åˆ†å€¼$a'$æˆ–$b'$ã€‚æ±‚æœ€å¤§çš„åˆ†å€¼ã€‚\n\nåŸºæœ¬æ¨¡å‹æ˜¯è®¾ç«‹ä¸¤ä¸ªè¶…çº§æºç‚¹ï¼Œæ¯ä¸ªç‰©å“åˆ†åˆ«è¿ï¼Œæœ€å¤§æ”¶ç›Šå°±æ˜¯æ”¶ç›Šæ€»å’Œ-æœ€å°å‰²\n\nå¯¹äºåŒå±äºä¸€éçš„é¢å¤–ç»„åˆï¼Œåˆ™æ–°å»ºèŠ‚ç‚¹ï¼Œè¶…çº§æºç‚¹ï¼ˆä»¥$A$ç¤ºä¾‹ï¼‰å‘è¯¥æ–°èŠ‚ç‚¹æµé¢å¤–æ”¶ç›Š$a'$ï¼Œä¸ºä¿è¯åç»­èŠ‚ç‚¹å¿…å®šåœ¨$A$éƒ¨ï¼Œè¯¥æ–°èŠ‚ç‚¹å‘è¯¥ç»„åˆçš„ä¸­é—´ç‚¹è¿æ— ç©·å¤§è¾¹ï¼Œè¿«ä½¿æœ€å°å‰²å¦‚æœä¿ç•™äº†$a'$è¾¹ï¼Œå°±å¿…é¡»éš”æ–­æ‰€æœ‰å’Œ$B$çš„è¾¹ï¼Œä»¥è¾¾æˆæ­£ç¡®æ€§ã€‚\n\n<img src=\"https://pic4.zhimg.com/v2-3f06c22d87598fc1b5c1774376d303c3_r.jpg\" alt=\"img\" style=\"zoom:25%;\" />\n\nç¤ºä¾‹ï¼š**2024æ­ç”µå¤šæ ¡ï¼ˆ5ï¼‰çŒ«å’ªä»¬ç‹‚æ¬¢**\n\nçŒ«å’ªä»¬ç”Ÿæ´»åœ¨æ ‘ä¸Šã€‚\n\nå…·ä½“æ¥è¯´ï¼Œæœ‰ $n$ åªçŒ«å’ªå’Œä¸¤æ£µå¤§å°ä¸º$n$çš„æ ‘ã€‚çŒ«å’ªç¼–å·ä¸º $1âˆ¼n$ ï¼Œæ¯æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ç¼–å·ä¹Ÿä¸º $1âˆ¼n$ï¼ˆç¼–å·å„ä¸ç›¸åŒï¼‰ ã€‚\n\nä»Šæ™šï¼Œæ¯åªçŒ«å’ªè¦åˆ†åˆ«é€‰æ‹©ä¸€æ£µæ ‘ï¼Œå¹¶å¾…åœ¨ä¸å…¶ç¼–å·ç›¸åŒçš„èŠ‚ç‚¹ã€‚\n\nåœ¨è¿™ $n$ åªçŒ«å’ªä¹‹ä¸­ï¼Œæœ‰ $k$ åªçŒ«å’ªæ˜¯ç‹‚æ¬¢çŒ«ã€‚ç‹‚æ¬¢çŒ«æ™šä¸Šä¸ä¼šç¡è§‰ï¼Œè€Œæ˜¯ä¼šé€‰æ‹©å¼€partyã€‚å…¶ä»–çŒ«å’ªåˆ™ä¼šé€‰æ‹©ç¡è§‰ã€‚\n\næ¯æ¡æ ‘è¾¹éƒ½æœ‰ä¸€ä¸ªç‹‚æ¬¢å€¼ï¼Œå¦‚æœè¿™æ¡è¾¹è¿æ¥çš„ä¸¤ä¸ªèŠ‚ç‚¹åœ¨æ™šä¸Šéƒ½æœ‰ç‹‚æ¬¢çŒ«å¾…ç€ï¼Œè¿™ä¸ªç‹‚æ¬¢å€¼å°±ä¼šè¢«ç´¯åŠ åˆ°æ€»ç‹‚æ¬¢å€¼ä¸Šã€‚\n\næœ€å¤§åŒ–ä»Šæ™šçš„æ€»ç‹‚æ¬¢å€¼ï¼Œå¹¶è¾“å‡ºè¿™ä¸ªå€¼ã€‚\n\n\n\næ˜¾ç„¶æ˜¯äºŒè€…é€‰å…¶ä¸€é—®é¢˜ï¼Œæ¯åªçŒ«å’ªæœ‰é€‰æ‹©å·¦è¿˜æ˜¯é€‰æ‹©å³çš„é—®é¢˜ï¼Œæœ‰æœ€å¤š$n-1$ç»„ç»„åˆä¼šæœ‰é¢å¤–æ”¶ç›Šã€‚ç‹‚æ¬¢çŒ«åªæœ‰$k$åªï¼Œæ¶‰åŠåˆ°çš„ç‹‚æ¬¢çŒ«æ‰å½¢æˆç»„é˜ŸèŠ‚ç‚¹ã€‚\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<int> cat(k + 1);\n    map<int, int> mp;\n    for (int i = 1; i <= k; i++)\n    {\n        cin >> cat[i];\n        mp[cat[i]] = 1;\n    }\n    const int s = 0, t = n + 1;\n    MaxFlow<i64> flow(4 * n + 10);\n    int virp = n + 2;\n    i64 ans = 0;\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        if (mp[u] && mp[v])\n        {\n            flow.addEdge(s, virp, w);\n            flow.addEdge(virp, u, INT_MAX / 2);\n            flow.addEdge(virp, v, INT_MAX / 2);\n            ans += w;\n            virp++;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        if (mp[u] && mp[v])\n        {\n            flow.addEdge(virp, t, w);\n            flow.addEdge(u, virp, INT_MAX / 2);\n            flow.addEdge(v, virp, INT_MAX / 2);\n            ans += w;\n            virp++;\n        }\n    }\n    cout << ans - flow.flow(s, t) << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.6 äºŒåˆ†å›¾æœ€å¤§è¾¹æƒåŒ¹é…\n\näºŒåˆ†å›¾çš„æœ€å¤§æƒåŒ¹é…æ˜¯æŒ‡äºŒåˆ†å›¾ä¸­è¾¹æƒå’Œæœ€å¤§çš„åŒ¹é…ã€‚æ•°æ®ä¿è¯æœ‰è§£ã€‚\n\nè€ƒè™‘è´¹ç”¨æµã€‚\n\nä¸ **äºŒåˆ†å›¾æœ€å¤§åŒ¹é…**ç±»ä¼¼ï¼ŒäºŒåˆ†å›¾çš„æœ€å¤§æƒåŒ¹é…ä¹Ÿå¯ä»¥è½¬åŒ–ä¸ºç½‘ç»œæµé—®é¢˜æ¥æ±‚è§£ã€‚\n\né¦–å…ˆï¼Œåœ¨å›¾ä¸­æ–°å¢ä¸€ä¸ªæºç‚¹å’Œä¸€ä¸ªæ±‡ç‚¹ã€‚\n\nä»æºç‚¹å‘äºŒåˆ†å›¾çš„æ¯ä¸ªå·¦éƒ¨ç‚¹è¿ä¸€æ¡æµé‡ä¸º $1$ ï¼Œè´¹ç”¨ä¸º $0$ çš„è¾¹ï¼Œä»äºŒåˆ†å›¾çš„æ¯ä¸ªå³éƒ¨ç‚¹å‘æ±‡ç‚¹è¿ä¸€æ¡æµé‡ä¸º $1$ ï¼Œè´¹ç”¨ä¸º $0$ çš„è¾¹ã€‚\n\næ¥ä¸‹æ¥å¯¹äºäºŒåˆ†å›¾ä¸­æ¯ä¸€æ¡è¿æ¥å·¦éƒ¨ç‚¹ $u$ å’Œå³éƒ¨ç‚¹ $v$ ï¼Œè¾¹æƒä¸º $w$ çš„è¾¹ï¼Œåˆ™è¿ä¸€æ¡ä» $u$ åˆ° $v$ï¼Œæµé‡ä¸º $1$ ï¼Œè´¹ç”¨ä¸º $w$ çš„è¾¹ã€‚\n\nå¦å¤–ï¼Œè€ƒè™‘åˆ°***æœ€å¤§æƒåŒ¹é…ä¸‹***ï¼Œ***åŒ¹é…è¾¹çš„æ•°é‡ä¸ä¸€å®šä¸æœ€å¤§åŒ¹é…çš„åŒ¹é…è¾¹æ•°é‡ç›¸ç­‰ï¼ˆä¸ä¸€å®šæœ€å¤§æµï¼‰***ï¼Œå› æ­¤å¯¹äºæ¯ä¸ªå·¦éƒ¨ç‚¹ï¼Œè¿˜éœ€å‘æ±‡ç‚¹è¿ä¸€æ¡æµé‡ä¸º$1$ ï¼Œè´¹ç”¨ä¸º $0$ çš„è¾¹ã€‚\n\næ±‚è¿™ä¸ªç½‘ç»œçš„ **æœ€å¤§è´¹ç”¨æœ€å¤§æµ**å³å¯å¾—åˆ°ç­”æ¡ˆã€‚æ­¤æ—¶ï¼Œè¯¥ç½‘ç»œçš„æœ€å¤§æµé‡ä¸€å®šä¸ºå·¦éƒ¨ç‚¹çš„æ•°é‡ï¼Œè€Œæœ€å¤§æµé‡ä¸‹çš„æœ€å¤§è´¹ç”¨å³å¯¹åº”ä¸€ä¸ªæœ€å¤§æƒåŒ¹é…æ–¹æ¡ˆã€‚æœ€å¤§è´¹ç”¨æœ€å¤§æµå¯ä»¥ç›´æ¥è´Ÿè´¹ç”¨çš„æœ€å°è´¹ï¼ŒJianglyæ¨¡æ¿æ”¯æŒã€‚\n\n#### 2.7.7 äºŒåˆ†å›¾æœ€å°è¾¹æƒç‚¹è¦†ç›–\n\näºŒåˆ†å›¾çš„æœ€å°è¾¹æƒç‚¹è¦†ç›–æŒ‡æ‰¾åˆ°ä¸€ä¸ªè¾¹æƒå’Œæœ€å°çš„é¡¶ç‚¹è¦†ç›–ã€‚æ•°æ®ä¿è¯æœ‰è§£ã€‚\n\nè€ƒè™‘æœ€å°è¦†ç›–çš„ä¸€ç§æ„é€ æ–¹å¼ï¼š\n\né€‰æ‹©ä¸€ä¸ªåŒ¹é…è¾¹é›†åˆ$E_1$ï¼Œæ‰€æœ‰ä¸å±äº$E_1$åŒ…å«çš„ç‚¹é›†$V_1$çš„ç‚¹é€‰æ‹©ä¸€æ¡ä¸è‡ªå·±ç›¸é‚»çš„ç‚¹ä¸­è¾¹æƒæœ€å°çš„é‚£ä¸€ä¸ªç‚¹ï¼Œæ·»åŠ å¯¹åº”è¾¹ï¼ˆ**å…è®¸é‡è¾¹**ï¼‰ã€‚å¯ä»¥è¯æ˜æœ€ä¼˜è§£ä¸€å®šå¯ä»¥è¢«è¿™ç§æ„é€ æ–¹å¼æ„é€ ï¼Œä¸”æ˜¯å¦æ˜¯æœ€ä¼˜è§£ä¸€å®šå–å†³äº$E_1$çš„é€‰æ‹©ã€‚\n\nè®¾ç‚¹$u$ä¸ºç«¯ç‚¹çš„è¾¹çš„æœ€å°è¾¹æƒä¸º$wm_u$ï¼Œåˆ™æœ‰ä¸€ä¸ªéå¸¸ç®€å•çš„åŒ–ç®€ï¼š\n$$\nCost=\\sum_{e\\in E_1}c(e)+\\sum_{v\\in V\\backslash V_1}wm_v=\\sum_{v\\in V}wm_v+\\sum_{e\\in E_1}(c(e_{u,v})-wm_u-wm_v)\n$$\næœ€å°åŒ–ç¬¬äºŒé¡¹æˆæœ¬å³å¯ã€‚æ„å»ºä»¥ä¸‹ç½‘ç»œæµäºŒåˆ†å›¾è·‘æœ€å°è´¹ç”¨æµï¼š\n\n- ä» $S$ å‘æ¯ä¸ª $X_i$ æ·»åŠ ä¸€æ¡è¾¹ï¼Œå®¹é‡ä¸º $1$ ï¼Œæˆæœ¬ä¸º $0$\n- å¯¹äºæ¯ä¸ª $(X_i,Y_j)$ ï¼Œä» $X_i$ å‘ $Y_j$ æ·»åŠ ä¸€æ¡è¾¹ï¼Œå®¹é‡ä¸º $1$ ï¼Œæˆæœ¬ä¸º $(c(e_{X_i,Y_i})-wm_{X_i}-wm_{Y_i})$\n- ä»æ¯ä¸ª $Y_i$ å‘ $T$ æ·»åŠ ä¸€æ¡è¾¹ï¼Œå®¹é‡ä¸º $1$ ï¼Œæˆæœ¬ä¸º $0$.\n- å¦å¤–ï¼Œè€ƒè™‘åˆ°***æœ€å°è´¹åŒ¹é…ä¸‹***ï¼Œ***åŒ¹é…è¾¹çš„æ•°é‡ä¸ä¸€å®šä¸æœ€å¤§åŒ¹é…çš„åŒ¹é…è¾¹æ•°é‡ç›¸ç­‰ï¼ˆä¸ä¸€å®šæœ€å¤§æµï¼Œè¿™ä¸ªå¸¦æœ‰è´Ÿæˆæœ¬çš„æ›´ä¸ºæ˜æ˜¾ï¼‰***ï¼Œå› æ­¤å¯¹äºæ¯ä¸ªå·¦éƒ¨ç‚¹ï¼Œè¿˜éœ€å‘æ±‡ç‚¹è¿ä¸€æ¡æµé‡ä¸º $1$ ï¼Œè´¹ç”¨ä¸º $0$ çš„è¾¹ã€‚\n\nç›´æ¥è·‘$MincostFlow.h$å°±è¡Œï¼ŒJianglyæ¨¡æ¿æ”¯æŒè´Ÿæ•°è´¹ç”¨ã€‚\n\nç¤ºä¾‹1ï¼š**ABC231H - Minimum Coloring**\n\næˆ‘ä»¬æœ‰ä¸€ä¸ªç½‘æ ¼ï¼Œæœ‰ $H$ è¡Œå’Œ $W$ åˆ—ã€‚ä»¤ $(i,j)$ è¡¨ç¤ºä»é¡¶éƒ¨ç®—èµ·ç¬¬ $i$ è¡Œå’Œä»å·¦ä¾§ç®—èµ·ç¬¬ $j$ åˆ—çš„æ–¹æ ¼ã€‚\n\nåœ¨è¿™ä¸ªç½‘æ ¼ä¸Šï¼Œæœ‰ $N$ ä¸ªç™½è‰²æ£‹å­ï¼Œç¼–å·ä¸º $1$ è‡³ $N$ ã€‚æ£‹å­ $i$ ä½äº $(A_i,B_i)$ ä¸Šã€‚\n\næ‚¨å¯ä»¥æ”¯ä»˜ $C_i$ çš„è´¹ç”¨æ¥å°†æ£‹å­ $i$ æ”¹ä¸ºé»‘è‰²æ£‹å­ã€‚\n\næ‰¾å‡ºåœ¨æ¯ä¸€è¡Œå’Œæ¯ä¸€åˆ—ä¸­è‡³å°‘æœ‰ä¸€ä¸ªé»‘è‰²æ£‹å­æ‰€éœ€çš„æœ€å°æ€»è´¹ç”¨ã€‚\n\nè£¸çš„æ¿å­ã€‚\n\n```cpp\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    const int s = n + m, t = n + m + 1;\n    MinCostFlow<i64> mcf(n + m + 10);\n    vector<int> a(n + m + 10, INT_MAX / 2);\n    vector<array<int, 3>> e(k);\n    for (int i = 0; i < k; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--;\n        v--;\n        e[i] = {u, v, w};\n        a[u] = min(a[u], w);\n        a[n + v] = min(a[n + v], w);\n    }\n    i64 ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        mcf.addEdge(s, i, 1, 0);\n        mcf.addEdge(i, t, 1, 0);\n        ans += a[i];\n    }\n    for (int j = 0; j < m; j++)\n    {\n        mcf.addEdge(n + j, t, 1, 0);\n        ans += a[n + j];\n    }\n    for (int i = 0; i < k; i++)\n    {\n        auto [u, v, w] = e[i];\n        mcf.addEdge(u, n + v, 1, w - a[u] - a[n + v]);\n    }\n    auto [flow, cost] = mcf.flow(s, t);\n    cout << ans + cost << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.8 å‰©ä½™ç‰©å“äº’ä¸ç›¸åŒé—®é¢˜\n\næ“ä½œåå‰©ä½™äº’ä¸ç›¸åŒï¼Œå¯ä»¥é€šè¿‡åˆ—ä¸¾å‡ºæ‰€æœ‰å‰©ä½™ç‰©å“ç§ç±»ä¹‹åæ¯ä¸ªåªå‘è¶…çº§æ±‡ç‚¹è¿ä¸€æ¡å®¹é‡ä¸º$1$çš„è¾¹ï¼Œä»¥ç¡®ä¿æ¯ç§ç‰©å“åªä¼šå‡ºç°ä¸€æ¬¡ã€‚\n\nå‰©ä½™æ•°é‡é™åˆ¶ä¸º$x$â€‹çš„æ—¶å€™åŒç†ï¼Œé™åˆ¶å®¹é‡å¤§å°å³å¯ã€‚\n\n**ç¤ºä¾‹1ï¼šï¼ˆ2024æˆéƒ½ç«™K)**\n\næ‚¨æœ‰ä¸€ä¸ªç¥å¥‡çš„é›†åˆï¼Œæœ€åˆåŒ…å« $n$ ä¸ªä¸åŒçš„æ•´æ•°ã€‚æ‚¨å‘ç°è¿™äº›æ•°å­—å¯ä»¥é€šè¿‡é™¤ä»¥å®ƒä»¬çš„å› æ•°æ¥äº§ç”Ÿèƒ½é‡ã€‚åœ¨æ¯ä¸ªæ­¥éª¤ä¸­ï¼Œæ‚¨å¯ä»¥ä»é›†åˆä¸­é€‰æ‹©ä»»ä½•å¤§äº $1$ çš„æ•°å­—ï¼Œå°†å…¶åˆ é™¤ï¼Œç„¶åæ’å…¥å®ƒçš„ä¸€ä¸ªå› æ•°ã€‚æ‚¨æ’å…¥çš„å› æ•°ä¸å¾—ç­‰äºåŸå§‹æ•°å­—ã€‚æ­¤å¤–ï¼Œç”±äºç¥å¥‡é›†åˆçš„ä¸ç¨³å®šæ€§ï¼Œæ‚¨çš„æ“ä½œå¿…é¡»ç¡®ä¿é›†åˆä¸­çš„æ•°å­—ä¿æŒä¸åŒã€‚\n\næ¯ä¸ªæ“ä½œéƒ½ä¼šäº§ç”Ÿä¸€ä¸ªèƒ½é‡å•ä½ï¼Œæ‚¨çš„ç›®æ ‡æ˜¯é€šè¿‡æ‰§è¡Œå°½å¯èƒ½å¤šçš„æ“ä½œæ¥æœ€å¤§åŒ–äº§ç”Ÿçš„æ€»èƒ½é‡ã€‚ç»™å®šé›†åˆä¸­çš„åˆå§‹æ•°å­—ï¼Œç¡®å®šå¯ä»¥äº§ç”Ÿçš„æœ€å¤§èƒ½é‡ï¼Œå³å¯æ‰§è¡Œçš„æœ€å¤§æ“ä½œæ•°ã€‚\n\næ˜¾ç„¶æ¯ä¸ªæ•°éƒ½ä¼šå°½å¯èƒ½çš„æŒ‰æ­¥æ•°åˆ†è§£ï¼Œæœ€å¤§çš„æ“ä½œæ•°ä¸€å®šå–å†³äºéšåå‰©ä½™çš„å› æ•°ç»„åˆé—®é¢˜ã€‚è§„çº¦åˆ°äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é…å³å¯ã€‚\n\nåˆ†è§£å› æ•°ï¼Œè¶…çº§æºç‚¹å‘åˆå§‹æ•°è¿ä¸€æ¡å®¹é‡ä¸º$1$ã€è´¹ç”¨ä¸º$0$çš„è¾¹ï¼›åˆå§‹æ•°å­—å‘å¯¹åº”å› æ•°è¿å®¹é‡ä¸º$1$ã€å¯¹åº”æ¶ˆè€—æ¬¡æ•°çš„è´¹ç”¨$w$ï¼›å¯¹åº”å› æ•°å‘è¶…çº§ç»ˆç‚¹è¿å®¹é‡ä¸º$1$ã€è´¹ç”¨ä¸º$0$çš„è¾¹ã€‚è·‘æœ€å¤§è´¹ç”¨æµå³å¯ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 2.7.9 å…¶ä»–è®°å½•\n\n1.å°Mçš„ä½œç‰©(æœ€å°å‰²) å·§å¦™å°†é—®é¢˜è½¬åŒ–ä¸ºæœ€å°å‰²\n\n2.å¥¶ç‰›çš„ç”µä¿¡Telecowmunication æœ€å°å‰²è¾¹è½¬åŒ–ä¸ºæœ€å°å‰²ç‚¹ï¼Œæ–¹æ³•æ˜¯æ‹†ç‚¹æŠŠä¸€ä¸ªç‚¹æ‹†æˆä¸¤ä¸ªç‚¹ï¼Œç”¨1çš„è¾¹é•¿è¿èµ·æ¥ï¼Œä¸¤ä¸ªä¸åŒç‚¹ä¹‹é—´çš„è¿çº¿ç”¨INFè¿èµ·æ¥ï¼Œè¿™æ ·çš„æœ€å°å‰²å°±åªèƒ½å‰²1çš„ç‚¹ï¼Œç›¸å½“äºå‰²ç‚¹äº† \n\n3.æ•™è¾…çš„ç»„æˆ ä¹Ÿæ˜¯æ‹†ç‚¹ï¼Œæˆ‘ä»¬é™åˆ¶ä¸€ä¸ªç‚¹é€šè¿‡çš„æµé‡ï¼Œå°±æ˜¯æŠŠè¿™ä¸ªç‚¹æ‹†æˆä¸¤ä¸ªç‚¹ï¼Œä¸­é—´è¿ä¸€æ¡æˆ‘ä»¬è¦é™åˆ¶çš„æµé‡çš„å¤§å°çš„è¾¹\n\n4.ç‹¼æ‰å…”å­ å¯ä»¥ç›´æ¥ç½‘ç»œæµ ä¹Ÿå¯ä»¥æœ€å°å‰²è½¬å¹³é¢å›¾æœ€çŸ­è·¯ï¼ˆå¹³é¢å›¾æœ€å°å‰²=å¯¹å¶å›¾çš„æœ€çŸ­è·¯ï¼‰\n\n5.æ–¹æ ¼å–æ•°é—®é¢˜ï¼Œæœ‰æ¡ä»¶çš„æœ€å€¼ã€‚äºŒåˆ†å›¾ç‚¹æƒæœ€å¤§ç‹¬ç«‹é›†\n\næŠŠæ–¹æ ¼æ ¹æ®i+jçš„å¥‡å¶æ€§åˆ†ä¸ºä¸¤ç±»ç‚¹ï¼Œå‘ç°ä¿ç•™ä¸€ä¸ªç‚¹çš„ä»£ä»·æ˜¯å–èµ°å‘¨å›´çš„å¦ä¸€ç±»çš„ç‚¹ï¼Œè½¬åŒ–ä¸ºæœ€å°å‰²ã€‚\n\nSè¿ç™½ç‚¹ï¼Œå®¹é‡ä¸ºç‚¹æƒï¼Œé»‘ç‚¹è¿TåŒç†ï¼ŒåŒæ—¶ä¸€ä¸ªç‚¹å‘å‘¨å›´å››ä¸ªç‚¹è¿è¾¹ï¼Œè¾¹æƒä¸ºinfï¼Œè¿™æ ·è·‘å‡ºæ¥çš„æœ€å°å‰²ï¼Œèˆå¼ƒä¸€ä¸ªç‚¹ä¸ºæ–­å¼€ä»–ä¸ä¸€ä¸ªæºç‚¹çš„è¿æ¥ï¼Œæ„æ€å°±æ˜¯ä¸è¦è¿™ä¸ªç‚¹ï¼Œä¿ç•™ä¸‹æ¥çš„ç‚¹å°±æ˜¯æœ€å¤§çš„ï¼Œsum-dinic()å³å¯\n\nå¥—è·¯ï¼šæ–¹æ ¼ä¸­çš„ç‚¹çœ‹çœ‹èƒ½ä¸èƒ½åˆ†ä¸ºä¸¤ç±»ï¼Œå³åˆ†ä¸ºä¸€ä¸ªäºŒåˆ†å›¾ï¼ŒåŒç±»çš„ç‚¹æ˜¯å¯ä»¥å…±å­˜çš„ï¼Œç„¶åä¸èƒ½å…±å­˜çš„ä¸€å®šæ˜¯ä¸¤ç±»ä¹‹é—´ï¼Œä¸­é—´è¿infè¾¹è·‘æœ€å¤§æµï¼Œç­”æ¡ˆå°±æ˜¯æ€»å’Œå‡å»æœ€å°å‰²ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n## 3. ç”Ÿæˆæ ‘\n\n#### 3.1 ä¸¤ç§æœ€å°ç”Ÿæˆæ ‘\n\n##### 3.1.1 Prim\n\n```cpp\nvoid prim(){\n    memset(dis,0x3f3f3f3f,sizeof(dis));\n    priority_queue<node>q;//æ‰€ä»¥è¿™é‡Œå…¶å®æ˜¯å°æ ¹å †ï¼Œå­˜çš„æ˜¯è¾¹ï¼ˆæ¯æ¬¡æŠ‰æ‹©æ—¶å¾…é€‰çš„è¾¹ï¼‰\n    node t;t.to=1,t.val=0;dis[1]=0;\n    q.push(t);//ï¼ˆæœ€å¼€å§‹é€‰æ‹©èµ·ç‚¹ï¼‰\n    while(q.size()!=0){\n        node now=q.top();q.pop();\n        if(vis[now.to]==1)continue;\n        vis[now.to]=1;\n        ans+=now.val;\n        for(auto i:edge[now.to]){\n            if(!vis[i.to]&&dis[i.to]>i.val){\n                //æœ‰æ›´æ–°çš„è¾¹ï¼Œéƒ½æ˜¯å¯èƒ½è¦è¢«é€‰çš„è¾¹ï¼ŒåŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œè¿™é‡Œçš„åˆ¤æ–­åªæœ‰è¾¹æƒï¼Œå› ä¸ºdisæ˜¯åˆ°å½“å‰é›†åˆçš„è·ç¦»\n                dis[i.to]=i.val;\n                q.push(i);\n            }\n        }\n    }\n}\n```\n\n##### 3.1.2 Kruskal\n\n```cpp\ncin>>n>>m;\n    for(int i=1;i<=n;i++)fa[i]=i;//å¹¶æŸ¥é›†ç»´æŠ¤æ˜¯å¦åœ¨ç”Ÿæˆæ ‘é‡Œ\n    for(int i=1;i<=m;i++){\n        cin>>u>>v>>sum;\n        a[i].x=u,a[i].y=v,a[i].val=sum;\n    }\n    sort(a+1,a+1+m);\n    for(int i=1;i<=m;i++){\n        if(fa[find(a[i].x)]==fa[find(a[i].y)])continue;//å·²ç»åŠ å…¥äº†é‚£å°±ä¸è¦äº†\n        else{\n            unions(a[i].x,a[i].y);//åŠ è¾¹\n            k++;\n            ans+=a[i].val;\n        }\n        if(k==n-1)break;\n    }\n    if(k<n-1)cout<<\"orz\";\nelse cout<<ans;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *3.2 Kruskalé‡æ„æ ‘\n\nKruskal é‡æ„æ ‘å°±æ˜¯åŸºäº Kruskal çš„æœ€å°ç”Ÿæˆæ ‘ç®—æ³•åœ¨æ— å‘å›¾ä¸­å¾—å‡ºçš„æ ‘æ‰€æ„é€ è€Œæˆçš„æ ‘ã€‚\n\n**æ€§è´¨**\n\n- æ˜¯ä¸€æ£µäºŒå‰æ ‘ã€‚\n- å¦‚æœæ˜¯æŒ‰æœ€å°ç”Ÿæˆæ ‘å»ºç«‹çš„è¯æ˜¯ä¸€ä¸ªå¤§æ ¹å †ã€‚\n- **å¼ºå¤§æ€§è´¨**ï¼šåŸå›¾ä¸­ä¸¤ä¸ªç‚¹é—´æ‰€æœ‰è·¯å¾„ä¸Šçš„è¾¹æœ€å¤§æƒå€¼çš„æœ€å°å€¼ == æœ€å°ç”Ÿæˆæ ‘ä¸Šä¸¤ç‚¹ç®€å•è·¯å¾„çš„è¾¹æœ€å¤§æƒå€¼ == $Kruskal$ é‡æ„æ ‘ä¸Šä¸¤ç‚¹ $LCA$ çš„ç‚¹æƒã€‚\n\nåˆ©ç”¨è¿™ä¸ªæ€§è´¨ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°åˆ°ç‚¹ $x$ çš„ç®€å•è·¯å¾„ä¸Šçš„è¾¹æœ€å¤§æƒå€¼çš„æœ€å°å€¼$â‰¤ val$çš„æ‰€æœ‰ç‚¹ $y$ã€‚å¯ä»¥å‘ç°éƒ½åœ¨ $Kruskal$ é‡æ„æ ‘ä¸Šçš„æŸä¸€æ£µå­æ ‘å†…ï¼Œä¸”æ°å¥½ä¸ºè¯¥å­æ ‘çš„æ‰€æœ‰å¶èŠ‚ç‚¹ã€‚\n\n**å…·ä½“ç»†èŠ‚**\n\næˆ‘ä»¬åœ¨ $Kruskal$ é‡æ„æ ‘ä¸Šæ‰¾åˆ° $x$ åˆ°æ ¹çš„è·¯å¾„ä¸Šæƒå€¼ $â‰¤val$ çš„æœ€æµ…çš„èŠ‚ç‚¹,è¿™å°±æ˜¯é‚£æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚è¿™ä¸ªåˆ°æ—¶å€™ç±»ä¼¼æ±‚$LCA$ç”±é«˜åˆ°ä½å€å¢è·³å°±è¡Œäº†ï¼Œä¸€èˆ¬è¿™ç§æƒ…å†µä¸‹è¿˜æœ‰æ ‘ä¸Šçº¿æ®µæ ‘åˆå¹¶æˆ–è€…ä¹¦ä¸Šä¸»å¸­æ ‘ä¹‹ç±»çš„ã€‚\n\n- å¦‚æœé¢˜ç›®è¦æ±‚æœ€å°æƒå€¼æœ€å¤§å€¼ï¼Œå¯ä»¥å»ºæœ€å¤§ç”Ÿæˆæ ‘çš„é‡æ„æ ‘ä»è€Œè¾¾åˆ°ä¸€æ ·çš„æ•ˆæœã€‚\n\n```cpp\nvoid Ex_Kruskal()\n{\n    int cnt=n;\n    sort(e+1,e+m+1,cmp);//å¯¹è¾¹æ’åº\n    for (int i=1;i<2*n;++i) f[i]=i;//é¢„å¤„ç†å¹¶æŸ¥é›†\n    for (int i=1;i<=m;++i)\n    {\n        int u=get(e[i].x),v=get(e[i].y);\n        if (u!=v)\n        {\n            ++cnt;//æ–°ç‚¹\n            f[u]=f[v]=cnt;//åˆå§‹åŒ–\n            val[cnt]=e[i].z;//æ–°ç‚¹æƒä¸ºè¿™ä¸ªè¾¹æƒ\n            add(cnt,u);add(cnt,v);//è¿è¾¹\n            if (cnt==2*n-1) break;//ä¸€å…±2*n-1ä¸ªç‚¹ï¼Œå»ºå¥½é€€å‡º\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 4.  äºŒåˆ†å›¾æœ€å¤§åŒ¹é…/äºŒåˆ†å›¾æœ€å°ç‚¹è¦†ç›–\n\nåŒˆç‰™åˆ©ç®—æ³•ï¼Œæˆ–è€…ç½‘ç»œæµã€‚\n\nåŒˆç‰™åˆ©ç®—æ³•,åˆ¤æ–­äºŒåˆ†å›¾ï¼šå¹¶æŸ¥é›†/dfsï¼ˆå³æŸ“è‰²æ³•/å¹¶æŸ¥é›†ï¼‰\n\näºŒåˆ†å›¾æ˜¯ä»€ä¹ˆï¼ŸèŠ‚ç‚¹ç”±ä¸¤ä¸ªé›†åˆç»„æˆï¼Œä¸”ä¸¤ä¸ªé›†åˆå†…éƒ¨æ²¡æœ‰è¾¹çš„å›¾ã€‚è¿™å¼ å›¾ä¸Šçš„æ‰€æœ‰è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹ï¼Œéƒ½åˆ†å±ä¸åŒçš„éƒ¨åˆ†ï¼Œæ— å‘å›¾\n\næœ€å¤§åŒ¹é…ï¼šè¦æ±‚é€‰å‡ºä¸€äº›è¾¹ï¼Œä½¿å¾—è¿™äº›è¾¹æ²¡æœ‰å…¬å…±é¡¶ç‚¹ï¼Œä¸”è¾¹çš„æ•°é‡æœ€å¤§ã€‚\n\näºŒåˆ†å›¾ä¸­ï¼Œæœ€å°ç‚¹è¦†ç›– = æœ€å¤§åŒ¹é…  æœ€å°ç‚¹è¦†ç›–ï¼šæŒ‡çš„æ˜¯åœ¨ä¸€ä¸ªå›¾ä¸­ï¼šä¸€ä¸ªç‚¹è¦†ç›–ä¸ä¹‹è¿æ¥çš„è¾¹ï¼Œæ±‚ç”¨æœ€å°‘çš„ç‚¹å¯ä»¥è¦†ç›–å›¾ã€‚\n\näºŒåˆ†å›¾ä¸­ï¼Œæœ€å¤§ç‹¬ç«‹é›† = $n- $æœ€å°ç‚¹è¦†ç›– \n\næœ€å¤§ç‹¬ç«‹é›†ï¼šä¸€ä¸ªç‚¹é›†ï¼Œé‡Œé¢çš„ç‚¹ä¸¤ä¸¤ä¸ç›¸é‚» \n\nç®—æ³•æ­¥éª¤ï¼šå¦‚æœåæ¥çš„å’Œä»¥å‰çš„å‘ç”ŸçŸ›ç›¾ï¼Œåˆ™ä»¥å‰çš„è¢«ç»¿ä¼˜å…ˆé€€è®©ã€‚\n\nå¦‚æœä»¥å‰çš„é€€è®©ä¹‹åæ²¡æœ‰cpå¯å¤„ï¼Œåˆ™ä»¥å‰çš„æ‹’ç»é€€è®©ï¼Œæ–°æ¥çš„å»å¯»æ‰¾ä¸‹ä¸€ä¸ªåŒ¹é…ã€‚\n\nå¦‚æœæ–°æ¥çš„è°ä¹ŸåŒ¹é…ä¸ä¸Šäº†ï¼Œé‚£å°±è¿™ä¹ˆå•ç€å§ã€‚\n\n```cpp\n//O(nm),ä½†æ˜¯Dinicå¯ä»¥sqrt(n)*m\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2*1e5+2;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> P;\nint n,m,e,u,v,ans;\nvector<int>edge[505];\nint vis[505],match[505];//matchï¼šä¸ºå³éƒ¨ç‚¹å»ºç«‹çš„æ•°ç»„ï¼Œå­˜çš„æ˜¯ä¸å®ƒåŒ¹é…çš„å·¦éƒ¨ç‚¹\nbool check(int x){\n    for(auto i:edge[x]){//æšä¸¾æ¯ä¸€ä¸ªå³éƒ¨ç‚¹\n        if(!vis[i]){//æ²¡è®¿é—®è¿‡\n            vis[i]=1;\n            if(!match[i]||check(match[i])){//å¯ä»¥ç›´æ¥åŒ¹é…oråŸå…ˆçš„iå¯ä»¥æ¢äºº\n                match[i]=x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    cin>>n>>m>>e;\n    for(int i=1;i<=e;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n    }\n    for(int i=1;i<=n;i++){\n        memset(vis,0,sizeof(vis));//å¯¹äºæ¯ä¸€ä¸ªuçš„ç ”ç©¶ï¼Œå¯¹å¦ä¸€å¤–ä¸€åŠåªèƒ½è®¿é—®ä¸€æ¬¡ï¼Œæ•…æ¯æ¬¡éƒ½è¦æ¸…ç©º\n        if(check(i))ans++;\n    }\n    cout<<ans;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 5.æ ‘ä¸Šé—®é¢˜\n\n### 5.1  æ ‘ä¸ŠLCA\n\nå…³äºå€å¢æ³•ä»¥åŠæ¬§æ‹‰åº$ST$è¡¨åœ¨çº¿åšæ³•å‚è§æ•°æ®ç»“æ„éƒ¨åˆ†ã€‚è¿™é‡Œåªç»™å‡ºç¦»çº¿$Tarjan$ç®—æ³•ï¼Œå®ç°$O(n+m)$â€‹å¤æ‚åº¦ã€‚\n\n```cpp\n#include<bits/stdc++.h>//Tarjanç¦»çº¿ç®—æ³•\nusing namespace std;\nconst int N=5*1e5+2;\ntypedef long long ll;\nstruct point{\n    int x,i;\n};\nvector<vector<int> >edge;\nvector<vector<point> >q;\nint dep[N],fa[N],vis[N],ans[N];\nint find(int x){//è·¯å¾„å‹ç¼©\n    if(fa[x]!=x){\n        fa[x]=find(fa[x]);\n    }\n    return fa[x];\n}\nvoid unions(int x,int y){//xåˆå¹¶åˆ°yä¸Š\n    fa[find(x)]=fa[find(y)];\n}\nvoid dfs(int x,int f){/***1.**ä»¥sä¸ºæ ¹èŠ‚ç‚¹ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚\n**2.**éå†è¯¥ç‚¹uæ‰€æœ‰å­èŠ‚ç‚¹vï¼Œå¹¶æ ‡è®°è¿™äº›å­èŠ‚ç‚¹vå·²è¢«è®¿é—®è¿‡ã€‚\n**3.**è‹¥æ˜¯vè¿˜æœ‰å­èŠ‚ç‚¹ï¼Œè¿”å›2ï¼Œå¦åˆ™ä¸‹ä¸€æ­¥ã€‚\n**4.**åˆå¹¶våˆ°uä¸Šã€‚\n**5.**å¯»æ‰¾ä¸å½“å‰ç‚¹uæœ‰è¯¢é—®å…³ç³»çš„ç‚¹vã€‚\n**6.**è‹¥æ˜¯vå·²ç»è¢«è®¿é—®è¿‡äº†ï¼Œåˆ™å¯ä»¥ç¡®è®¤uå’Œvçš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¸ºvè¢«åˆå¹¶åˆ°çš„çˆ¶äº²èŠ‚ç‚¹aã€‚*/\n    vis[x]=1;\n    for(auto i:edge[x]){\n        if(i!=f){\n            dfs(i,x);\n            unions(i,x);\n        }\n    }\n    for(auto t:q[x]){\n        if(vis[t.x])ans[t.i]=find(t.x);\n    }\n}\nint main(){\n    int n,m,s;int x,y;\n    cin>>n>>m>>s;\n    edge.resize(n+1);\n    q.resize(n+1);\n    for(int i=1;i<=n;i++)fa[i]=i;\n    for(int i=1;i<n;i++){\n        cin>>x>>y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    for(int i=1;i<=m;i++){\n        cin>>x>>y;\n        q[x].push_back({y,i});//å¦ä¸€ä¸ªç›¸å…³ç‚¹å’Œç»„æ•°\n        q[y].push_back({x,i});\n    }\n    dfs(s,0);\n    for(int i=1;i<=m;i++)cout<<ans[i]<<endl;\n    return 0;\n}\n\n/*ä¸€ä¸ªç†Šå­©å­Linkä»ä¸€æ£µæœ‰æ ¹æ ‘çš„æœ€å·¦è¾¹æœ€åº•ä¸‹çš„ç»“ç‚¹çŒå²©æµ†ï¼ŒLinkè¡¨ç¤ºå¾ˆè®¨åŒè¿™ç§å€’ç€é•¿çš„æ ‘ã€‚\nå²©æµ†ä¼šä¸æ–­çš„æ³¨å…¥ï¼Œç›´åˆ°æ³¨æ»¡æ•´ä¸ªæ ‘â€¦\nå¦‚æœå²©æµ†çŒæ»¡äº†ä¸€æ£µå­æ ‘ï¼ŒLinkå‘ç°æ ‘çš„å¦ä¸€è¾¹æœ‰ä¸€æ£µæ›´æ·±çš„å­æ ‘ï¼ŒLinkä¼šå…ˆå»å°†é‚£æ£µå­æ ‘çŒæ»¡ã€‚\nå²©æµ†åªæœ‰åœ¨è¿«ä¸å¾—å·²çš„æƒ…å†µä¸‹æ‰ä¼šå‘ä¸Šå‡é«˜ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ–°çš„å­æ ‘ç»§ç»­æ³¨å…¥ã€‚\næœº(yu)æ™º(chun)çš„Linkå‘ç°äº†æ‰¾LCAçš„å¥½æ–¹æ³•ï¼Œå³å¦‚æœä¸¤ä¸ªç»“ç‚¹éƒ½è¢«å²©æµ†çƒ§æ‰æ—¶ï¼Œä»–ä»¬çš„LCAå³ä¸ºé‚£æ£µå­æ ‘ä¸Šå²©æµ†æœ€é«˜çš„ä½ç½®*/\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.2 æ ‘é“¾å‰–åˆ†\n\nå‚è§æ•°æ®ç»“æ„éƒ¨åˆ†é™æ€æ ‘ç« èŠ‚ï¼Œå¯¹äºé•¿é“¾ã€é‡é“¾éƒ½æœ‰ã€‚\n\nè¿™é‡Œè´´å‡ºé‡é“¾å‰–åˆ†å¤´æ–‡ä»¶$HLD.h$ã€‚è¿™ä¸ªæ˜¯ä»$0$å¼€å§‹çš„ã€‚\n\n```cpp\n/*\n     *@brief é‡é“¾å‰–åˆ†(jiangly)ç‰ˆæœ¬\n     *@brief æ—¶é—´å¤æ‚åº¦O(n)\n     *@brief ç©ºé—´å¤æ‚åº¦O(n)\n     */\n    struct HLD\n    {\n        int n;\n        std::vector<int> siz, top, dep, parent, dfn, enddfn, rk;\n        std::vector<std::vector<int>> adj;\n        int cur;\n        HLD() {}\n        HLD(int n)\n        {\n            init(n);\n        }\n        void init(int n)\n        {\n            this->n = n;\n            siz.resize(n);\n            top.resize(n);\n            dep.resize(n);\n            parent.resize(n);\n            dfn.resize(n);\n            enddfn.resize(n);\n            rk.resize(n);\n            cur = 0;\n            adj.assign(n, {});\n        }\n        void add_edges(int u, int v)\n        {\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        /*\n         * @brief é‡é“¾å‰–åˆ†ï¼ˆjianglyï¼‰ï¼Œåªèƒ½å‰–ä¸€æ¬¡ï¼Œä¸æ”¯æŒåŠ¨æ€æ ‘ï¼ŒèŠ‚ç‚¹ç¼–å·å’Œæ ‘å‰–ç¼–å·éƒ½æ˜¯ä»0å¼€å§‹ã€‚\n         * @param root æ ¹èŠ‚ç‚¹\n         * @note é‡é“¾å‰–åˆ†å‰éœ€è¦å…ˆè°ƒç”¨initå‡½æ•°,è°ƒç”¨é‡é“¾å‰–åˆ†åï¼Œé‚»æ¥è¡¨vectorä¸­å­˜å‚¨çš„æ˜¯é‡é“¾å‰–åˆ†åçš„æ ‘ï¼Œæ²¡æœ‰æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„è¾¹\n         * @note é‡é“¾å‰–åˆ†åï¼Œdfnæ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯èŠ‚ç‚¹çš„dfsåºï¼Œrkæ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯dfsåºå¯¹åº”çš„èŠ‚ç‚¹ï¼Œenddfnæ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯èŠ‚ç‚¹æ‰€å¯¹åº”å­æ ‘çš„dfsåºçš„ç»“æŸä½ç½®çš„åä¸€ä¸ªï¼ˆå·¦é—­å³å¼€ï¼‰ã€‚\n         */\n        void work(int root = 0)\n        {\n            top[root] = root;\n            dep[root] = 0;\n            parent[root] = -1;\n            dfs1(root);\n            dfs2(root);\n        }\n        void dfs1(int u)\n        {\n            if (parent[u] != -1)\n            {\n                adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));\n            }\n            siz[u] = 1;\n            for (auto &v : adj[u])\n            {\n                parent[v] = u;\n                dep[v] = dep[u] + 1;\n                dfs1(v);\n                siz[u] += siz[v];\n                if (siz[v] > siz[adj[u][0]])\n                {\n                    std::swap(v, adj[u][0]);\n                }\n            }\n        }\n        void dfs2(int u)\n        {\n            dfn[u] = cur++;\n            rk[dfn[u]] = u;\n            for (auto v : adj[u])\n            {\n                top[v] = v == adj[u][0] ? top[u] : v;\n                dfs2(v);\n            }\n            enddfn[u] = cur;\n        }\n        /*\n         * @brief è¿”å›uåˆ°vçš„æœ€è¿‘å…¬å…±ç¥–å…ˆ\n         * @param u èµ·ç‚¹\n         * @param v ç»ˆç‚¹\n         * @return è¿”å›uåˆ°vçš„æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹\n         */\n        int lca(int u, int v)\n        {\n            while (top[u] != top[v])\n            {\n                if (dep[top[u]] > dep[top[v]])\n                {\n                    u = parent[top[u]];\n                }\n                else\n                {\n                    v = parent[top[v]];\n                }\n            }\n            return dep[u] < dep[v] ? u : v;\n        }\n        /*\n         * @brief è¿”å›uåˆ°vçš„è·ç¦»\n         * @param u èµ·ç‚¹\n         * @param v ç»ˆç‚¹\n         * @return è¿”å›uåˆ°vçš„è·ç¦»\n         */\n        int dist(int u, int v)\n        {\n            return dep[u] + dep[v] - 2 * dep[lca(u, v)];\n        }\n        /*\n         * @brief è·³è·ƒ\n         * @param u èµ·ç‚¹\n         * @param k è·³è·ƒè·ç¦»\n         * @return è¿”å›è·³è·ƒåçš„èŠ‚ç‚¹\n         */\n        int jump(int u, int k)\n        {\n            if (dep[u] < k)\n            {\n                return -1;\n            }\n\n            int d = dep[u] - k;\n\n            while (dep[top[u]] > d)\n            {\n                u = parent[top[u]];\n            }\n\n            return rk[dfn[u] - dep[u] + d];\n        }\n        /*\n         * @brief åˆ¤æ–­uæ˜¯å¦æ˜¯vçš„ç¥–å…ˆ\n         * @param u èµ·ç‚¹\n         * @param v ç»ˆç‚¹\n         * @return è¿”å›uæ˜¯å¦æ˜¯vçš„ç¥–å…ˆ\n         */\n        bool isAncester(int u, int v)\n        {\n            return dfn[u] <= dfn[v] && dfn[v] < enddfn[u];\n        }\n        /*\n        int rootedParent(int u, int v)\n        {\n            std::swap(u, v);\n            if (u == v)\n            {\n                return u;\n            }\n            if (!isAncester(u, v))\n            {\n                return parent[u];\n            }\n            auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y)\n                                       { return dfn[x] < dfn[y]; }) -\n                      1;\n            return *it;\n        }\n        int rootedSize(int u, int v)\n        {\n            if (u == v)\n            {\n                return n;\n            }\n            if (!isAncester(v, u))\n            {\n                return siz[v];\n            }\n            return n - siz[rootedParent(u, v)];\n        }\n\n        int rootedLca(int a, int b, int c)\n        {\n            return lca(a, b) ^ lca(b, c) ^ lca(c, a);\n        }*/\n    };\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.3 æ ‘çš„ç›´å¾„\n\næ ‘å½¢$dp$ï¼Œæ±‚å‡ºæ¯ä¸ªç‚¹çš„æœ€é•¿è·¯å’Œæ¬¡é•¿è·¯ã€‚\n\n```cpp\nvoid dfs(int u,int fa){\n    int sum1=0,sum2=0;\n    f[u]=1;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            dfs(i,u);\n            if(f[i]>sum1)sum2=sum1,sum1=f[i];\n            else if(f[i]>sum2)sum2=f[i];\n        }\n    }\n    if(f[u]+sum1+sum2>ans)ans=f[u]+sum1+sum2;\n    f[u]+=sum1;\n}\n```\n\n### 5.4 æ ‘çš„é‡å¿ƒ\n\næ— æ ¹æ ‘çš„é‡å¿ƒç‚¹å®šä¹‰ä¸ºæ ‘ç§çš„ç‚¹$u$ï¼Œä½¿å¾—$u$ç›¸é‚»çš„æ‰€æœ‰å­æ ‘çš„å­æ ‘å¤§å°å‡ä¸å¤§äºæ ‘å¤§å°çš„ä¸€åŠã€‚æ˜¾ç„¶ä¸€æ£µæ ‘æœ€å¤šåªæœ‰ä¸¤ä¸ªé‡å¿ƒï¼ˆå½“æ ‘èŠ‚ç‚¹ä¸ºå¥‡æ•°æ—¶ï¼‰ï¼Œä¸”ä¸¤ä¸ªé‡å¿ƒå¿…å®šç›¸é‚»ã€‚æ ¹æ®è¿™ä¸ªå¯ä»¥è¿›è¡Œä¸€å®šçš„äºŒåˆ†ï¼ˆ2024å—äº¬ç«™Gï¼‰\n\n**æ€§è´¨1**\n\næŸä¸ªç‚¹æ˜¯æ ‘çš„**é‡å¿ƒ**ç­‰ä»·äºå®ƒæœ€å¤§å­æ ‘å¤§å°**ä¸å¤§äº**æ•´æ£µæ ‘å¤§å°çš„**ä¸€åŠ**ã€‚\n\n**æ€§è´¨2**\n\næ ‘**è‡³å¤šæœ‰ä¸¤ä¸ª**é‡å¿ƒã€‚å¦‚æœæ ‘æœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œé‚£ä¹ˆå®ƒä»¬**ç›¸é‚»**ã€‚æ­¤æ—¶æ ‘ä¸€å®šæœ‰**å¶æ•°**ä¸ªèŠ‚ç‚¹ï¼Œä¸”å¯ä»¥è¢«åˆ’åˆ†ä¸ºä¸¤ä¸ªå¤§å°ç›¸ç­‰çš„åˆ†æ”¯ï¼Œæ¯ä¸ªåˆ†æ”¯å„è‡ªåŒ…å«ä¸€ä¸ªé‡å¿ƒã€‚\n\n**æ€§è´¨3**\n\næ ‘ä¸­æ‰€æœ‰ç‚¹åˆ°æŸä¸ªç‚¹çš„è·ç¦»å’Œä¸­ï¼Œåˆ°é‡å¿ƒçš„è·ç¦»å’Œæ˜¯æœ€å°çš„ï¼›å¦‚æœæœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œé‚£ä¹ˆåˆ°å®ƒä»¬çš„è·ç¦»å’Œä¸€æ ·ã€‚åè¿‡æ¥ï¼Œè·ç¦»å’Œæœ€å°çš„ç‚¹ä¸€å®šæ˜¯é‡å¿ƒã€‚\n\n**æ€§è´¨4**\n\nå¾€æ ‘ä¸Šå¢åŠ æˆ–å‡å°‘ä¸€ä¸ªå¶å­ï¼Œå¦‚æœåŸèŠ‚ç‚¹æ•°æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆé‡å¿ƒå¯èƒ½å¢åŠ ä¸€ä¸ªï¼ŒåŸé‡å¿ƒä»æ˜¯é‡å¿ƒï¼›å¦‚æœåŸèŠ‚ç‚¹æ•°æ˜¯å¶æ•°ï¼Œé‡å¿ƒå¯èƒ½å‡å°‘ä¸€ä¸ªï¼Œå¦ä¸€ä¸ªé‡å¿ƒä»æ˜¯é‡å¿ƒ\n\n**æ€§è´¨5**\n\næŠŠä¸¤æ£µæ ‘é€šè¿‡ä¸€æ¡è¾¹ç›¸è¿å¾—åˆ°ä¸€æ£µæ–°çš„æ ‘ï¼Œåˆ™æ–°çš„é‡å¿ƒåœ¨è¾ƒå¤§çš„ä¸€æ£µæ ‘ä¸€ä¾§çš„è¿æ¥ç‚¹ä¸åŸé‡å¿ƒä¹‹é—´çš„ç®€å•è·¯å¾„ä¸Šã€‚å¦‚æœä¸¤æ£µæ ‘å¤§å°ä¸€æ ·ï¼Œåˆ™é‡å¿ƒå°±æ˜¯ä¸¤ä¸ªè¿æ¥ç‚¹ã€‚\n\n```cpp\nint n, sz[MAXN], mss[MAXN]; // nï¼šæ€»ç»“ç‚¹æ•°ï¼ˆè¯·ä»å¤–éƒ¨ä¼ å…¥ï¼‰ï¼Œszï¼šæ ‘çš„å¤§å°ï¼Œmssï¼šæœ€å¤§å­æ ‘å¤§å°\nvector<int> ctr; // é‡å¿ƒ\nvoid dfs(int p, int fa = 0) // æ‰¾é‡å¿ƒ\n{\n    sz[p] = 1, mss[p] = 0;\n    for (auto [to, w] : edges[p])\n        if (to != fa)\n        {\n            dfs(to, p);\n            mss[p] = max(mss[p], sz[to]);\n            sz[p] += sz[to];\n        }\n    mss[p] = max(mss[p], n - sz[p]);\n    if (mss[p] <= n / 2) ctr.push_back(p);\n}\n```\n\n### 5.5 æ ‘ä¸Šå·®åˆ†\n\nè§æ•°æ®ç»“æ„é™æ€æ ‘éƒ¨åˆ†ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5.6 æ ‘ä¸Šå¯å‘å¼åˆå¹¶\n\næ ‘ä¸Šå¯å‘å¼åˆå¹¶æ˜¯ä¸€ç§æš´åŠ›çš„$Trick$ï¼Œé€šè¿‡å°å­æ ‘ä¿¡æ¯å‘å¤§å­æ ‘åˆå¹¶ï¼Œå®ç°å’Œå¹¶æŸ¥é›†æŒ‰ç§©åˆå¹¶ä¸€æ ·çš„äºšçº¿æ€§å¤æ‚åº¦ã€‚ä¼°ç®—æŒ‰ç…§$nlogn$â€‹ç®—å°±è¡Œï¼Œä¹Ÿæ˜¯ä¸€ç§ä¹±æåšæ³•ã€‚\n\nç¤ºä¾‹1: **2024æ­ç”µå¤šæ ¡1 æ ‘**\n\nç»™ä¸€æ£µæ ¹ä¸º $1$ çš„æœ‰æ ¹æ ‘ï¼Œç‚¹ $i$ å…·æœ‰ä¸€ä¸ªæƒå€¼ $A_i$ ã€‚\n\nå®šä¹‰ä¸€ä¸ªç‚¹å¯¹çš„å€¼ $f(u,v)=max(A_u,A_v)Ã—|A_uâˆ’A_v|$ ã€‚\n\nä½ éœ€è¦å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ $i$ ï¼Œè®¡ç®— $ans_i=âˆ‘_{uâˆˆsubtree(i),vâˆˆsubtree(i)}f(u,v) $ï¼Œå…¶ä¸­ $subtree(i)$ è¡¨ç¤º $i$ çš„å­æ ‘ã€‚\n\nè¯·ä½ è¾“å‡º $âŠ•(ans_i\\ mod\\ 2^{64})$ ï¼Œå…¶ä¸­ âŠ• è¡¨ç¤º $XOR$â€‹â€‹.\n\næ˜¾ç„¶ç¡¬æŒ‰ç€ç»“ç‚¹ä¸å¥½æƒ³ã€‚\n\nè€ƒè™‘ä¸¤ä¸ªå­æ ‘åˆå¹¶ï¼Œ$ans_i$çš„ä¿¡æ¯æ˜¯ä¸€å®šè¦ç»§æ‰¿$ans_{u},u\\in son(i)$çš„ã€‚è€ƒè™‘ä¸åŒå±äºä¸¤ä¸ªå­æ ‘çš„ç‚¹å¦‚ä½•å¤„ç†ã€‚\n\næƒå€¼æ ‘åˆå¹¶ï¼Œæƒå€¼æ ‘åŒºé—´åˆå¹¶çš„æ—¶å€™ï¼Œä¸€å®šæ˜¯å·¦éƒ¨åˆ†çš„åŒºé—´ç‚¹æƒå°äºå³éƒ¨åˆ†çš„åŒºé—´ç‚¹æƒã€‚æ‰€ä»¥ä¸¤éƒ¨åˆ†åˆå¹¶çš„æ—¶å€™å³åŠåŒºé—´çš„æ¯ä¸€ä¸ªç‚¹ä¼šé¢å¤–äº§ç”Ÿ\n$$\n\\large\\sum -sum_{lsons}\\times val_{r_i}+cnt_{lson}\\times val_{r_i}^2\n$$\nçº¿æ®µæ ‘ç»“ç‚¹ç»´æŠ¤åŒºé—´$sum$ã€åŒºé—´æ•°ä¸ªæ•°ã€åŒºé—´$sum^2$å³å¯ã€‚ç„¶å$nlogn$â€‹çº¿æ®µæ ‘æ ‘ä¸Šå¯å‘å¼åˆå¹¶å³å¯ã€‚\n\n<div style=\"page-break-after: always;\"></div>\n\nç¤ºä¾‹2ï¼š**2024æ­ç”µå¤šæ ¡3 æ—…è¡Œ**\n\næœ‰ä¸€æ£µ$n$ ä¸ªç»“ç‚¹çš„æ— æ ¹æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹éƒ½æœ‰å¯¹åº”çš„ç±»å‹ $c_i$ å’Œæƒé‡ $w_i$ ï¼Œä½ éœ€è¦åœ¨è¿™æ£µæ ‘ä¸Šè§„åˆ’è‹¥å¹²æ¬¡æ—…è¡Œã€‚\n\nå¯¹äºä¸€æ¬¡æ—…è¡Œï¼Œä½ å°†ä»ä¸€ä¸ªæ ‘ä¸Šçš„ä¸€ä¸ªç»“ç‚¹å‡ºå‘ï¼Œæ²¿ç€æ ‘ä¸Šçš„è¾¹è¿›è¡Œæ—…è¡Œï¼Œæœ€ç»ˆåˆ°è¾¾å¦ä¸€ä¸ªå’Œèµ·ç‚¹ç±»å‹ç›¸åŒçš„ç»“ç‚¹ã€‚\n\nä½ ä¼šè¿›è¡Œå¾ˆå¤šæ¬¡æ—…è¡Œï¼Œä½†ä½ å¸Œæœ›å¯¹äºæ¯ä¸ªç»“ç‚¹ï¼Œåœ¨æ‰€æœ‰æ—…è¡Œè·¯çº¿ä¸­æœ€å¤šåªä¼šç»è¿‡ä¸€æ¬¡ã€‚\n\nä¸€æ¬¡æ—…è¡Œçš„ä»·å€¼æ˜¯èµ·å§‹ç‚¹å’Œç»ˆæ­¢ç‚¹çš„æƒé‡å’Œï¼Œä½ éœ€è¦è§„åˆ’æ—…è¡Œçš„æ–¹æ¡ˆä½¿å¾—æ—…è¡Œçš„æ€»æƒé‡å’Œæœ€å¤§ã€‚\n\n$\\sum n\\le 2e5,c_i\\le n,w_i \\le 1e6$â€‹\n\nå’Œå­æ ‘æœ‰å…³ï¼Œè€ƒè™‘å­æ ‘åˆå¹¶ã€‚\n\nä¸€ä¸ªå­æ ‘å†…æœ€ä¼˜è§£ä¸º$dp_u$ï¼Œé‚£ä¹ˆå…¶å’Œå¦ä¸€ä¸ªå­æ ‘$dp_v$è¿›è¡Œåˆå¹¶æ›´æ–°ã€‚é‚£ä¹ˆæœ‰ä¸¤ç§æ›´æ–°æ–¹å¼ï¼š\n\n$\\large dp_u=max(dp_u+dp_v,\\{f_{u,c}+f_{v,c}\\})$\n\nå…¶ä¸­$f_{u,c}$è¡¨ç¤º$u$å­æ ‘ä¸Šä¼ ä¸€ä¸ªé¢œè‰²ä¸º$c$çš„è·¯å¾„æ¥å£æ‰€èƒ½æä¾›çš„æœ€å¤§æƒå€¼å’Œã€‚æ˜¾ç„¶$dp_u$æ˜¯ä¸æä¾›ä¸Šä¼ è·¯å¾„çš„ã€‚\n\nå¯¹$f_{u,c}$â€‹çš„æ›´æ–°æœ‰ä¸‹åˆ—å¼å­ï¼Œå‡ºäºå¯å‘å¼åˆå¹¶ï¼Œå¦‚æœ$v$ä¸Šä¼ è·¯å¾„ç©¿è¿‡$u$ï¼Œåˆ™ä¸èƒ½ä½¿ç”¨$dp_u$\n\n$f_{u,c}=max(f_{u,c}+dp_v,f_{v,c}+\\sum_{t\\in son(u)} dp_t)$â€‹\n\nå¯å‘å¼çº¿æ®µæ ‘åˆå¹¶å³å¯ã€‚\n\n```cpp\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 mod = 998244353;\n#define endl '\\n'\n#define int long long\nstruct node\n{\n    int l, r;\n    i64 f;\n    i64 lz = 0;\n};\nconst int maxn = 3e5 + 9;\nnode tree[maxn << 5];\nint tot = 0;\nint newnode()\n{\n    tot++;\n    tree[tot] = {0, 0, 0, 0};\n    return tot;\n}\nvoid pushup(int rt)\n{\n    tree[rt].f = max(tree[tree[rt].l].f, tree[tree[rt].r].f);\n    return;\n}\nvoid pushd(int rt)\n{\n    if (tree[rt].lz)\n    {\n        if (tree[rt].l)\n        {\n            tree[tree[rt].l].f += tree[rt].lz;\n            tree[tree[rt].l].lz += tree[rt].lz;\n        }\n        if (tree[rt].r)\n        {\n            tree[tree[rt].r].f += tree[rt].lz;\n            tree[tree[rt].r].lz += tree[rt].lz;\n        }\n        tree[rt].lz = 0;\n    }\n    return;\n}\nvoid upd(int &rt, int pos, int val, int cl, int cr)\n{\n    if (!rt)\n        rt = newnode();\n    if (cl == cr)\n    {\n        tree[rt].f = val;\n        return;\n    }\n    pushd(rt);\n    int mid = (cl + cr) >> 1;\n    if (pos <= mid)\n        upd(tree[rt].l, pos, val, cl, mid);\n    else\n        upd(tree[rt].r, pos, val, mid + 1, cr);\n    pushup(rt);\n    return;\n}\nvector<i64> dp, dpson, w, c;\nint n;\nvector<vector<int>> con;\nvector<int> root;\nvoid merges(int &rt1, int &rt2, int cl, int cr, i64 &ans, i64 dpv, i64 dpson)\n{\n    if (!rt1 || !rt2)\n    {\n        if (rt1)\n        {\n            tree[rt1].f += dpv;\n            tree[rt1].lz += dpv;\n        }\n        else\n        {\n            tree[rt2].f += dpson;\n            tree[rt2].lz += dpson;\n        }\n        rt1 |= rt2;\n        return;\n    }\n    if (cl == cr)\n    {\n        ans = max(ans, tree[rt1].f + tree[rt2].f);\n        tree[rt1].f = max(tree[rt1].f + dpv, tree[rt2].f + dpson);\n        return;\n    }\n    int mid = (cl + cr) >> 1;\n    pushd(rt1), pushd(rt2);\n    merges(tree[rt1].l, tree[rt2].l, cl, mid, ans, dpv, dpson);\n    merges(tree[rt1].r, tree[rt2].r, mid + 1, cr, ans, dpv, dpson);\n    pushup(rt1);\n    return;\n}\nvoid dfs(int u, int f)\n{\n    upd(root[u], c[u], w[u], 1, n);\n    dp[u] = 0, dpson[u] = 0;\n    for (auto &v : con[u])\n    {\n        if (v == f)\n            continue;\n        dfs(v, u);\n        i64 tmp = 0;\n        merges(root[u], root[v], 1, n, tmp, dp[v], dpson[u]);\n        dp[u] = max(dp[u] + dp[v], tmp);\n        dpson[u] += dp[v];\n    }\n}\nvoid solve()\n{\n    tot = 0;\n    cin >> n;\n    dp.assign(n + 1, 0);\n    dpson.assign(n + 1, 0);\n    w.assign(n + 1, 0);\n    c.assign(n + 1, 0);\n    root.assign(n + 1, 0);\n    for (int i = 1; i <= n; i++)\n        cin >> c[i];\n    for (int i = 1; i <= n; i++)\n        cin >> w[i];\n    con.assign(n + 1, vector<int>());\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        con[u].push_back(v);\n        con[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout << dp[1] << endl;\n}\n\nsigned main()\n{\n    // freopen(\"1002.in\", \"r\", stdin);\n    // freopen(\"1.out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\nç¤ºä¾‹3ï¼šï¼ˆæœªçŸ¥æ¥æºï¼Œæœ±çš„ä¾‹é¢˜ï¼‰\n\n```cpp\n//å¤„ç†å­æ ‘ç›¸å…³çš„é—®é¢˜ï¼Œä¸æ”¯æŒä¿®æ”¹ï¼Œnlognçš„å¤æ‚åº¦ï¼Œç¦»çº¿ç®—æ³•\n#include<bits/stdc++.h>\n#define LL long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint N, col[MAXN], son[MAXN], siz[MAXN], cnt[MAXN], Mx, Son;\nLL sum = 0, ans[MAXN];\nvector<int> v[MAXN];\nvoid dfs(int x, int fa) {\n    siz[x] = 1;\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa) continue;\n        dfs(to, x);\n        siz[x] += siz[to];\n        if(siz[to] > siz[son[x]]) son[x] = to;//è½»é‡é“¾å‰–åˆ†\n    }\n}\nvoid add(int x, int fa,int c) {//æš´åŠ›è®¡ç®—xçš„å­æ ‘é¢œè‰²å’Œï¼Œä¸è€ƒè™‘é‡è¾¹ï¼Œ\n    cnt[col[x]] +=c;//è¿™é‡Œå¯èƒ½ä¼šå› é¢˜ç›®è€Œå¼‚\n    if(cnt[col[x]] > Mx) Mx = cnt[col[x]], sum = col[x];\n    else if(cnt[col[x]] == Mx) sum += (LL)col[x];\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa || to == Son) continue;\n        add(to, x,c);\n    }\n}\nvoid dfs2(int x, int fa, int opt) {//å¤„ç†å½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆ\n    for(int i = 0; i < v[x].size(); i++) {\n        int to = v[x][i];\n        if(to == fa) continue;\n        if(to != son[x]) dfs2(to, x, 0);//ç®€å•çš„å¾€è½»è¾¹èµ°ç®—è½»è¾¹çš„ç­”æ¡ˆï¼Œopt = 0è¡¨ç¤ºé€’å½’å®Œæˆåæ¶ˆé™¤å¯¹è¯¥ç‚¹çš„å½±å“\n    }\n    if(son[x]) dfs2(son[x], x, 1), Son = son[x];//ç»Ÿè®¡é‡å„¿å­çš„è´¡çŒ®ï¼Œä¸æ¶ˆé™¤å½±å“\n    //è¿™æ—¶å€™çš„sumå’ŒMxéƒ½æ˜¯åªè€ƒè™‘é‡å„¿å­è®¡ç®—å‡ºæ¥çš„\n    add(x, fa,1); Son = 0;\n    //æš´åŠ›ç»Ÿè®¡æ‰€æœ‰è½»å„¿å­çš„è´¡çŒ®ï¼Œä¼šé€’å½’æ‰€æœ‰è½»å„¿å­ï¼Œé™¤äº†å½“å‰èŠ‚ç‚¹çš„é‡å„¿å­ï¼Œè€Œä¸æ˜¯son[x]ï¼Œå› ä¸ºè½»å„¿å­çš„é‡å„¿å­æ˜¯éœ€è¦è®¡ç®—çš„ï¼Œè¿™é‡Œåªæ˜¯ä¸éœ€è¦è®¡ç®—xçš„é‡å„¿å­\n    ans[x] = sum;//æ›´æ–°ç­”æ¡ˆ\n    if(!opt) add(x,fa,-1), sum = 0, Mx = 0;//å¦‚æœéœ€è¦åˆ é™¤è´¡çŒ®çš„è¯å°±åˆ æ‰\n}\nint main() {\n    N = read();\n    for(int i = 1; i <= N; i++) col[i] = read();\n    for(int i = 1; i <= N - 1; i++) {\n        int x = read(), y = read();\n        v[x].push_back(y); v[y].push_back(x);\n    }\n    dfs(1, 0);\n    dfs2(1, 0, 1);\n    for(int i = 1; i <= N; i++) printf(\"%I64d \", ans[i]);\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 6.å›¾çš„è¿é€šæ€§\n\n### 6.1 æ— å‘å›¾è¿é€šæ€§\n\næ— å‘å›¾çš„è¿é€šæ€§ä¸»è¦å…³äºç‚¹åŒè”é€šåˆ†é‡å’Œè¾¹åŒè”é€šåˆ†é‡ï¼Œç”¨äºæ“ä½œç¼©ç‚¹ä»¥åŠç¼©è¾¹ï¼Œä»è€ŒæŠŠæ— å‘å›¾ä¸­çš„ç¯åˆ æ‰ã€‚\n\n#### 6.1.1 å‰²ç‚¹\n\nå¯¹äºä¸€ä¸ªæ— å‘å›¾ï¼Œå¦‚æœæŠŠä¸€ä¸ªç‚¹åˆ é™¤åè¿™ä¸ªå›¾çš„æå¤§è¿é€šåˆ†é‡æ•°å¢åŠ äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹å°±æ˜¯è¿™ä¸ªå›¾çš„å‰²ç‚¹ï¼ˆåˆç§°å‰²é¡¶ï¼‰ã€‚\n\n```cpp\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=2e4+1e3;\nint n,m,ans;\nvector<int> g[N];\nbool cut[N];\nint dfn[N],low[N],cnt;\nvoid tarjan(int u,int root){\n    dfn[u]=low[u]=++cnt;\n    int child=0;\n    for(auto v:g[u]){\n        if(!dfn[v]){\n            tarjan(v,root),low[u]=min(low[u],low[v]);\n            if(low[v]>=dfn[u]&&u!=root) cut[u]=true;//å¦‚æœå„¿å­çš„lowå€¼å¤§äºç­‰äºdfnï¼Œåˆ™ä»£è¡¨å…¶ä¸ºå„¿å­ä¸å…¶ä»–éå­æ ‘ç‚¹ç›¸è¿çš„å”¯ä¸€é€”å¾„\n            if(u==root) child++;\n        }\n        else low[u]=min(low[u],dfn[v]);//æ³¨æ„è¿™é‡Œæ˜¯dfn[v]\n    //å› ä¸ºå‰²ç‚¹åˆ¤å®šæ³•åˆ™æ˜¯å°äºç­‰äºå·ï¼Œæ‰€ä»¥åœ¨æ±‚å‰²ç‚¹æ—¶ï¼Œä¸å¿…è€ƒè™‘çˆ¶èŠ‚ç‚¹å’Œé‡è¾¹çš„é—®é¢˜ï¼Œä»xå‡ºå‘èƒ½è®¿é—®åˆ°çš„æ‰€æœ‰ç‚¹çš„æ—¶é—´æˆ³éƒ½å¯ä»¥ç”¨æ¥æ›´æ–° lowx\n    }\n    if(child>=2&&u==root)cut[u]=true;//å¯¹æ ¹çš„å¤„ç†,å¤§äºä¸¤ä¸ªå­æ ‘\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        g[u].pb(v);g[v].pb(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(!dfn[i]) tarjan(i,i);\n    for(int i=1;i<=n;i++)\n        if(cut[i]) ans++;\n    cout<<ans<<endl;\n    for(int i=1;i<=n;i++)\n        if(cut[i]) cout<<i<<\" \";\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.2 å‰²è¾¹\n\nå¯¹äºä¸€ä¸ªæ— å‘å›¾ï¼Œå¦‚æœåˆ æ‰ä¸€æ¡è¾¹åå›¾ä¸­çš„è¿é€šåˆ†é‡æ•°å¢åŠ äº†ï¼Œåˆ™ç§°è¿™æ¡è¾¹ä¸ºæ¡¥æˆ–è€…å‰²è¾¹ã€‚ä¸¥è°¨æ¥è¯´ï¼Œå°±æ˜¯ï¼šå‡è®¾æœ‰è¿é€šå›¾ $G=(V,E)$â€‹ï¼Œ$e$â€‹æ˜¯å…¶ä¸­ä¸€æ¡è¾¹ï¼ˆå³ $e\\in E$â€‹)ï¼Œå¦‚æœ$G-e$â€‹ æ˜¯ä¸è¿é€šçš„ï¼Œåˆ™è¾¹ $e$â€‹æ˜¯å›¾$G$â€‹çš„ä¸€æ¡å‰²è¾¹ï¼ˆæ¡¥)ã€‚\n\n```cpp\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=200;\nint n,m,sum;\nint a[200][200];\nbool cut[N];\nint dfn[N],low[N],cnt,fa[N];\nstruct Edge {\n    int x,y;\n} edge[5001];\nbool cmp(struct Edge a,struct Edge b) {\n    if(a.x==b.x)return a.y<b.y;\n    return a.x<b.x;\n}\nvoid tarjan(int u){\n    dfn[u]=low[u]=++cnt;\n    for(int v=1; v<=n; v++) {\n        if(!a[u][v])continue;\n        if(!dfn[v]){\n            fa[v]=u,tarjan(v),low[u]=min(low[u],low[v]);\n            if(low[v]>dfn[u]) edge[++sum].x=u, edge[sum].y=v;//å„¿å­å›ä¸åˆ°çˆ¶äº²ä»¥ä¸Šçš„ä½ç½®\n        }\n        else if(v!=fa[u])low[u]=min(low[u],dfn[v]);//æ³¨æ„è¿™é‡Œä¸èƒ½æ˜¯fa[u],ä¸ç„¶ä¸Šé¢çš„ifé‚£é‡Œä¸€å®šå–ä¸äº†å¤§äºå·ï¼\n        //lowçš„æ„æ€è¿™é‡Œæ˜¯ä¸ç»è¿‡çˆ¶äº²èƒ½å›åˆ°çš„æœ€æ—©çš„ç‚¹\n    }\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        a[u][v]=a[v][u]=1;\n    }\n    for(int i=1; i<=n; i++) \n        if(!dfn[i])tarjan(i);//tarjan\n    sort(edge+1,edge+sum+1,cmp);\n    for(int i=1;i<=sum; i++) {\n        cout<<min(edge[i].x,edge[i].y)<<' '<<max(edge[i].x,edge[i].y)<<endl;//è¾“å‡º\n    }\n    return 0;\n}\n\n```\n\nå°è£…é£æ ¼ï¼š\n\n```cpp\nmap<array<int, 3>, int> mp;\n    vector<int> dfn(n), low(n), fa(n);\n    int cnt = 0;\n    function<void(int)> tarjan = [&](int u)\n    {\n        dfn[u] = low[u] = ++cnt;\n        for (auto [v, w] : newcon[u])\n        {\n            if (!dfn[v])\n            {\n                fa[v] = u, tarjan(v), low[u] = min(low[u], low[v]);\n                if (low[v] > dfn[u])\n                    mp[{u, v, w}] = mp[{v, u, w}] = 1; // å‰²è¾¹\n            }\n            else if (v != fa[u])\n                low[u] = min(low[u], dfn[v]);\n        }\n    };\n    for (int i = 0; i < n; i++)\n        if (!dfn[i])\n            tarjan(i);\n```\n\n\n\n\n\n#### 6.1.3 ç‚¹åŒ\n\nè‹¥ä¸€ä¸ªæ— å‘å›¾ä¸­çš„å»æ‰ä»»æ„ä¸€ä¸ªç‚¹éƒ½ä¸ä¼šæ”¹å˜æ­¤å›¾çš„è¿é€šæ€§ï¼Œå³ä¸å­˜åœ¨å‰²ç‚¹ï¼Œåˆ™ç§°ä½œç‚¹åŒè¿é€šå›¾ã€‚ä¸€ä¸ªæ— å‘å›¾ä¸­çš„æ¯ä¸€ä¸ªæå¤§ç‚¹åŒè¿é€šå­å›¾ç§°ä½œæ­¤æ— å‘å›¾çš„ç‚¹åŒè¿é€šåˆ†é‡ã€‚\n\nå¯¹äºä¸¤ä¸ªç‚¹$u,v$ï¼Œå¦‚æœåˆ é™¤é™¤ä»–ä»¬è‡ªå·±å¤–å“ªä¸€ä¸ªç‚¹éƒ½ä¸èƒ½ä½¿å…¶ä¸è”é€šï¼Œåˆ™ç§°ä¸¤ç‚¹ä¹‹é—´åŒè”é€šã€‚ç‚¹åŒè”é€šä¸å…·æœ‰ä¼ é€’æ€§ã€‚\n\n```cpp\n/*ç‚¹åŒè¿é€šï¼šè‹¥å¯¹äºä¸€ä¸ªæ— å‘å›¾ï¼Œå…¶ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å¯¹äºè¿™ä¸ªå›¾æœ¬èº«è€Œè¨€éƒ½ä¸æ˜¯å‰²ç‚¹ï¼Œåˆ™ç§°å…¶ç‚¹åŒè¿é€šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ é™¤ä»»æ„ç‚¹åŠå…¶ç›¸å…³è¾¹åï¼Œæ•´ä¸ªå›¾ä»ç„¶å±äºä¸€ä¸ªè¿é€šåˆ†é‡ã€‚\n\nç‚¹åŒè¿é€šåˆ†é‡ï¼šæ— å‘å›¾ä¸­ï¼Œæå¤§çš„ç‚¹åŒè¿é€šå­å›¾ã€‚ä¸è¿é€šåˆ†é‡ç±»ä¼¼ï¼ŒæŠ½ç¦»å‡ºä¸€äº›ç‚¹åŠå®ƒä»¬ä¹‹é—´çš„è¾¹ï¼Œä½¿å¾—æŠ½ç¦»å‡ºçš„å›¾æ˜¯ä¸€ä¸ªç‚¹åŒè¿é€šå›¾ï¼Œåœ¨è¿™ä¸ªå‰æä¸‹ï¼Œä½¿å¾—æŠ½ç¦»å‡ºçš„å›¾è¶Šå¤§è¶Šå¥½ã€‚*/\n\n/*æ¡¥ï¼ˆå‰²è¾¹ï¼‰ä¸å±äºä»»ä½• e-DCCï¼ˆè¾¹åŒè¿é€šåˆ†é‡ï¼‰ï¼Œä½†æ˜¯å‰²ç‚¹å¯èƒ½å±äºå¤šä¸ª v-DCC*/\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int N = 1000010, M = 5000010;\nint dfn[N], low[N], stack[N],cut[N];\nint n, m, tot = 1, num, root, top, sum, cnt;\nvector<int> dcc[N * 2];//dcc[i] å­˜å‚¨ç¼–å·ä¸º i çš„ v-DCC ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹\nvector<int> edge[N];\nvoid tarjan(int u,int root) {\n    //ä¸ç”¨ç‰¹åˆ«æ ¹èŠ‚ç‚¹æ˜¯ä¸æ˜¯å‰²ç‚¹ï¼Œå®ƒä¸€å®šå±äºå®ƒå„¿å­çš„ç‚¹åŒä¸­ï¼Œæ— è®ºæ˜¯ä¸æ˜¯å‰²ç‚¹\n    dfn[u] = low[u] = ++cnt;\n    stack[++top] = u;\n    if (u == root && edge[u].size() == 0) { //å­¤ç«‹ç‚¹ç›´æ¥å¤„ç†\n        dcc[++sum].push_back(u);\n        return;\n    }\n    for (auto v:edge[u]) {\n        if (!dfn[v]) {\n            tarjan(v,root);low[u] = min(low[u], low[v]);\n            if (low[v] >= dfn[u]) {//uä¸ºå‰²ç‚¹ï¼ŒæŠŠæ ˆé‡Œuå‰çš„éƒ½è¦å‡ºå»\n                sum++;\n                int z;\n                do {//å¼¹æ ˆ\n                    z = stack[top--];\n                    dcc[sum].push_back(z);\n                } while (z != v);//æŠŠvå¼¹èµ°åç›®å‰æ ˆé¡¶ä¸ºu(uä¸ºå‰²ç‚¹)ï¼Œuä¸èƒ½å¼¹èµ°å› ä¸ºå®ƒå±äºå¤šä¸ªç‚¹åŒï¼ˆè‡³å°‘2ï¼‰\n                dcc[sum].push_back(u);//å•ç‹¬åŠ å…¥u\n            }\n        } \n        else low[u] = min(low[u], dfn[v]);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        if(u!=v)edge[u].push_back(v),edge[v].push_back(u);//åˆ¤è‡ªç¯\n    }\n    for (int i=1;i<=n;i++)\n        if (!dfn[i])tarjan(i,i);\n    //for (int i=1;i<=n;i++)cout<<low[i]<<endl;\n    cout<<sum<<endl;\n    for (int i=1;i<=sum;i++) { \n        cout<<dcc[i].size();\n        for (auto j:dcc[i])\n            cout << ' ' << j;\n        cout<<endl;\n    }\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.1.4 è¾¹åŒ\n\nè‹¥ä¸€ä¸ªæ— å‘å›¾ä¸­çš„å»æ‰ä»»æ„ä¸€æ¡è¾¹éƒ½ä¸ä¼šæ”¹å˜æ­¤å›¾çš„è¿é€šæ€§ï¼Œå³ä¸å­˜åœ¨å‰²æ¡¥ï¼Œåˆ™ç§°ä½œè¾¹åŒè¿é€šå›¾ã€‚ä¸€ä¸ªæ— å‘å›¾ä¸­çš„æ¯ä¸€ä¸ªæå¤§è¾¹åŒè¿é€šå­å›¾ç§°ä½œæ­¤æ— å‘å›¾çš„è¾¹åŒè¿é€šåˆ†é‡ã€‚\n\nåœ¨ä¸€å¼ è¿é€šçš„æ— å‘å›¾ä¸­ï¼Œå¯¹äºä¸¤ä¸ªç‚¹$u$å’Œ$v$ï¼Œå¦‚æœæ— è®ºåˆ å»å“ªæ¡è¾¹ï¼ˆåªèƒ½åˆ å»ä¸€æ¡ï¼‰éƒ½ä¸èƒ½ä½¿å®ƒä»¬ä¸è¿é€šï¼Œæˆ‘ä»¬å°±è¯´$u$å’Œ$v$ **è¾¹åŒè¿é€š**ã€‚è¾¹åŒè”é€šå…·æœ‰ä¼ é€’æ€§\n\n```cpp\n//è¾¹åŒè¿é€šåˆ†é‡ï¼Œå¾ˆæ˜¾ç„¶ï¼Œè¾¹åŒè¿é€šåˆ†é‡ä¸­æ²¡æœ‰å‰²è¾¹ï¼Œæ‰€ä»¥åªéœ€è¦å»æ‰æ‰€æœ‰æ¡¥è¾¹å‰©ä¸‹çš„å°±æ˜¯è¾¹åŒï¼Œè·‘dfså³å¯\n//æ³¨æ„è¿™é‡Œå¯èƒ½æœ‰é‡è¾¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å­˜å›¾çš„æ—¶å€™é¢å¤–å­˜ä¸€ä¸‹æ¯è¾¹çš„æ•°é‡ï¼ˆmapï¼‰ï¼Œæ‰¾æ¡¥çš„æ—¶å€™æ­£å¸¸æ‰¾ï¼Œå¦‚æœéæ¡¥è¾¹æœ‰å¤šä¸ªä¸å½±å“ï¼Œæ¡¥è¾¹æœ‰å¤šä¸ªå°±è¯´æ˜é¢å¤–è¿èµ·æ¥äº†ä¸¤ä¸ªv-eccï¼Œæ‰€ä»¥æˆ‘ä»¬æ‰¾åˆ°æ¡¥è¾¹å°±æ•°é‡-1ï¼Œdfsçš„æ—¶å€™æ­£å¸¸dfsï¼Œå¦‚æœæ¡¥è¾¹è¿˜æœ‰é‚£å°±èµ°ï¼Œæ²¡æœ‰çš„è¯å°±è¯´æ˜æ˜¯ä¸€ä¸ªv-ecc\n//ç”¨äºæ— å‘å›¾çš„ç¼©ç‚¹\n#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=5e5+10;\nint n,m,sum;\nint dfn[N],low[N],cnt,fa[N],vis[N];\nunordered_map<int,int>mp[N];\nvector<int>edge[N],ans[N];//anså³æ˜¯bcc\nvoid tarjan(int u){\n    dfn[u]=low[u]=++cnt;\n    for(auto v:edge[u]) {\n        if(!dfn[v]){\n            fa[v]=u,tarjan(v),low[u]=min(low[u],low[v]);\n            if(low[v]>dfn[u]) mp[u][v]--,mp[v][u]--;//å„¿å­å›ä¸åˆ°çˆ¶äº²ä»¥ä¸Šçš„ä½ç½®\n        }\n        else if(v!=fa[u])low[u]=min(low[u],dfn[v]);//æ³¨æ„è¿™é‡Œä¸èƒ½æ˜¯fa[u],ä¸ç„¶ä¸Šé¢çš„ifé‚£é‡Œä¸€å®šå–ä¸äº†å¤§äºå·ï¼\n        //lowçš„æ„æ€è¿™é‡Œæ˜¯ä¸ç»è¿‡çˆ¶äº²èƒ½å›åˆ°çš„æœ€æ—©çš„ç‚¹\n    }\n}\nvoid dfs(int u,int k){\n    ans[k].emplace_back(u);\n    vis[u]=1;\n    for(auto v:edge[u]){\n        if(!vis[v]&&mp[u][v]){\n            dfs(v,k);\n        }\n    }\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        if(u==v)continue;\n        if(mp[u].find(v)==mp[u].end()||mp[v].find(u)==mp[v].end()){\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n            mp[u][v]=1;\n            mp[v][u]=1;\n        }\n        else  mp[u][v]++,mp[v][u]++;\n    }\n    for(int i=1; i<=n; i++) \n        if(!dfn[i])tarjan(i);//tarjan\n    for(int i=1; i<=n; i++) {\n        if(!vis[i]){\n            sum++;\n            dfs(i,sum);\n        }\n    }\n    cout<<sum<<endl;\n    for(int i=1;i<=sum;i++){\n        cout<<ans[i].size()<<\" \";\n        for(auto j:ans[i])cout<<j<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *6.1.5 åœ†æ–¹æ ‘\n\n```cpp\n//ç‚¹åŒçš„å…³é”®æ€§è´¨:å¯¹äºä¸€ä¸ªç‚¹åŒä¸­çš„ä¸¤ç‚¹ï¼Œå®ƒä»¬ä¹‹é—´ç®€å•è·¯å¾„çš„å¹¶é›†ï¼Œæ°å¥½å®Œå…¨ç­‰äºè¿™ä¸ªç‚¹åŒã€‚\n//å³åŒä¸€ä¸ªç‚¹åŒä¸­çš„ä¸¤ä¸åŒç‚¹ u,v ä¹‹é—´ä¸€å®šå­˜åœ¨ä¸€æ¡ç®€å•è·¯å¾„ç»è¿‡ç»™å®šçš„åœ¨åŒä¸€ä¸ªç‚¹åŒå†…çš„å¦ä¸€ç‚¹ wã€‚æ‰€ä»¥çœ‹åˆ°ç®€å•è·¯å¾„çš„æ—¶å€™ï¼Œå¯ä»¥è€ƒè™‘åœ†æ–¹æ ‘\n//åœ†æ–¹æ ‘ï¼šç‚¹åŒå½“ä½œä¸€ä¸ªç‚¹ï¼Œè¿™ä¸ªç‚¹å’Œæ‰€æœ‰ç‚¹è¿è¾¹å½¢æˆçš„æ ‘ï¼Œè¿™æ ·ä¸åŒç‚¹åŒä¼šé å‰²ç‚¹è”ç³»èµ·æ¥å½¢æˆä¸€æ£µæ ‘\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//äº¤äº’é¢˜å°±åˆ \nusing namespace std;\nconst int N = 100005;\nint n,m, cnt;\nint dfn[N], low[N], dfc;\nint stk[N], tp;\nvector<int> G[N], T[N * 2];//ç›¸å…³æ•°ç»„å¼€ä¸¤å€ï¼ï¼ï¼\nvoid tarjan(int u) {\n    low[u] = dfn[u] = ++dfc; //dfsåº\n    stk[++tp] = u; \n    for (auto v : G[u]) { // éå† u çš„ç›¸é‚»èŠ‚ç‚¹\n        if (!dfn[v]) { \n            tarjan(v); low[u] = min(low[u], low[v]); \n            if (low[v] == dfn[u]) { // æ‰¾åˆ°ä¸€ä¸ªä»¥ u ä¸ºæ ¹çš„ç‚¹åŒè¿é€šåˆ†é‡\n                ++cnt; // å¢åŠ æ–¹ç‚¹ä¸ªæ•°\n                for (int x = 0; x != v; --tp) {// å°†ç‚¹åŒä¸­é™¤äº† u çš„ç‚¹é€€æ ˆï¼Œå¹¶åœ¨åœ†æ–¹æ ‘ä¸­è¿è¾¹\n                    x = stk[tp];\n                    T[cnt].push_back(x);\n                    T[x].push_back(cnt);\n                }\n                T[cnt].push_back(u);\n                T[u].push_back(cnt);\n            }\n        }\n        else low[u] = min(low[u], dfn[v]); // å·²è®¿é—®çš„å’Œ dfn å– min\n    }\n}\nsigned main() {\n    cin>>n>>m;\n    cnt = n; \n    for (int i = 1; i <= m; ++i) {\n        int u, v;cin>>u>>v;\n        G[u].push_back(v); \n        G[v].push_back(u);\n    }\n    // å¤„ç†éè¿é€šå›¾\n    for (int u = 1; u <= n; ++u)\n        if (!dfn[u]) tarjan(u), --tp;\n        // æ³¨æ„åˆ°é€€å‡º Tarjan æ—¶æ ˆä¸­è¿˜æœ‰ä¸€ä¸ªå…ƒç´ å³æ ¹ï¼Œå°†å…¶é€€æ ˆ\n    return 0;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6.2 æœ‰å‘å›¾è¿é€šæ€§\n\n#### 6.2.1 å¼ºè¿é€šåˆ†é‡\n\nå¼ºè¿é€šçš„å®šä¹‰æ˜¯ï¼šæœ‰å‘å›¾ G å¼ºè¿é€šæ˜¯æŒ‡ï¼ŒG ä¸­ä»»æ„ä¸¤ä¸ªç»“ç‚¹è¿é€šã€‚\n\nå¼ºè¿é€šåˆ†é‡ï¼ˆStrongly Connected Componentsï¼ŒSCCï¼‰çš„å®šä¹‰æ˜¯ï¼šæå¤§çš„å¼ºè¿é€šå­å›¾\n\n```cpp\n#include <bits/stdc++.h> //O(n+m)\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\nconst int M = 1e6 + 10;\nint n, m, u, v, cnt, sum;\nint dfn[N], low[N], vis[N], belong[N], flag[N]; // belongçš„å«ä¹‰æ˜¯è¿™ä¸ªç‚¹æ˜¯å¦å±äºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œlow[x] xèƒ½é€šè¿‡æœ‰å‘è¾¹èƒ½å›æº¯åˆ°çš„æœ€æ—©æ—¶é—´æ®µ\nvector<int> edge[N];\nvector<int> q[N];\nstack<int> s;\nvoid tarjan(int x)\n{ // tarjanç®—æ³•ï¼Œå¤„ç†xæ‰€åœ¨çš„è¿é€šå—çš„å¼ºè¿é€šåˆ†é‡\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (!belong[i])\n            low[x] = min(dfn[i], low[x]);\n        // å¦‚æœè¿™ä¸ªç‚¹ä¸å±äºä»»ä½•ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œè¯´æ˜åœ¨æ ˆä¸­ï¼Œå³éœ€è¦è€ƒè™‘æ›´æ–°lowå€¼\n        // ä¸åœ¨æ ˆé‡Œè¯´æ˜ä¸å¯èƒ½å­˜åœ¨äºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡(è®¿é—®è¿‡äº†åˆä¸åœ¨æ ˆé‡Œï¼Œè¯´æ˜å·²ç»æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å‡ºå»äº†)\n    }\n    if (low[x] == dfn[x])\n    { // å›æº¯æ—¶æŠŠï¼ˆxåˆ°æ ˆé¡¶çš„ç‚¹ï¼‰å…¨å½’ä¸ºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0; // é€€æ ˆ\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> u >> v;\n        edge[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        if (!dfn[i])\n            tarjan(i);\n    cout << sum << endl;\n    for (int i = 1; i <= n; i++)\n    {\n        if (!flag[i])\n        {\n            sort(q[belong[i]].begin(), q[belong[i]].end());\n            for (auto j : q[belong[i]])\n            {\n                flag[j] = 1;\n                cout << j << \" \";\n            }\n            cout << endl;\n        }\n    }\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### 6.2.2 ç¼©ç‚¹\n\nç¼©ç‚¹çš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ªç¯å¯ä»¥ç­‰æ•ˆå¤„ç†æˆä¸€ä¸ªç‚¹æ—¶ï¼Œæˆ‘ä»¬æŠŠæ—§å›¾çš„æ¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å½“ä½œä¸€ä¸ªç‚¹å»ºç«‹ä¸€ä¸ªæ–°å›¾ï¼Œå¹¶æŠŠä¸€ä¸ªç¯çš„ä¿¡æ¯å…¨éƒ¨ç»Ÿè®¡åˆ°ä¸€ä¸ªæ–°ç‚¹ä¸Šã€‚\n\nç»™å®šä¸€ä¸ª $n$ä¸ªç‚¹ $m$ æ¡è¾¹æœ‰å‘å›¾ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªæƒå€¼ï¼Œæ±‚ä¸€æ¡è·¯å¾„ï¼Œä½¿è·¯å¾„ç»è¿‡çš„ç‚¹æƒå€¼ä¹‹å’Œæœ€å¤§ã€‚ä½ åªéœ€è¦æ±‚å‡ºè¿™ä¸ªæƒå€¼å’Œã€‚\n\nå…è®¸å¤šæ¬¡ç»è¿‡ä¸€æ¡è¾¹æˆ–è€…ä¸€ä¸ªç‚¹ï¼Œä½†æ˜¯ï¼Œé‡å¤ç»è¿‡çš„ç‚¹ï¼Œæƒå€¼åªè®¡ç®—ä¸€æ¬¡ã€‚\n\n```cpp\n#include <bits/stdc++.h> //ç¼©ç‚¹çš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ªç¯å¯ä»¥ç­‰æ•ˆå¤„ç†æˆä¸€ä¸ªç‚¹æ—¶ï¼Œæˆ‘ä»¬æŠŠæ—§å›¾çš„æ¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å½“ä½œä¸€ä¸ªç‚¹å»ºç«‹ä¸€ä¸ªæ–°å›¾ï¼Œå¹¶æŠŠä¸€ä¸ªç¯çš„ä¿¡æ¯å…¨éƒ¨ç»Ÿè®¡åˆ°ä¸€ä¸ªæ–°ç‚¹ä¸Š\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\nconst int M = 1e6 + 10;\nint n, m, u, v, cnt, sum, k;\nint dfn[N], low[N], vis[N], belong[N], a[N], b[N], in[N], c[N], f[N];\nvector<int> edge[N];\nvector<int> out[N];\nvector<int> inn[N];\nvector<int> q[N];\nstack<int> s;\nvoid topo()\n{\n    queue<int> q;\n    for (int i = 1; i <= sum; i++)\n        if (!in[i])\n            q.push(i);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        c[++k] = u;\n        for (auto j : out[u])\n        {\n            in[j]--;\n            if (!in[j])\n                q.push(j);\n        }\n    }\n}\nvoid tarjan(int x)\n{ // tarjanç®—æ³•\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (vis[i])\n            low[x] = min(low[i], low[x]);\n    }\n    if (low[x] == dfn[x])\n    {\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0;\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> u >> v;\n        edge[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        if (!dfn[i])\n            tarjan(i);\n    // ç°åœ¨æœ‰sumä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œæ¥ä¸‹æ¥å°†æ¯ä¸ªå¼ºè¿é€šåˆ†é‡çš„ä¿¡æ¯ç»Ÿè®¡åˆ°ä¸€ä¸ªç‚¹ä¸Š\n    for (int i = 1; i <= sum; i++)\n    {\n        for (auto j : q[i])\n        {\n            b[i] += a[j];\n        }\n    }\n    // bæ•°ç»„å‚¨å­˜äº†æ¯ä¸ªå¼ºè¿é€šåˆ†é‡çš„æƒå€¼å’Œï¼Œç»Ÿè®¡å®Œæ¯•åå»ºç«‹æ–°å›¾\n    // å»ºå›¾æ—¶æ³¨æ„è€ƒè™‘ï¼Œä¸¤ä¸ªå¼ºè¿é€šåˆ†é‡ä¹‹é—´å¯èƒ½ä¼šæœ‰å¤šé‡è¾¹ï¼ï¼æœç´¢æ—¶æ³¨æ„visæ•°ç»„\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto j : edge[i])\n        {\n            if (belong[i] == belong[j])\n                continue;\n            out[belong[i]].push_back(belong[j]);\n            inn[belong[j]].push_back(belong[i]);\n            in[belong[j]]++;\n        }\n    }\n    topo();\n    // æ‹“æ‰‘æ’åºæ¥å†³å®šdpè½¬ç§»é¡ºåºï¼Œå› ä¸ºä¸€ä¸ªç‚¹çš„æœ€ä¼˜è§£æ˜¯ä»å®ƒçš„æ‰€æœ‰æ¥è¾¹è½¬ç§»è¿‡æ¥çš„ï¼Œæ‹“æ‰‘æ’åºå†³å®šäº†åœ¨å¤„ç†å½“å‰ç‚¹æ—¶ï¼Œå®ƒçš„æ¥è¾¹å·²ç»å…¨éƒ¨å¤„ç†å¥½äº†\n    for (int i = 1; i <= k; i++)\n    {\n        int u = c[i];\n        f[u] = b[u];\n        for (auto j : inn[u])\n        { // ç›´æ¥è½¬ç§»å°±å¯ä»¥\n            f[u] = max(f[u], f[j] + b[u]);\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= k; i++)\n        ans = max(ans, f[i]);\n    cout << ans;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n#### *6.2.3 2-SATé€‚å®šæ€§é—®é¢˜\n\næœ‰ $n$ ä¸ªå¸ƒå°”å˜é‡ $x_1$$\\sim$$x_n$ï¼Œå¦æœ‰ $m$ ä¸ªéœ€è¦æ»¡è¶³çš„æ¡ä»¶ï¼Œæ¯ä¸ªæ¡ä»¶çš„å½¢å¼éƒ½æ˜¯ ã€Œ$x_i$ ä¸º `true` / `false` æˆ– $x_j$ ä¸º `true` / `false`ã€ã€‚æ¯”å¦‚ ã€Œ$x_1$ ä¸ºçœŸæˆ– $x_3$ ä¸ºå‡ã€ã€ã€Œ$x_7$ ä¸ºå‡æˆ– $x_2$ ä¸ºå‡ã€ã€‚\n\n2-SAT é—®é¢˜çš„ç›®æ ‡æ˜¯ç»™æ¯ä¸ªå˜é‡èµ‹å€¼ä½¿å¾—æ‰€æœ‰æ¡ä»¶å¾—åˆ°æ»¡è¶³ã€‚\n\n**è¾“å…¥æ ¼å¼**\n\nç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $n$ å’Œ $m$ï¼Œæ„ä¹‰å¦‚é¢˜é¢æ‰€è¿°ã€‚\n\næ¥ä¸‹æ¥ $m$ è¡Œæ¯è¡Œ $4$ ä¸ªæ•´æ•° $i$, $a$, $j$, $b$ï¼Œè¡¨ç¤º ã€Œ$x_i$ ä¸º $a$ æˆ– $x_j$ ä¸º $b$ã€($a, b\\in \\{0,1\\}$)\n\n**è¾“å‡ºæ ¼å¼**\n\nå¦‚æ— è§£ï¼Œè¾“å‡º `IMPOSSIBLE`ï¼›å¦åˆ™è¾“å‡º `POSSIBLE`ã€‚\n\nä¸‹ä¸€è¡Œ $n$ ä¸ªæ•´æ•° $x_1\\sim x_n$ï¼ˆ$x_i\\in\\{0,1\\}$ï¼‰ï¼Œè¡¨ç¤ºæ„é€ å‡ºçš„è§£ã€‚\n\n$1\\leq n, m\\leq 10^6$ \n\n```cpp\n/*å®é™…çš„é—®é¢˜é‡Œå¾€å¾€æ˜¯ç»™å‡ºä¸€ä¸ªæ›´ç»†è‡´çš„æƒ…æ™¯ï¼Œè€Œä¸”é¢˜å¹²ä¿¡æ¯ä¸­\nä¼šæœ‰äºŒé€‰ä¸€çš„æ ‡å¿—ï¼Œæ­¤æ—¶å¯ä»¥è€ƒè™‘å¾€2-satæ¨¡å‹ä¸Šè€ƒè™‘ã€‚è€ƒè™‘è¿‡ç¨‹ï¼Œå³\nå»å¯»æ‰¾é¢˜ç›®ä¸­çš„é™åˆ¶ï¼ŒæŠŠäºŒé€‰ä¸€ç­‰ä¿¡æ¯ï¼Œè½¬åŒ–ä¸ºä¸€ä¸ªè•´å«å…³ç³»ï¼Œå³\na â‡’ b è¿™æ ·çš„å¼å­*/\n// å…¶ä¸­ä¸€ä¸ªä¸æˆç«‹åˆ™å¦ä¸€ä¸ªä¸€å®šæˆç«‹\n#include <bits/stdc++.h> //O(n+m)\n#define int long long\n#define endl '\\n'\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 2e6 + 10;\nconst int M = 2e6 + 10;\nint n, m, u, v, cnt, sum;\nint dfn[N], low[N], vis[N], belong[N], flag[N]; // belongçš„å«ä¹‰æ˜¯è¿™ä¸ªç‚¹æ˜¯å¦å±äºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œlow[x] xèƒ½é€šè¿‡æœ‰å‘è¾¹èƒ½å›æº¯åˆ°çš„æœ€æ—©æ—¶é—´æ®µ\nvector<int> edge[N];\nvector<int> q[N];\nstack<int> s;\nvoid tarjan(int x)\n{ // tarjanç®—æ³•ï¼Œå¤„ç†xæ‰€åœ¨çš„è¿é€šå—çš„å¼ºè¿é€šåˆ†é‡\n    dfn[x] = low[x] = ++cnt;\n    vis[x] = 1;\n    s.push(x);\n    for (auto i : edge[x])\n    {\n        if (!dfn[i])\n            tarjan(i), low[x] = min(low[i], low[x]);\n        else if (!belong[i])\n            low[x] = min(dfn[i], low[x]);\n        // å¦‚æœè¿™ä¸ªç‚¹ä¸å±äºä»»ä½•ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œè¯´æ˜åœ¨æ ˆä¸­ï¼Œå³éœ€è¦è€ƒè™‘æ›´æ–°lowå€¼\n        // ä¸åœ¨æ ˆé‡Œè¯´æ˜ä¸å¯èƒ½å­˜åœ¨äºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡(è®¿é—®è¿‡äº†åˆä¸åœ¨æ ˆé‡Œï¼Œè¯´æ˜å·²ç»æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å‡ºå»äº†)\n    }\n    if (low[x] == dfn[x])\n    { // å›æº¯æ—¶æŠŠï¼ˆxåˆ°æ ˆé¡¶çš„ç‚¹ï¼‰å…¨å½’ä¸ºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡\n        ++sum;\n        q[sum].push_back(x);\n        vis[x] = 0; // é€€æ ˆ\n        belong[x] = sum;\n        while (s.top() != x)\n        {\n            int t = s.top();\n            s.pop();\n            q[sum].push_back(t);\n            belong[t] = sum;\n            vis[t] = 0;\n        }\n        s.pop();\n    }\n}\nvoid add(int a, int b)\n{\n    edge[a].push_back(b);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int a, b, x, y;\n        cin >> a >> x; // ç¬¬aä¸ªæ•°ä¸ºxæˆ–ç¬¬bä¸ªæ•°ä¸ºy\n        cin >> b >> y;\n        if (x == 0 && y == 0) //\"å¦‚æœç¬¬aä¸ªæ•°ä¸º0æˆ–ç¬¬bä¸ªæ•°ä¸º0\"è‡³å°‘æ»¡è¶³å…¶ä¸€\n        {\n            add(a + n, b); // a=1åˆ™b=0\n            add(b + n, a); // b=1åˆ™a=0\n        }\n        if (x == 0 && y == 1) //\"å¦‚æœç¬¬aä¸ªæ•°ä¸º0æˆ–ç¬¬bä¸ªæ•°ä¸º1\"è‡³å°‘æ»¡è¶³å…¶ä¸€\n        {\n            add(a + n, b + n); // a=1åˆ™b=1\n            add(b, a);         // b=0åˆ™a=0\n        }\n        if (x == 1 && y == 0) //\"å¦‚æœç¬¬aä¸ªæ•°ä¸º1æˆ–ç¬¬bä¸ªæ•°ä¸º0\"è‡³å°‘æ»¡è¶³å…¶ä¸€\n        {\n            add(a, b);         // a=0åˆ™b=0\n            add(b + n, a + n); // b=1åˆ™a=1\n        }\n        if (x == 1 && y == 1) //\"å¦‚æœç¬¬aä¸ªæ•°ä¸º1æˆ–ç¬¬bä¸ªæ•°ä¸º1\"è‡³å°‘æ»¡è¶³å…¶ä¸€\n        {\n            add(a, b + n); // a=0åˆ™b=1\n            add(b, a + n); // b=0åˆ™a=1\n        }\n    }\n    for (int i = 1; i <= 2 * n; i++)\n        if (!dfn[i])\n            tarjan(i); // ä¸¤å€\n    for (int i = 1; i <= n; i++)\n    {\n        if (belong[i] == belong[i + n]) // åŒä¸€å˜é‡çš„ä¸¤ç§å–å€¼åœ¨åŒä¸€å¼ºè”é€šåˆ†é‡é‡Œ,è¯´æ˜æ— è§£\n        {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    cout << \"POSSIBLE\" << endl; // å¦åˆ™å°±æ˜¯æœ‰è§£\n    for (int i = 1; i <= n; i++)\n    {\n        if (belong[i] > belong[i + n])\n            cout << 1 << \" \"; // ä¸¤ç§å–å€¼ä¸­é€‰æ‹©æ‹“æ‰‘åºè¾ƒå¤§çš„é‚£ä¸ªå€¼ï¼Œè€Œå¼ºè”é€šåˆ†é‡ç¼–å·è¶Šå° -> æ‹“æ‰‘åºè¶Šå¤§ -> è¶Šä¼˜\n        else\n            cout << 0 << \" \";\n    }\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## *7. åŸºç¯æ ‘\n\nåŸºç¯æ ‘ï¼Œåªæœ‰ä¸€ä¸ªç¯çš„æ ‘ï¼Œè¾¹æ•°ä¸º$n$.\n\n```cpp\n//1. æš´åŠ›åˆ è¾¹\n//æ¯æ¬¡æ–­å¼€ç¯ä¸Šçš„ä¸€æ¡è¾¹è·‘ä¸€éç­”æ¡ˆï¼Œç„¶åå–æœ€å¤§å€¼  é€‚ç”¨äº:æ•°æ®è¾ƒå°ï¼Œä¸”ç¯ä¸ä¼šå½±å“ç­”æ¡ˆçš„é¢˜ç›®\n//egï¼šæ—…è¡Œï¼Œæ¯æ¬¡çš„æ—…è¡Œä¸€å®šæ˜¯èµ°n-1æ¡è¾¹ï¼Œç›´æ¥æš´åŠ›æšä¸¾åˆ æ‰æŸä¸€æ¡è¾¹ï¼Œè·‘ä¸€æ¬¡ç­”æ¡ˆ ï¼Œn^2è¿‡\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'//äº¤äº’é¢˜å°±åˆ \nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=2e5+10;\nint n,m,x[N],y[N],ans[N],cnt,tx,ty,sum[N],vis[N];\nvector<int>edge[N];\nvoid dfs(int u,int fa){\n    ans[++cnt]=u;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            dfs(i,u);\n        }\n    }\n}\nvoid dfs2(int u,int fa){\n    vis[u]=1;\n    sum[++cnt]=u;\n    for(auto i:edge[u]){\n        if(i!=fa){\n            if((i==tx&&u==ty)||(i==ty&&u==tx)||vis[i])continue;\n            dfs2(i,u);\n        }\n    }\n}\nbool check(){\n    for(int i=1;i<=n;i++){\n        if(sum[i]==ans[i])continue;\n        else if(sum[i]>ans[i])return 0;\n        else return 1;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>m;\n    for(int u,v,i=1;i<=m;i++){\n        cin>>u>>v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n        x[i]=u;y[i]=v;\n    }\n    for(int i=1;i<=n;i++)\n        sort(edge[i].begin(),edge[i].end());\n    if(m==n-1){\n        dfs(1,0);\n        for(int i=1;i<=n;i++)\n            cout<<ans[i]<<\" \";\n        return 0;\n    }\n    for(int i=1;i<=m;i++){\n        memset(vis,0,sizeof(vis));\n        tx=x[i],ty=y[i];cnt=0;\n        dfs2(1,0);\n        if(cnt<n)continue;\n        if(ans[1]==0)\n            for(int j=1;j<=n;j++)ans[j]=sum[j];\n        else if(check())\n            for(int j=1;j<=n;j++)ans[j]=sum[j];\n    }\n    for(int i=1;i<=n;i++)\n        cout<<ans[i]<<\" \";\n    return 0;\n}\n//2. æ–­è¾¹è·‘ä¸¤æ¬¡\n//éª‘å£«ï¼Œæ¯ä¸ªäººæœ‰ä¸ªè®¨åŒçš„äººï¼Œé‚£ä¹ˆå°±æ˜¯nä¸ªç‚¹næ¡è¾¹ï¼Œå½¢æˆäº†åŸºç¯æ ‘ï¼Œæ³¨æ„åˆ°ç¯ä¸Šçš„æŸä¸€æ¡è¾¹ï¼Œæ„å‘³ç€uå’Œvä¸èƒ½åŒæ—¶é€‰ï¼Œæˆ‘ä»¬è®¡ç®—ä¸¤ç§æƒ…å†µï¼Œé€‰uå’Œé€‰v\n//ç­‰ä»·äºå¼ºåˆ¶éš”å¼€è¿™ä¸¤ä¸ªäººå„è‡ªé€‰ä¸€æ¬¡\n//æ­£ç¡®æ€§ï¼šæ¯ä¸ªäººåªæœ‰ä¸€ä¸ªè®¨åŒçš„äººï¼Œé‚£ä¹ˆæœ€ç»ˆæƒ…å†µä¸€å®šæ˜¯ï¼Œè¦ä¹ˆæœ‰ä»–ï¼Œè¦ä¹ˆæœ‰ä»–è®¨åŒçš„äººï¼Œä¸å¯èƒ½éƒ½æ²¡æœ‰ï¼Œæ‰€ä»¥è·‘ä¸¤æ¬¡æ˜¯æ­£ç¡®çš„\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define N 1000010\nconst int inf=0x3f3f3f3f;\nusing namespace std;\nint w[N],d[N],n,vis[N],flag,f[N][2],ans;\nvector<int>edge[N];\nvoid dp(int u){\n    vis[u]=1;\n    f[u][0]=0;f[u][1]=w[u];\n    for(auto i:edge[u]){\n        if(i!=flag){//ä¸èƒ½dpå›æ ¹\n            dp(i);\n            f[u][0]+=max(f[i][0],f[i][1]);\n            f[u][1]+=f[i][0];\n        }\n    }\n}\nvoid dfs(int u){\n    vis[u]=1;\n    if(vis[d[u]])flag=u;\n    else dfs(d[u]);\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n;\n    for(int u,v,i=1;i<=n;i++){\n        cin>>w[i]>>d[i];\n        edge[d[i]].push_back(i);//å­˜çš„æ˜¯ä»‡æ¨ä»–çš„äººæœ‰å“ªäº›\n    }\n    for(int i=1;i<=n;i++){\n        if(vis[i])continue;\n        dfs(i);\n        //ç°åœ¨å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç¯ä¸Šçš„ä¸€æ¡è¾¹:flag å’Œ d[flag]\n        //æˆ‘ä»¬å¼ºåˆ¶å…¶ä¸­ä¸€ä¸ªç‚¹ä¸é€‰\n        dp(flag);\n        int ans1=f[flag][0];//ä¸é€‰flag\n        flag=d[flag];\n        dp(flag);\n        int ans2=f[flag][0];//ä¸é€‰d[flag]\n        ans+=max(ans1,ans2);\n    }\n    cout<<ans<<endl;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n\n\n# Part 5. å­—ç¬¦ä¸²\n\n***å¼ºåˆ¶è§„å®šï¼šæ‰€æœ‰ä¸å­—ç¬¦ä¸²ç›¸å…³çš„æ•°ç»„ä¸‹æ ‡æˆ–è€…å‡½æ•°æ¥å£å¦‚æœæœªç‰¹æ®Šè¯´æ˜ï¼Œéƒ½æ˜¯ä»$0$å¼€å§‹ã€‚***\n\n## 1.å­—ç¬¦ä¸²å“ˆå¸Œï¼ˆåŒå“ˆå¸Œï¼‰\n\n```cpp\ntemplate <int m1, int mod1, int m2, int mod2>\nstruct Stringhashs\n{\n    int n;\n    vector<i64> h1, h2, mi1, mi2;\n    string s;\n    void init(int n)\n    {\n        this->n = n;\n        h1.resize(n + 10);  // h1[i]è¡¨ç¤ºå‰iä¸ªå­—ç¬¦çš„å“ˆå¸Œå€¼ï¼Œæ³¨æ„å“ˆå¸Œæ•°ç»„æ˜¯ä»1å¼€å§‹çš„\n        h2.resize(n + 10);  // h2[i]è¡¨ç¤ºå‰iä¸ªå­—ç¬¦çš„å“ˆå¸Œå€¼\n        mi1.resize(n + 10); // mi1[i]è¡¨ç¤ºm1^i,å“ˆå¸Œæ¨¡æ•°\n        mi2.resize(n + 10); // mi2[i]è¡¨ç¤ºm2^i,å“ˆå¸Œæ¨¡æ•°\n        mi1[0] = mi2[0] = 1;\n        s.clear();\n        for (int i = 1; i <= n; i++)\n        {\n            mi1[i] = (i64)mi1[i - 1] * m1 % mod1;\n            mi2[i] = (i64)mi2[i - 1] * m2 % mod2;\n            h1[i] = ((i64)h1[i - 1] * m1 + s[i - 1]) % mod1;\n            h2[i] = ((i64)h2[i - 1] * m2 + s[i - 1]) % mod2;\n        }\n    }\n    void insert(string s)\n    {\n        assert(s.size() <= n);\n        this->s = s;\n        for (int i = 0; i < s.size(); i++)\n        {\n            h1[i + 1] = ((i64)h1[i] * m1 % mod1 + s[i]) % mod1;\n            h2[i + 1] = ((i64)h2[i] * m2 % mod2 + s[i]) % mod2;\n        }\n    }\n    array<int, 2> queryfullhash(string s)\n    {\n        int h1 = 0, h2 = 0;\n        for (int i = 0; i < s.size(); i++)\n        {\n            h1 = ((i64)h1 * m1 % mod1 + s[i]) % mod1;\n            h2 = ((i64)h2 * m2 % mod2 + s[i]) % mod2;\n        }\n        return {h1, h2};\n    }\n    array<int, 2> query(int l, int r)\n    {\n        assert(n);\n        assert(l >= 0 && r < n && l <= r);\n        l++, r++;\n        int h1 = ((this->h1[r] - (i64)this->h1[l - 1] * mi1[r - l + 1] % mod1) % mod1 + mod1) % mod1;\n        int h2 = ((this->h2[r] - (i64)this->h2[l - 1] * mi2[r - l + 1] % mod2) % mod2 + mod2) % mod2;\n        return {h1, h2};\n    }\n};\nconst int mod1 = 1e9 + 7, mod2 = 998244353;\nusing hashs = Stringhashs<131, mod1, 13331, mod2>;\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.KMPå­—ç¬¦ä¸²åŒ¹é…\n\né€‚é…ï¼šæ–‡æœ¬ä¸²å›ºå®š$T$ï¼Œå¤šä¸ªä¸»ä¸²$S$ï¼Œè¯¢é—®$T$åœ¨$S$ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚æ—¶é—´å¤æ‚åº¦$O(|T|+\\sum |S|)$\n\n### 2.1 å‰ç¼€å‡½æ•°ä¸nxtæ•°ç»„\n\nå‰ç¼€å‡½æ•°å®šä¹‰ï¼š$\\pi[i]$è¡¨ç¤º$s.substr(0,i+1)$ä¸­å…¬å…±å‰åç¼€çš„é•¿åº¦ã€‚å³æœ‰$s[0,\\cdots,\\pi[i]-1]=s[i-\\pi[i]+1,\\cdots,i]$ã€‚\n\nè§„å®šé•¿åº¦ä¸º$1$çš„å­—ç¬¦ä¸²å‰ç¼€å‡½æ•°ä¸º$0$ã€‚\n\n```cpp\nvector<int> prefix_function(string s) {\n  int n = (int)s.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\n```\n\nåŸºäºæ­¤ç»´æŠ¤çš„$KMP\\ nxt$æ•°ç»„å°±æ˜¯æ–¹ä¾¿å¯»æ‰¾å¤±é…ä¹‹åä¸‹ä¸€ä¸ªé…å¯¹çš„ä½ç½®ï¼š\n\n```cpp\nnxt[0] = 0;\n        for (int i = 1, j = 0; i < T.size(); i++)\n        {\n            while (j && T[i] != T[j])\n                j = nxt[j - 1];\n            if (T[i] == T[j])\n                j++;\n            nxt[i] = j;\n        }\n```\n\n\n\n### 2.2 KMPå­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…ç®—æ³•\n\n$KMP$ç®—æ³•çš„ç²¾é«“åœ¨äºå½“å‰åŒ¹é…å¤±é…ä¹‹åæ¨¡å¼ä¸²$T$çš„æŒ‡é’ˆè·³åˆ°å“ªé‡Œå¼€å§‹é‡æ–°åŒ¹é…çš„é—®é¢˜ã€‚å› ä¸ºå·²åŒ¹é…éƒ¨åˆ†ä¿è¯äº†ä¸¤æ®µç›¸åŒï¼Œé‚£ä¹ˆåªéœ€è¦è·³åˆ°å…¬å…±å‰åç¼€çš„å‰ç¼€åä¸€ä½ç»§ç»­åŒ¹é…å°±è¡Œäº†ã€‚å‰ç¼€å‡½æ•°æ˜¯å¯¹æ¨¡å¼ä¸²$T$æ±‚è§£çš„ã€‚\n\n$KMP$åŒ¹é…æ€æƒ³ä¸åªå±€é™äºå­—ç¬¦ä¸²åŒ¹é…ï¼Œä¸åŒ¹é…æœ‰å…³çš„$dp$é¢˜ä¹Ÿä¼šåˆ©ç”¨åˆ°$nxt$æ•°ç»„çš„æ€æƒ³æ¥ä¼˜åŒ–$dp$ã€‚\n\n```cpp\nstruct KMP\n{\n    string T;\n    vector<int> nxt;\n    KMP(string T) : T(T)\n    {\n        nxt.resize(T.size());\n        nxt[0] = 0;\n        for (int i = 1, j = 0; i < T.size(); i++)\n        {\n            while (j && T[i] != T[j])\n                j = nxt[j - 1];\n            if (T[i] == T[j])\n                j++;\n            nxt[i] = j;\n        }\n    }\n    vector<int> match(string S)\n    {\n        vector<int> res;\n        for (int i = 0, j = 0; i < S.size(); i++)\n        {\n            while (j && S[i] != T[j])\n                j = nxt[j - 1];\n            if (S[i] == T[j])\n                j++;\n            if (j == T.size())\n            {\n                res.push_back(i - j + 1);\n                j = nxt[j - 1];\n            }\n        }\n        return res;\n    }\n};\n```\n\nç¤ºä¾‹1:**2024æ¹–å—çœèµ› ç»æ–‡**\n\né¢˜ç›®å¤§æ„ï¼šæœ‰ä¸€ä¸ªé•¿åº¦ä¸º$n\\le 1000$çš„ç©ºä¸²å’Œé•¿åº¦ä¸º$t\\le 100$çš„æ¨¡å¼ä¸²$T$ï¼Œè¯¢é—®æœ‰å¤šå°‘ç”¨å°å†™è‹±æ–‡å­—æ¯å¡«å……ç©ºä¸²çš„æ–¹æ¡ˆæ•°ï¼Œä½¿å¾—$T$äºå…¶ä¸­ä¸ç›¸äº¤çš„å‡ºç°ç²¾å‡†$k$æ¬¡ã€‚\n\nè®¾$dp_{i,j,l}$è¡¨ç¤ºå‰$i$ä¸ªå­—ç¬¦å·²ç»åŒ¹é…äº†$j$ä¸ªå®Œæ•´æ–‡æœ¬ä¸²ï¼Œç°åœ¨æ­£åœ¨åŒ¹é…$l$ä½ç½®çš„æ–¹æ¡ˆæ•°ã€‚æšä¸¾$26$ä¸ªå°å†™å­—æ¯ï¼Œåˆå§‹åŒ¹é…æŒ‡é’ˆ$pre=l$\n\nå¦‚æœ$s[pre]==char$ï¼Œåˆ™ç›´æ¥æœ‰$dp[i][j][pre+1]+=dp[i][j][l]$ï¼Œæ»¡ä¸€ä¸ªåˆ™$j$è¿›ä½ã€‚\n\nå¦‚æœè¯¥å­—ç¬¦å¯¼è‡´äº†$fail$åŒ¹é…ï¼Œåˆ™ç±»ä¼¼$KMP$è·³è½¬$pre=nxt[pre-1]$ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªä½ç½®çš„åŒ¹é…ï¼Œç›´åˆ°$pre=0$ã€‚å¦‚æœ$pre=0$éƒ½æœªèƒ½åŒ¹é…ï¼Œåˆ™è¯´æ˜ä¸‹ä¸€ä¸ªä½ç½®åªèƒ½ä»å¤´å¼€å§‹ã€‚\n\n```cpp\nbool flag = 0;\nfor (int pre = l; 1; pre = nxt[pre - 1])\n{\n    if (s[pre] == 'a' + m)\n    {\n        if (pre == sz - 1)\n        {\n            if (j + 1 <= k)\n            {\n                dp[i + 1][j + 1][0] += dp[i][j][l];\n                dp[i + 1][j + 1][0] %= mod;\n            }\n        }\n        else\n        {\n            dp[i + 1][j][pre + 1] += dp[i][j][l];\n            dp[i + 1][j][pre + 1] %= mod;\n        }\n        flag = 1;\n        break;\n    }\n    if (!pre)\n        break;\n}\n```\n\nå®Œæ•´ä»£ç ï¼š\n\n```cpp\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int sz = s.size();\n    vector<int> nxt(sz);\n    nxt[0] = 0;\n    for (int i = 1, j = 0; i < sz; i++)\n    {\n        while (j && s[i] != s[j])\n            j = nxt[j - 1];\n        if (s[i] == s[j])\n            j++;\n        nxt[i] = j;\n    }\n    vector<vector<vector<i64>>> dp(n + 1, vector<vector<i64>>(k + 1, vector<i64>(sz + 1)));\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; i++)              // å‰iä¸ªå­—ç¬¦\n        for (int j = 0; j <= k; j++)         // å·²ç»åŒ¹é…äº†jä¸ª\n            for (int l = 0; l < sz; l++)     // æ­£åœ¨åŒ¹é…ç¬¬lä¸ª\n                for (int m = 0; m < 26; m++) // æšä¸¾å­—ç¬¦\n                {\n                    bool flag = 0;\n                    for (int pre = l; 1; pre = nxt[pre - 1])\n                    {\n                        if (s[pre] == 'a' + m)\n                        {\n                            if (pre == sz - 1)\n                            {\n                                if (j + 1 <= k)\n                                {\n                                    dp[i + 1][j + 1][0] += dp[i][j][l];\n                                    dp[i + 1][j + 1][0] %= mod;\n                                }\n                            }\n                            else\n                            {\n                                dp[i + 1][j][pre + 1] += dp[i][j][l];\n                                dp[i + 1][j][pre + 1] %= mod;\n                            }\n                            flag = 1;\n                            break;\n                        }\n                        if (!pre)\n                            break;\n                    }\n                    if (!flag)\n                    {\n                        dp[i + 1][j][0] += dp[i][j][l];\n                        dp[i + 1][j][0] %= mod;\n                    }\n                }\n\n    i64 ans = 0;\n    for (int i = 0; i < sz; i++)\n    {\n        ans += dp[n][k][i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 3. å­—å…¸æ ‘Trie\n\nå†™æ³•è§æ•°æ®ç»“æ„éƒ¨åˆ†$01$Trie,æ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚\n\n### 4. Manacheré©¬æ‹‰è½¦ç®—æ³•\n\nä¸€ç§éå¸¸ä¼˜ç§€çš„ä»¥çº¿æ€§æ—¶é—´å¤æ‚åº¦æ±‚è§£å­—ç¬¦ä¸²ä¸­æœ€é•¿å›æ–‡å­ä¸²çš„ç®—æ³•ã€‚\n\n```cpp\nint manacher(string t)\n{\n    string s;\n    int tot = 0;\n    s.push_back('$');\n    for (int i = 0; i < t.size(); i++)\n    {\n        s.push_back('#');\n        s.push_back(t[i]);\n    }\n    s.push_back('#');\n    int ans = 0;\n    vector<int> d(s.size() + 10);\n    d[0] = 1; // d[i]ä»£è¡¨iä¸ºä¸­å¿ƒçš„æœ€å¤§åŠå¾„-1,ä¹Ÿè¡¨ç¤ºåŸå›æ–‡ä¸²é•¿åº¦\n    for (int i = 1, l = 0, r = 0; i < s.size(); ++i)\n    {\n        if (i <= r)\n            d[i] = min(d[l + r - i], r - i + 1);\n        while (s[i + d[i]] == s[i - d[i]])\n            d[i]++;\n        if (d[i] + i - 1 > r)\n            r = d[i] + i - 1, l = i - d[i] + 1;\n        ans = max(ans, d[i]);\n    }\n    return ans - 1;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 5. ACè‡ªåŠ¨æœº\n\nä¸$KMP$äº’è¡¥ï¼Œæœ¬è´¨ä¾æ—§æ˜¯$KMP$ï¼Œå®ç°çš„æ˜¯å¤šæ¨¡å¼ä¸²$T_1\\to T_n$åŒ¹é…å”¯ä¸€ä¸»ä¸²$S$â€‹.å¤æ‚åº¦$O(2\\sum|T_i|+|S|)$\n\nå­—å…¸æ ‘ä¸Šæ„å»º$Fail$æŒ‡é’ˆçš„æ€è·¯ä¸$nxt$æ•°ç»„æå…¶ç›¸ä¼¼ã€‚è€ƒè™‘æœ¬æ¨¡æ¿ä¸­å¦‚æœæœ‰$s[i]\\neq s[j]$ï¼Œåˆ™$j=nxt[j-1]$å«ä¹‰ä¸º$i$åŒ¹é…å¤±è´¥åæ‰€è·³è·ƒçš„ä½ç½®ã€‚**ç¬¬$i$ä¸ªå¤±é…äº†ï¼Œè‚¯å®šè¦è·³è·ƒ$i-1$çš„ä¸‹ä¸€ä¸ªé€‚é…ç‚¹ï¼Œä¹Ÿå°±æ˜¯$nxt[j-1]$**\n\nè€ƒè™‘å­—å…¸æ ‘ä¸­ï¼Œå¦‚æœç»“ç‚¹$u$å¤±é…ï¼Œæ„å‘³ç€ç»“ç‚¹$u$çš„æ‰€æœ‰å„¿å­éƒ½ä¸é€‚é…ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œä½†æ˜¯ç»“ç‚¹$u$çš„çˆ¶äº²æ˜¯é€‚é…ä¸Šä¸€ä¸ªå­—ç¬¦çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å»è·³è½¬ä¸‹ä¸€ä¸ªå¯¹åº”ä¸Šä¸€ä¸ªå­—ç¬¦çš„ç»“ç‚¹ï¼Œè¿™ä¸ªå°±æ˜¯$u$ç»“ç‚¹çˆ¶äº²æ‰€æŒ‡å‘çš„$Fail$â€‹ç»“ç‚¹ã€‚\n\n```cpp\nint Fail = trie[u].fail;\nfor (int i = 0; i < 26; i++)\n{\n    int v = trie[u].son[i];\n    if (!v)\n    {\n        trie[u].son[i] = trie[Fail].son[i];\n        continue;\n    }\n    trie[v].fail = trie[Fail].son[i];\n    in[trie[v].fail]++;\n    q.push(v);\n}\n```\n\nä¸‹é¢æ˜¯æ¨¡æ¿ï¼Œæ¯é‡æ–°ä¸€æ¬¡æ–°ä¸»ä¸²$S$éƒ½è¦é‡æ–°è·³ä¸€é$Fail$æŒ‡é’ˆã€‚\n\nç‰ˆæœ¬1ï¼šï¼ˆåªæ±‚æœ‰å¤šå°‘ä¸ªæ–‡æœ¬ä¸²$T$äºä¸»ä¸²$S$ä¸­å‡ºç°è¿‡ï¼‰\n\n```cpp\n// æ„å»ºå­—å…¸å›¾å®ç°è‡ªåŠ¨è·³è½¬ï¼Œæ„å»ºå¤±é…æŒ‡é’ˆå®ç°å¤šæ¨¡å¼åŒ¹é…ã€‚\n// æœ¬é¢˜ACè‡ªåŠ¨æœºè§£å†³æ±‚æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸²é‡Œå‡ºç°è¿‡ï¼Œä¸”ä¸¤ä¸ªæ¨¡å¼ä¸²ä¸åŒå½“ä¸”ä»…å½“ä»–ä»¬ç¼–å·ä¸åŒï¼›\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct AC\n{\n    const static int N = 1 * 1e6 + 4;\n    int t[N][30], idx, q; // t[i][j]:è¡¨ç¤ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹çš„ç¼–å·ä¸ºI,è‡ªå·±çš„å­—ç¬¦æ˜¯jï¼Œidxæ˜¯èŠ‚ç‚¹æ€»æ•°\n    int cnt[N];           // è®°å½•ä»¥è¿™ä¸ªç‚¹ä¸ºç»“å°¾æœ‰å‡ ä¸ªå•è¯\n    int fail[N];          // å¤±é…æŒ‡é’ˆï¼Œä»iè·³åˆ°jå°±è¯´æ˜ï¼Œword(j)æ˜¯içš„æœ€é•¿åç¼€ï¼ï¼\n    int getnum(char ch)\n    { // å­—ç¬¦è½¬ä¸ºæ•°å­—\n        if (ch >= 'a' && ch <= 'z')\n            return ch - 'a' + 1;\n    }\n    void insert(string s)\n    {                              // æ’å…¥\n        int p = 0, len = s.size(); // ä»0èŠ‚ç‚¹å¼€å§‹\n        for (int i = 0; i < len; i++)\n        {\n            int c = getnum(s[i]);\n            if (!t[p][c])\n                t[p][c] = ++idx; // åˆ›å»ºèŠ‚ç‚¹\n            p = t[p][c];         // æŠŠçˆ¶èŠ‚ç‚¹æ›´æ”¹ä¸ºä¸Šä¸ªèŠ‚ç‚¹\n        }\n        cnt[p]++; // ä»¥è¯¥ç‚¹ä¸ºç»“å°¾çš„å•è¯æ•°é‡ï¼Œå› ä¸ºä¸ä¿è¯æ¨¡å¼ä¸²ä¸€è‡´\n    }\n    void build()\n    {\n        queue<int> q;\n        memset(fail, 0, sizeof(fail));\n        for (int i = 1; i <= 26; i++)\n            if (t[0][i])\n                q.push(t[0][i]);\n        // æ ¹èŠ‚ç‚¹çš„é¦–å­—ç¬¦å…¥é˜Ÿ\n        // ä¸ç›´æ¥å°†0å…¥é˜Ÿæ˜¯ä¸ºäº†é¿å…æŒ‡å‘è‡ªå·±\n        while (!q.empty())\n        {\n            int k = q.front();\n            q.pop(); // å½“å‰ç»“ç‚¹\n            for (int i = 1; i <= 26; i++)\n            {\n                if (t[k][i])\n                {                                  // å¦‚æœå­èŠ‚ç‚¹å­˜åœ¨\n                    fail[t[k][i]] = t[fail[k]][i]; // æ„å»ºå½“å‰çš„failæŒ‡é’ˆ\n                    // åŸç†ï¼Œä¸Šä¸€å±‚çš„failå·²ç»æ±‚å‡ºï¼Œä¾‹å¦‚ä¸Šä¸€å±‚ä¸ºherï¼Œè‡ªå·±æ˜¯sï¼Œrçš„failæŒ‡å‘äº†erï¼Œè‹¥ræœ‰è¿™ä¸ªå­èŠ‚ç‚¹sï¼Œç”±äºeræ˜¯herçš„æœ€é•¿åç¼€ï¼Œé‚£ä¹ˆerså¿…ç„¶æ˜¯hersçš„æœ€é•¿åç¼€ã€‚\n                    // å¦å¤–ç»“åˆelseçš„ä»£ç  ï¼ŒåŸæœ¬æŒ‰é“ç†å¦‚æœæ²¡æœ‰sè¿™ä¸ªèŠ‚ç‚¹åº”ä¸æ–­è·³failï¼Œä½†è¿™é‡Œä¸ºä»€ä¹ˆä¸ç”¨å‘¢ï¼Ÿå› ä¸ºå¦‚æœè·³å®Œfailçš„è¯èƒ½æ¢åˆ°ä¸€æ¡é“¾ï¼Œåˆ™elseçš„ä»£ç èƒ½å¤Ÿå¸®åŠ©ä¸€æ­¥è·³è¿‡å»æ‰€ä»¥å¯ä»¥ä¸€æ­¥ï¼Œå¦‚æœä¸èƒ½ï¼Œåˆ™èµ‹å€¼ä¸º0ï¼ŒåŒæ ·ä¹Ÿæ˜¯æ ¹èŠ‚ç‚¹ï¼Œå®Œç¾\n                    q.push(t[k][i]); // å…¥é˜Ÿ\n                }\n                else\n                    t[k][i] = t[fail[k]][i];\n                // åŒ¹é…åˆ°ç©ºå­—ç¬¦ï¼Œåˆ™ç´¢å¼•åˆ°çˆ¶èŠ‚ç‚¹failæŒ‡é’ˆå¯¹åº”çš„å­—ç¬¦ï¼Œä»¥ä¾›åç»­æŒ‡é’ˆçš„æ„å»º\n                // ç±»ä¼¼å¹¶å·®é›†çš„è·¯å¾„å‹ç¼©ï¼ŒæŠŠä¸å­˜åœ¨çš„tr[k][i]å…¨éƒ¨æŒ‡å‘tr[fail[k]][i]\n                // è¿™å¥è¯åœ¨åé¢åŒ¹é…ä¸»ä¸²çš„æ—¶å€™ä¹Ÿèƒ½å¸®åŠ©è·³è½¬\n            }\n        }\n    }\n    int queryy(string S)\n    {\n        int len = S.size(), p = 0, ans = 0;\n        for (int i = 0; i < len; i++)\n        {\n            p = t[p][getnum(S[i])];\n            for (int j = p; j && ~cnt[j]; j = fail[j])\n                ans += cnt[j], cnt[j] = -1; // ç­”æ¡ˆåŠ ä¸Šç»“å°¾ï¼Œcnt[j]=-1å°±æ˜¯ä»¥ååˆ«åœ¨ç»Ÿè®¡è¿™é‡Œç›¸å…³çš„äº†ï¼Œé˜²æ­¢é‡å¤\n            // è¿™ä¸ªç‚¹å¼€å§‹è·³failæ•°ç»„ï¼Œæ±‚å¾—ä¸ä¹‹ç›¸å…³çš„åç¼€çš„å•è¯æœ‰æ²¡æœ‰\n            // åˆ†æj&&~cnt[j]:åªæœ‰=-1æ—¶å–åæ‰æ˜¯0ï¼Œæ‰€ä»¥ç»“æŸæ¡ä»¶ä¸ºè·³åˆ°æ ¹èŠ‚ç‚¹ï¼ˆj=0ï¼‰æˆ–è€…åˆ°è¾¾äº†æ±‚è¿‡çš„ç‚¹\n            // å› ä¸ºæœ¬é¢˜è¦æ±‚æœ‰å¤šå°‘ä¸ªæ¨¡å¼ä¸²å‡ºç°è¿‡ï¼Œæ‰€ä»¥ä¸èƒ½é‡å¤è´¡çŒ®\n        }\n        return ans;\n    }\n};\nAC ac;\nint main()\n{\n    int n;\n    cin >> n;\n    string s;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> s;\n        ac.insert(s);\n    }\n    ac.build();\n    cin >> s;\n    cout << ac.queryy(s) << endl;\n}\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\nç‰ˆæœ¬2ï¼šè¿”å›æ¯ä¸€ä¸ª$T_i$â€‹çš„å‡ºç°æ¬¡æ•°\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nstruct AC\n{\n    const static int maxn = 2e5 + 9;\n    int n, cnt = 1, vis[maxn], ans, in[maxn << 5], Map[maxn];\n    struct Trie\n    {\n        int son[26], fail, flag, ans;\n        void clear() { memset(son, 0, sizeof(son)), fail = flag = ans = 0; }\n    } trie[maxn << 5];\n    queue<int> q;\n    void init(int _n)\n    {\n        for (int i = 0; i <= cnt; i++)\n            trie[i].clear();\n        for (int i = 1; i <= n; i++)\n            vis[i] = 0;\n        cnt = 1;\n        n = _n;\n    }\n    void insert(string t, int num)\n    {\n        int u = 1, len = t.size();\n        for (int i = 0; i < len; i++)\n        {\n            int v = t[i] - 'a';\n            if (!trie[u].son[v])\n                trie[u].son[v] = ++cnt;\n            u = trie[u].son[v];\n        }\n        if (!trie[u].flag)\n            trie[u].flag = num;\n        Map[num] = trie[u].flag;\n    }\n    void getFail()\n    {\n        for (int i = 0; i < 26; i++)\n            trie[0].son[i] = 1;\n        q.push(1);\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            int Fail = trie[u].fail;\n            for (int i = 0; i < 26; i++)\n            {\n                int v = trie[u].son[i];\n                if (!v)\n                {\n                    trie[u].son[i] = trie[Fail].son[i];\n                    continue;\n                }\n                trie[v].fail = trie[Fail].son[i];\n                in[trie[v].fail]++;\n                q.push(v);\n            }\n        }\n    }\n    void topu()\n    {\n        for (int i = 1; i <= cnt; i++)\n            if (in[i] == 0)\n                q.push(i);\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            vis[trie[u].flag] = trie[u].ans;\n            int v = trie[u].fail;\n            in[v]--;\n            trie[v].ans += trie[u].ans;\n            if (in[v] == 0)\n                q.push(v);\n        }\n    }\n    void query(string s)\n    {\n        int u = 1, len = s.size();\n        for (int i = 0; i < len; i++)\n            u = trie[u].son[s[i] - 'a'], trie[u].ans++;\n    }\n    vector<int> querys(string s)\n    {\n        vector<int> res;\n        query(s);\n        topu();\n        for (int i = 1; i <= n; i++)\n            res.push_back(vis[Map[i]]);\n        return res;\n    }\n};\nAC ac;\nint main()\n{\n    int n;\n    cin >> n;\n    ac.init(n);\n    for (int i = 1; i <= n; i++)\n    {\n        string t;\n        cin >> t;\n        ac.insert(t, i);\n    }\n    ac.getFail();\n    string s;\n    cin >> s;\n    auto res = ac.querys(s);\n    for (auto i : res)\n        cout << i << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 6. åç¼€æ•°ç»„SA\n\n***Warning: æ­¤å¤„SAæ•°ç»„çš„å­—ç¬¦ä¸²ä¸‹æ ‡å®šä¹‰æ˜¯ä»1å¼€å§‹çš„ï¼***\n\nåç¼€æ•°ç»„$sa[i]$è¡¨ç¤ºçš„æ˜¯å­—å…¸åºæ’åç¬¬$i$å°çš„åç¼€æ˜¯åŸæ¥å­—ç¬¦ä¸²ä¸­å“ªä¸€ä¸ªåç¼€ã€‚\n\næ’åæ•°ç»„$rk[i]$è¡¨ç¤ºåŸæ¥å­—ç¬¦ä¸²çš„åç¼€ä¸­ç¬¬$i$ä¸ªåç¼€æ˜¯å¤šå°‘å­—å…¸åºã€‚\n\nç¬¬$i$ä¸ªåç¼€çš„å®šä¹‰ï¼š$s[i\\cdots n]$\n\n$O(nlogn)$æ±‚æ³•ï¼š\n\n```cpp\nstruct SufArray\n{\n    const static int maxn = 1e6 + 9;\n    // rk[i] i çš„æ’å  sa[i] ç¬¬iå\n    // å­—ç¬¦ä¸²çš„åºå·  +k å°±æ˜¯å¾€åèµ°kä¸ª\n    int rk[maxn + 10], sa[maxn + 10], n, lstrk[maxn + 10], lstsa[maxn], w,\n        m = 127, cnt[maxn], h[maxn], f[maxn][20];\n    string s;\n\n#define siz n * sizeof(int)\n    void init(string _s)\n    {\n        s = _s;\n        m = 127;\n        n = s.length();\n        memset(cnt, 0, sizeof cnt);\n        memset(sa, 0, sizeof sa);\n        memset(rk, 0, sizeof rk);\n        memset(h, 0, sizeof h);\n        for (int i = 1; i <= n; ++i)\n            ++cnt[rk[i] = s[i - 1]];\n        for (int i = 1; i <= m; ++i)\n            cnt[i] += cnt[i - 1];\n        for (int i = n; i >= 1; --i)\n            sa[cnt[rk[i]]--] = i;\n        memcpy(lstrk + 1, rk + 1, siz);\n        for (int p = 0, i = 1; i <= n; ++i)\n            if (lstrk[sa[i]] == lstrk[sa[i - 1]])\n                rk[sa[i]] = p;\n            else\n                rk[sa[i]] = ++p;\n        for (w = 1; w < n; w <<= 1, m = n)\n        {\n            for (int p = 0, i = n; i >= n - w + 1; --i)\n                lstsa[++p] = i;\n            for (int p = w, i = 1; i <= n; ++i)\n                if (sa[i] > w)\n                    lstsa[++p] = sa[i] - w;\n            memset(cnt, 0, sizeof cnt);\n            for (int i = 1; i <= n; ++i)\n                ++cnt[rk[lstsa[i]]];\n            for (int i = 1; i <= m; ++i)\n                cnt[i] += cnt[i - 1];\n            for (int i = n; i >= 1; --i)\n                sa[cnt[rk[lstsa[i]]]--] = lstsa[i];\n            memcpy(lstrk + 1, rk + 1, siz);\n            for (int p = 0, i = 1; i <= n; ++i)\n                if (lstrk[sa[i]] == lstrk[sa[i - 1]] && lstrk[sa[i] + w] == lstrk[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n        }\n        for (int i = 1, k = 0; i <= n; ++i)\n        {\n            if (rk[i] == 0)\n                continue;\n            if (k)\n                --k;\n            while (s[i + k - 1] == s[sa[rk[i] - 1] + k - 1])\n                ++k;\n            h[rk[i]] = k;\n        }\n\n        memset(f, 0x3f, sizeof f);\n        for (int i = 1; i <= n; ++i)\n            f[i][0] = h[i];\n        for (int j = 1; (1 << j) <= n; ++j)\n            for (int i = 1; i <= n - (1 << j) + 1; ++i)\n                f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n    }\n    int lcp(int x, int y)\n    { // åç¼€xå’Œåç¼€yçš„æœ€é•¿å…¬å…±å‰ç¼€\n        if (x == y)\n            return n - y + 1;\n        x = rk[x], y = rk[y];\n        if (x >= y)\n            swap(x, y);\n        int k = log2(y - (x + 1) + 1);\n        return min(f[x + 1][k], f[y - (1 << k) + 1][k]);\n    }\n} SA;\nvoid solve()\n{\n    string s;\n    cin >> s;\n    SA.init(s);\n    for (int i = 1; i <= SA.n; i++)\n        cout << SA.sa[i] << ' ';\n    cout << endl;\n    // for (int i = 1; i <= SA.n; i++)\n    //     cout << SA.h[i] << ' ';\n    // cout << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 7. SAæ•°ç»„(çº¿æ€§SA-IS)\n\n**Warningï¼šæ­¤å¤„SAæ•°ç»„ä»¥åŠheightæ•°ç»„æ˜¯ä»0å¼€å§‹çš„**\n\n```cpp\nstruct SA\n{\n    int n;\n    vector<int> sa, rk;\n    vector<i64> h;\n    SA(string s)\n    {\n        n = s.size();\n        s.push_back(0);\n        sa.resize(n);\n        h.resize(n - 1);\n        rk.resize(n);\n        iota(sa.begin(), sa.end(), 0);\n        sort(sa.begin(), sa.end(), [&](int a, int b)\n             { return s[a] < s[b]; });\n        rk[sa[0]] = 0;\n        for (int i = 1; i < n; ++i)\n        {\n            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);\n        }\n        int k = 1;\n        vector<int> tmp, cnt(n);\n        tmp.reserve(n);\n        while (rk[sa[n - 1]] < n - 1)\n        {\n            tmp.clear();\n            for (int i = 0; i < k; ++i)\n            {\n                tmp.push_back(n - k + i);\n            }\n            for (auto i : sa)\n            {\n                if (i >= k)\n                {\n                    tmp.push_back(i - k);\n                }\n            }\n            fill(cnt.begin(), cnt.end(), 0);\n            for (int i = 0; i < n; ++i)\n            {\n                ++cnt[rk[i]];\n            }\n            for (int i = 1; i < n; ++i)\n            {\n                cnt[i] += cnt[i - 1];\n            }\n            for (int i = n - 1; i >= 0; --i)\n            {\n                sa[--cnt[rk[tmp[i]]]] = tmp[i];\n            }\n            swap(rk, tmp);\n            rk[sa[0]] = 0;\n            for (int i = 1; i < n; ++i)\n            {\n                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);\n            }\n            k *= 2;\n        }\n        for (int i = 0, j = 0; i < n; ++i)\n        {\n            if (rk[i] == 0)\n            {\n                j = 0;\n                continue;\n            }\n            for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j];)\n                ++j;\n            h[rk[i] - 1] = j;\n        }\n    }\n};\n\nvoid solve()\n{\n    string s;\n    cin >> s;\n    SA sa(s);\n    for (int i = 0; i < s.size(); i++)\n        cout << sa.sa[i] + 1 << \" \";\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 8. åç¼€è‡ªåŠ¨æœºSAM\n\n$SAM$è‡ªåŠ¨æœºæ˜¯ä¸€ç§å‹ç¼©å­ä¸²ä¿¡æ¯çš„è‡ªåŠ¨æœºï¼Œå¯ä»¥åœ¨çº¿æ€§æ—¶é—´å†…è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š\n\n- åœ¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æœç´¢ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ‰€æœ‰å‡ºç°ä½ç½®ã€‚\n- è®¡ç®—ç»™å®šçš„å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªä¸åŒçš„å­ä¸²ã€‚\n\n```cpp\nstruct SAM {\n    //rootæ˜¯1\n    int size, last, len[N << 1], fa[N << 1], tr[N << 1][31];\n    int nxt[N << 1], head[N << 1], to[N << 1], ecnt = 1;\n    int cnt[N << 1], first_pos[N << 1], is_clone[N << 1];\n\n#define sfor(x, i) for(int i = 0; i <= 30; ++i) if(tr[x][i])\n    SAM() {\n        size = last = ecnt = 1;\n    }\n    int extend(int x) {\n        int cur = ++ size,u;\n        cnt[cur] = 1, first_pos[cur] = len[cur] = len[last] + 1;\n        for(u = last; u && !tr[u][x]; u = fa[u]) tr[u][x] = cur;\n        if(!u) fa[cur] = 1;\n        else {\n            int v = tr[u][x];\n            if(len[v] == len[u] + 1) fa[cur] = v;\n            else {\n                int clone = ++ size;\n                len[clone] = len[u] + 1, fa[clone] = fa[v], first_pos[clone] = first_pos[v], is_clone[clone] = 1;\n                memcpy(tr[clone], tr[v], sizeof(tr[v]));//æ—¶é—´å¤æ‚åº¦åœ¨è¿™ä¸ªåœ°æ–¹\n                for(; u && tr[u][x] == v; u = fa[u]) tr[u][x] = clone;\n                fa[cur] = fa[v] = clone;\n            }\n        }\n        return last = cur;\n    }\n    //cntæ•°ç»„è¡¨ç¤ºendposçš„å¤§å°ï¼Œé»˜è®¤æ˜¯çœŸå®å¤§å°\n    //dæ•°ç»„è¡¨ç¤ºä¸‹é¢å¯ä»¥èµ°å¤šå°‘è·¯å¾„ï¼Œé»˜è®¤å’Œendposé›†åˆå¤§å°æœ‰å…³\n    //æ¯ä¸ªç»“ç‚¹çš„endposé›†åˆèµ·å§‹å°±æ˜¯ç»ˆç‚¹ç»“ç‚¹çš„endposçš„é›†åˆ\n//=========================================å»ºæ ‘=========================================\n    void add(int x, int y) {\n        nxt[++ecnt] = head[x], to[ecnt] = y, head[x] = ecnt;\n    }\n    void build_tree() {\n        for(int i = 2; i <= size; ++i) add(fa[i], i);\n    }\n\n//===========================================æ±‚occ=========================================\n    int pos[N << 1], f[N << 1][20];//posä»£è¡¨s[1...r]å¯¹åº”çš„ç»“ç‚¹\n    //è°ƒç”¨çš„æ—¶å€™pos[r] = extend(s[r] - 'a' + 1);\n    //è°ƒç”¨æ—¶å…ˆå»ºæ ‘ å¹¶æ±‚å¾—cnt\n    void get_f(int x = 1){//éå†åç¼€é“¾æ¥æ ‘\n        f[x][0] = fa[x];\n        for(int i = 1; i <= 19; ++i) f[x][i] = f[f[x][i - 1]][i - 1];\n        for(int i = head[x]; i; i = nxt[i]) if(fa[x] != to[i]) {\n            get_f(to[i]);\n        }\n    }\n    int node(int l, int r){\n        int now = pos[r];\n        for(int i = 19; i >= 0; --i) if(len[f[now][i]] >= r-l+1) now = f[now][i];\n        return now;//æ‰¾åˆ°l...ræ‰€åœ¨çš„ç»“ç‚¹\n    }\n    int occ(int l, int r){\n        return cnt[node(l, r)];\n    }\n//==========================================æ±‚ç»“ç‚¹çš„cnt=======================================\n    void Get_cnt(int x) {\n        for(int i = head[x]; i; i = nxt[i]) Get_cnt(to[i]), cnt[x] += cnt[to[i]];\n    }\n    //è°ƒç”¨æ—¶å…ˆå»ºæ ‘\n    void get_cnt(int type = 1) {\n        if(type == 0) for(int i = 1; i <= size; ++i) cnt[i] = 1;    //ä¸åŒä½ç½®çš„å­ä¸²ç®—ä½œä¸€ä¸ª å¼ºåˆ¶æ¯ä¸ªå­ä¸²åªå‡ºç°ä¸€æ¬¡\n        else Get_cnt(1);\n    }\n    vector<int> endpos(int x) {\n        queue<int> q;\n        vector<int> ep;\n        q.push(x);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            if(!is_clone[now])  //æ˜¯ç»ˆç‚¹ç»“ç‚¹\n                ep.push_back(first_pos[now]);\n            for(int i = head[now]; i; i = nxt[i])\n                q.push(to[i]);\n        }\n        return ep;\n    }\n    //éå†åç¼€æ ‘ï¼šç”¨å›¾é‚£ä¸€å¥— ä»1å¼€å§‹ //éå†åç¼€è‡ªåŠ¨æœºï¼šä»1å¼€å§‹ç”¨trè½¬ç§»\n    ll d[N], ans[N];//dè®°å½•äº†ä»xå¼€å§‹å¾€ä¸‹æœ‰å‡ æ¡è·¯å¾„ ansè®°å½•äº†ä»xå¼€å§‹ï¼Œå¾€ä¸‹æ‰€æœ‰è·¯å¾„ä¸Šä¸åŒå­ä¸²çš„æ€»é•¿åº¦ã€‚\n    void get_d(int x = 1) {\n        if(d[x]) return ;\n        d[x] = cnt[x];\n        sfor(x, i) get_d(tr[x][i]), d[x] += d[tr[x][i]];\n    }\n    void debug() {\n        puts(\"--------Debug_SAM--------\");\n        for(int i = 1; i <= size; ++i)\n            cout << \"i = \" << i << \", endpos_size = \" << cnt[i] << \", fa = \" << fa[i] << \", len = \" << len[i] << \", d = \" << d[i] << endl;\n        for(int i = 1; i <= size; ++i) {\n            cout << \"i = \" << i << \" can trans to \" << endl;\n            sfor(i, j)  cout << tr[i][j] << \" by \" << char(j + 'a' - 1) << endl;\n        }\n        puts(\"--------End_Debug--------\");\n    }\n} sam;\n\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n# Part 6. åŠ¨æ€è§„åˆ’\n\n## 1. sosdpï¼ˆé«˜ç»´å‰ç¼€å’Œdp)\n\nå¯¹äºæ‰€æœ‰çš„$i$,$0â‰¤iâ‰¤2^nâˆ’1$,æ±‚è§£$âˆ‘_{jâŠ‚i}a_j$ã€‚\n\nä»¥$O(n2^n)$çš„å¤æ‚åº¦ç®¡ç†å­é›†å‰ç¼€å’Œ$dp$â€‹ã€‚\n\nå­é›†ï¼š$i$å¯¹åº”æ˜¯$0$çš„ä½ç½®ï¼Œ$j$å¿…é¡»å¯¹åº”ä¸º$0$\n\n```cpp\nfor(int j = 0; j < n; j++) \n    for(int i = 0; i < 1 << n; i++)\n        if(i >> j & 1) f[i] += f[i ^ (1 << j)];\n\n```\n\nè¶…é›†ï¼š$i$å¯¹åº”æ˜¯$1$çš„ä½ç½®ï¼Œ$j$å¿…é¡»å¯¹åº”$1$\n\n```cpp\nfor(int j = 0; j < n; j++) \n    for(int i = 0; i < 1 << n; i++)\n        if(!(i >> j & 1)) f[i] += f[i ^ (1 << j)];\n\n```\n\nç¤ºä¾‹1ï¼šï¼ˆ2024æ¹–å—çœèµ›ï¼‰\n\nç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º$n$çš„æ­£æ•´æ•°ä¸² ã€‚ç°åœ¨å¯ä»¥æŠŠä¸¤ä¸ªæ²¡æœ‰é‡å çš„è¿ç»­å­ä¸²å‰åæ‹¼æ¥èµ·æ¥ï¼Œä½†æ˜¯è¦æ±‚æ‹¼æ¥ä¹‹åçš„æ•°ä¸²ä¸­æ¯ä¸ªæ­£æ•´æ•°ä¸èƒ½å‡ºç°è¶…è¿‡$1$æ¬¡ã€‚è¯·é—®èƒ½æ‹¼æ¥å‡ºæ¥çš„ç¬¦åˆè¦æ±‚çš„æ•°å­—ä¸²çš„æœ€å¤§é•¿åº¦æ˜¯å¤šå°‘ã€‚ä¿è¯$a_i\\le18$.\n\næ•°æ®èŒƒå›´ä¸€çœ¼çŠ¶å‹$dp$ï¼Œè€ƒè™‘ç»´æŠ¤å‡ºç°ä¸è¶…è¿‡ä¸€æ¬¡ã€‚æ˜¾ç„¶ä¸¤ä¸ªä¸²çš„$mask$ä½çš„äº¤é›†ä¸º$0$ï¼Œè€ƒè™‘ä¸²$A$çš„$mask$ä½$K$ï¼Œåˆ™æ˜¾ç„¶ä¸²$B$çš„$mask$å¿…å®šæœ‰$mask_B\\subset(2^{18}\\oplus mask_A)$\n\nä¸²é•¿åº¦ä¸è¶…è¿‡$18$ï¼Œæš´åŠ›æšä¸¾æ‰€æœ‰åˆæ³•ä¸²åˆå§‹åŒ–$dp$æ•°ç»„ï¼Œç„¶åè·‘$sosdp$ç»´æŠ¤å­é›†$max$ï¼Œæœ€åæš´åŠ›æ£€æŸ¥ä¸€åœˆå°±è¡Œäº†ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int B = (1 << 18) - 1;\nint mp[2 * B];\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], a[i]--;\n    int i = 1, j = 1;\n    int bit = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        bit = 0;\n        for (int j = 0; j < 18 && j + i <= n; j++)\n        {\n            if ((bit >> a[i + j]) & 1)\n            {\n                break;\n            }\n            bit ^= (1 << a[i + j]);\n            mp[bit] = max(mp[bit], j + 1);\n        }\n    }\n    int ans = 0;\n    for (int j = 0; j < 18; j++)\n    {\n        for (int i = 0; i <= B; i++)\n        {\n            if (i >> j & 1)\n                mp[i] = max(mp[i], mp[i ^ (1 << j)]);\n        }\n    }\n    for (int i = 0; i <= B; i++)\n    {\n        ans = max(ans, mp[i] + mp[B ^ i]);\n    }\n    cout << ans << endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n## 2.çº¿æ€§dp\n\n### 2.1 LIS ($O(nlogn)$â€‹)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint a[N], dp[N], dp2[N];\nint main()\n{\n    int n, ans = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        dp[i] = 1;\n    }\n    // O(nlogn)åšæ³•\n    int maxx = 0;\n    memset(dp2, inf, sizeof(dp2));\n    for (int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(dp2, dp2 + n, a[i]) - dp2;\n        if (j + 1 > maxx)\n            maxx = j + 1;\n        dp2[j] = a[i];\n    }\n    cout << maxx << endl;\n}\n```\n\nå•è°ƒæ ˆä¼˜åŒ–ï¼š\n\n```cpp\nint arr[maxn], sta[maxn];\nsigned main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> arr[i];\n    int len = 1;\n    sta[len] = arr[1];\n    for (int i = 2; i <= n; i++)\n    {\n        if (arr[i] > sta[len])\n        {\n            sta[++len] = arr[i];\n        }\n        else\n        {\n            int tem = lower_bound(sta + 1, sta + 1 + len, arr[i]) - sta;\n            sta[tem] = arr[i];\n        }\n    }\n    cout << len << endl;\n    // system(\"pause\");\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.2 èƒŒåŒ…\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 2;\n// ç‰©å“å®¹ç§¯ä¸æƒé‡\nint c[N], w[N], dp[N];\nint main()\n{\n    // 01èƒŒåŒ…\n    // ç‰©å“æ•°ç›®ä¸èƒŒåŒ…ä½“ç§¯\n    int n, v;\n    for (int i = 1; i <= n; i++)        // æšä¸¾æ‰€æœ‰ç‰©å“\n        for (int j = v; j >= c[i]; j--) // æšä¸¾èƒŒåŒ…ä½“ç§¯\n            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);\n    // åˆ†ç»„èƒŒåŒ…\n    // t[k][i]è¡¨ç¤ºç¬¬kç»„çš„ç¬¬iä»¶ç‰©å“çš„ç¼–å·æ˜¯å¤šå°‘\n    int ts, m, cnt[N], t[N][N];\n    for (int k = 1; k <= ts; k++)                                        // å¾ªç¯æ¯ä¸€ç»„\n        for (int i = m; i >= 0; i--)                                     // å¾ªç¯èƒŒåŒ…å®¹é‡\n            for (int j = 1; j <= cnt[k]; j++)                            // å¾ªç¯è¯¥ç»„çš„æ¯ä¸€ä¸ªç‰©å“\n                if (i >= w[t[k][j]])                                     // èƒŒåŒ…å®¹é‡å……è¶³\n                    dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]); // åƒ0 - 1èƒŒåŒ…ä¸€æ ·çŠ¶æ€è½¬ç§»\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.3 æ•´æ•°åˆ’åˆ†\n\n```cpp\nll dp[maxn][maxn];\nll f[maxn][maxn], g[maxn][maxn];\nint n, k;\nvoid div1()\n{\n    // dp[i][j] ä»£è¡¨å°†iåˆ’åˆ†ä¸ºä¸å¤§äºjçš„åˆ’åˆ†æ•°(å…è®¸é‡å¤æ•°å­—)\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (j == 1)\n                dp[i][j] = 1;\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        }\n    }\n}\nvoid div2()\n{\n    // dp[i][j] ä»£è¡¨å°†iåˆ’åˆ†ä¸ºä¸å¤§äºjçš„åˆ’åˆ†æ•°(æ²¡æœ‰é‡å¤æ•°å­—)\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (j == 1)\n            {\n                if (i == 1)\n                    dp[i][j] = 1;\n                else\n                    dp[i][j] = 0; // åˆå§‹åŒ–ä¸åŒå³å¯, è½¬ç§»æ–¹ç¨‹ä¾æ—§ç›¸åŒ.\n            }\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1];\n        }\n    }\n}\nvoid div3()\n{\n    // dp[i][j]ä¸ºå°†iæ°å¥½åˆ’åˆ†ä¸ºjä¸ªæ•´æ•°çš„åˆ’åˆ†æ•°\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i == j)\n                dp[i][j] = 1;\n            else if (i < j)\n                dp[i][j] = 0;\n            else\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];\n        }\n    }\n}\nvoid div4()\n{\n    // è®¾f[i][j]ä¸ºå°†iæ°å¥½åˆ’åˆ†ä¸ºjä¸ªå¥‡æ•°ä¹‹å’Œçš„åˆ’åˆ†æ•°\n    //  g[i][j]ä¸ºå°†iæ°å¥½åˆ’åˆ†ä¸ºjä¸ªå¶æ•°ä¹‹å’Œçš„åˆ’åˆ†æ•°ã€‚\n    f[0][0] = g[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i < j)\n                f[i][j] = g[i][j] = 0;\n            else\n            {\n                f[i][j] = f[i - 1][j - 1] + g[i - j][j];\n                g[i][j] = f[i - j][j];\n            }\n        }\n    }\n}\nvoid div5()\n{\n    // dp[i][j] ä»£è¡¨iåˆ’åˆ†ä¸ºä¸å¤šäºjä¸ªæ­£æ•´æ•°çš„åˆ’åˆ†æ•°\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= k; j++)\n        {\n            if (i == 1 || j == 1)\n                dp[i][j] = 1;\n            else if (i == j)\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if (i < j)\n                dp[i][j] = dp[i][i];\n            else\n                dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        }\n    }\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.4 æ•°ä½dp\n\n```cpp\nint a[maxn], f[maxn][maxn][2];\n// f[len][state],çŠ¶å‹çš„stateè®°å½•çŠ¶æ€\nint dfs(int pos, int pre, bool limit, bool lead0, int cnt) {\n    if (!pos)\n        return 1;  // çœ‹æƒ…å†µreturn 1è¿˜æ˜¯cnt\n    auto& now = f[pos][pre][limit];\n    if (!lead0 && ~now)\n        return now;\n    int up = limit ? a[pos] : 9;\n    int res = 0;\n    for (int i = 0; i <= up; i++) {\n        if (!lead0 && abs(i - pre) < 2)\n            continue;  // ä¿è¯æšä¸¾çš„è¦åˆæ³•\n        res += dfs(pos - 1, i, limit && i == up, lead0 && i == 0, cnt);\n    }\n    if (!lead0)\n        now = res;\n    return res;\n}\nint solve(int x) {\n    int len = 0;\n    while (x > 0) {\n        a[++len] = x % 10;\n        x /= 10;\n    }\n    return dfs(len, 0, true, true, 0);\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.5 å››è¾¹å½¢ä¸ç­‰å¼ä¼˜åŒ–dp\n\n```cpp\nint m[maxn][maxn],dp[maxn][maxn],sum[maxn],arr[maxn];\n//mæ˜¯åŒºé—´åˆ†å‰²ç‚¹\nsigned main(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>arr[i];\n        sum[i]=sum[i-1]+arr[i];\n        m[i][i]=i;\n    }\n    for(int len=2;len<=n;len++){//æšä¸¾åŒºé—´é•¿åº¦ï¼Œä¹Ÿæ˜¯å¯¹è§’çº¿æ¡æ•°\n        for(int i=1,j=len;j<=n;i++,j++){\n            dp[i][j]=inf;\n            for(int k=m[i][j-1];k<=m[i+1][j];k++){\n                if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]<dp[i][j]){\n                    dp[i][j]=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1];\n                    m[i][j]=k;\n                }\n            }\n        }\n    }\n    cout<<dp[1][n]<<endl;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.6 çŠ¶æ€å‹ç¼©dp\n\n```cpp\nusing namespace std;\nconst int maxn = 1 << 16;\ndb f[17][1 << 17]; // å½“å‰åˆ°ç¬¬iä¸ªå¥¶é…ªï¼Œå¹¶ä¸”å·²ç»ç»è¿‡çš„çŠ¶æ€ä¸ºj\ndb d[17][17];\ndb x[17] = {0}, y[17] = {0};\ndb dis(int i, int j)\n{\n    return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n}\nint main()\n{\n    int n = read();\n    memset(f, 127, sizeof(f));\n    db ans = f[0][0];\n    for (int i = 1; i <= n; i++)\n        cin >> x[i] >> y[i];\n    for (int i = 0; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            d[i][j] = d[j][i] = dis(i, j); // åˆå§‹åŒ–ä»»æ„ä¸¤ä¸ªå¥¶é…ªä¹‹é—´çš„è·ç¦»\n    for (int i = 1; i <= n; i++)\n        f[i][1 << (i - 1)] = d[0][i];\n    for (int j = 0; j < (1 << n); j++)\n    { // æšä¸¾å½“å‰å·²ç»èµ°è¿‡çš„çŠ¶æ€\n        for (int i = 1; i <= n; i++)\n        {\t\t\t\t\t\t\t\t   // æšä¸¾å½“å‰å·²ç»åˆ°ç¬¬iä¸ªå¥¶é…ª\n            if ((j & (1 << (i - 1))) == 0) // æœ¬åº”å·²ç»åˆ°äº†iä¸ªå¥¶é…ªï¼Œä½†æ˜¯è¿˜æ²¡èµ°è¿‡iä¸åˆé¢˜æ„\n                continue;\n            for (int k = 1; k <= n; k++)\n            { // æšä¸¾ä¸Šä¸€ä¸ªèµ°åˆ°çš„å¥¶é…ª\n                if (i == k)\n                    continue;\t\t\t\t   // é‡å¤äº†è·³è¿‡\n                if ((j & (1 << (k - 1))) == 0) // ç›®å‰èµ°è¿‡çš„jæ²¡èµ°è¿‡k\n                    continue;\n                f[i][j] = min(f[i][j], f[k][j - (1 << (i - 1))] + d[i][k]);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        ans = min(ans, f[i][(1 << n) - 1]);\n    cout << fixed << setprecision(2) << ans << endl;\n    return 0;\n}\n```\n\n<div style=\"page-break-after: always;\"></div>\n\n### 2.7 æœ€çŸ­è·¯ä¼˜åŒ–dp\n\næœ€çŸ­è·¯$dp$åæ•ˆæ€§é—®é¢˜ä¼šè¢«æœ€çŸ­è·¯ä¼˜åŒ–æ‰ã€‚\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\n#define int long long\nconst int maxn = 2e5 + 9;\nvector<pair<int, int>> connects[maxn];\nint a[maxn];\nvoid add_edge(int u, int v, int w)\n{\n    connects[u].push_back({v, w});\n    connects[v].push_back({u, w});\n    return;\n}\nvector<int> dist, dist1;\nvoid Dijkstra_queue0()\n{\n    using pi = pair<int, int>;\n    vector<bool> vis(n + 1, 0);\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    for (int i = 1; i <= n; i++)\n    {\n        q.push({dist[i], i});\n    }\n    while (!q.empty())\n    {\n        auto [dis, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto [v, w] : connects[u])\n        {\n            if (vis[v])\n                continue;\n            if (dist[v] > dist[u] + w)\n            {\n                dist[v] = dist[u] + w;\n                q.push({dist[v], v});\n            }\n        }\n    }\n    return;\n}\nvoid Dijkstra_queue1()\n{\n    using pi = pair<int, int>;\n    vector<bool> vis(n + 1, 0);\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    for (int i = 1; i <= n; i++)\n    {\n        q.push({dist1[i], i});\n    }\n    while (!q.empty())\n    {\n        auto [dis, u] = q.top();\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto [v, w] : connects[u])\n        {\n            int now = min(dist[u], dist1[u] + w);\n            if (now < dist1[v])\n            {\n                dist1[v] = now;\n                q.push({dist1[v], v});\n            }\n        }\n    }\n    return;\n}\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        add_edge(u, v, w);\n    }\n    dist.resize(n + 10), dist1.resize(n + 10);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        dist[i] = dist1[i] = a[i];\n    }\n    Dijkstra_queue0();\n    Dijkstra_queue1();\n    cout << *max_element(dist1.begin() + 1, dist1.end()) << endl;\n}\n```\n\n","tags":["ACM","ICPC","ç®—æ³•æ¨¡ç‰ˆ"]},{"title":"æˆ‘çš„21å²","url":"/2024/11/29/æˆ‘çš„21å²/","content":"æææƒšæƒšå·²ç»æ¥åˆ°è¿™ä¸ªä¸–ç•Œä¸Š20ä¸ªå¹´å¤´ï¼Œè¿™æ®µæ—¶æœŸé‡Œæœ‰é«˜å…‰ä¹Ÿæœ‰ä½è°·ï¼Œæ— è®ºæ€æ ·ï¼Œä¸€åˆ‡éƒ½å·²éšé£è€Œå»ã€‚å¯¹äºè¿‡å»ï¼Œå”¯æœ‰æ„Ÿæ©ã€‚æ­£å¦‚æ¶›æ¶›çš„ç¥ç¦ä¸€æ ·ï¼Œå¸Œæœ›è‡ªå·±åœ¨ä»Šåå¿ƒæ€å’Œèƒ½åŠ›éƒ½è¦æå‡ï¼Œæ›´åŠ æˆç†Ÿä¸€ç‚¹ã€‚æ–°çš„ä¸€å²ï¼Œè¦åšåˆ°**è¨€å¿…ä¿¡ï¼Œè¡Œå¿…æœ**ã€‚æ¶›æ¶›çš„ç¥ç¦è¯­è¿˜æœ‰ä¸€å¥â€æ— äº‹ç»Šå¿ƒå¼¦ï¼Œéšç¼˜çš†æ‰€å¿µâ€ã€‚å¥½å¥‡ä¸ºä»€ä¹ˆä¸æ˜¯â€œæ‰€æ„¿çš†æ‰€å¿µâ€ï¼Œå¯æ˜¯å‘ç°â€œéšç¼˜â€æ¯”â€œæ‰€æ„¿â€æ›´å¥½......çœŸæ­£åœ¨æ„ä½ çš„äººï¼Œåˆæ€ä¹ˆä¼šè®©ä½ ä¼¤å¿ƒå‘¢ï¼Œâ€œé€ç»™è‡ªå·±ä¸€æœµå°çº¢èŠ±ï¼Œå¼€åœ¨æˆ‘æ–°é•¿çš„ææ¡ â€ï¼Œæ‹¥æŠ±æœªæ¥ï¼Œçæƒœçˆ±æˆ‘çš„äººã€‚\n\n<center>\n\n<img src=\"https://s2.loli.net/2024/11/29/Fh43SXJnB8y1Y5C.jpg\" width=\"100%\" />\n\nFigure 1\n</center>\n\nå’Œå®¤å‹èšé¤åº†ç¥ä¸€ä¸‹ã€‚\n\n<center>\n\n<img src=\"https://s2.loli.net/2024/11/29/mn7x5To8t9VAEwY.jpg\" width=\"100%\" />\n\nFigure 2\n</center>","tags":["ç”Ÿæ—¥"]},{"title":"Mini App","url":"/2024/10/30/Mini App/","content":"**ä½œä¸šè¯´æ˜ï¼š**\nä¸ªäººä½œä¸šã€‚ä¸é™ä¸»é¢˜ï¼Œä¸é™åŠŸèƒ½ï¼Œåšå‡ºä¸€æ¬¾Mini App\n\n**å…·ä½“è¦æ±‚ï¼š**\n1.åŠŸèƒ½è¦æ±‚ï¼šå¯ä½¿ç”¨ä»»æ„ç•Œé¢æ¡†æ¶å®Œæˆè‡³å°‘ä¸€ä¸ªçš„åŠŸèƒ½ç‚¹\n2.æŠ€æœ¯è¦æ±‚ï¼šéœ€è¦ä½¿ç”¨åˆ°ç½‘ç»œã€å­˜å‚¨ç­‰æŠ€æœ¯ç‚¹ä¸­è‡³å°‘ä¸€æ¡\n3.æ€§èƒ½è¦æ±‚ï¼šä¸å¡é¡¿ã€æ— æ˜æ˜¾èµ„æºæ³„éœ²\n\n**æäº¤è¦æ±‚ï¼š**\n1.äº§å“æŠ¥å‘Šï¼šä¸é™äºppt/word/pdfæ ¼å¼ï¼Œå†…å®¹éœ€è‡³å°‘åŒ…æ‹¬ â‘ äº§å“åŠŸèƒ½ä»‹ç»ï¼›â‘¡ç¨‹åºæ¦‚è¦è®¾è®¡ï¼›â‘¢è½¯ä»¶æ¶æ„å›¾ï¼›â‘£æŠ€æœ¯äº®ç‚¹åŠå…¶å®ç°åŸç†ï¼ˆéå¿…é€‰ï¼‰\n2.æºä»£ç ï¼šè¦æ±‚æäº¤åˆ°GitHub/gitee repoä»“åº“ï¼Œå°†ä»“åº“åœ°å€ç²˜è´´åˆ°txtæäº¤å³å¯\n3.æ¼”ç¤ºå½•å±ï¼šmkv, mp4, avi, rm, rmvbæ ¼å¼ä¼˜å…ˆ\n4.æäº¤æ—¶é—´ï¼š11æœˆ30æ—¥æ™š12ç‚¹å‰\n\n**æäº¤æ ¼å¼ï¼š**\nè¯·å°†ä»¥ä¸Šä¸‰ä¸ªå†…å®¹åˆå¹¶åˆ°ä¸€ä¸ªæ–‡ä»¶å¤¹å¹¶å‹ç¼©ï¼Œå‘½åï¼šå­¦æ ¡+å§“å+Android/iOS+Appåç§°\nä¸Šä¼ è‡³ï¼š\nè…¾è®¯å®¢æˆ·ç«¯èè‹±ç­è¯¾ç¨‹å¤§ä½œä¸šæäº¤\n\n**æ ·ä¾‹å‚è€ƒï¼š**\nä¾‹1ï¼šã€Šè¡¨æƒ…å›¾åº“ã€‹\n1.åŠŸèƒ½è¦æ±‚ï¼šä½¿ç”¨ç½‘æ ¼/åˆ—è¡¨ï¼Œå±•ç¤ºè¡¨æƒ…å›¾åº“\n2.æŠ€æœ¯è¦æ±‚ï¼šä½¿ç”¨ DB å­˜å‚¨å›¾ç‰‡æ–‡ä»¶ä¿¡æ¯ï¼Œä½¿ç”¨æ–‡ä»¶å­˜å‚¨è¡¨æƒ…å›¾ç‰‡\n3.æ€§èƒ½è¦æ±‚ï¼šå¿«é€Ÿæ‰“å¼€è¶…è¿‡1000å¼ å›¾ç‰‡çš„å›¾åº“ï¼Œæ˜¾ç¤ºå›¾ç‰‡æµç•…æ»‘åŠ¨ä¸å¡é¡¿ï¼Œå†…å­˜èµ„æºä¸æ³„éœ²\n\nä¾‹2ï¼šã€Šå¾®ä¿¡æ–‡æœ¬/å›¾ç‰‡èŠå¤©ã€‹\n1.åŠŸèƒ½è¦æ±‚ï¼šä»¿ç…§å¾®ä¿¡åšä¸€ä¸ªå¯ä»¥æ–‡æœ¬/å›¾ç‰‡èŠå¤©çš„ç•Œé¢\n2.æŠ€æœ¯è¦æ±‚ï¼šèƒ½å¤Ÿè¿›è¡Œä¸¤äººä»¥ä¸Šçš„èŠå¤©ï¼Œèƒ½å¤Ÿå‘é€æ–‡æœ¬/å›¾ç‰‡\n3.æ€§èƒ½è¦æ±‚ï¼šèŠå¤©åˆ—è¡¨ä¸Šä¸‹æ»‘åŠ¨ä¸å¡é¡¿ï¼Œæ²¡æœ‰èµ„æºæ³„éœ²\n\næ³¨ï¼šä»¥ä¸Šä»…ä¸ºæ ·ä¾‹å‚è€ƒï¼ŒåŒå­¦ä»¬å¯ä»¥ä»»æ„é€‰æ‹©è‡ªå·±æƒ³åšçš„ Mini Appã€‚","tags":["Mini App","è…¾è®¯"]},{"title":"ã€Šè½¯ä»¶å·¥ç¨‹ã€‹å¤ä¹ ","url":"/2024/10/30/ã€Šè½¯ä»¶å·¥ç¨‹ã€‹å¤ä¹ /","content":"## 1.2 è½¯ä»¶åŠå…¶ç‰¹ç‚¹\n### è½¯ä»¶çš„ç»„æˆ\nç¨‹åºã€æ•°æ®å’Œç›¸å…³æ–‡æ¡£ \n### è½¯ä»¶çš„ç”Ÿå‘½å‘¨æœŸ\néœ€æ±‚åˆ†æã€è½¯ä»¶è®¾è®¡ã€ç¼–ç å®ç°ã€è½¯ä»¶æµ‹è¯•ã€éƒ¨ç½²è¿è¡Œã€ä½¿ç”¨ç»´æŠ¤ã€‚\n### è½¯ä»¶çš„åˆ†ç±»\n**åº”ç”¨è½¯ä»¶**\n**ç³»ç»Ÿè½¯ä»¶**\n**æ”¯æ’‘è½¯ä»¶**\n### å¼€æºè½¯ä»¶çš„ä¼˜åŠ¿\n#### **å¼€æºè½¯ä»¶çš„å¥½å¤„**\næºä»£ç å¯è‡ªç”±ä¼ æ’­\næ¿€å‘åˆ›ä½œè€…çš„çƒ­æƒ…\nå…è´¹ä½¿ç”¨é™ä½æˆæœ¬\n#### **å¼€æºè½¯ä»¶çš„ä¼˜åŠ¿**\n**é‡‡è´­å’Œå¼€å‘çš„æˆæœ¬æ›´ä½**ï¼šå¼€æºè½¯ä»¶é€šå¸¸æ˜¯å…è´¹çš„ï¼Œå³ä½¿è¦ä»˜è´¹ï¼Œå…¶è´¹ç”¨ä¹Ÿéå¸¸ä½å»‰\n**è½¯ä»¶è´¨é‡æ›´é«˜ã€æ›´å®‰å…¨**ï¼šæ ¸å¿ƒä»£ç éƒ½åœ¨å…¬ä¼—çš„è§†é‡ä¹‹ä¸­ï¼Œä»£ç é—®é¢˜ï¼ˆå¦‚ç¼ºé™·ã€å®‰å…¨æ¼æ´ç­‰ï¼‰å¾ˆå®¹æ˜“è¢«äººå‘ç°\n**è½¯ä»¶ç ”åˆ¶å’Œäº¤ä»˜çš„æ›´å¿«**ï¼šåŸºäºå¼€æºè½¯ä»¶çš„é¡¹ç›®å¼€å‘å¯ä»¥æ›´ä¸ºå¿«é€Ÿåœ°ç»™ç”¨æˆ·äº¤ä»˜è½¯ä»¶äº§å“\n**è½¯ä»¶åŠŸèƒ½æ›´ä¸ºå¼ºå¤§**ï¼šå¤§é‡çš„è½¯ä»¶å¼€å‘è€…ä¸ä»…å‚ä¸è½¯ä»¶å¼€å‘ï¼Œè´¡çŒ®ä»–ä»¬çš„ä»£ç ï¼Œè€Œä¸”è¿˜å‚ä¸è½¯ä»¶çš„åˆ›æ–°ï¼Œæå‡ºå’Œæ„æ€è½¯ä»¶éœ€æ±‚ï¼Œä¸æ–­å®Œå–„è½¯ä»¶åŠŸèƒ½\n### è½¯ä»¶è´¨é‡è¦ç´ \næ­£ç¡®æ€§ã€å¯é æ€§ã€å¥å£®æ€§ã€æœ‰æ•ˆæ€§ã€å®‰å…¨æ€§ã€å¯ç»´æŠ¤æ€§ã€å¯ç§»æ¤æ€§ã€å¯é‡ç”¨æ€§ã€å¯ç†è§£æ€§ã€å¯ä¿¡æ€§ã€æŒç»­æ€§ã€å¯ç”¨æ€§ã€äº’æ“ä½œæ€§ã€‚\n\n## 2 è½¯ä»¶å·¥ç¨‹æ¦‚è¿°\n### è½¯ä»¶å±æœºçš„è¡¨ç°\nå¼€å‘æˆæœ¬é«˜\nè¿›åº¦éš¾ä»¥æ§åˆ¶\nè´¨é‡éš¾ä»¥ä¿è¯\nè½¯ä»¶ç»´æŠ¤å›°éš¾\nå¤±è´¥é£é™©å¾ˆå¤§\n\n### è½¯ä»¶å·¥ç¨‹çš„è¦ç´ \n![alt text](image.png)\n### è½¯ä»¶å·¥ç¨‹çš„åŸåˆ™\næŠ½è±¡å’Œå»ºæ¨¡ã€æ¨¡å—åŒ–ã€è½¯ä»¶é‡ç”¨ã€ä¿¡æ¯éšè—ã€å…³æ³¨ç‚¹åˆ†ç¦»ã€åˆ†è€Œæ²»ä¹‹ã€åŒå‘è¿½è¸ªåŸåˆ™ã€å·¥å…·è¾…åŠ©ã€‚\n\n## 3.1 è½¯ä»¶è¿‡ç¨‹æ¨¡å‹\n### å…¸å‹è½¯ä»¶è¿‡ç¨‹æ¨¡å‹\n**ç€‘å¸ƒæ¨¡å‹ã€å¢é‡æ¨¡å‹ã€è¿­ä»£æ¨¡å‹ã€åŸå‹æ¨¡å‹ã€èºæ—‹æ¨¡å‹**ã€åŸºäºæ„ä»¶çš„è¿‡ç¨‹æ¨¡å‹ã€UPæ¨¡å‹ã€‚\n\n## 3.2 æ•æ·è½¯ä»¶å¼€å‘æ–¹æ³•\n### æ•æ·å¼€å‘çš„æ¦‚å¿µå’Œè§‚ç‚¹\n\n### æ•æ·å‡†åˆ™\n\n### æ•æ·å¼€å‘ä»£è¡¨æ–¹æ³•\n\n## 4 è½¯ä»¶éœ€æ±‚åˆ†æåŸºç¡€\n### åˆ©ç›Šç›¸å…³æ–¹\n\n### è½¯ä»¶éœ€æ±‚çš„ç±»åˆ«\n\n### é¢å‘å¯¹è±¡çš„éœ€æ±‚åˆ†ææ–¹æ³•\n\n## 5 è·å–è½¯ä»¶éœ€æ±‚\n### è·å–è½¯ä»¶éœ€æ±‚çš„æ–¹æ³•\n### ç”¨ä¾‹å›¾\n\n## 6 åˆ†æè½¯ä»¶éœ€æ±‚\n### é¡ºåºå›¾\n### ç±»å›¾\n### çŠ¶æ€å›¾\n### åˆ†æè½¯ä»¶éœ€æ±‚è¿‡ç¨‹\n### è½¯ä»¶éœ€æ±‚æ–‡æ¡£\n\n## 7 è½¯ä»¶è®¾è®¡åŸºç¡€\n### è½¯ä»¶è®¾è®¡çš„è´¨é‡è¦æ±‚\n### è½¯ä»¶è®¾è®¡åŸåˆ™\n\n## 8 è½¯ä»¶ä½“ç³»ç»“æ„è®¾è®¡\n### å¸¸ç”¨è½¯ä»¶ä½“ç³»ç»“æ„é£æ ¼\n\n## 10 è½¯ä»¶è¯¦ç»†è®¾è®¡\n### è¯¦ç»†è®¾è®¡è¿‡ç¨‹\n### æ´»åŠ¨å›¾\n### ç”¨ä¾‹è®¾è®¡\n### ç±»è®¾è®¡\n### æ•°æ®è®¾è®¡\n\n## 13 è½¯ä»¶æµ‹è¯•\n### è½¯ä»¶æµ‹è¯•è¿‡ç¨‹\n### è½¯ä»¶æµ‹è¯•åŸåˆ™\n### è½¯ä»¶æµ‹è¯•æŠ€æœ¯\n\n## 15 è½¯ä»¶ç»´æŠ¤å’Œæ¼”åŒ–\n### è½¯ä»¶ç»´æŠ¤çš„å½¢å¼\n### è½¯ä»¶ç»´æŠ¤æŠ€æœ¯","tags":["å¤ä¹ ","è½¯ä»¶å·¥ç¨‹"]},{"title":"Hackathonå†³èµ›","url":"/2024/10/26/Hackathonå†³èµ›/","content":"æœ¬æ¬¡æ‰€é€‰å·¥ç¨‹é¢˜ç›®å¯¹äºæˆ‘ä»¬æ¥è¯´éš¾åº¦è¿˜æ˜¯å¤ªå¤§äº†ã€‚æ‰€ä»¥å†³å®šå…ˆå»è§‚å…‰ä¸€ä¸‹åä¸ºæ¬§æ´²å°é•‡å§~\n<center>\n<img src=\"https://s2.loli.net/2024/10/26/dDNqeRghP17isKX.jpg\" width=\"100%\" />\n\nFigure 1\n</center>\n\næ„æ–™ä¹‹å¤–è·å¾—â€œå®‰æ…°å¥–â€ã€‚\n<center>\n<img src=\"https://s2.loli.net/2024/10/29/xtLy9h3d5SHAeuZ.jpg\" width=\"100%\" />\n\nFigure 2\n</center>\n\nè¿”ç¨‹é£æœºä¸Šçš„ä½“éªŒæ„Ÿè¿˜ä¸é”™ã€‚\n<center>\n<img src=\"https://s2.loli.net/2024/10/29/UOLH8Fyaf7lPsI6.jpg\" width=\"100%\" />\n\nFigure 3\n</center>","tags":["Hackathon","åä¸º","æ¯”èµ›","ä½“éªŒ"]},{"title":"C/C++ è¯»å–EXCELæ•°æ®","url":"/2024/10/25/è¯»å–EXCELæ•°æ®/","content":"- æ‰“å¼€Excelæ–‡ä»¶ï¼Œç‚¹å‡»æ–‡ä»¶-å¦å­˜ä¸º\n- åœ¨ä¿å­˜ç±»å‹è¿™é‡Œè®¾ç½®ä¿å­˜ä¸ºcsvæ ¼å¼\n- é€‰æ‹©å¥½æƒ³ä¿å­˜çš„ç›®å½•åï¼Œç‚¹å‡»ä¿å­˜\n- å›åˆ°å·¥ä½œç•Œé¢åï¼Œä¼šå¼¹å‡ºçª—å£ï¼Œé€‰æ‹©ç¡®å®šå°±å¯ä»¥äº†\n\n**æŒ‰è¡Œè¯»å–ã€‚**\n```C++\n#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    ifstream file(\"01.csv\"); // æ‰“å¼€CSVæ–‡ä»¶\n    if (!file.is_open()) {\n        cout << \"æ— æ³•æ‰“å¼€æ–‡ä»¶ï¼\" << endl;\n        return 1;\n    }\n\n    string line;\n    while (getline(file, line)) { // é€è¡Œè¯»å–æ–‡ä»¶\n        cout << line << endl; // æ‰“å°æ¯ä¸€è¡Œå†…å®¹\n    }\n\n    file.close(); // å…³é—­æ–‡ä»¶\n    return 0;\n}\n```","tags":["c++"]},{"title":"åŸºäºVirtualBoxè™šæ‹Ÿæœºå®‰è£…Ubuntuæ•™ç¨‹","url":"/2024/10/17/åŸºäºVirtualBoxè™šæ‹Ÿæœºå®‰è£…Ubuntuæ•™ç¨‹/","content":"## ä¸€. ä¸‹è½½å®‰è£…VirtualBox\n\n1. [å®˜ç½‘ä¸‹è½½VirtualBoxå®‰è£…ç¨‹åº](https://www.virtualbox.org/wiki/Downloads)ï¼Œæˆ‘çš„ç‰ˆæœ¬ï¼ˆreleased July 28 2021ï¼‰ï¼šVirtualBox 6.1.26 for Windows hosts x86/amd64\n\n2. ä¸‹è½½å¥½äº†å®‰è£…VirtualBoxï¼Œä¸€è·¯`Next`å°±å¯ä»¥äº†,è¿™ä¸ªæ¯”è¾ƒç®€å•ã€‚\n\n3. è¿è¡ŒVirtulBoxç¨‹åº, å¦‚ä¸‹å›¾ï¼š\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/wV8GSWjOA7szHuf.png\" width=\"80%\" />\n</center>\n\n4. é…ç½®VirtualBoxã€‚æŒ‰ `CTRL+G`æ‰“å¼€å…¨å±€è®¾å®šï¼Œæ ¹æ®éœ€è¦å¯ä»¥è®¾å®šè™šæ‹Ÿè„‘ä½ç½®å’Œç•Œé¢è¯­è¨€ï¼š\n\nä¿®æ”¹`é»˜è®¤è™šæ‹Ÿè„‘ä½ç½®`æ¯”å¦‚`D:\\VirtualBox VMs`å¯ä»¥è®©è‡ªå·±æ›´æ–¹ä¾¿çš„æŸ¥æ‰¾ï¼Œå¤‡ä»½å®‰è£…å¥½çš„è™šæ‹Ÿæœºã€‚\\\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/c6gMmE9kOTUKePa.png\" width=\"80%\" />\n</center>\n\nå¦‚æœç•Œé¢æ˜¯è‹±æ–‡ï¼Œå¯ä»¥æ”¹æˆä¸­æ–‡ï¼š\\\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Ui6OyNV37F9pfZ8.png\" width=\"80%\" />\n</center>\n\n5. å®‰è£…VirtualBox Extension Packï¼ˆæ–°æ‰‹å¯ä»¥ä¸åšï¼‰\n\n[ä¸‹è½½](https://download.virtualbox.org/virtualbox/6.1.4/Oracle_VM_VirtualBox_Extension_Pack-6.1.4.vbox-extpack), åŒå‡»å®‰è£…ï¼Œæ”¯æŒUSB 2.0 å’ŒUSB 3.0 è®¾å¤‡, VirtualBox RDP, ç£ç›˜åŠ å¯†ï¼Œè™šæ‹Ÿæœºå¿«ç…§ç­‰åŠŸèƒ½ã€‚\n\n## äºŒã€å®‰è£…Ubuntu\n\n### åˆ›å»ºè™šæ‹Ÿæœº\n\n1. è¿è¡ŒVirtulBoxç¨‹åºï¼Œç‚¹å‡»â€œæ–°å»ºâ€æŒ‰é’®ï¼Œæ–°å»ºä¸€ä¸ªè™šæ‹Ÿæœºã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/BUaJM38DxXOEISC.png\" width=\"80%\" />\n</center>\n\n2. è™šæ‹Ÿæœºåç§°å¯ä»¥éšæ„è¾“å…¥ï¼Œç¤ºä¾‹ï¼š`zhy`ã€‚æ“ä½œç³»ç»Ÿé€‰æ‹©Linuxï¼Œç‰ˆæœ¬é€‰æ‹©ubuntu(64-bit)ã€‚ç‚¹å‡»â€œä¸‹ä¸€æ­¥â€ã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Ov6DCRIuglzAwrP.png\" width=\"80%\" />\n</center>\n3. è®¾å®šè™šæ‹Ÿæœºçš„å†…å­˜ï¼Œæ­¤å†…å­˜å³ä¸ºè™šæ‹Ÿæœºæ‰€å ç”¨çš„ç³»ç»Ÿå†…å­˜ï¼Œå¯éšæ„ä¿®æ”¹ï¼Œå»ºè®®ä¸è¦è¶…è¿‡ç³»ç»Ÿå†…å­˜çš„1/2ã€‚\\\n   é¦–å…ˆäº†è§£è‡ªå·±çš„ç¬”è®°æœ¬ç”µè„‘ç³»ç»Ÿå†…å­˜å¤§å°ï¼Œâ€œæˆ‘çš„ç”µè„‘â€->â€œå±æ€§â€ã€‚æ ·æœºä¸º16Gã€‚\\\n   ä¸ºäº†æ–¹ä¾¿ä»¥åç¼–ç¨‹å­¦ä¹ ä½¿ç”¨ï¼Œè¿™é‡Œå°†è™šæ‹Ÿå†…å­˜è®¾ä¸º4Gã€‚ç‚¹å‡»â€œä¸‹ä¸€æ­¥â€ã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/PI3uBHkc1NQ4DhJ.png\" width=\"80%\" />\n</center>\n\n4. ä¸ºè™šæ‹Ÿæœºåˆ›å»ºä¸€å—è™šæ‹Ÿç¡¬ç›˜ã€‚é€‰æ‹©â€œç°åœ¨åˆ›å»ºè™šæ‹Ÿç¡¬ç›˜â€ï¼Œå¹¶å•å‡»â€œåˆ›å»ºâ€ã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/uxgviweoWYF7AmR.png\" width=\"80%\" />\n</center>\n\nå¦‚æœä½ å®‰è£…æœ‰é—®é¢˜ï¼Œå¯ä»¥å»åˆ«äººç”µè„‘ä¸Š`é»˜è®¤è™šæ‹Ÿè„‘ä½ç½®`æ¯”å¦‚`D:\\VirtualBox VMs`å¤„æ‹·è´åˆ«äººå®‰è£…å¥½çš„XXX.vdiæ–‡ä»¶ï¼Œåœ¨æ­¤é€‰æ‹©â€œä½¿ç”¨å·²æœ‰çš„è™šæ‹Ÿç¡¬ç›˜æ–‡ä»¶â€ï¼Œç„¶åé€‰ä¸­æ‹·è´è¿‡æ¥çš„vdiæ–‡ä»¶å°±å¯ä»¥äº†ï¼Œä¸‹é¢çš„å®‰è£…å°±ä¸ç”¨åšäº†ã€‚\n\n**åœ¨æ­¤å¼ºçƒˆå»ºè®®æŠŠæ•™ç¨‹èµ°å®Œï¼Œå‡ºé”™äº†ä¹Ÿä¼šæœ‰ä¸ä¸€æ ·çš„æ”¶è·**\n\n5. é€‰æ‹©è™šæ‹Ÿç¡¬ç›˜æ–‡ä»¶ç±»å‹ã€‚é€‰æ‹©é»˜è®¤çš„VDIï¼ˆVirtualBoxç£ç›˜æ˜ åƒï¼‰ï¼Œå¹¶å•å‡»â€œä¸‹ä¸€æ­¥â€ã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/aXFf74RUsb5B1DW.png\" width=\"80%\" />\n</center>\n\n6. é€‰æ‹©â€œåŠ¨æ€æ‰©å±•â€ï¼Œå¹¶å•å‡»â€œä¸‹ä¸€æ­¥â€ã€‚\\\n   å› ä¸ºåˆ†é…ç»™è™šæ‹Ÿæœºçš„å†…å­˜ç©ºé—´è¾ƒå¤§ï¼Œä½¿ç”¨æ—¶é€æ¸å ç”¨ç£ç›˜ç©ºé—´ï¼Œé—²ç½®æ—¶è‡ªåŠ¨ç¼©å‡æ¯”è¾ƒåˆç†ï¼Œæ‰€ä»¥é€‰æ‹©åŠ¨æ€æ‰©å±•ç±»å‹ã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/6Todt8VHPwBabZX.png\" width=\"80%\" />\n</center>\n\n7. è¾“å…¥è™šæ‹Ÿç¡¬ç›˜æ–‡ä»¶çš„åç§°ï¼Œå¹¶é€‰æ‹©ä¿å­˜ä½ç½®ã€‚\\\n   é€‰æ‹©è™šæ‹Ÿç¡¬ç›˜å¤§å°æ—¶ä¸€å®šå…ˆç¡®å®šä¿å­˜æ‰€åœ¨ä½ç½®ç£ç›˜çš„å¯ç”¨å¤§å°ã€‚å¯ç”¨ç©ºé—´ä¸º500Gï¼Œè™šæ‹Ÿç¡¬ç›˜å¤§å°è®¾ç½®ä¸º10Gã€‚å•å‡»â€œåˆ›å»ºâ€ã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/Y1TEbI2jc4Fkis9.png\" width=\"80%\" />\n</center>\n\n8. è™šæ‹Ÿæœºåˆ›å»ºå®Œæˆã€‚ä¹Ÿå°±æ˜¯è¯´Ubuntuæ‰€éœ€çš„ç¡¬ä»¶èµ„æºå‡†å¤‡å¥½äº†ï¼Œç›¸å½“äºä¹°äº†ä¸€ä¸ªæ²¡æœ‰å®‰è£…æ“ä½œç³»ç»Ÿçš„ç”µè„‘ä¸»æœºã€‚\n\n<center>\n<img src=\"https://s2.loli.net/2024/12/06/6mFDeJh9cHsoCbQ.png\" width=\"80%\" />\n</center>\n\n### å®‰è£…Ubuntu ç³»ç»Ÿè½¯ä»¶\n\nåœ¨è™šæ‹Ÿæœºä¸Šå®‰è£…Ubuntuå’Œåœ¨çœŸå®æœºå™¨ä¸Šå®‰è£…æ²¡æœ‰å¤§çš„å·®åˆ«ã€‚\n\n1. [å®˜ç½‘ä¸‹è½½æ¡Œé¢ç‰ˆ](http://www.ubuntu.com.cn/desktop)ï¼Œç›®å‰(20200405)æ¨èç‰ˆæœ¬ï¼šUbuntu 18.04 LTSï¼Œæœ€æ–°ç‰ˆæœ¬19.10\n\n2. åŒå‡»å¯åŠ¨åˆ›å»ºå¥½çš„è™šæ‹Ÿæœº\n\n![startvm](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030053304656-1946165443.png>)\\\nå¼¹å‡ºä¸‹å›¾å¯¹è¯æ¡†ï¼Œé€‰æ‹©å¯åŠ¨ç›˜ã€‚å•å‡»å³ä¾§æ–‡ä»¶å¤¹å°å›¾æ ‡ã€‚\\\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030053731296-1064190557.png>)\n\né€‰æ‹©è™šæ‹Ÿå…‰ç›˜æ–‡ä»¶ubuntu-19.10.-desktop-amd64.isoï¼Œå•å‡»â€œå¯åŠ¨â€ã€‚\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20200405170800808-395758806.png>)\n\n3. è¿›å…¥å®‰è£…ç•Œé¢ã€‚ é€‰æ‹©â€œä¸­æ–‡ç®€ä½“â€ï¼Œé€‰æ‹©â€œå®‰è£…Ubuntuâ€\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030054941046-982728984.png>)\n\n4. é€‰æ‹©â€œç»§ç»­â€ã€‚ ç½‘ç»œçŠ¶å†µä¸å¥½å¯ä»¥ä¸é€‰æ‹©â€œå®‰è£…Ubuntuæ—¶ä¸‹è½½æ›´æ–°â€\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030055248000-1724687394.png>)\n\n5. é€‰æ‹©â€œæ¸…é™¤æ•´ä¸ªç£ç›˜å¹¶å®‰è£…Ubuntuâ€å•å‡»â€œç°åœ¨å®‰è£…â€\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030060024171-1240794498.png>)\n\nå¼¹å‡ºè­¦å‘Šæ¡†ï¼Œé€‰æ‹©â€œç»§ç»­â€ã€‚\n\n6. å®‰è£…è¿‡ç¨‹ä¸­æ—¶åŒºï¼Œç”¨é¼ æ ‡å•å‡»åœ°å›¾ä¸­çš„â€œä¸­å›½â€ï¼Œå°±ä¼šé€‰æ‹©â€œä¸Šæµ·â€ï¼Œå•å‡»â€œç»§ç»­â€ã€‚\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030061543234-2029302227.png>)\n\nè¯­è¨€é€‰â€œæ±‰è¯­â€ï¼š\\\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030072319203-288566262.png>)\n\n7. è¾“å…¥ä¸ªäººä¿¡æ¯ï¼šç”¨æˆ·åï¼Œå£ä»¤ç­‰ã€‚å•å‡»â€œç»§ç»­â€ï¼Œå®‰è£…è¿‡ç¨‹å¯èƒ½éœ€è¦å‡ ååˆ†é’Ÿï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚\n\n8. å®‰è£…å®Œæ¯•ï¼Œé‡å¯ä¸€ä¸‹Ubuntuã€‚\n\n## å®‰è£…VirtualBoxè™šæ‹Ÿæœºå¢å¼ºåŠŸèƒ½\n\næ³¨æ„ï¼šä»¥ä¸‹éœ€è¦è¾“å…¥å‘½ä»¤ä»£ç æ—¶è¯·æ³¨æ„ä¹‹é—´çš„ç©ºæ ¼ï¼ä»¥åŠæ–‡ä»¶åç›¸äº’å¯¹åº”ï¼\n\n1. è¿›å…¥è™šæ‹ŸæœºUbuntuç³»ï¼Œå®‰è£…VirtualBoxå¢å¼ºåŠŸèƒ½ï¼Œè¿™å¯ä»¥æå¤§çš„æé«˜è™šæ‹Ÿæœºæ•ˆç‡ã€‚é¦–å…ˆç‚¹å‡»VBoxèœå•æ çš„â€œè®¾å¤‡â€é¡¹ï¼Œé€‰æ‹©æœ€ä¸‹é¢çš„â€œå®‰è£…å¢å¼ºåŠŸèƒ½â€ã€‚\n\n![zq](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030081531281-1113664421.png>)\n\n3. è¿™æ—¶å¯ä»¥çœ‹åˆ°æ¡Œé¢å¤šå‡ºä¸€ä¸ªå…‰ç›˜å›¾æ ‡ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™é‡è¯•æœ¬æ­¥ã€‚\n\n4. æŒ‰`CTRL+ALT+T`æ‰“å¼€â€œç»ˆç«¯â€ã€‚è¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼ˆ**æ³¨æ„ç©ºæ ¼ï¼æ³¨æ„è·¯å¾„ã€æ–‡ä»¶åç›¸äº’å¯¹åº”ã€‚**ï¼‰\n\nè¾“å…¥å‘½ä»¤æ—¶è¦æ ¹æ®è‡ªå·±çš„æƒ…å†µä¿®æ”¹ï¼Œæ–‡ä»¶åç”¨`Tab`è¡¥å…¨ï¼Œå‡å°‘å½•å…¥é”™è¯¯ã€‚\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030091439796-2006488083.png>)\n\nç­‰å¾…å‡ åˆ†é’Ÿå°±å®‰è£…å¥½äº†ï¼\n\n### åˆ†é…å…±äº«æ•°æ®ç©ºé—´(æ˜“å‡ºé”™ï¼Œæ–°æ‰‹å¯ä»¥ä¸åš)\n\nä¸ºäº†æ–¹ä¾¿è™šæ‹Ÿæœºå’Œå®¿ä¸»æœºä¹‹é—´çš„æ•°æ®ä¼ è¾“ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºè™šæ‹Ÿæœºè®¾ç½®ä¸€ä¸ªå’Œä¸»æœºå…±äº«çš„â€œæ•°æ®ç©ºé—´â€ã€‚VBoxä¸ºæˆ‘ä»¬æä¾›äº†è¿™ä¸ªåŠŸèƒ½ã€‚\n\n1. åœ¨VBoxä¸»ç•Œé¢å·¦ä¾§é€‰æ‹©åˆšåˆšåˆ›å»ºå¥½çš„è™šæ‹Ÿæœºï¼Œç‚¹å‡»ä¸Šæ–¹çš„â€œè®¾ç½®â€æŒ‰é’®ï¼Œè¿›å…¥è™šæ‹Ÿæœºé…ç½®ç•Œé¢ã€‚ç‚¹å‡»å·¦ä¾§â€œå…±äº«æ–‡ä»¶å¤¹â€æŒ‰é’®ï¼Œåœ¨æ–°çª—å£ä¸­ä»»æ„é€‰æ‹©ä¸€ä¸ªæœ¬åœ°æ–‡ä»¶å¤¹ä½œä¸ºå…±äº«æ–‡ä»¶å¤¹ã€‚ç¤ºä¾‹é€‰æ‹©æ–‡ä»¶å¤¹ä½ç½®ä¸ºC:\\rocshareï¼Œä¸è¦å‹¾é€‰â€œåªè¯»åˆ†é…â€ã€‚å•å‡»â€œç¡®å®šâ€ï¼Œå¹¶å…³é—­è®¾ç½®çª—å£ã€‚\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030093638484-754721120.png>)\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030094135281-471357754.png>)\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030093648984-2094658791.png>)\n\n2. å¯åŠ¨Ubuntuï¼Œæ‰“å¼€ç»ˆç«¯çª—å£ã€‚ï¼ˆæ³¨æ„ç©ºæ ¼ï¼ï¼‰\\\n   ä¸€ä¸ªè¦ç‚¹æ˜¯ï¼šå‘½ä»¤ï¼Œæ–‡ä»¶åè¦é€šè¿‡`Tab`è¡¥å…¨ï¼Œè¿™æ ·å°±ä¼šå‡å°‘å½•å…¥é”™è¯¯ã€‚\n\n* è¾“å…¥å‘½ä»¤â€œsudo mkdir /mnt/sharedâ€ã€‚å›è½¦åé”®å…¥å¯†ç ã€‚\n* ç»§ç»­è¾“å…¥å‘½ä»¤â€œsudo mount â€“t vboxsf rocshare /mnt/shared\" //æ³¨æ„rocshare /mnt/shared è¦è·Ÿæ®è‡ªå·±çš„æƒ…å†µä¿®æ”¹\n* è¾“å…¥å‘½ä»¤â€œsudo gedit /etc/fstabâ€\n\n3. åœ¨å¼¹å‡ºçš„æ–‡æœ¬æœ«å°¾æ·»åŠ ä¸€è¡Œä¸‹é¢çš„å†…å®¹ï¼š\n\n* â€œrocshare /mnt/shared vboxsf rw,gid=100,uid=1000,auto 0 0â€\n\n4. ç°åœ¨æ‰“å¼€/mnt/sharedæ–‡ä»¶å¤¹ï¼Œå°±å¯ä»¥çœ‹åˆ°ä¸»æœºå¯¹åº”å…±äº«æ–‡ä»¶å¤¹rocshareä¸­çš„å†…å®¹äº†ã€‚è¿™å°±æ˜¯å®¿ä¸»æœºå’Œè™šæ‹Ÿæœºä¹‹é—´çš„æ¡¥æ¢ã€‚\n\næ¯”å¦‚æˆ‘ä»¬åœ¨Ubuntuä¸­ç”¨touchå‘½ä»¤æ–°å»ºä¸€ä¸ªtesttestçš„æ–‡ä»¶ï¼Œåˆ°å®¿ä¸»æœºçš„c://rocshareä¸­å°±èƒ½çœ‹åˆ°è¿™ä¸ªæ–‡ä»¶ã€‚\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030095516359-1565360436.png>)\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030095524640-2011954975.png>)\n\n5. è‡³æ­¤ï¼Œè™šæ‹Ÿæœºå®‰è£…é…ç½®å®Œæˆã€‚\n\n## é…ç½®Ubuntu\n\nUbuntuçš„ä½¿ç”¨å¯ä»¥å‚è€ƒ[åˆ«å‡ºå¿ƒè£çš„Linuxå‘½ä»¤å­¦ä¹ æ³•](http://www.cnblogs.com/rocedu/p/4902411.html).\n\n1. é€šè¿‡`sudo apt-get update;sudo apt-get upgrade` æ›´æ–°ä¸€ä¸‹ç³»ç»Ÿã€‚\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030110713000-318570997.png>)\n\n2. å®‰è£…è½¯ä»¶ã€‚Ubuntuä¸­å®‰è£…è½¯ä»¶æ¯”è¾ƒç®€å•ï¼Œä½¿ç”¨`sudo apt-get install XXX`å°±å¯ä»¥å®‰è£…XXXè½¯ä»¶ï¼Œæ¯”å¦‚æˆ‘ä»¬å¸¸ç”¨çš„Vim,å°±å¯ä»¥ç”¨`sudo apt-get install Vim`æ¥å®‰è£…ã€‚\n\n![install vim](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030110919031-429532360.png>)\n\næ³¨æ„ï¼šUbuntuä¸­ä½¿ç”¨åˆ°æŸä¸ªæ²¡æœ‰å®‰è£…çš„è½¯ä»¶æ—¶ï¼Œä¼šæœ‰è´´å¿ƒçš„æç¤ºï¼Œå¦‚ä¸Šå›¾ã€‚\n\næˆ‘ä»¬å¯ä»¥é€šè¿‡`apt-cache search XXXX`æ¥æŸ¥æ‰¾è½¯ä»¶åº“ä¸­æœ‰æ²¡æœ‰æˆ‘ä»¬æƒ³è¦å®‰è£…çš„è½¯ä»¶ã€‚æ¯”å¦‚æˆ‘ä»¬æƒ³çœ‹çœ‹æœ‰æ²¡æœ‰å¸¸ç”¨çš„è°ƒè¯•å·¥å…·cgdb,å°±å¯ä»¥ä½¿ç”¨`apt-cache search cgdb`æ¥æŸ¥æ‰¾ï¼š\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030112106046-695358617.png>)\n\næ‰¾åˆ°åå°±å¯ä»¥é€šè¿‡`sudo apt-get install cgdb`æ¥å®‰è£…äº†ã€‚\n\næˆ‘ä»¬å¯ä»¥ä¸€æ¬¡å®‰è£…å¤šä¸ªè½¯ä»¶ï¼Œæ¯”å¦‚`sudo apt-get install git ddd`å°±ä¼šå®‰è£…åˆ†å¸ƒå¼ç‰ˆæœ¬æ§åˆ¶å·¥å…·gitå’Œå›¾å½¢åŒ–è°ƒè¯•å·¥å…·dddï¼š\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030112525687-2083766394.png>)\n\nè¿™æé†’æˆ‘ä»¬å¯ä»¥å†™ä¸ªè„šæœ¬ç®€åŒ–è½¯ä»¶çš„å®‰è£…ï¼Œä½ å¯ä»¥æºæºä¸æ–­çš„æŠŠè‡ªå·±ç”¨çš„è½¯ä»¶æ·»åŠ åˆ°è¿™ä¸ªè„šæœ¬ä¸­ï¼Œæ–¹ä¾¿æ—¥åè‡ªå·±å®‰è£…æ–°ç³»ç»Ÿï¼š\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030113309812-1973136131.png>)\n\n![](<./åŸºäºVirtualBoxå®‰è£…(Ubuntu,openEuler)å›¾æ–‡æ•™ç¨‹ - å¨„è€å¸ˆ - åšå®¢å›­_files/741560-20161030113321468-101934690.png>)\n\næˆ‘çš„å®‰è£…è„šæœ¬ä¾›å¤§å®¶èƒ½å‚è€ƒï¼š\n\n```bash\n#!/bin/sh\n\n# update system\n\nsudo apt-get update\nsudo apt-get grade \nsudo apt-get autoremove\n\n# utilities\nsudo apt-get install krusader unace unrar zip unzip p7zip-full p7zip-rar sharutils rar uudeview mpack  arj cabextract file-roller\nsudo apt-get install apvlv biff bsdgames byobu calcurse curl dia dia2code dtach dump fbset filezilla  freemind gimp  htop iotop jhead ksnapshot multitail moreutils pandoc planner powertop putty python-pip retext rpm screen sniffit socat stardict tmux tpp tree  vlc vnc4server xvnc4viewer wireshark xchm xpdf tweak\n\n# cheat \nsudo pip install docopt pygments\ngit clone https://github.com/chrisallenlane/cheat.git\ncd cheat\nsudo python setup.py install  \n\n#vi \ncd ~/.vim/bundle\nwget http://www.vim.org/scripts/download_script.php?src_id=9679\n\n#java\nsudo apt-get install eclipse  eclipse-wtp eclipse-emf eclipse-gef netbeans  gaphor umbrello umlet\n\n#programming\nsudo apt-get install ascii automake bison bison-doc bluefish  cgdb clang cmake codeblocks codeblocks-dbg codeblocks-dev cscope cvs dia ddd doxygen doxygen-doc doxygen-gui dstat eclipse eclipse-cdt eclipse-cdt-qt  eclipse-cdt-valgrind eclipse-eclox eclipse-egit  eclipse-egit-mylyn eclipse-mylyn  exuberant-ctags flex fossil fp-compiler fp-ide  g++ gcc gdb  git gitk git-gui git-doc git-cvs git-svn git-sh gnustep groovy ifstat indent jedit jython  libncurses5-dev ncurses-doc libasound2-dev libasound2-doc manpages-posix manpages-posix-dev  nasm python-django python-django-doc qtcreator splint sqlite3 libsqlite3-dev sqlitebrowser sqliteman swig2.0 sysstat tcl8.5 tcl8.5-doc tk8.5 tk8.5-doc txt2tags python-pip qtcreator ruby1.9.3  qt4-qmake qtcreator jruby subversion tidy valgrind vim scala \n\n#security\nsudo apt-get install lib32z1 libc6-dev-i386     //64->32\nsudo apt-get install lib32readline-gplv2-dev\n```\n","tags":["æ•™ç¨‹","VirtualBox","Ubuntu"]},{"title":"MiniMIPS32","url":"/2024/10/12/MiniMIPS32/","content":"## æŒ‡ä»¤é›†ä»¿çœŸå™¨ -- TEMU\n### å®éªŒç®€ä»‹\né‡‡ç”¨é«˜çº§è¯­è¨€ï¼ˆC/C++ã€Javaæˆ–Pythonç­‰ï¼‰è®¾è®¡é¢å‘32ä½MIPSæˆ–LoongArchæŒ‡ä»¤é›†å­é›†çš„æŒ‡ä»¤é›†ä»¿çœŸå™¨ -- TEMUï¼Œç”¨äºå®ç°å¯¹ç¨‹åºæ‰§è¡Œè¿‡ç¨‹çš„æ¨¡æ‹Ÿå’Œè°ƒè¯•ã€‚è¯¥æŒ‡ä»¤é›†ä»¿çœŸå™¨å¯æ¨¡æ‹Ÿå¸¸è§æŒ‡ä»¤ï¼Œæ”¯æŒå•æ­¥æ‰§è¡Œã€æ–­ç‚¹ã€æ˜¾ç¤ºå¯„å­˜å™¨ä¿¡æ¯ã€æ˜¾ç¤ºç‰¹å®šå­˜å‚¨å•å…ƒä¿¡æ¯ç­‰åŠŸèƒ½ï¼Œä¸ºåç»­çš„å¤„ç†å™¨è®¾è®¡å®éªŒæä¾›ä»¿çœŸæµ‹è¯•å·¥å…·ã€‚","tags":["MiniMIPS32"]},{"title":"æ•°å€¼è®¡ç®—æ–¹æ³•","url":"/2024/10/08/æ•°å€¼è®¡ç®—æ–¹æ³•/","content":"## æ’å€¼æ³•\n**å®ç°èŒƒå¾·è’™å¾·å¤šé¡¹å¼æ’å€¼ã€æ‹‰æ ¼æœ—æ—¥æ’å€¼ã€ç‰›é¡¿æ’å€¼ã€åˆ†æ®µçº¿æ€§ã€åˆ†æ®µä¸‰æ¬¡ Hermite æ’å€¼ï¼Œå¹¶å®Œæˆå„æ–¹æ³•ä¹‹é—´çš„å¯¹æ¯”ã€‚**\n<font color=red>è¾“å…¥</font>ï¼šæ’å€¼åŒºé—´ $[a, b]$ï¼Œå‚æ•° $c, d, e, f$ ä½œä¸ºæ ‡å‡†å‡½æ•° $f(x) = c \\cdot \\sin dx + e \\cdot \\cos fx$ çš„å€¼ï¼Œå‚æ•° $n+1$ ä½œä¸ºé‡‡æ ·ç‚¹çš„ä¸ªæ•°ï¼Œå‚æ•° $m$ ä½œä¸ºå®éªŒç‚¹çš„ä¸ªæ•°ã€‚\n<font color=red>è¦æ±‚</font>ï¼šåœ¨åŒºé—´ $[a, b]$ ä¸Šå‡åŒ€é‡‡é›†ä¸ªé‡‡é›†ç‚¹ï¼Œåˆ©ç”¨è¿™ $n+1$ ä¸ªé‡‡é›†ç‚¹ï¼Œåˆ†åˆ«ä½¿ç”¨èŒƒå¾·è’™å¾·å¤šé¡¹å¼æ’å€¼ã€æ‹‰æ ¼æœ—æ—¥æ’å€¼ã€ç‰›é¡¿æ’å€¼ã€åˆ†æ®µçº¿æ€§ã€åˆ†æ®µä¸‰æ¬¡ Hermite æ’å€¼è¿›è¡Œæ’å€¼ï¼Œæ±‚å‡º $L(x)$ï¼Œä¹‹åå†é€‰å– $m$ ä¸ªç‚¹ä½œä¸ºå®éªŒç‚¹ï¼Œè®¡ç®—åœ¨è¿™ $m$ ä¸ªå®éªŒç‚¹ä¸Šæ’å€¼å‡½æ•° $L(x)$ ä¸ç›®æ ‡å‡½æ•° $f(x)$ çš„å¹³å‡è¯¯å·®ã€‚åŒæ—¶å¯¹æ¯”å„æ’å€¼æ–¹æ³•ä¹‹é—´çš„ç²¾åº¦å·®å¼‚ã€‚\n<font color=red>è¾“å‡º</font>ï¼šå¯¹æ¯”å‡½æ•°æ›²çº¿ï¼Œå¹³å‡è¯¯å·®ã€‚\n```Python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# èŒƒå¾·è’™å¾·å¤šé¡¹å¼æ’å€¼\ndef vandermonde_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    c = []\n    for i in range(n):\n        coeff = []\n        for j in range(n):\n            coeff.append(x[i]**j)\n        coefficients.append(coeff)\n        c.append(y[i])\n    A = np.array(coefficients)\n    inv_A = np.linalg.inv(A)\n    a = inv_A.dot(c)\n    sum = 0\n    for i in range(n):\n        sum += a[i] * x_values ** i\n    return sum\n\n# æ‹‰æ ¼æœ—æ—¥æ’å€¼\ndef lagrange_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n):\n        p = y[i]\n        for j in range(n):\n            if j != i:\n                p *= (x_values - x[j]) / (x[i] - x[j])\n        result += p\n    return result\n\n# ç‰›é¡¿æ’å€¼\ndef newton_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    for i in range(n-1, 0, -1):\n        divided_diff = (y[i] - y[i-1]) / (x[i] - x[i-1])\n        coefficients.append(divided_diff)\n        for j in range(n-i-1, 0, -1):\n            divided_diff = (-divided_diff + coefficients[j-1]) / (x[n-j] - x[i-1])\n            coefficients[j-1] = divided_diff\n    coefficients.append(y[0])\n    result = coefficients[0]\n    for i in range(n-2, -1, -1):\n        result = result * (x_values - x[i]) + coefficients[n-1-i]\n    return result\n\n# åˆ†æ®µçº¿æ€§æ’å€¼\ndef piecewise_linear_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        mask = (x[i] <= x_values) & (x_values < x[i+1])\n        slope = (y[i+1] - y[i]) / (x[i+1] - x[i])\n        result += ((y[i] + slope * (x_values - x[i]))*mask)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# åˆ†æ®µä¸‰æ¬¡Hermiteæ’å€¼\ndef piecewise_cubic_hermite_interpolation(x, y, yy, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        if ((x[i] <= x_values) & (x_values < x[i+1])):\n            ai = (1+2*(x_values-x[i])/(x[i+1]-x[i]))*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            bi = (x_values - x[i])*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            ai1 = (1+2*(x_values-x[i+1])/(x[i]-x[i+1]))*((x_values-x[i])/(x[i+1]-x[i]))**2\n            bi1 = (x_values - x[i+1])*((x_values-x[i])/(x[i+1]-x[i]))**2\n            result += (y[i] * ai +yy[i] * bi +y[i+1] * ai1 +yy[i+1] * bi1)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# ç›®æ ‡å‡½æ•°\ndef target_function(c,d,e,f,x):\n    return [(c*np.sin(d*val)+e*np.cos(f*val)) for val in x] \n\n# ç›®æ ‡å‡½æ•°å¯¼å‡½æ•°\ndef derivative_function(c,d,e,f,x):\n    return [(c*d*np.cos(d*val)-e*f*np.sin(f*val)) for val in x]\n\n# è®¡ç®—å¹³å‡è¯¯å·®\ndef compute_average_error(f, g, x_values):\n    return sum([abs(f[i] - g[i]) for i in range(len(x_values))]) / len(x_values)\n\n# è®¾ç½®æ’å€¼åŒºé—´å’Œå‚æ•°\na = float(input())\nb = float(input())\nc = float(input())\nd = float(input())\ne = float(input())\nf = float(input())\nnum_samples = int(input())\nnum_experiments = int(input())\nx_values = [a + (b - a) * i / (num_samples - 1) for i in range(num_samples)]\nys = target_function(c,d,e,f,x_values)\nyy = derivative_function(c,d,e,f,x_values)\n\n# è®¡ç®—å®éªŒç‚¹\nexperiment_points = [a + (b - a) * i / (num_experiments - 1) for i in range(num_experiments)]\n\n# è®¡ç®—å„æ’å€¼æ–¹æ³•çš„æ’å€¼ç»“æœå’Œå¹³å‡è¯¯å·®\nvandermonde_interpolated = [vandermonde_interpolation(x_values, ys, val) for val in experiment_points]\nvandermonde_error = compute_average_error(target_function(c,d,e,f,experiment_points), vandermonde_interpolated, experiment_points)\n\nlagrange_interpolated = [lagrange_interpolation(x_values, ys, val) for val in experiment_points]\nlagrange_error = compute_average_error(target_function(c,d,e,f,experiment_points), lagrange_interpolated, experiment_points)\n\nnewton_interpolated = [newton_interpolation(x_values, ys, val) for val in experiment_points]\nnewton_error = compute_average_error(target_function(c,d,e,f,experiment_points), newton_interpolated, experiment_points)\n\npiecewise_linear_interpolated = [piecewise_linear_interpolation(x_values, ys, val) for val in experiment_points]\npiecewise_linear_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_linear_interpolated, experiment_points)\n\npiecewise_cubic_hermite_interpolated = [piecewise_cubic_hermite_interpolation(x_values, ys, yy, val) for val in experiment_points]\npiecewise_cubic_hermite_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_cubic_hermite_interpolated, experiment_points)\n\nfig = plt.figure(num = 1,dpi = 120)\nax = plt.subplot(1,1,1)\n # åæ ‡è½´\nax = plt.gca()  # get current axis è·å¾—åæ ‡è½´å¯¹è±¡\nax.spines['right'].set_color('none')  # å°†å³è¾¹ è¾¹æ²¿çº¿é¢œè‰²è®¾ç½®ä¸ºç©º å…¶å®å°±ç›¸å½“äºæŠ¹æ‰è¿™æ¡è¾¹\nax.spines['top'].set_color('none')\nax.xaxis.set_ticks_position('bottom')\nax.yaxis.set_ticks_position('left')\n# è®¾ç½®ä¸­å¿ƒçš„ä¸ºï¼ˆ0ï¼Œ0ï¼‰çš„åæ ‡è½´\nax.spines['bottom'].set_position(('data', 0))  # æŒ‡å®š data è®¾ç½®çš„bottom(ä¹Ÿå°±æ˜¯æŒ‡å®šçš„xè½´)ç»‘å®šåˆ°yè½´çš„0è¿™ä¸ªç‚¹ä¸Š\nax.spines['left'].set_position(('data', 0))\n\nx=list(np.arange(a,b,0.01))#æ­¤å¤„å¯è°ƒæ•´è‡ªå˜é‡å–å€¼èŒƒå›´ï¼Œä»¥ä¾¿é€‰æ‹©åˆé€‚çš„è§‚å¯Ÿå°ºåº¦\ny=[]\ny1=[]\ny2=[]\ny3=[]\ny4=[]\ny5=[]\nfor i in range(len(x)):\n    y = target_function(c,d,e,f,x)\n    y1.append(vandermonde_interpolation(x_values, ys, x[i]))\n    y2.append(lagrange_interpolation(x_values, ys, x[i]))\n    y3.append(newton_interpolation(x_values, ys, x[i]))\n    y4.append(piecewise_linear_interpolation(x_values, ys, x[i]))\n    y5.append(piecewise_cubic_hermite_interpolation(x_values, ys, yy, x[i]))\n    \n\nax.plot(x,y,label = \"Target Function\",color =\"blueviolet\")\nax.plot(x_values,ys, marker = \"*\",linestyle = \"\", color = \"blueviolet\")\nax.plot(x,y1,label = \"vandermonde interpolation\\n average error=%f\"%vandermonde_error,color =\"red\")\nax.plot(experiment_points, vandermonde_interpolated, marker = \"o\",linestyle = \"\", color = \"red\")\nax.plot(x,y2,label = \"lagrange interpolation\\n average error=%f\"%lagrange_error,color =\"yellow\")\nax.plot(experiment_points, lagrange_interpolated, marker = \"o\",linestyle = \"\", color = \"yellow\")\nax.plot(x,y3,label = \"newton interpolation\\n average error=%f\"%newton_error,color =\"green\")\nax.plot(experiment_points, newton_interpolated, marker = \"o\",linestyle = \"\", color = \"green\")\nax.plot(x,y4,label = \"piecewise linear interpolation\\n average error=%f\"%piecewise_linear_error,color =\"blue\")\nax.plot(experiment_points, piecewise_linear_interpolated, marker = \"o\",linestyle = \"\", color = \"blue\")\nax.plot(x,y5,label = \"piecewise cubic hermite interpolation\\n average error=%f\"%piecewise_cubic_hermite_error,color =\"purple\")\nax.plot(experiment_points, piecewise_cubic_hermite_interpolated, marker = \"o\",linestyle = \"\", color = \"purple\")\n#ax.set_xlim(0,2)\n#plt.draw()\nplt.legend()\nplt.show()\n```\n\n## å‡½æ•°é€¼è¿‘\n**å®ç°æœ€ä½³å¹³æ–¹é€¼è¿‘ä¸æœ€å°äºŒä¹˜æ‹Ÿåˆï¼Œå¹¶å®Œæˆä¸¤ç§æ–¹æ³•ä¹‹é—´çš„å¯¹æ¯”ã€‚**\n<font color=red>è¾“å…¥</font>ï¼šå‡½æ•°åŒºé—´ $[a, b]$ï¼Œå‚æ•° $c$ ä½œä¸ºæ ‡å‡†å‡½æ•°$f(x)=\\frac{1}{1+cx^2}$çš„å€¼ï¼Œå‚æ•° $k$ ä½œä¸ºæ‰€æ„é€ çš„é€¼è¿‘å¤šé¡¹å¼çš„æ¬¡æ•° $(k=1,2,3)$ ã€‚å‚æ•° $n+1$ ä½œä¸ºé‡‡æ ·ç‚¹çš„ä¸ªæ•°ï¼Œå‚æ•° $m$ ä½œä¸ºå®éªŒç‚¹çš„ä¸ªæ•°ã€‚\n<font color=red>è¦æ±‚</font>ï¼šè¦æ±‚é€‰ç”¨å‹’è®©å¾·æ­£äº¤å¤šé¡¹å¼ä½œæœ€ä½³å¹³æ–¹é€¼è¿‘ï¼›åœ¨åŒºé—´ $[a, b]$ ä¸Šå‡åŒ€é‡‡é›† $n$ ä¸ªé‡‡é›†ç‚¹ï¼Œåˆ©ç”¨è¿™ $n+1$ ä¸ªé‡‡é›†ç‚¹ï¼Œè®¡ç®—é‡‡é›†ç‚¹ä¸Šçš„å‡½æ•°å€¼ï¼Œæ„é€ æœ€å°äºŒä¹˜æ‹Ÿåˆå¤šé¡¹å¼å‡½æ•°ã€‚ä¹‹åå†é€‰å– $m$ ä¸ªç‚¹ä½œä¸ºå®éªŒç‚¹ï¼Œè®¡ç®—åœ¨è¿™ $m$ ä¸ªå®éªŒç‚¹ä¸Šæ‰€æ„é€ çš„é€¼è¿‘å‡½æ•°ä¸ç»™å®šçš„ç›®æ ‡å‡½æ•° $f(x)$ çš„å¹³å‡è¯¯å·®ã€‚åŒæ—¶å¯¹æ¯”ä¸¤ç§é€¼è¿‘æ–¹æ³•ä¹‹é—´çš„ç²¾åº¦å·®å¼‚ã€‚\n<font color=red>è¾“å‡º</font>ï¼šå¯¹æ¯”å‡½æ•°æ›²çº¿ï¼Œå¹³å‡è¯¯å·®ã€‚\n```Python\nfrom sympy import *\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.rcParams['font.sans-serif']=['SimHei']\nplt.rcParams['axes.unicode_minus'] = False\ndef qpow(a,n):\n    ans=1\n    while n!=0:\n        if n&1:\n            ans*=a\n        a*=a\n        n>>=1\n    return ans\ndef F(x):\n    res = 1/(1+c*x*x)\n    return res\ndef cntpf():\n    t = symbols('t')\n    # (b-a)*t/2+(b+a)/2\n    fp[0] = integrate(1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2)),(t, -1, 1)).evalf()\n    fp[1] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (t),(t, -1, 1)).evalf()\n    fp[2] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (3 * t * t / 2 - 1 / 2),(t, -1, 1)).evalf()\n    fp[3] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (5 * t * t * t / 2 - 3 * t / 2),(t, -1, 1)).evalf()\ndef bsa(inp):\n    res=0\n    inp =(2 * inp -a - b) / (b - a)\n    for i in range(0,k):\n        res+=(2*i+1)*fp[i]*qpow(inp,i)/2\n    return res\ndef setup():\n    for i in range(0,100):\n        vispa[i]=0\n        vispb[i]=0\ndef initx():\n    d=(b-a)/n\n    x[0]=a\n    for i in range(1,n):\n        x[i]=x[i-1]+d\ndef compa(i):\n    if vispa[i]==1:\n        return  pa[i]\n    up=0\n    down=0\n    for j in range(0,n):\n        up+=comP(i-1,x[j])*comP(i-1,x[j])*x[j]\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispa[i] = 1\n    pa[i] = res\n    return res\ndef compb(i):\n    if vispb[i]==1:\n        return pb[i]\n    up = 0\n    down = 0\n    for j in range(0, n):\n        up += comP(i, x[j]) * comP(i, x[j])\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispb[i] = 1\n    pb[i] = res\n    return res\ndef comP(i,inp):\n    res=0\n    if i==0:\n        res=1\n    elif i==1:\n        res = (inp -compa(1))*comP(0, inp)\n    else:\n        res = (inp -compa(i))*comP(i - 1, inp)-compb(i - 1) * comP(i - 2, inp)\n\n    return res\ndef lsf(inp):\n    initx()\n    res=0\n    for i in range(0,k):\n        up=0\n        down=0\n        for j in range(0,n):\n            up += F(x[j]) * comP(i, x[j])\n            down += comP(i, x[j]) * comP(i, x[j])\n        res += comP(i, inp)*up / down\n    return res\ndef bsaerror(inp):\n    return abs(bsa(inp)-F(inp))\ndef lsferror(inp):\n    return abs(lsf(inp)-F(inp))\n\n#å…¨å±€å˜é‡\nx=[None]*200\nfp=[None]*50\nvispa=[0]*100\nvispb=[0]*100\npa=[None]*200\npb=[None]*200\n\n#ä¸»å‡½æ•°æ®µ\na, b, c = map(int, input(\"è¾“å…¥a,b,c: \").split())\nn , k = map(int, input(\"è¾“å…¥n,k: \").split())\nm=input(\"è¯·è¾“å…¥æµ‹è¯•ç»„æ•°ï¼š\")\ntst = input(\"è¯·è¾“å…¥æµ‹è¯•ç”¨ä¾‹ï¼š\").split()\n\nsetup() #åˆå§‹åŒ–fpæ•°ç»„\ncntpf() #åˆå§‹åŒ–fpæ•°ç»„\n\nbsax=range(int(a),int(b))\nbsay=[]\nbsae=0\nfor i in bsax:\n    bsay.append(bsa(i))\n    \nlsfx=range(int(a),int(b))\nlsfy=[]\nlsfe=0\nfor i in lsfx:\n    lsfy.append(lsf(i))\n    \nnx=range(int(a),int(b))\nny=[]\nfor i in nx:\n    ny.append(F(i))\n    \nfor i in tst:\n    bsae+=bsaerror(float(i))\n    lsfe+=lsferror(float(i))\nbsae/=float(m)\nlsfe/=float(m)\nprint('æœ€ä½³å¹³æ–¹é€¼è¿‘çš„å¹³å‡è¯¯å·®ä¸º%f'%bsae)\nprint('æœ€å°äºŒä¹˜æ‹Ÿåˆçš„å¹³å‡è¯¯å·®ä¸º%f'%lsfe)\nplt.plot(bsax, bsay, label='æœ€ä½³å¹³æ–¹é€¼è¿‘', color='red')\nplt.plot(lsfx, lsfy, label='æœ€å°äºŒä¹˜æ‹Ÿåˆ', color='blue')\nplt.plot(nx, ny, label='åŸå‡½æ•°', color='orange')\nplt.legend()\nplt.title('å‡½æ•°é€¼è¿‘å¯¹æ¯”å‡½æ•°')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n```\n\n## æ•°å€¼ç§¯åˆ†\n**å®ç°å¤åŒ–æ¢¯å½¢å…¬å¼å’Œé¾™è´æ ¼ç®—æ³•è®¡ç®—ç§¯åˆ†ï¼Œå¹¶å®Œæˆä¸¤ç§æ–¹æ³•ä¹‹é—´çš„ç²¾åº¦å¯¹æ¯”ã€‚**\n<font color=red>è¾“å…¥</font>ï¼šå‡½æ•°åŒºé—´ $[a, b]$ï¼Œè¢«ç§¯å‡½æ•°ä¸º $f(x) =\\sqrt{x}lnx$ï¼Œå‚æ•° $h$ ä½œä¸ºæ­¥é•¿ã€‚å‚æ•° $Îµ$ ä½œä¸ºè¦æ±‚æ»¡è¶³çš„ç²¾åº¦æ¡ä»¶ã€‚\n<font color=red>è¦æ±‚</font>ï¼šå–ä¸åŒçš„æ­¥é•¿ $h$ï¼Œè¦æ±‚ç”¨å¤åŒ–æ¢¯å½¢å…¬å¼å’Œé¾™è´æ ¼ç®—æ³•åˆ†åˆ«è®¡ç®—ç§¯åˆ†å€¼è®¡ç®—å½“ç²¾åº¦è¾¾åˆ° $Îµ$ æ—¶ï¼Œæ‰€éœ€è¦ç­‰åˆ†ç§¯åˆ†åŒºé—´çš„æ¬¡æ•°ï¼ˆå‡è®¾æ¯æ¬¡éƒ½æ˜¯äºŒç­‰åˆ†ï¼‰åŠ $h$ çš„å¤§å°ã€‚å½“è¾¾åˆ°ç²¾åº¦è¦æ±‚æ—¶ï¼Œå¯¹æ¯”ä¸¤ç§æ–¹æ³•éœ€è¦åˆ’åˆ†æ¬¡æ•°åŠæ­¥é•¿ $h$ çš„å¤§å°ã€‚\n<font color=red>è¾“å‡º</font>ï¼šæ•°å€¼ç§¯åˆ†è®¡ç®—ç»“æœï¼Œåˆ’åˆ†æ¬¡æ•°ï¼Œæ­¥é•¿ $h$ çš„å¤§å°ã€‚\n```Python\nimport math\n#åˆå§‹åŒ–å˜é‡\nvis = [[0 for i in range(1000)] for j in range(1000)]\nT = [[0 for i in range(1000)] for j in range(1000)]\n\ndef f(x):\n    res=math.sqrt(x)*math.log(x,math.e)\n    return res\n\ndef F(x):\n    x3=x*x*x\n    res=2*math.log(x,math.e)*math.sqrt(x3)/3-4*math.sqrt(x3)/9\n    return res\n\n#ä½¿ç”¨ç‰›é¡¿è±å¸ƒå°¼èŒ¨å…¬å¼ç›´æ¥ç§¯åˆ†\ndef Fitg(a,b):\n    res=F(b)-F(a)\n    return  res\n\n#ä½¿ç”¨å¤åˆæ¢¯å½¢æ±‚ç§¯å…¬å¼ç›´æ¥ç§¯åˆ†\ndef ctqf(n):\n    h=(b-a)/n\n    res=0\n    for k in range(n):\n        res+=f(a+k*h)+f(a+(k+1)*h)\n    res=res*h/2\n    return res\n\n#è®¡ç®—Tçš„å€¼\ndef cntT(m,k):\n    if(vis[m][k]==1):\n        return T[m][k]\n    else:\n        vis[m][k] == 1\n        if(m==0 and k==0):\n            T[m][k]=(b-a)*(f(a)+f(b))/2\n        elif(m==0):\n            n=1<<(k-1)\n            h=(b-a)/n\n            sm=0\n            for i in range(n):\n                sm+=f(a+(2*i+1)*h/2)\n            sm=sm*h/2\n            T[m][k]=cntT(m,k-1)/2+sm\n        else:\n            fourm=math.pow(4,m)\n            T[m][k]=fourm*cntT(m-1,k+1)/(fourm-1)-cntT(m-1,k)/(fourm-1)\n    return T[m][k]\n\n#ä½¿ç”¨é¾™è´æ ¼ç§¯åˆ†æ±‚ç§¯\ndef Romberg(m):\n    return cntT(m,0)\n\na,b =map(float,input(\"è¯·è¾“å…¥ç§¯åˆ†åŒºé—´a,b: \").split())\ne=float(input(\"è¯·è¾“å…¥ç²¾åº¦æ¡ä»¶e: \"))\n\nfor k in range(1000):\n    n=1<<k\n    eps=abs(ctqf(n)-Fitg(a,b))\n    if(eps<e):\n        h=(b-a)/n\n        print('å¤åˆæ¢¯å½¢æ±‚ç§¯å…¬å¼çš„è®¡ç®—ç»“æœä¸ºï¼š%f'%(ctqf(n)))\n        print('åˆ’åˆ†æ¬¡æ•°ä¸ºï¼š%d'%(k))\n        print('æ­¥é•¿ä¸ºï¼š%f' % (h))\n        break\n\nfor k in range(1,1000):\n    n=1<<k\n    eps=abs(Romberg(k)-Romberg(k-1))\n    if(eps<e):\n        h=(b-a)/n\n        print('é¾™è´æ ¼æ±‚ç§¯å…¬å¼çš„è®¡ç®—ç»“æœä¸ºï¼š%f'%(Romberg(k)))\n        print('åˆ’åˆ†æ¬¡æ•°ä¸ºï¼š%d'%(k))\n        print('æ­¥é•¿ä¸ºï¼š%f' % (h))\n        break\n```\n\n## çº¿æ€§æ–¹ç¨‹ç»„çš„ç›´æ¥è§£æ³•\n**1. ç¼–å†™åˆ—ä¸»å…ƒæ¶ˆå…ƒæ³•çš„é€šç”¨ç¨‹åºã€‚**\n<font color=red>è¾“å…¥</font>ï¼šçŸ©é˜µ $A$ å’Œå‘é‡ $b$ã€‚\n<font color=red>è¾“å‡º</font>ï¼šæ¶ˆå…ƒåçš„å¢å¹¿çŸ©é˜µåŠæ–¹ç¨‹ $Ax=b$ çš„æ ¹å€¼ $x^*$ã€‚\n<font color=red>è¦æ±‚1</font>ï¼šé€‰å–è¿›è¡Œæµ‹è¯•ï¼Œæ‰“å°å‡ºä¸Šè¿°ç¨‹åºçš„è¾“å‡ºã€‚\n<font color=red>è¦æ±‚2</font>ï¼šéšæœºç”Ÿæˆ $n$ é˜¶ï¼ˆ$n$>=20ï¼Œå…·ä½“å€¼è‡ªå®šï¼‰æ–¹é˜µ $A$ï¼Œ$n*1$ ç»´éé›¶å‘é‡ $b$ï¼Œæ±‚è§£ $x$ã€‚\n\n**2. ç¼–å†™ä½¿ç”¨LUåˆ†è§£æ³•æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„çš„é€šç”¨ç¨‹åºã€‚**\n<font color=red>è¾“å…¥</font>ï¼šçŸ©é˜µ $A$ å’Œå‘é‡ $b$ã€‚\n<font color=red>è¾“å‡º</font>ï¼šå¯¹çŸ©é˜µ $A$ è¿›è¡Œ $LU$ åˆ†è§£åçš„ $L$ å’Œ $U$ï¼Œä»¥åŠæ–¹ç¨‹ç»„çš„æ ¹å€¼ $x^*$ã€‚  \n<font color=red>è¦æ±‚1</font>ï¼šé€‰å–è¿›è¡Œæµ‹è¯•ï¼Œæ‰“å°è¾“å‡ºç»“æœã€‚\n<font color=red>è¦æ±‚2</font>ï¼šéšæœºç”Ÿæˆ $n$ é˜¶ï¼ˆ$n$>=20ï¼Œå…·ä½“å€¼è‡ªå®šï¼‰æ–¹é˜µ $A$ï¼Œ$n*1$ ç»´éé›¶å‘é‡ $b$ï¼Œæ±‚è§£ $x$ã€‚\n```C++\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include <random>\n\nusing namespace std;\nint n;\nconst int maxn=200;\ndouble inA[maxn][maxn];\ndouble A[maxn][maxn];\ndouble L[maxn][maxn];\ndouble U[maxn][maxn];\ndouble ans[maxn];\ndouble ansy[maxn];\nvoid Pivot();//åˆ—ä¸»å…ƒæ¶ˆå…ƒæ³•\nvoid copyA();//å°†è¾“å…¥çŸ©é˜µå¤åˆ¶ç»™A\nvoid printA();//æ‰“å°çŸ©é˜µA\nvoid printb();//æ‰“å°å‘é‡b\nvoid exc(int i,int j);//äº¤æ¢è¡Œ\nvoid Minus(int i,int j,double mult);//ç¬¬jè¡Œå‡ç¬¬iè¡Œ\nvoid printans();//æ‰“å°ç­”æ¡ˆ\nvoid LU();//LUåˆ†è§£æ³•\nvoid iscorrect();//å›ä»£åˆ¤æ–­ç­”æ¡ˆæ˜¯å¦æ­£ç¡®\ndouble gerandom(double a,double b);//ç”Ÿæˆaåˆ°bdoubleç±»å‹çš„éšæœºæ•°\nint main(){\n    int T;\n     cout<<\"please input T :\";\n     cin>>T;\n     while (T--)\n     {\n         cout << \"please input n :\";\n         cin >> n;\n         cout << \"enter 1 if you want to use your own input or 2 if you want your input to be random\"<<endl;\n         int cho;\n         cin>>cho;\n         if (cho == 1)\n         {\n             cout << \"please input matrix A :\" << endl;\n             for (int i = 1; i <= n; i++)\n             {\n                 for (int j = 1; j <= n; j++)\n                 {\n                     cin >> inA[i][j];\n                 }\n             }\n             cout << \"please input vector b :\" << endl;\n             for (int i = 1; i <= n; i++)\n             {\n                 cin >> inA[i][n + 1];\n             }\n         }\n         else{\n            double a,b;\n            cout << \"please input the range of the random number :\" << endl;\n            cin>>a>>b;\n            for (int i = 1; i <= n; i++)\n             {\n                 for (int j = 1; j <= n; j++)\n                 {\n                    inA[i][j]=gerandom(a,b);\n                 }\n             }\n             for (int i = 1; i <= n; i++)\n             {\n                inA[i][n + 1]=gerandom(a,b);\n             }\n         }\n         cout << \"enter 1-Pivot or 2-LU:\" << endl;\n         cin>>cho;\n         if(cho==1){\n            Pivot();\n         }\n         else{\n            LU();\n         }\n         printans();\n         iscorrect();\n     }\n    return 0;\n}\nvoid printA(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cout<<inA[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n}\nvoid copyA(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n+1;j++){\n            A[i][j]=inA[i][j];\n        }\n    }\n}\nvoid exc(int i,int j){\n    for(int k=1;k<=n+1;k++){\n        swap(A[i][k],A[j][k]);\n    }\n}\nvoid Minus(int i,int j,double mult){\n    for(int k=1;k<=n+1;k++){\n        A[j][k]-=A[i][k]*mult;\n    }\n}\nvoid printans(){\n    for(int i=1;i<=n;i++){\n        cout<<ans[i]<<\" \";\n    }\n    cout<<endl;\n}\nvoid Pivot(){\n    copyA();\n    for(int t=1;t<=n-1;t++){\n        double nman=0;\n        int maxi=0;\n        for(int i=t;i<=n;i++){\n            double tp=abs(A[i][t]);\n            if(tp>=nman){\n                maxi=i;\n                nman=tp;\n            }\n        }\n        exc(t,maxi);\n        for(int i=t+1;i<=n;i++){\n            double multi=A[i][t]/A[t][t];\n            Minus(t,i,multi);\n        }\n    }\n    for(int t=n;t>=1;t--){\n        double right=A[t][n+1];\n        for(int j=n;j>t;j--){\n            right-=A[t][j]*ans[j];\n        }\n        ans[t]=right/A[t][t];\n    }\n}\nvoid iscorrect(){\n    int tag=1;\n    for(int i=1;i<=n;i++){\n        double myans=0;\n        for(int j=1;j<=n;j++){\n            myans+=inA[i][j]*ans[j];\n        }\n        if(abs(myans-inA[i][n+1])>=1e-4){\n            tag=0;\n        }\n    }\n    if(tag){\n        cout<<\"answer is correct!\"<<endl;\n    }\n    else{\n        cout<<\"answer is wrong!\"<<endl;\n    }\n}\nvoid LU(){\n    copyA();\n    for(int i=1;i<=n;i++){\n        U[1][i]=A[1][i];\n        L[i][i]=1;\n    }\n    for(int i=2;i<=n;i++){\n        L[i][1]=A[i][1]/U[1][1];\n    }\n    for(int r=2;r<=n;r++){\n        for(int i=r;i<=n;i++){\n            double tplu=0;\n            for(int k=1;k<=r-1;k++){\n                tplu+=L[r][k]*U[k][i];\n            }\n            U[r][i]=A[r][i]-tplu;\n        }\n        if(r!=n){\n            for(int i=r+1;i<=n;i++){\n                double tplu=0;\n                for(int k=1;k<=r-1;k++){\n                    tplu+=L[i][k]*U[k][r];\n                }\n                L[i][r]=(A[i][r]-tplu)/U[r][r];\n            }\n        }\n    }\n    ansy[1]=A[1][n+1];\n    for(int i=2;i<=n;i++){\n        double tply=0;\n        for(int k=1;k<=i-1;k++){\n            tply+=L[i][k]*ansy[k];\n        }\n        ansy[i]=A[i][n+1]-tply;\n    }\n    ans[n]=ansy[n]/U[n][n];\n    for(int i=n-1;i>=1;i--){\n        double tpux=0;\n        for(int k=i+1;k<=n;k++){\n            tpux+=U[i][k]*ans[k];\n        }\n        ans[i]=(ansy[i]-tpux)/U[i][i];\n    }\n}\ndouble gerandom(double a,double b){\n    static random_device rd;\n    static mt19937 gen(rd());\n    uniform_real_distribution<double> dis(a, b);\n    return dis(gen);\n}\n```\n\n## çº¿æ€§æ–¹ç¨‹ç»„çš„è¿­ä»£è§£æ³•\n**1. ç¼–å†™é«˜æ–¯-å¡å¾·å°”è¿­ä»£å’ŒSORè¿­ä»£çš„é€šç”¨ç¨‹åºã€‚**\n<font color=red>è¾“å…¥</font>ï¼šçŸ©é˜µAå’Œå‘é‡bï¼Œè¿­ä»£åˆå€¼x0ï¼Œè¿­ä»£æœ€å¤§æ­¥æ•°Kï¼Œè¯¯å·®æ§åˆ¶ã€‚å¯¹äºè¶…æ¾å¼›è¿­ä»£ï¼Œè¿˜éœ€è¾“å…¥æ¾å¼›å› å­ã€‚\n<font color=red>è¾“å‡º</font>ï¼šè¿­ä»£æ­¥æ•°åŠæ–¹ç¨‹ $Ax=b$ çš„æ ¹å€¼ $x^*$ã€‚\n<font color=red>è¦æ±‚</font>ï¼š\n(1)é€‰å–è¿›è¡Œæµ‹è¯•ï¼Œå–åˆå€¼x<sup>(0)</sup>=0ï¼Œè¯¯å·®æ§åˆ¶=10<sup>-8</sup>ï¼Œæ‰“å°å‡ºä¸¤ç§è¿­ä»£æ–¹æ³•çš„è¾“å‡ºã€‚\n(2)å–æ¾å¼›å› å­ $=\\frac{i}{50}$ï¼Œ$i$=1,2,...99,æ‰“å°è¿­ä»£æ­¥æ•°ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªæœ€ä½³å€¼ã€‚\n```C++\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int maxn = 1000;\ndouble a[maxn][maxn];\ndouble b[maxn];\ndouble xk[maxn];\ndouble xk1[maxn];\nint n;\nint K;\ndouble w;\ndouble eps;\ndouble mf;\ndouble nstep;\nvoid setxk0();//åˆå§‹åŒ–xk0\nvoid movk();//å°†xk1èµ‹å€¼ç»™xk\ndouble cntloss();//è®¡ç®—detx\nvoid SOR(double w);//è¶…æ¾å¼›è¿­ä»£æ³•\nvoid printx();//æ‰“å°x\nvoid iscorrect();//å›ä»£éªŒè¯ç­”æ¡ˆæ˜¯å¦æ­£ç¡®\nint main(){\n    cout<<\"input max step K : \";\n    cin>>K;\n    cout<<\"input eps  : \";\n    cin>>eps;\n    cout<<\"input the size of A  : \";\n    cin>>n;\n    cout<<\"matrix A :\"<<endl;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>a[i][j];\n        }\n    }\n    cout<<\"vector b :\"<<endl;\n    for(int i=1;i<=n;i++){\n        cin>>b[i];\n    }\n    cout<<\"enter 1 if you want to test one w\"<<endl;\n    cout<<\"or 2 if you want to find the best w\"<<endl;\n    cout<<\"enter : \";\n    cin>>mf;\n    if(mf==1){\n        cout<<\"input Relaxation factor w  : \";\n        cin>>w;\n        SOR(w);\n        printx();\n        iscorrect();\n    }\n    else{\n        int bst=K+1;\n        double bsw=0;\n        for(int i=1;i<=99;i++){\n            double ii = (double)i;\n            double nw=ii/(double)50;\n            cout<<\"now i is \"<<i<<endl;\n            SOR(nw);\n            if(nstep<bst){\n                bst = nstep;\n                bsw=nw;\n            }\n        }\n        cout<<\"the best w is \"<<bsw<<endl;\n    }\n    \n    return 0;\n}\nvoid setxk0(){\n    for(int i=1;i<=n;i++){\n        xk[i]=0;\n    }\n}\nvoid movk(){\n    for(int i=1;i<=n;i++){\n        xk[i]=xk1[i];\n    }\n}\ndouble cntloss(){\n    double res = 0;\n    for(int i=1;i<=n;i++){\n        double tp = abs(xk1[i]-xk[i]);\n        if(tp>res){\n            res = tp;\n        }\n    }\n    return res;\n}\nvoid printx(){\n    for(int i=1;i<=n;i++){\n        cout<<xk1[i]<<\" \";\n    }\n    cout<<endl;\n}\nvoid iscorrect(){\n    int flag = 1;\n    for(int i=1;i<=n;i++){\n        double s=0;\n        for(int j=1;j<=n;j++){\n            s+=a[i][j]*xk1[j];\n        }\n        if(abs(s-b[i])>1e-3){\n            flag=0;\n        }\n    }\n    if(flag){\n        cout<<\"answer is correct!\"<<endl;\n    }\n    else{\n        cout<<\"answer is wrong!\"<<endl;\n    }\n}\nvoid SOR(double w){\n    setxk0();\n    for(int step=1;step<=K;step++){\n        for(int i=1;i<=n;i++){\n            double s1 = 0;\n            double s2 = 0;\n            for(int j=1;j<=i-1;j++){\n                s1+=a[i][j]*xk1[j];\n            }\n            for(int j=i;j<=n;j++){\n                s2+=a[i][j]*xk[j];\n            }\n            xk1[i]=xk[i]+w*(b[i]-s1-s2)/a[i][i];\n        }\n        if(cntloss()<eps){\n            if(mf==2){\n                nstep = step;\n                cout<<\"the step is \"<<step<<endl;\n            }\n            break;\n        }\n        else{\n            movk();\n        }\n    }\n}\n```\n\n## éçº¿æ€§æ–¹ç¨‹ï¼ˆç»„ï¼‰çš„æ•°å€¼è§£æ³•\n**1. ç¼–å†™ä¸åŠ¨ç‚¹è¿­ä»£ã€æ–¯ç‰¹èŠ¬æ£®åŠ é€Ÿè¿­ä»£å’Œç‰›é¡¿è¿­ä»£çš„é€šç”¨ç¨‹åºã€‚**\n<font color=red>è¦æ±‚</font>ï¼š\n(1)è®¾è®¡ä¸€ç§ä¸åŠ¨ç‚¹è¿­ä»£æ ¼å¼ï¼Œæ±‚è§£å‡½æ•° $f(x)=x^2-3x+2-e^x$ å’Œ $g(x)=x^3+2x^2+10x-20$ çš„æ ¹ï¼Œè¦æ±‚è¯¥è¿­ä»£æ ¼å¼æ”¶æ•›ã€‚ç„¶åå†ä½¿ç”¨æ–¯ç‰¹èŠ¬æ£®åŠ é€Ÿè¿­ä»£ï¼Œè®¡ç®—åˆ° |x<sub>k</sub>-x<sub>k-1</sub>|<10<sup>-8</sup> ä¸ºæ­¢ã€‚\n(2)ç”¨ç‰›é¡¿è¿­ä»£ï¼ŒåŒæ ·è®¡ç®—åˆ° |x<sub>k</sub>-x<sub>k-1</sub>|<10<sup>-8</sup> ã€‚è¾“å‡ºè¿­ä»£åˆå€¼ã€è¿­ä»£æ¬¡æ•°åŠå„æ¬¡è¿­ä»£å€¼ï¼Œæ¯”è¾ƒæ–¹æ³•ä¼˜åŠ£ã€‚\n```Python\n\n```\n**2. æœ¬ç« è®¡ç®—å®ä¹ é¢˜3ã€‚**\n```Python\n\n```","tags":["æ•°å€¼è®¡ç®—æ–¹æ³•","å®éªŒè®°å½•","Python"]},{"title":"å›¾è®ºç®—æ³•åšé¢˜æ€»ç»“","url":"/2024/10/07/å›¾è®ºç®—æ³•åšé¢˜æ€»ç»“/"},{"title":"å•è°ƒæ ˆåšé¢˜æ€»ç»“","url":"/2024/10/06/å•è°ƒæ ˆåšé¢˜æ€»ç»“/","content":"# åŸºç¡€\n## æ¯æ—¥æ¸©åº¦\n```C++\n/***** æ‰¾åé¢ç¬¬ä¸€ä¸ªå¤§ *****/\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n=temperatures.size();\n        vector<int> ans(n);\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&temperatures[s.top()]<temperatures[i]){ //æ ˆä¸­ç»´æŠ¤ä¸‹æ ‡å†™æ³•\n                ans[s.top()]=i-s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        return ans;\n    }\n};\n```\n## å•†å“æŠ˜æ‰£åçš„æœ€ç»ˆä»·æ ¼\n```C++\n/***** æ‰¾åé¢ç¬¬ä¸€ä¸ªå°äºç­‰äº *****/\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n=prices.size();\n        vector<int> ans(n);\n \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&prices[s.top()]>=prices[i]){\n                ans[s.top()]=prices[s.top()]-prices[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n        \n        while(!s.empty()){\n            ans[s.top()]=prices[s.top()];\n            s.pop();\n        }\n        return ans;\n    }\n};\n```\n## ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I\n```C++\n/***** æ‰¾åé¢ç¬¬ä¸€ä¸ªå¤§ *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        unordered_map<int,int> hashmap;\n        \n        //å¤„ç†nums2\n        stack<int> s;\n        for(int i=0;i<nums2.size();i++){\n            while(!s.empty()&&nums2[s.top()]<nums2[i]){\n                int temp=nums2[s.top()];\n                hashmap[temp]=nums2[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        for(int i=0;i<nums1.size();i++){\n            int temp=nums1[i];\n            if(hashmap[temp]) ans[i]=hashmap[temp];\n            else ans[i]=-1;\n        }\n        return ans;\n    }\n};\n```\n## ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II\n```C++\n/***** å¾ªç¯æ‰¾åé¢ç¬¬ä¸€ä¸ªå¤§ *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> ans(n,-1);\n \n        stack<int> s;\n        for(int i=0;i<2*n-1;i++){\n            while(!s.empty()&&nums[s.top()]<nums[i%n]){\n                ans[s.top()]=nums[i%n];\n                s.pop();\n            }\n            s.push(i%n);\n        }\n        \n        return ans;\n    }\n};\n```\n## æœ€å¤§å®½åº¦å¡\n```C++\n/*å•è°ƒé€’å‡æ ˆ*/\nclass Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        stack<int> s;\n        int n = nums.size();\n        for (int i = 0;i < n;i++) {\n            if (s.empty() || nums[s.top()] > nums[i]) {//è¦æŠŠç¬¬ä¸€ä¸ªæ•°æ®push\n                s.push(i);\n            }\n        }\n        int ans = 0;\n        for (int i = n - 1;i >= 0;i--) {\n            while (!s.empty() && nums[s.top()]<=nums[i]) {\n                ans = max(ans,i - s.top());\n                s.pop();\n            }\n        }\n        return ans;\n    }\n};\n```\n## è½¦é˜Ÿ\n```C++\n/***** æ’åº+å•è°ƒæ ˆ *****/\n/***** æ ¹æ®ä½ç½®ç”±å°åˆ°å¤§æ’åºï¼Œä½ç½®å¤§çš„å·¦ä¾§ï¼ˆä½ç½®å°ï¼‰çš„æ—¶é—´ä¸åº”æ›´å°ç­‰->ï¼ˆä¸¥æ ¼ï¼‰å•è°ƒé€’å‡æ ˆ *****/\nclass Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        map<int,int> ps; //è‡ªåŠ¨æ’åº\n        for(int i=0;i<position.size();i++){\n            ps[position[i]]=speed[i];\n        }\n\n        stack<double> s;\n        for(auto& [pos,spd]:ps){\n            double time=double(target-pos)/spd;\n            while(!s.empty()&&s.top()<=time){\n                s.pop();\n            }\n            s.push(time);\n        }\n        return s.size();\n    }\n};\n```\n# çŸ©å½¢é¢ç§¯ï¼ˆå®Œç»“ï¼‰\n## æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢\n```C++\n/***** å•è°ƒæ ˆçš„å…¶ä¸­ä¸€ç§å†™æ³•---å¤„ç†æ ˆä¸­å…ƒç´  *****/\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> left(n,-1), right(n,n); //å·¦è¾¹ç¬¬ä¸€ä¸ªå°çš„ä½ç½®ã€å³è¾¹ç¬¬ä¸€ä¸ªå°çš„ä½ç½®\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){ //å¤„ç†å³è¾¹\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tright[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n \n        s = stack<int> (); //æ¸…ç©ºæ ˆ\n        for(int i=n-1;i>=0;i--){ //å¤„ç†å·¦è¾¹\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tleft[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);\n        }\n        return ans;\n    }\n};\n```\n## å¥½å­æ•°ç»„çš„æœ€å¤§åˆ†æ•°\n```C++\n/***** å•è°ƒæ ˆçš„å¦ä¸€ç§å†™æ³•---å¤„ç†å½“å‰å…ƒç´  *****/\nclass Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> left(n,-1),right(n,n); //å·¦è¾¹ç¬¬ä¸€å°çš„ç¼–å·ã€å³è¾¹ç¬¬ä¸€å°çš„ç¼–å·\n \n        stack<int> s;\n        for(int i=0;i<n;i++){ //å¤„ç†å·¦è¾¹\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) left[i]=s.top();\n            s.push(i);\n        }\n \n        s=stack<int> ();\n        for(int i=n-1;i>=0;i--){ //å¤„ç†å³è¾¹\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) right[i]=s.top();\n            s.push(i);\n        }\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            int h=nums[i],l=left[i],r=right[i];\n            if(l<k&&r>k){ //å¤šäº†ä¸€ä¸ªåŒºé—´åˆ¤æ–­\n                ans=max(ans,h*(r-l-1));\n            }\n        }\n        return ans;\n    }   \n};\n```\n## æœ€å¤§çŸ©å½¢\n```C++\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int n=matrix.size(); //è¡Œæ•°\n        int m=matrix[0].size(); //åˆ—æ•°\n        vector<vector<int>> left(n,vector<int>(m,0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(matrix[i][j]=='1'){\n                    left[i][j]=(j==0?1:left[i][j-1]+1); //å¾€å·¦èƒ½å¤Ÿå»¶ç”³çš„æœ€å¤§é•¿åº¦\n                }\n            }\n        }\n        int ret=0;\n \n        //å¯¹äºæ¯ä¸€åˆ—ï¼Œä½¿ç”¨åŸºäºæŸ±çŠ¶å›¾æ±‚æœ€å¤§çŸ©å½¢çš„æ–¹æ³•\n        for(int j=0;j<m;j++){\n            vector<int> up(n,0),down(n,0);\n \n            stack<int> s;\n            for(int i=0;i<n;i++){ \n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                up[i]=s.empty()?-1:s.top(); //ä¸Šè¾¹ç¬¬ä¸€ä¸ªå°äºçš„ç¼–å·\n                s.push(i);\n            }\n            s=stack<int>();//æ¸…ç©ºæ ˆ\n            for(int i=n-1;i>=0;i--){\n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                down[i]=s.empty()?n:s.top(); //ä¸‹è¾¹ç¬¬ä¸€ä¸ªå°äºçš„ç¼–å·\n                s.push(i);\n            }\n            \n            for(int i=0;i<n;i++){\n                int width=down[i]-up[i]-1;\n                int area=width*left[i][j];\n                ret=max(ret,area);\n            }\n        }\n \n        return ret;\n    }\n};\n```\n## ç»Ÿè®¡å…¨ 1 å­çŸ©å½¢\n```C++\nclass Solution {\npublic:\n    int numSubmat(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<int> height(m);\n \n        /*å•è°ƒæ ˆæ±‚å·¦å³æ›´å°å€¼(åŒæ—¶å¤„ç†)*/\n        auto calc=[&]()->int{\n            vector<int> left(m,-1),right(m,m);\n \n            stack<int> s;\n            for(int i=0;i<m;i++){\n                while(!s.empty()&&height[s.top()]>height[i]){\n                    right[s.top()]=i;\n                    s.pop();\n                }\n                if(!s.empty()){\n                    left[i]=s.top();\n                }\n                s.push(i);\n            }\n \n            int ans=0;\n            /* è®¡ç®—ç»“æœæ—¶, ä¹˜æ³•åŸç† * çŸ©é˜µé«˜åº¦ */\n            for(int i=0;i<m;i++){\n                ans+=(right[i]-i)*(i-left[i])*height[i];\n            }\n            return ans;\n        };\n \n        int ans=0;\n        for(int i=0;i<n;i++){ /* éå†æ¯ä¸€è¡Œçš„é«˜åº¦, æ›´æ–°æ”¹è¡Œçš„é«˜åº¦å€¼ä½¿ç”¨å•è°ƒæ ˆè®¡ç®—å·¦ä¾§æ›´å°å€¼å’Œå³ä¾§æ›´å°å€¼,å†è®¡ç®—æ¯ä¸ªå°çŸ©é˜µå‡ºç°çš„æ¬¡æ•°*/\n            for(int j=0;j<m;j++){\n                if(mat[i][j]==0){\n                    height[j]=0;\n                }\n                else{\n                    height[j]++;\n                }\n            }\n            ans+=calc();\n        }\n        return ans;\n    }\n};\n```\n## æ¥é›¨æ°´\n```C++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans=0;\n        int n=height.size();\n\n        stack<int> s;\n        for (int i=0;i<n;i++) {\n            while (!s.empty() && height[s.top()]<height[i]) {\n                int top = s.top();\n                s.pop();\n                if (s.empty()) {\n                    break;\n                }\n                int left = s.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            s.push(i);\n        }\n        \n        return ans;\n    }\n};\n/***** ä¸èƒ½å•çº¯æ‰¾å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§ã€å³è¾¹ç¬¬ä¸€ä¸ªå¤§ *****/\n/*è¿™ç§æƒ…å†µä¼šå¤šç®—\n*   *\n** **\n** **\n*****\n*/\n```\n# æœ€å°å­—å…¸åº\n## ç§»æ‰ K ä½æ•°å­—\n","tags":["ç¼–ç¨‹","å•è°ƒæ ˆ","c++"]},{"title":"åŠ¨æ€è§„åˆ’åšé¢˜æ€»ç»“","url":"/2024/10/02/åŠ¨æ€è§„åˆ’åšé¢˜æ€»ç»“/","content":"# å…¥é—¨ DP\n## çˆ¬æ¥¼æ¢¯\n### çˆ¬æ¥¼æ¢¯\n```C\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> f(n+1);     \n        f[0]=1,f[1]=1;\n        for(int i=2;i<=n;i++){\n            f[i]=f[i-1]+f[i-2];\n        }\n        return f[n];\n    }\n};\n/*ç”±äºè¿™é‡Œçš„ f(x) åªå’Œ f(xâˆ’1) ä¸ f(xâˆ’2) æœ‰å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ã€Œæ»šåŠ¨æ•°ç»„æ€æƒ³ã€æŠŠç©ºé—´å¤æ‚åº¦ä¼˜åŒ–æˆ O(1)*/\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; i++) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n```\n### ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯\n```C\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n + 1);\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[n];\n    }\n};\n```\n### ç»„åˆæ€»å’Œ â…£\n```C\n/*æœ¬è´¨æ˜¯çˆ¬æ¥¼æ¢¯ï¼Œç›¸å½“äºæ¯æ¬¡å¾€ä¸Šçˆ¬ nums[i] æ­¥*/\nclass Solution {\npublic:\n    long long combinationSum4(vector<int>& nums, int target) {\n        vector<long long> dp(target + 1);\n        dp[0] = 1; //åªæœ‰å½“ä¸é€‰å–ä»»ä½•å…ƒç´ æ—¶ï¼Œå…ƒç´ ä¹‹å’Œæ‰ä¸º 0ï¼Œå› æ­¤åªæœ‰ 1 ç§æ–¹æ¡ˆã€‚\n        for (int i = 1; i <= target; i++) {\n            for (int& num : nums) {\n                if (num <= i&& dp[i - num] < INT_MAX - dp[i]) {\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n        return dp[target];\n    }\n};\n/*å¦ä¸€ç§å†™æ³•*/\nclass Solution {\npublic:\n    int combinationSum4(vector<int> &nums, int target) {\n        // ä½¿ç”¨ unsigned å¯ä»¥è®©æº¢å‡ºä¸æŠ¥é”™\n        // å¯¹äºæº¢å‡ºçš„æ•°æ®ï¼Œä¸ä¼šå½±å“ç­”æ¡ˆçš„æ­£ç¡®æ€§ï¼ˆé¢˜ç›®ä¿è¯ï¼‰\n        vector<unsigned> f(target + 1);\n        f[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int x : nums) {\n                if (x <= i) {\n                    f[i] += f[i - x];\n                }\n            }\n        }\n        return f[target];\n    }\n};\n```\n### ç»Ÿè®¡æ„é€ å¥½å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•°\n```C\nclass Solution {\npublic:\n    int countGoodStrings(int low, int high, int zero, int one) {\n        const int MOD = 1'000'000'007;\n        int ans = 0;\n        vector<int> f(high + 1); // f[i] è¡¨ç¤ºæ„é€ é•¿ä¸º i çš„å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•°\n        f[0] = 1; // æ„é€ ç©ºä¸²çš„æ–¹æ¡ˆæ•°ä¸º 1\n        for (int i = 1; i <= high; i++) {\n            if (i >= zero) f[i] = f[i - zero];\n            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;\n            if (i >= low)  ans = (ans + f[i]) % MOD;\n        }\n        return ans;\n    }\n};\n```\n### ç»Ÿè®¡æ‰“å­—æ–¹æ¡ˆæ•°\n```C\nclass Solution {\npublic:\n    int countTexts(string pressedKeys) {\n        int m = 1000000007;\n        vector<long long> dp3 = {1, 1, 2, 4};   // è¿ç»­æŒ‰å¤šæ¬¡ 3 ä¸ªå­—æ¯æŒ‰é”®å¯¹åº”çš„æ–¹æ¡ˆæ•°\n        vector<long long> dp4 = {1, 1, 2, 4};   // è¿ç»­æŒ‰å¤šæ¬¡ 4 ä¸ªå­—æ¯æŒ‰é”®å¯¹åº”çš„æ–¹æ¡ˆæ•°\n        int n = pressedKeys.size();\n        for (int i = 4; i < n + 1; ++i) {\n            dp3.push_back((dp3[i-1] + dp3[i-2] + dp3[i-3]) % m);\n            dp4.push_back((dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % m);\n        }\n        long long res = 1;   // æ€»æ–¹æ¡ˆæ•°\n        int cnt = 1;   // å½“å‰å­—ç¬¦è¿ç»­å‡ºç°çš„æ¬¡æ•°\n        for (int i = 1; i < n; ++i) {\n            if (pressedKeys[i] == pressedKeys[i-1]) {\n                ++cnt;\n            } else {\n                // å¯¹æŒ‰é”®å¯¹åº”å­—ç¬¦æ•°é‡è®¨è®ºå¹¶æ›´æ–°æ€»æ–¹æ¡ˆæ•°\n                if (pressedKeys[i-1] == '7' || pressedKeys[i-1] == '9') {\n                    res *= dp4[cnt];\n                } else {\n                    res *= dp3[cnt];\n                }\n                res %= m;\n                cnt = 1;\n            }\n        }\n        // æ›´æ–°æœ€åä¸€æ®µè¿ç»­å­—ç¬¦å­ä¸²å¯¹åº”çš„æ–¹æ¡ˆæ•°\n        if (pressedKeys[n-1] == '7' || pressedKeys[n-1] == '9') {\n            res *= dp4[cnt];\n        } else {\n            res *= dp3[cnt];\n        }\n        res %= m;\n        return res;\n    }\n};\n```\n## æ‰“å®¶åŠ«èˆ\n### æ‰“å®¶åŠ«èˆ\n```C\n/*é¢˜æ„è½¬åŒ–ä¸ºï¼šä»åºåˆ—ä¸­é€‰æ‹©å­åºåˆ—ä½¿å¾—å®ƒä»¬çš„å’Œæœ€å¤§ï¼Œæ•°ä¸èƒ½æœ‰ç›¸é‚»*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        vector<int> dp(n,0); //ç”¨ dp[i] è¡¨ç¤ºå‰ i é—´æˆ¿å±‹èƒ½å·çªƒåˆ°çš„æœ€é«˜æ€»é‡‘é¢\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n        }  \n        return dp[n-1];\n    }\n};\n/*ä¸Šè¿°æ–¹æ³•ä½¿ç”¨äº†æ•°ç»„å­˜å‚¨ç»“æœã€‚è€ƒè™‘åˆ°æ¯é—´æˆ¿å±‹çš„æœ€é«˜æ€»é‡‘é¢åªå’Œè¯¥æˆ¿å±‹çš„å‰ä¸¤é—´æˆ¿å±‹çš„æœ€é«˜æ€»é‡‘é¢ç›¸å…³ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ï¼Œåœ¨æ¯ä¸ªæ—¶åˆ»åªéœ€è¦å­˜å‚¨å‰ä¸¤é—´æˆ¿å±‹çš„æœ€é«˜æ€»é‡‘é¢ã€‚*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\n};\n```\n### åˆ é™¤å¹¶è·å¾—ç‚¹æ•°\n```C\nclass Solution {\nprivate:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxval=0;\n        for(int val:nums){\n            maxval=max(maxval,val);\n        }\n        vector<int>sum(maxval+1,0);\n        for(int val:nums){\n            sum[val]+=val;\n        }\n        return rob(sum);\n    }\n};\n```\n### ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•°\n```C\n/*å•ç‹¬è€ƒè™‘ä¸€ä¾§çš„æˆ¿å­ï¼Œå®šä¹‰ f[i] è¡¨ç¤ºå‰ i ä¸ªåœ°å—çš„æ”¾ç½®æ–¹æ¡ˆæ•°ï¼Œå…¶ä¸­ç¬¬ i ä¸ªåœ°å—å¯ä»¥æ”¾æˆ¿å­ï¼Œä¹Ÿå¯ä»¥ä¸æ”¾æˆ¿å­ã€‚*/\nconst int mod=1e9+7;\nclass Solution {\npublic:\n    int countHousePlacements(int n) {\n        vector<long long> f(n+1,0);\n        f[0]=1;\n        f[1]=2;\n        for(int i=2;i<=n;i++){\n            f[i]=(f[i-1]+f[i-2])%mod;\n        }\n        return f[n]*f[n]%mod;\n    }\n};\n```\n### æ‰“å®¶åŠ«èˆ II\n```C\n/*ç¬¬ä¸€é—´æˆ¿å±‹å’Œæœ€åä¸€é—´æˆ¿å±‹ä¸åŒæ—¶å·çªƒ*/\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        int first = nums[start], second = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n\n    int rob(vector<int>& nums) {\n        int length = nums.size();\n        if (length == 1) {\n            return nums[0];\n        } \n        else if (length == 2) {\n            return max(nums[0], nums[1]);\n        }\n        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n};\n```\n### æ–½å’’çš„æœ€å¤§æ€»ä¼¤å®³\n## æœ€å¤§å­æ•°ç»„å’Œ\n>*å®šä¹‰çŠ¶æ€ f[i] è¡¨ç¤ºä»¥ a[i] ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œï¼Œä¸å’Œ i å·¦è¾¹æ‹¼èµ·æ¥å°±æ˜¯f[i]=a[i]ï¼Œå’Œ i å·¦è¾¹æ‹¼èµ·æ¥å°±æ˜¯f[i]=f[iâˆ’1]+a[i]ï¼Œå–æœ€å¤§å€¼å°±å¾—åˆ°äº†çŠ¶æ€è½¬ç§»æ–¹ç¨‹ f[i]=max(f[iâˆ’1],0)+a[i]ï¼Œç­”æ¡ˆä¸º max(f)ã€‚è¿™ä¸ªåšæ³•ä¹Ÿå«åš Kadane ç®—æ³•ã€‚*\n### æœ€å¤§å­æ•°ç»„å’Œ\n```C\n/*æ¨¡æ¿é¢˜*/\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n        }\n        return ranges::max(dp);\n    }\n};\n```\n### æ‰¾åˆ°æœ€å¤§å¼€é”€çš„å­å­—ç¬¦ä¸²\n```C\n/*ä¸€ç‚¹è½¬åŒ–+æ¨¡æ¿é¢˜*/\nclass Solution {\npublic:\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\n        vector<int> m(26+1);\n        iota(m.begin(),m.end(),0);\n        for(int i=0;i<chars.size();i++){\n            m[chars[i]-'a'+1]=vals[i];\n        }\n \n        vector<int> dp(s.size());\n        dp[0]=m[s[0]-'a'+1];\n        int ans=max(0,dp[0]);\n        for(int i=1;i<s.size();i++){\n            dp[i]=max(dp[i-1],0)+m[s[i]-'a'+1];\n            ans=max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n```\n### ä»»æ„å­æ•°ç»„å’Œçš„ç»å¯¹å€¼çš„æœ€å¤§å€¼\n```C\n/*é¢˜ç›®è½¬åŒ–ä¸ºmax(æœ€å¤§å­æ•°ç»„å’Œï¼Œ-æœ€å°å­æ•°ç»„å’Œï¼Œ0)*/\nclass Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        int ans1=dp[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n            ans1=max(ans1,dp[i]);\n        }\n \n        vector<int> dp1(nums.size());\n        dp1[0]=nums[0];\n        int ans2=dp1[0];\n        for(int i=1;i<nums.size();i++){\n            dp1[i]=min(dp1[i-1],0)+nums[i];\n            ans2=min(ans2,dp1[i]);\n        }\n        int ans=max(0,ans1);\n        ans=max(ans,-ans2);\n        return ans;\n    }\n};\n```\n### K æ¬¡ä¸²è”åæœ€å¤§å­æ•°ç»„ä¹‹å’Œ\n```C\n/*\nè€ƒè™‘ä¸¤ç§æƒ…å†µï¼š\n\n1.å¦‚æœk=1ï¼Œé‚£å°±æ˜¯æ­£å¸¸DPã€‚\n\n2.k>1æ—¶ä¹Ÿè€ƒè™‘ä¸¤ç§æƒ…å†µï¼šæ•°ç»„æ‰€æœ‰å…ƒç´ å’Œå¤§äº0ï¼Œæ•°ç»„æ‰€æœ‰å…ƒç´ å’Œå°äºç­‰äº0ã€‚\né¦–å…ˆè®¡ç®—ä¸¤ä¸ªç›¸æ¥çš„DPä¹Ÿå°±æ˜¯k=2çš„æƒ…å†µï¼Œå¦‚æœæ•°ç»„å…ƒç´ å’Œå¤§äº0ï¼Œé‚£å¯ä»¥çœ‹æˆå†ç¬¬ä¸€æ®µç»“å°¾ç¬¬äºŒæ®µå¼€å¤´æ’å…¥k-2ä¸ªæ­£æ•°ï¼Œå¦‚æœæ•°ç»„æ‰€æœ‰å…ƒç´ å’Œä¸ºè´Ÿï¼Œé‚£k=2çš„æƒ…å†µå°±æ˜¯æœ€å¤§çš„æƒ…å†µã€‚\n*/\nclass Solution {\npublic:\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        const int mod=1e9+7;\n        int n=arr.size();\n        long long sum=0,presum=0,result=0;\n        for(int i=0;i<n*(k>1?2:1);i++){\n            long long num=arr[i%n];\n            presum=max(presum,0ll)+num;\n            result=max(result,presum);\n            if(i<n) sum+=num;\n        }\n        if(sum>0&&k>1){\n            result=(result+sum*(k-2)%mod)%mod;\n        }\n        return result;\n    }\n};\n/*\n1.sum>0ã€k=2æ—¶ï¼Œæœ€å¤§å­æ•°ç»„å’Œå¦‚æœæ²¡æœ‰è·¨è¿‡ä¸¤ä¸ªæ•°ç»„ï¼Œé‚£å²‚ä¸æ˜¯ä¸èƒ½åœ¨ä¸­é—´æ’å…¥k-2ä¸ªsumå—ï¼Ÿ\nåè¯æ³•ï¼Œåè®¾sum>0æ—¶ï¼Œå¦‚æœæœ€å¤§å­æ•°ç»„å’Œæ²¡æœ‰è·¨è¿‡ä¸¤ä¸ªæ•°ç»„ã€‚ä»Låˆ°Rçš„å­æ•°ç»„çš„å’Œæœ€å¤§ï¼ˆ0<=L<=R<n-1ï¼‰ï¼Œè€ƒè™‘Rå‘å³nä¸ªæ•°(R+1åˆ°R+n)ï¼Œè¿™nä¸ªæ•°ä¸€å®šæ˜¯å’Œarrçš„æ•°æ˜¯ä¸€æ ·çš„ï¼ˆå¾ªç¯äº†ï¼‰ï¼Œé‚£ä¹ˆè¿™nä¸ªæ•°çš„å’Œæ˜¯sumï¼Œå¤§äº0ã€‚æ‰€ä»¥ä»Låˆ°R+nçš„å­æ•°ç»„çš„å’Œè¦æ›´å¤§ï¼Œè€Œè¿™ä¸ªå­æ•°ç»„è·¨è¿‡äº†ä¸¤ä¸ªæ•°ç»„ï¼Œä¸åè®¾çŸ›ç›¾ã€‚æ‰€ä»¥è¿™æ ·åšæ˜¯å¯¹çš„ã€‚\n2.sum<=0æ—¶ï¼Œä¸ºä»€ä¹ˆå¯ä»¥åŒ–å½’åˆ°k=2çš„æƒ…å†µï¼Ÿ\nè¿˜æ˜¯åè¯æ³•ï¼Œå‡è®¾æœ€å¤§å­æ•°ç»„çš„é•¿åº¦>2nï¼Œé‚£ä¸€å®šåŒ…æ‹¬ä¸€ä¸ªå®Œæ•´çš„arræ•°ç»„ï¼Œé‚£ä¹ˆå› ä¸ºsum<=0ï¼Œæ‰€ä»¥æ‹¿æ‰è¿™ä¸€éƒ¨åˆ†ï¼ŒæŠŠå‰åæ‹¼æ¥åœ¨ä¸€èµ·ï¼ˆè¿™æ ·åšæ˜¾ç„¶æ˜¯åˆæ³•çš„ï¼‰ï¼Œè¿™æ ·åšç»“æœåªä¼šæ›´ä¼˜ï¼Œå¦‚æ­¤æ“ä½œä¸‹å»ï¼Œå°±å¯ä»¥åˆ’å½’åˆ°k=2çš„æƒ…å†µäº†ã€‚\n*/\n```\n### ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ\n```C\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> qianmax(n); //å‰ç¼€æœ€å¤§å€¼\n        int presum=nums[0];\n        qianmax[0]=nums[0];\n\n        int pre=nums[0];\n        int ans=pre;\n\n        for(int i=1;i<n;i++){\n            pre=max(pre,0)+nums[i];\n            ans=max(ans,pre);\n\n            presum+=nums[i];\n            qianmax[i]=max(qianmax[i-1],presum);\n        }\n\n        int housum=0;\n        for(int i=n-1;i>0;i--){ //æšä¸¾åç¼€å’Œ\n            housum+=nums[i];\n            ans=max(ans,housum+qianmax[i-1]);\n        }\n        return ans;\n    }\n};\n```\n### æ‹¼æ¥æ•°ç»„çš„æœ€å¤§åˆ†æ•°\n```C\n/*è½¬æ¢æˆæœ€å¤§å­æ•°ç»„å’Œ*/\nclass Solution {\n    int solve(vector<int> &nums1, vector<int> &nums2) {\n        int sum = 0, maxSum = 0;\n        for (int i = 0, s = 0; i < nums1.size(); i++) {\n            sum += nums1[i];\n            s = max(s,0)+(nums2[i] - nums1[i]);\n            maxSum = max(maxSum, s);\n        }\n        return sum + maxSum;\n    }\n\npublic:\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2) {\n        return max(solve(nums1, nums2), solve(nums2, nums1));\n    }\n};\n```\n### (æ‰©å±•ï¼‰ä¹˜ç§¯æœ€å¤§å­æ•°ç»„\n```C\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector <long> maxF(nums.begin(),nums.end()), minF(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            maxF[i] = max(maxF[i - 1] * nums[i], max((long)nums[i], minF[i - 1] * nums[i]));\n            minF[i] = min(minF[i - 1] * nums[i], min((long)nums[i], maxF[i - 1] * nums[i]));\n            if(minF[i]<INT_MIN) {\n                minF[i]=nums[i];\n            }\n        }\n        return *max_element(maxF.begin(), maxF.end());\n    }\n};\n/*ä¼˜åŒ–ç©ºé—´*/\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        long maxF = nums[0], minF = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            long mx = maxF, mn = minF;\n            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));\n            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));\n            if(minF<INT_MIN) {\n                minF=nums[i];\n            }\n            ans = max(maxF, ans);\n        }\n        return ans;\n    }\n};\n```\n# ç½‘æ ¼å›¾ DP\n## åŸºç¡€\n### ç å®çš„æœ€é«˜ä»·å€¼\n```C\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(n,vector<int>(m));\n        f[0][0]=frame[0][0];\n        for(int i=1;i<n;i++){ //å¤„ç†ç¬¬ä¸€åˆ—\n            f[i][0]=f[i-1][0]+frame[i][0];\n        }\n        for(int j=1;j<m;j++){ //å¤„ç†ç¬¬ä¸€è¡Œ\n            f[0][j]=f[0][j-1]+frame[0][j];\n        }\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                f[i][j]=max(f[i-1][j],f[i][j-1])+frame[i][j];\n            }\n        }\n        return f[n-1][m-1];\n    }\n};\n \n/*æ³¨æ„åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­ï¼Œf(i,j) åªä¼šä» f(iâˆ’1,j) å’Œ f(i,jâˆ’1) è½¬ç§»è€Œæ¥ï¼Œè€Œä¸ f(iâˆ’2,â‹¯) ä»¥åŠæ›´æ—©çš„çŠ¶æ€æ— å…³ï¼Œå› æ­¤æˆ‘ä»¬åŒä¸€æ—¶åˆ»åªéœ€è¦å­˜å‚¨æœ€åä¸¤è¡Œçš„çŠ¶æ€ï¼Œå³ä½¿ç”¨ä¸¤ä¸ªé•¿åº¦ä¸º n çš„ä¸€ä½æ•°ç»„ä»£æ›¿ nÃ—m çš„äºŒç»´æ•°ç»„ fï¼Œäº¤æ›¿åœ°è¿›è¡ŒçŠ¶æ€è½¬ç§»ï¼Œå‡å°‘ç©ºé—´å¤æ‚åº¦ã€‚*/\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(2,vector<int>(m));\n        for(int i=0;i<n;i++){\n            int pos=i%2;\n            for(int j=0;j<m;j++){\n                f[pos][j]=0;\n                if(i>0) f[pos][j]=max(f[pos][j],f[1-pos][j]);\n                if(j>0) f[pos][j]=max(f[pos][j],f[pos][j-1]);\n                f[pos][j]+=frame[i][j];\n            }\n        }\n        return f[(n-1)%2][m-1];\n    }\n};\n```\n### ä¸åŒè·¯å¾„\n```C\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++) f[i][0]=1;\n        for(int j=0;j<n;j++) f[0][j]=1;\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n/*æ­¤å¤–ï¼Œç”±äº f(i,j) ä»…ä¸ç¬¬ i è¡Œå’Œç¬¬ iâˆ’1 è¡Œçš„çŠ¶æ€æœ‰å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä»£æ›¿ä»£ç ä¸­çš„äºŒç»´æ•°ç»„ï¼Œä½¿ç©ºé—´å¤æ‚åº¦é™ä½ä¸º O(n)ã€‚*/\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> f(n,1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                f[j]+=f[j-1];\n            }\n        }\n        return f[n - 1];\n    }\n};\n```\n### ä¸åŒè·¯å¾„ II\n```C\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++){ //å¤„ç†ç¬¬ä¸€åˆ—\n            if(obstacleGrid[i][0]==1){ //æœ‰éšœç¢ \n                f[i][0]=0; \n                break; //åé¢éƒ½åˆ°è¾¾ä¸äº†\n            }\n            else f[i][0]=1;\n        }\n        for(int j=0;j<n;j++){  //å¤„ç†ç¬¬ä¸€è¡Œ\n            if(obstacleGrid[0][j]==1){ //æœ‰éšœç¢\n                f[0][j]=0; \n                break; //åé¢éƒ½åˆ°è¾¾ä¸äº†\n            }\n            else f[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(obstacleGrid[i][j]==1) f[i][j]=0;\n                else f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n```\n### æœ€å°è·¯å¾„å’Œ\n```C\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m));\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<n;i++) dp[i][0]=dp[i-1][0]+grid[i][0];\n        for(int j=1;j<m;j++) dp[0][j]=dp[0][j-1]+grid[0][j];\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};\n```\n### ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ\n```C\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            dp[i][0]=dp[i-1][0]+triangle[i][0]; //ç¬¬ä¸€åˆ—åªèƒ½ä»ä¸Šé¢è½¬ç§»\n            for(int j=1;j<i;j++){\n                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n            }\n            dp[i][i]=dp[i-1][i-1]+triangle[i][i];//æœ€åä¸€åˆ—åªèƒ½ä»å·¦ä¸Šè½¬ç§»\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n/*å¯ä»¥å‘ç°ï¼Œdp[i][j] åªä¸ dp[iâˆ’1][..] æœ‰å…³ï¼Œè€Œä¸ dp[iâˆ’2][..] åŠä¹‹å‰çš„çŠ¶æ€æ— å…³ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¿…å­˜å‚¨è¿™äº›æ— å…³çš„çŠ¶æ€ã€‚å…·ä½“åœ°ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªé•¿åº¦ä¸º n çš„ä¸€ç»´æ•°ç»„è¿›è¡Œè½¬ç§»ï¼Œå°† i æ ¹æ®å¥‡å¶æ€§æ˜ å°„åˆ°å…¶ä¸­ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œé‚£ä¹ˆ iâˆ’1 å°±æ˜ å°„åˆ°äº†å¦ä¸€ä¸ªä¸€ç»´æ•°ç»„ã€‚è¿™æ ·æˆ‘ä»¬ä½¿ç”¨è¿™ä¸¤ä¸ªä¸€ç»´æ•°ç»„ï¼Œäº¤æ›¿åœ°è¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚*/\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            int cur=i%2; //å½“å‰è¡Œ\n            int pre=1-cur; //ä¸Šä¸€è¡Œ\n            dp[cur][0]=dp[pre][0]+triangle[i][0]; //ç¬¬ä¸€åˆ—åªèƒ½ä»ä¸Šé¢è½¬ç§»\n            for(int j=1;j<i;j++){\n                dp[cur][j]=min(dp[pre][j-1],dp[pre][j])+triangle[i][j];\n            }\n            dp[cur][i]=dp[pre][i-1]+triangle[i][i];//æœ€åä¸€åˆ—åªèƒ½ä»å·¦ä¸Šè½¬ç§»\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n### ä¸‹é™è·¯å¾„æœ€å°å’Œ\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        copy(matrix[0].begin(),matrix[0].end(),dp[0].begin());\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++){\n                int minn=dp[i-1][j]; //éƒ½èƒ½ä»æ­£ä¸Šæ–¹è½¬ç§»\n                if(j>0){ //å¯ä»¥ä»å·¦ä¸Šæ–¹è½¬ç§»\n                    minn=min(minn,dp[i-1][j-1]);\n                }\n                if(j<n-1){ //å¯ä»¥ä»å³ä¸Šæ–¹è½¬ç§»\n                    minn=min(minn,dp[i-1][j+1]);\n                }\n                dp[i][j]=minn+matrix[i][j];\n            }\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n```\n### çŸ©é˜µä¸­ç§»åŠ¨çš„æœ€å¤§æ¬¡æ•°\n```C\nclass Solution {\npublic:\n    int maxMoves(vector<vector<int>>& grid) {\n        int ans=0; bool flag=1;\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m)); //dp[i][j]==1è¡¨ç¤º(i,j)ä½ç½®å¯åˆ°è¾¾\n        for(int i=0;i<n;i++) dp[i][0]=1; \n        for(int j=1;j<m;j++){\n            if(!flag) return ans;\n            flag=0;\n            for(int i=0;i<n;i++){\n                if(grid[i][j-1]<grid[i][j]&&dp[i][j-1]){\n                    dp[i][j]=1;\n                }\n                if(i>0){\n                    if(grid[i-1][j-1]<grid[i][j]&&dp[i-1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(i<n-1){\n                    if(grid[i+1][j-1]<grid[i][j]&&dp[i+1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(dp[i][j]){\n                    flag=1;\n                    ans=j;\n                }\n            }\n        }\n        //ans+=1;\n        return ans;\n    }\n};\n```\n### ç½‘æ ¼ä¸­çš„æœ€å°è·¯å¾„ä»£ä»·\n```C\nclass Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0]=grid[0];\n        for(int i=1;i<m;i++){\n            int cur=i%2; //å½“å‰è¡Œ\n            int pre=1-cur; //ä¸Šä¸€è¡Œ\n            for(int j=0;j<n;j++){ //å½“å‰è¡Œæ¯ä¸€åˆ—\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<n;k++){ //ä¸Šä¸€è¡Œæ¯ä¸€åˆ—\n                    dp[cur][j]=min(dp[cur][j],dp[pre][k]+moveCost[grid[i-1][k]][j]+grid[i][j]);\n                }\n            }\n        }\n        return *min_element(dp[(m-1)%2].begin(),dp[(m-1)%2].end());\n    }\n};\n```\n### ä¸‹é™è·¯å¾„æœ€å°å’Œ II\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(m));\n        dp[0]=grid[0];\n        for(int i=1;i<n;i++){ \n            int cur=i%2; //å½“å‰è¡Œ\n            int pre=1-cur; //ä¸Šä¸€è¡Œ\n            for(int j=0;j<m;j++){ //å½“å‰è¡Œæ¯ä¸€åˆ—\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<m;k++){ //ä¸Šä¸€è¡Œæ¯ä¸€åˆ—\n                    if(j!=k){\n                        dp[cur][j]=min(dp[cur][j],dp[pre][k]+grid[i][j]);\n                    }\n                }\n            }\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n## è¿›é˜¶\n### çŸ©é˜µçš„æœ€å¤§éè´Ÿç§¯\n```C\nclass Solution {\npublic:\n    int maxProductPath(vector<vector<int>>& grid) {\n        const int mod=1e9+7;\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<long long>> maxgt(m,vector<long long>(n));\n        vector<vector<long long>> minlt(m,vector<long long>(n));\n        maxgt[0][0]=minlt[0][0]=grid[0][0];\n        for(int j=1;j<n;j++){ //å¤„ç†ç¬¬ä¸€è¡Œ\n            maxgt[0][j]=minlt[0][j]=maxgt[0][j-1]*grid[0][j];\n        }\n        for(int i=1;i<m;i++){ //å¤„ç†ç¬¬ä¸€åˆ—\n            maxgt[i][0]=minlt[i][0]=maxgt[i-1][0]*grid[i][0];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(grid[i][j]>=0){\n                    maxgt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                    minlt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                }\n                else{\n                    maxgt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                    minlt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                }\n            }\n        }\n        if(maxgt[m-1][n-1]<0) return -1;\n        else{\n            return maxgt[m-1][n-1]%mod;\n        }\n    }\n};\n```\n### æœ€å¤§å¾—åˆ†çš„è·¯å¾„æ•°ç›®\n```C\nusing PII = pair<int, int>;\n\nclass Solution {\nprivate:\n    static constexpr int mod = (int)1e9 + 7;\n\npublic:\n    void update(vector<vector<PII>>& dp, int n, int x, int y, int u, int v) {\n        if (u >= n || v >= n || dp[u][v].first == -1) {\n            return;\n        }\n        if (dp[u][v].first > dp[x][y].first) {\n            dp[x][y] = dp[u][v];\n        }\n        else if (dp[u][v].first == dp[x][y].first) {\n            dp[x][y].second += dp[u][v].second;\n            if (dp[x][y].second >= mod) {\n                dp[x][y].second -= mod;\n            }\n        }\n    }\n\n    vector<int> pathsWithMaxScore(vector<string>& board) {\n        int n = board.size();\n        vector<vector<PII>> dp(n, vector<PII>(n, {-1, 0}));\n        dp[n - 1][n - 1] = {0, 1};\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (!(i == n - 1 && j == n - 1) && board[i][j] != 'X') {\n                    update(dp, n, i, j, i + 1, j);\n                    update(dp, n, i, j, i, j + 1);\n                    update(dp, n, i, j, i + 1, j + 1);\n                    if (dp[i][j].first != -1) {\n                        dp[i][j].first += (board[i][j] == 'E' ? 0 : board[i][j] - '0');\n                    }\n                }\n            }\n        }\n        return dp[0][0].first == -1 ? vector<int>{0, 0} : vector<int>{dp[0][0].first, dp[0][0].second};\n    }\n};\n```\n### çŸ©é˜µä¸­å’Œèƒ½è¢« K æ•´é™¤çš„è·¯å¾„\n```C\n/*æŠŠè·¯å¾„å’Œæ¨¡ k çš„ç»“æœå½“æˆä¸€ä¸ªæ‰©å±•ç»´åº¦*/\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>> &grid, int k) {\n        const int mod = 1e9 + 7;\n        int m = grid.size(), n = grid[0].size(), f[m + 1][n + 1][k];\n        memset(f, 0, sizeof(f)); // f[i][j][v] è¡¨ç¤ºä»å·¦ä¸Šèµ°åˆ° (i,j)ï¼Œä¸”è·¯å¾„å’Œæ¨¡ k çš„ç»“æœä¸º v æ—¶çš„è·¯å¾„æ•°\n        f[0][1][0] = 1;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                for (int v = 0; v < k; ++v)\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\n        return f[m][n][0];\n    }\n};\n/*ä»£ç å®ç°æ—¶ï¼Œä¸ºäº†é¿å…åˆ¤æ–­æ˜¯å¦è¶Šç•Œï¼Œå¯ä»¥æŠŠä¸‹æ ‡éƒ½åŠ ä¸€ã€‚æ­¤æ—¶å¯ä»¥è®¾åˆå§‹å€¼ f[0][1][0]=1ï¼ˆæˆ–è€… f[1][0][0]=1ï¼‰ç®€åŒ–ä¸€ç‚¹ç‚¹ä»£ç ã€‚*/\n```\n### åœ°ä¸‹åŸæ¸¸æˆ\n```C\n\n```\n# èƒŒåŒ…\n## 0-1 èƒŒåŒ…\n>*æ¯ä¸ªç‰©å“åªèƒ½é€‰ä¸€æ¬¡*\n### å’Œä¸ºç›®æ ‡å€¼çš„æœ€é•¿å­åºåˆ—çš„é•¿åº¦\n```C\n\n```\n## å®Œå…¨èƒŒåŒ…\n## å¤šé‡èƒŒåŒ…\n## åˆ†ç»„èƒŒåŒ…\n# ç»å…¸çº¿æ€§ DP\n## æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰\n>*ä¸€èˆ¬å®šä¹‰f[i][j]è¡¨ç¤ºå¯¹(s[:i],t[:j])çš„æ±‚è§£ç»“æœã€‚*\n### æœ€é•¿å…¬å…±å­åºåˆ—\n```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.size(),n=text2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1)); \n        for(int i=1;i<=m;i++){\n            char c1=text1[i-1];\n            for(int j=1;j<=n;j++){\n                char c2=text2[j-1];\n                if(c1==c2){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                else{\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n### ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ\n```C++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; i++) {\n            char c1 = word1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = word2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        int lcs = dp[m][n];\n        return m - lcs + n - lcs;\n    }\n};\n```\n### ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å°ASCIIåˆ é™¤å’Œ\n```C++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int m = s1.size();\n        int n = s2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; ++i) {\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\n        }\n        for (int j = 1; j <= n; ++j) {\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\n        }\n        for (int i = 1; i <= m; i++) {\n            char c1 = s1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = s2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n```\n### ç¼–è¾‘è·ç¦»\n```C++\n\n```\n## æœ€é•¿é€’å¢å­åºåˆ—ï¼ˆLISï¼‰\n","tags":["åŠ¨æ€è§„åˆ’","ç¼–ç¨‹"]},{"title":"è½¯ä»¶å·¥ç¨‹ç»¼åˆå®è·µ","url":"/2024/10/01/è½¯ä»¶å·¥ç¨‹ç»¼åˆå®è·µ/","content":"## æ•…äº‹åœºæ™¯\n>ä½ ä»¬æ˜¯å‡ ååˆ°æŸè½¯ä»¶å¼€å‘å…¬å¸ï¼ˆä»¥ä¸‹ç®€ç§°Tè½¯ï¼‰å®ä¹ çš„å­¦ç”Ÿã€‚ä¸Šç­ç¬¬ä¸€å¤©ï¼Œè€æ¿å‘Šè¯‰ä½ ä»¬ï¼Œå…¬å¸ç°åœ¨æœ‰ä¸ªç´§æ€¥é¡¹ç›®ï¼Œè¦æ±‚ä¸‰å‘¨åä¸Šçº¿ï¼Œä½†æ˜¯â€¦â€¦ä¸Šå‘¨æœ«ï¼Œè¿™ä¸ªé¡¹ç›®å”¯ä¸€çš„ç¨‹åºå‘˜ï¼Œå°ä¸œï¼Œå› ä¸æ»¡å…¬å¸çš„è–ªæ°´å¾…é‡è¿‡ä½è€Œç¦»èŒäº†ï¼Œç°åœ¨ç•™ä¸‹äº†ä¸€ä¸ªåŠæˆå“çš„çƒ‚æ‘Šå­ï¼Œé‡æ‹…è½åœ¨äº†ä½ ä»¬å‡ ä¸ªæ¯«æ— å¼€å‘ç»éªŒçš„å®ä¹ ç”Ÿèº«ä¸Šâ€¦â€¦\n## JDBC é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ JDBC å°è£…æ•°æ®å±‚ï¼Œå¹¶å®ç°å¢åˆ æ”¹æŸ¥â€çš„é—®é¢˜ã€‚**\n## å‰ç«¯é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ HTML5+CSS3+JavaScript å¼€å‘ä¼ä¸šçº§å‰ç«¯é™æ€é¡µé¢â€çš„é—®é¢˜ã€‚**\n## JavaWeb é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ Vueï¼ˆå‰ç«¯ï¼‰+Servletï¼ˆæœåŠ¡ç«¯ï¼‰å¼€å‘åŸºäºå‰åç«¯åˆ†ç¦»æ¶æ„åº”ç”¨ç¨‹åºâ€çš„é—®é¢˜ã€‚**\n## SpringBoot é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ Vueï¼ˆå‰ç«¯ï¼‰+SpringBootï¼ˆæœåŠ¡ç«¯ï¼‰å¼€å‘åŸºäºå‰åç«¯åˆ†ç¦»æ¶æ„åº”ç”¨ç¨‹åºâ€çš„é—®é¢˜ã€‚**\n## SpringCloud é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ Vueï¼ˆå‰ç«¯ï¼‰+SpringCloudï¼ˆæœåŠ¡ç«¯ï¼‰å¼€å‘åŸºäºå¾®æœåŠ¡çš„äº’è”ç½‘åº”ç”¨ç¨‹åºâ€çš„é—®é¢˜ã€‚**","tags":["è½¯ä»¶å·¥ç¨‹","å®è·µ","å¼€å‘"]},{"title":"è®¡ç®—æœºç½‘ç»œå®è·µè®°å½•","url":"/2024/09/28/è®¡ç®—æœºç½‘ç»œå®è·µè®°å½•/","content":"---\n- å¤©æ´¥å¤§å­¦ 2024 è®¡ç®—æœºç½‘ç»œ TCP è¯¾ç¨‹å®è·µ\n- Lab Memberï¼šæµ·æ£ æœªé›¨ï¼Œæ¢¨èŠ±å…ˆé›ª\n- æœ€ç»ˆæˆç»© +âˆ åˆ†æ ğŸ˜‹\n---\n# æ–‡ä»¶ç»“æ„è¯´æ˜\n```markdown\ntju_tcp ----------------- é¡¹ç›®æ ¹ç›®å½• \nâ”œâ”€ build ---------------- å­˜æ”¾æ‰€æœ‰ç¼–è¯‘çš„ä¸­é—´æ–‡ä»¶\nâ”‚  â”œâ”€ kernel.o\nâ”‚  â”œâ”€ tju_packet.o  \nâ”‚  â””â”€ tju_tcp.o\nâ”œâ”€ inc ------------------ å­˜æ”¾æ‰€æœ‰å¤´æ–‡ä»¶\nâ”‚  â”œâ”€ global.h ---------- å®šä¹‰ä¸€äº›å…¨å±€éƒ½ä¼šç”¨åˆ°çš„å˜é‡å’Œç»“æ„\nâ”‚  â”œâ”€ kernel.h ---------- æ¨¡æ‹Ÿä¸€éƒ¨åˆ†linuxå†…æ ¸è¡Œä¸º æ¯”å¦‚å¦‚ä½•å‘é€æ•°æ®åˆ°ä¸‹ä¸€å±‚ æ ¹æ®äº”å…ƒç»„æŸ¥æ‰¾socketç­‰\nâ”‚  â”œâ”€ tju_packet.h ------ å®šä¹‰TCPæ‰€ç”¨åˆ°çš„æ•°æ®åŒ…æ ¼å¼ æä¾›å„ç§æ•°æ®åŒ…çš„æ“ä½œ(åˆ›å»º è·å¾—å­—æ®µç­‰)\nâ”‚  â””â”€ tju_tcp.h --------- éœ€è¦å®ç°çš„TCPçš„å„ç§ç»“æ„å’ŒåŠŸèƒ½çš„å®šä¹‰\nâ”œâ”€ src ------------------ å­˜æ”¾æ‰€æœ‰æºä»£ç æ–‡ä»¶\nâ”‚  â”œâ”€ client.c ---------- å®¢æˆ·ç«¯ä¸»å‡½æ•°å®ç°\nâ”‚  â”œâ”€ server.c ---------- æœåŠ¡ç«¯ä¸»å‡½æ•°å®ç°\nâ”‚  â”œâ”€ kernel.c ---------- è™šæ‹Ÿå†…æ ¸å®ç°\nâ”‚  â”œâ”€ tju_packet.c ------ å¯é å±‚åŒ…å°è£…å®ç°\nâ”‚  â””â”€ tju_tcp.c --------- å¯é å±‚å®ç°\nâ”œâ”€ Makefile ------------- ç”Ÿæˆè„šæœ¬\nâ”œâ”€ README.md ------------ æ–‡ä»¶è¯´æ˜\nâ””â”€ bin\n   â”œâ”€ client\n   â””â”€ server\n```\n---\n# ç³»ç»Ÿç¯å¢ƒä¿¡æ¯\n```SHELL\nneofetch\n--------------\nOS: Ubuntu 20.04.2 LTS x86_64\nHost: Oracle Corporation VirtualBox\nKernel: 5.4.0-80-generic\nUptime: 3 mins\nPackages: 676 (dpkg), 4 (snap)\nShell: bash 5.0.17\nResolution: 800x600\nTerminal: /dev/pts/0\nCPU: 11th Gen Intel i7-11800H (2) @ 2.304GHz\nGPU: VirtualBox Graphics Adapter\nMemory: 294MiB / 981MiB\n```\n---\n# å…·ä½“å®éªŒè®°å½•\n## è¿æ¥ç®¡ç†\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/t2LOxSBZgRkiblj.png\" width=\"60%\" />\n</center>\n\n### ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿æ¥\n**1. tju_connect( )**\n`tju_connect( )`å‡½æ•°æ˜¯ä¸‰æ¬¡æ¡æ‰‹çš„å¼€ç«¯ã€‚åœ¨è¯¥å‡½æ•°ä¸­ï¼Œå®¢æˆ·ç«¯çš„sockç»‘å®šå¥½æœ¬åœ°çš„ipå’Œportåå‘æœåŠ¡å™¨ç«¯å‘é€SYNåŒ…ï¼ŒåŒæ—¶æŠŠå½“å‰çš„çŠ¶æ€å˜åŒ–ä¸ºSYN_SENTã€‚æˆåŠŸå»ºç«‹è¿æ¥åå°†sockæ”¾å…¥ESTABLISHEDçš„hashè¡¨ä¸­ã€‚\n```C\nint tju_connect(tju_tcp_t* sock, tju_sock_addr target_addr){\n    sock->established_remote_addr = target_addr;\n\n    tju_sock_addr local_addr;\n    local_addr.ip = inet_network(CLIENT_IP);\n    local_addr.port = 5678; // è¿æ¥æ–¹è¿›è¡Œconnectè¿æ¥çš„æ—¶å€™ å†…æ ¸ä¸­æ˜¯éšæœºåˆ†é…ä¸€ä¸ªå¯ç”¨çš„ç«¯å£\n    sock->established_local_addr = local_addr;\n\n    // è¿™é‡Œä¹Ÿä¸èƒ½ç›´æ¥å»ºç«‹è¿æ¥ éœ€è¦ç»è¿‡ä¸‰æ¬¡æ¡æ‰‹\n    // å®é™…åœ¨linuxä¸­ connectè°ƒç”¨å ä¼šè¿›å…¥ä¸€ä¸ªwhileå¾ªç¯\n    // å¾ªç¯è·³å‡ºçš„æ¡ä»¶æ˜¯socketçš„çŠ¶æ€å˜ä¸ºESTABLISHED è¡¨é¢çœ‹ä¸Šå»å°±æ˜¯ æ­£åœ¨è¿æ¥ä¸­ é˜»å¡\n    // è€ŒçŠ¶æ€çš„æ”¹å˜åœ¨åˆ«çš„åœ°æ–¹è¿›è¡Œ åœ¨æˆ‘ä»¬è¿™å°±æ˜¯tju_handle_packet\n    uint32_t seq = 0;  // åºåˆ—å·\n    uint32_t ack = 0;  // ç¡®è®¤å·\n    uint8_t flag=SYN_FLAG_MASK; //flagæ ‡è®°ä¸ºï¼šè¿æ¥çŠ¶æ€è¿›è¡Œåˆ°å“ªä¸€æ­¥\n    char *SYN = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n    sendToLayer3(SYN, DEFAULT_HEADER_LEN); //å®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯å‘é€åŒæ­¥æŠ¥æ–‡--ç¬¬ä¸€æ¬¡æ¡æ‰‹\n    change_sock_state(sock, SYN_SENT);\n    // printf(\"clientå‘é€SYN\\n\");\n    \n    Timeout_retransmission(sock, ESTABLISHED, SYN, DEFAULT_HEADER_LEN); //é˜»å¡ç­‰å¾…ï¼Œç›´åˆ°sockè¢«å»ºç«‹\n    int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n    established_socks[hashval] = sock;\n    return 0;\n}\n```\n**2. Timeout_retransmission( )**\n```C\nvoid Timeout_retransmission(tju_tcp_t* sock, int exp_state, char* pkt, int pktlen) { //è¶…æ—¶é‡ä¼ å‘åŒ…å‡½æ•°\n    //printf(\"bg1\\n\");\n    long timeout = 100000L;\n    struct timeval start_time, end_time;\n    gettimeofday(&start_time, NULL);\n    while (sock->state != exp_state){\n        gettimeofday(&end_time, NULL);\n        long Time = 1000000L * (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_usec - start_time.tv_usec);\n        if (Time >= timeout) { //è¶…æ—¶é‡ä¼ \n            gettimeofday(&start_time, NULL);\n            sendToLayer3(pkt, pktlen);\n        }\n    }\n    //printf(\"ed1\\n\");\n}\n```\n**3. change_sock_state( )**\n```C\nvoid change_sock_state(tju_tcp_t* sock, int state) {  //æ·»åŠ ï¼šsockçŠ¶æ€æ”¹å˜\n    while (pthread_mutex_lock(&(sock->state_lock)) != 0) ; //æ”¹å˜sockçŠ¶æ€å‰å…ˆåŠ é”\n    sock->state = state;  \n    pthread_mutex_unlock(&(sock->state_lock)); //è§£é”\n}\n```\n**4. tju_accept()**\n`tju_accept( )`å‡½æ•°ä¸­æ·»åŠ äº†ä¸€ä¸ªé˜»å¡ï¼Œä½¿å¾—åªæœ‰å½“å…¨è¿æ¥hashè¡¨ä¸­å­˜åœ¨è¿™ä¸€ä¸ªsockï¼ŒæœåŠ¡å™¨ç«¯æ‰ç®—è¿æ¥å®Œæˆï¼Œæ‰èƒ½æŠŠæ–°çš„sockåŠ å…¥åˆ°ESTABLISHEDçš„hashè¡¨ä¸­ã€‚\n```C\ntju_tcp_t *tju_accept(tju_tcp_t *listen_sock){\n    while (listen_sock->received_len < DEFAULT_HEADER_LEN);\n    char *header = malloc(DEFAULT_HEADER_LEN);\n    memcpy(header, listen_sock->received_buf, DEFAULT_HEADER_LEN);\n    memset(listen_sock->received_buf, 0, DEFAULT_HEADER_LEN);\n    listen_sock->received_buf = NULL;\n    listen_sock->received_len = listen_sock->received_len - DEFAULT_HEADER_LEN;\n\n    tju_tcp_t* new_conn = (tju_tcp_t*)malloc(sizeof(tju_tcp_t));\n    pthread_mutex_init(&(new_conn->state_lock), NULL);\n    memcpy(new_conn, listen_sock, sizeof(tju_tcp_t));\n\n    tju_sock_addr local_addr, remote_addr;\n    /*\n     è¿™é‡Œæ¶‰åŠåˆ°TCPè¿æ¥çš„å»ºç«‹\n     æ­£å¸¸æ¥è¯´åº”è¯¥æ˜¯æ”¶åˆ°å®¢æˆ·ç«¯å‘æ¥çš„SYNæŠ¥æ–‡\n     ä»ä¸­æ‹¿åˆ°å¯¹ç«¯çš„IPå’ŒPORT\n     æ¢å¥è¯è¯´ ä¸‹é¢çš„å¤„ç†æµç¨‹å…¶å®ä¸åº”è¯¥æ”¾åœ¨è¿™é‡Œ åº”è¯¥åœ¨tju_handle_packetä¸­\n    */\n    remote_addr.ip = inet_network(CLIENT_IP);  //å…·ä½“çš„IPåœ°å€\n    remote_addr.port = 5678;  //ç«¯å£\n\n    local_addr.ip = listen_sock->bind_addr.ip;  //å…·ä½“çš„IPåœ°å€\n    local_addr.port = listen_sock->bind_addr.port;  //ç«¯å£\n\n    new_conn->established_local_addr = local_addr;\n    new_conn->established_remote_addr = remote_addr;\n\n    while (listen_sock->state != ESTABLISHED) ;\n    change_sock_state(new_conn, ESTABLISHED);\n\n    // å°†æ–°çš„connæ”¾åˆ°å†…æ ¸å»ºç«‹è¿æ¥çš„socketå“ˆå¸Œè¡¨ä¸­\n    int hashval = cal_hash(local_addr.ip, local_addr.port, remote_addr.ip, remote_addr.port);\n    established_socks[hashval] = new_conn;\n    return new_conn;\n}\n```\n**5. tju_handle_packet( )**\n`tju_handle_packet( )`å‡½æ•°ä¸­éœ€è¦è§£å†³å¯¹å„ç§æŠ¥æ–‡çš„è§£æã€‚`onTCPPocket( )`å‡½æ•°å¦‚æœä»established_hashæˆ–listen_hashä¸­æ‰¾åˆ°äº†å¯¹åº”çš„socketï¼Œå°±ä¼šè°ƒç”¨ `tju_handle_packet( )`å‡½æ•°å¯¹æ”¶åˆ°çš„æ•°æ®åŒ…è¿›è¡Œå¤„ç†ã€‚\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    if (sock->state == LISTEN && get_flags(pkt) == SYN_FLAG_MASK){ //ç¬¬äºŒæ¬¡æ¡æ‰‹\n        while (pthread_mutex_lock(&(sock->recv_lock)) != 0);\n        if (sock->received_buf == NULL) sock->received_buf = malloc(DEFAULT_HEADER_LEN);\n        else sock->received_buf = realloc(sock->received_buf, sock->received_len + DEFAULT_HEADER_LEN);\n        memcpy(sock->received_buf + sock->received_len, pkt, DEFAULT_HEADER_LEN);\n        sock->received_len += DEFAULT_HEADER_LEN;\n        pthread_mutex_unlock(&(sock->recv_lock));\n\n        tju_sock_addr remote;\n        remote.ip = inet_network(CLIENT_IP);\n        remote.port = get_src(pkt);\n\n        sock->established_local_addr = sock->bind_addr;\n        sock->established_remote_addr = remote;\n\n        int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, remote.ip, remote.port);\n        half_connection[hashval] = sock;  //æ”¶åˆ°SYNæŠ¥æ–‡åæ”¾è¿›LISTENçš„åŠè¿æ¥é˜Ÿåˆ—ä¸­\n        established_socks[hashval] = sock; //è¿˜ä¼šå°†è¯¥æ–°å»ºçš„socketæ”¾åˆ°ehashä¸­\n\n        uint32_t seq = 0;  \n        uint32_t ack = get_seq(pkt) + 1; //ç¡®è®¤å·æ˜¯SYNæŠ¥æ–‡åºåˆ—å·+1\n        uint8_t flag = SYN_FLAG_MASK | ACK_FLAG_MASK; //çŠ¶æ€è®°ä¸ºSYN+ACKï¼Œè¿™é‡Œé‡‡ç”¨ä½è¿ç®—|\n        char *SYNACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(SYNACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, SYN_RECV);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == (ACK_FLAG_MASK | SYN_FLAG_MASK)){ //ç¬¬ä¸‰æ¬¡æ¡æ‰‹\n        //printf(\"clientæ”¶åˆ°SYCACK, å‡†å¤‡å‘é€ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == SYN_FLAG_MASK){ //ç¬¬ä¸‰æ¬¡æ¡æ‰‹ï¼ˆå¥‡æ€ªï¼‰\n        // //printf(\"clientæ”¶åˆ°SYCACK, å‡†å¤‡å‘é€ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == (SYN_FLAG_MASK | ACK_FLAG_MASK)){  //ä¸‰æ¬¡æ¡æ‰‹ç¬¬ä¸‰ä¸ªåŒ…çš„é‡ä¼ \n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == SYN_RECV && get_flags(pkt) == ACK_FLAG_MASK){\n        // //printf(\"serveræ”¶åˆ°ACK\\n\");\n        sock->window.wnd_recv->expect_seq = get_seq(pkt) + get_plen(pkt) - DEFAULT_HEADER_LEN;\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        com_connection[hash] = sock;\n        half_connection[hash] = NULL;\n        change_sock_state(sock, ESTABLISHED);\n        if (get_plen(pkt) > DEFAULT_HEADER_LEN) { //ACKåŒ…æºå¸¦ä¿¡æ¯\n            pkt2buffer(sock, pkt);\n        }\n    }\n```\n**6. pkt2buffer( )**\n```C\nvoid pkt2buffer(tju_tcp_t* sock, char* pkt) {\n    //printf(\"bg6\\n\");\n    uint32_t data_len = get_plen(pkt) - DEFAULT_HEADER_LEN;\n\n    while (pthread_mutex_lock(&(sock->recv_lock)) != 0); // åŠ é”\n    if (sock->received_buf == NULL){\n        sock->received_buf = malloc(data_len);\n    }\n    else{\n        sock->received_buf = realloc(sock->received_buf, sock->received_len + data_len);\n    }\n    memcpy(sock->received_buf + sock->received_len, pkt + DEFAULT_HEADER_LEN, data_len);    \n    sock->received_len += data_len;\n    pthread_mutex_unlock(&(sock->recv_lock)); // è§£é”\n    //printf(\"ed6\\n\");\n}\n```\n### å››æ¬¡æŒ¥æ‰‹å…³é—­è¿æ¥\n**1. tju_close ( )**\nå››æ¬¡æŒ¥æ‰‹æœ‰ä¸¤ç§æƒ…å†µï¼Œåˆ†åˆ«ä¸ºå…ˆåå…³é—­å’ŒåŒæ—¶å…³é—­ï¼Œä¸¤ç§æ–¹å¼é¦–å…ˆéƒ½éœ€è¦è°ƒç”¨`tju_close( )`å‡½æ•°ï¼Œå› æ­¤ï¼Œåœ¨`tju_close( )`å‡½æ•°ä¸­ï¼Œéœ€è¦æ„é€ ä¸€ä¸ª FIN+ACK æŠ¥æ–‡ï¼Œseqå’Œackéƒ½æ˜¯å½“å‰æŠ¥æ–‡çª—å£çš„ä¸‹ä¸€ä¸ªæ•°å€¼ï¼Œå¹¶æŠŠè‡ªèº«çŠ¶æ€å˜ä¸º FIN-WAIT1ã€‚\n```C\nint tju_close (tju_tcp_t* sock){\n    uint16_t flag = FIN_FLAG_MASK | ACK_FLAG_MASK;\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_send->nextseq;\n    char* FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n    sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n    change_sock_state(sock, FIN_WAIT_1);\n    sock->window.wnd_send->nextseq++;\n\n    while (sock->state != CLOSED) ;\n    //printf(\"è¿æ¥å®Œå…¨å…³é—­\\n\");\n    return 0;\n}\n```\n**2. tju_handle_packet( )**\næ¥ä¸‹æ¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä½†å¤„ç†è¿‡ç¨‹å‡åœ¨`tju_handle_packet( )`ä¸­å®Œæˆï¼Œ`tju_handle_packet( )`ä½œä¸ºå¯¹æ”¶åˆ°çš„åŒ…è¿›è¡Œå“åº”çš„å‡½æ•°ã€‚\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    ``````\n    ``````\n    ``````\n    else if (sock->state == ESTABLISHED && get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK)){ // serveræ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼Œå¹¶è¿›è¡Œç¬¬äºŒæ¬¡æŒ¥æ‰‹å’Œç¬¬ä¸‰æ¬¡æŒ¥æ‰‹\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"å‘é€ç¬¬äºŒæ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n        change_sock_state(sock, CLOSE_WAIT);\n        \n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        seq = sock->window.wnd_send->nextseq;\n        ack = get_seq(pkt) + 1;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"å‘é€ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == ESTABLISHED && get_flags(pkt) == FIN_FLAG_MASK){ // serveræ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼Œå¹¶è¿›è¡Œç¬¬äºŒæ¬¡æŒ¥æ‰‹å’Œç¬¬ä¸‰æ¬¡æŒ¥æ‰‹\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, CLOSE_WAIT);\n        //printf(\"å‘é€ç¬¬äºŒæ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n\n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"å‘é€ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == FIN_WAIT_1 && get_flags(pkt) == ACK_FLAG_MASK){ // clientæ”¶åˆ°ç¬¬äºŒæ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, FIN_WAIT_2);\n        //printf(\"æ”¶åˆ°ç¬¬äºŒæ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n    } \n    else if (sock->state == FIN_WAIT_2 && (get_flags(pkt) == (ACK_FLAG_MASK | FIN_FLAG_MASK))){ // clientæ”¶åˆ°ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹è¿›è¡Œç¬¬å››æ¬¡æŒ¥æ‰‹å¹¶å…³é—­è¿æ¥\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint32_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN,flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"æ”¶åˆ°ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹æŠ¥æ–‡, å¹¶å‘å‡ºç¬¬å››æ¬¡æŒ¥æ‰‹\\n\");\n        change_sock_state(sock, TIME_WAIT);\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,    sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        //è¿™é‡Œè¦ç­‰å¾…2MSL\n        change_sock_state(sock, CLOSED);\n        established_socks[hash] = NULL;\n        //printf(\"å…³é—­è¿æ¥\\n\");\n    } \n    else if (sock->state == LAST_ACK && (get_flags(pkt) == ACK_FLAG_MASK)){ // serveræ”¶åˆ°ç¬¬å››æ¬¡æŒ¥æ‰‹å¹¶å…³é—­è¿æ¥\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"å…³é—­è¿æ¥\\n\");\n    }\n    else if (sock->state == FIN_WAIT_1 && (get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK))){ // åŒæ—¶å…³é—­æ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK,DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n        // //printf(\"åŒæ—¶å…³é—­å‘å‡ºACK\\n\");\n    } \n    else if(sock->state == FIN_WAIT_1 && get_flags(pkt) == FIN_FLAG_MASK){ // åŒæ—¶å…³é—­æ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == CLOSING && get_flags(pkt) == ACK_FLAG_MASK){ // åŒæ—¶å…³é—­æ—¶æ”¶åˆ°ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, TIME_WAIT);\n        //ç­‰å¾…2MSL\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"åŒæ—¶å…³é—­å½»åº•å…³é—­\\n\");\n    }\n}\n```\n## å¯é æ•°æ®ä¼ è¾“\n### å‘é€ç¼“å†²åŒºç®¡ç†\n**1. `global.h` ä¸­å®å®šä¹‰ TCP å‘é€çª—å£å¤§å°ã€‚**\n```C\n#define TCP_SENDWN_SIZE 1000 \n```\n**2. `tju_packet.h` ä¸­ä¸ºå‘é€ç¼“å†²åŒºåˆ›å»º1000ä¸ªæŠ¥æ–‡é•¿åº¦çš„å¾ªç¯é˜Ÿåˆ—ï¼Œæ–¹ä¾¿æ•°æ®åŒ…è¶…æ—¶é‡ä¼ ã€‚**\n```C\n// TCP æŠ¥æ–‡çš„ç»“æ„å®šä¹‰\ntypedef struct {\n\ttju_header_t header;\n\tstruct timeval sent_time;\n\tchar* data;\n} tju_packet_t;\ntju_packet_t* pktlist[TCP_SENDWN_SIZE];\n```\n**3. tju_send( )**\nä¸Šå±‚è°ƒç”¨ `tju_send( )` æ—¶ï¼Œæˆ‘ä»¬åœ¨ `tju_send( )`å‡½æ•°å†…åˆ›å»ºå‘é€çº¿ç¨‹å¹¶æŠŠå‘é€æ•°æ®å­˜å…¥ç¼“å†²åŒºä¸­ã€‚\n&emsp;è¿™é‡Œæˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸‹åˆ›å»ºçº¿ç¨‹ `pthread_create( )`å‡½æ•°ã€‚\n>int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg);\n>- tidpï¼šäº‹å…ˆåˆ›å»ºå¥½çš„pthread_tç±»å‹çš„å‚æ•°ã€‚æˆåŠŸæ—¶tidpæŒ‡å‘çš„å†…å­˜å•å…ƒè¢«è®¾ç½®ä¸ºæ–°åˆ›å»ºçº¿ç¨‹çš„çº¿ç¨‹IDã€‚\n>- attrï¼šç”¨äºå®šåˆ¶å„ç§ä¸åŒçš„çº¿ç¨‹å±æ€§ã€‚APUEçš„12.3èŠ‚è®¨è®ºäº†çº¿ç¨‹å±æ€§ã€‚é€šå¸¸ç›´æ¥è®¾ä¸ºNULLã€‚\n>- start_rtnï¼šæ–°åˆ›å»ºçº¿ç¨‹ä»æ­¤å‡½æ•°å¼€å§‹è¿è¡Œã€‚æ— å‚æ•°æ˜¯argè®¾ä¸ºNULLå³å¯ã€‚\n>- argï¼šstart_rtnå‡½æ•°çš„å‚æ•°ã€‚æ— å‚æ•°æ—¶è®¾ä¸ºNULLå³å¯ã€‚æœ‰å‚æ•°æ—¶è¾“å…¥å‚æ•°çš„åœ°å€ã€‚å½“å¤šäºä¸€ä¸ªå‚æ•°æ—¶åº”å½“ä½¿ç”¨ç»“æ„ä½“ä¼ å…¥ã€‚\n>- è¿”å›å€¼ä¸º 0ï¼ˆè¡¨ç¤ºçº¿ç¨‹æˆåŠŸåˆ›å»ºï¼‰ã€‚\n```C\nint send_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    // è¿™é‡Œå½“ç„¶ä¸èƒ½ç›´æ¥ç®€å•åœ°è°ƒç”¨sendToLayer\n    if(!send_thread_flag){\n        send_thread_flag = 1;\n        pthread_t sendthreadid;\n        int ret = pthread_create(&sendthreadid, NULL, send_pkt, (void *)sock);\n    }\n\n    while (pthread_mutex_lock(&(sock->send_lock)) != 0) ;\n    memcpy(sock->sending_buf + sock->index, (char*)buffer, len);\n    sock->sending_len += len;\n    sock->index += len;\n    pthread_mutex_unlock(&(sock->send_lock));\n\n    return 0;\n}\n```\n**4. send_pkt( )**\n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    //printf(\"bg4\\n\");\n    //struct timeval start_time, now_time;\n    //gettimeofday(&start_time, NULL);\n    //long deltatime = 0; //æ—¶é—´å·®\n    while (1){ //ä¸æ–­æ£€æŸ¥å’Œå‘é€æ•°æ®åŒ…\n        if (sock->window.wnd_send->nextseq < sock->index){ //æ£€æŸ¥å‘é€çª—å£ï¼šæ£€æŸ¥å½“å‰å‘é€åºåˆ—å·æ˜¯å¦å°äºç´¢å¼•ï¼Œç¡®ä¿æœ‰æ•°æ®éœ€è¦å‘é€ã€‚\n            //gettimeofday(&now_time, NULL);\n            //deltatime = now_time.tv_sec - start_time.tv_sec;\n\n            while (pthread_mutex_lock(&(sock->send_lock)) != 0);\n            int unlen = sock->sending_len - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base); //è®¡ç®—å½“å‰æœªå‘é€çš„æ•°æ®é•¿åº¦ã€‚ \n            int len = min(unlen, MAX_DLEN); //ç¡®å®šæœ¬æ¬¡å‘é€çš„é•¿åº¦ï¼Œå–æœªå‘é€é•¿åº¦å’Œæœ€å¤§æ•°æ®é•¿åº¦ä¸­çš„æœ€å°å€¼ã€‚ \n            pthread_mutex_unlock(&(sock->send_lock));\n            int leftlen = sock->window.wnd_send->rwnd - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base);\n            len =len>leftlen?leftlen:len;            \n\n            if (sock->window.wnd_send->nextseq - sock->window.wnd_send->base + len <= sock->window.wnd_send->rwnd) { //æ£€æŸ¥çª—å£å¤§å°ï¼šæ£€æŸ¥å½“å‰å·²å‘é€çš„é•¿åº¦åŠ ä¸Šæœ¬æ¬¡å‘é€é•¿åº¦æ˜¯å¦åœ¨æ¥æ”¶çª—å£èŒƒå›´å†…ã€‚ \n                uint32_t seq = sock->window.wnd_send->nextseq;\n                uint32_t ack = seq + len; //ä¸ç†è§£ \n                uint8_t flag = ACK_FLAG_MASK;\n                uint16_t pkt_len = len + DEFAULT_HEADER_LEN;\n                char *data = (char *)malloc(MAX_DLEN);\n                memcpy(data, sock->sending_buf + sock->window.wnd_send->nextseq, len);\n                tju_packet_t *datapacket = create_packet(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n\n                sendToLayer3(ACK, pkt_len);\n                \n                sock->window.wnd_send->nextseq += len;\n                pktlist[sock->packetr] = datapacket;\n                gettimeofday(&pktlist[sock->packetr]->sent_time, NULL);\n                sock->packetr = (sock->packetr + 1) % TCP_SENDWN_SIZE;\n                if (len == (int)(sock->window.wnd_send->nextseq - sock->window.wnd_send->base)){\n                    gettimeofday(&(sock->window.wnd_send->send_time), NULL);\n                    \n                    while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n                    sock->window.wnd_send->ack_cnt = 0;\n                    pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n                }\n            }\n        }\n    }\n    printf(\"ed4\\n\");\n}\n```\n### å¤±åºæŠ¥æ–‡æ•°ç»„çš„ç®¡ç†\n**1. tju_handle_packet( )**\n`tju_handle_packet( )`ä¸­æ·»åŠ å»ºç«‹è¿æ¥åæ”¶åˆ°æ•°æ®åŒ…çš„å¤„ç†ã€‚\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    `````` å»ºç«‹è¿æ¥ ``````\n    ````````````````````\n    ````````````````````\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == ACK_FLAG_MASK){ //æ”¶åˆ°æ•°æ®åŒ…\n        char hostname[8];\n        gethostname(hostname, 8);\n        if (strcmp(hostname, \"server\") == 0){\n            serverrdt(sock, pkt);\n        } \n        else{\n            clientrdt(sock, pkt);\n        } \n    }\n    `````` å…³é—­è¿æ¥ ``````\n    ````````````````````\n    ````````````````````\n}\n```\n**2. `tju_tcp_t` ç»“æ„ä½“ä¸­åˆ›å»ºç©ºé—´ç”¨æ¥å­˜å‚¨å¤±åºæŠ¥æ–‡å¹¶è®°å½•å¤±åºæŠ¥æ–‡çš„ä¸ªæ•°ã€‚**\n```C\n// TJU_TCP ç»“æ„ä½“ ä¿å­˜TJU_TCPç”¨åˆ°çš„å„ç§æ•°æ®\ntypedef struct {\n\tchar unorder[100][MAX_LEN]; //å¤±åºæŠ¥æ–‡æ•°ç»„\n\tint unolen; //å¤±åºæŠ¥æ–‡ä¸ªæ•°\n} tju_tcp_t;\n```\n**3. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){ // æœåŠ¡å™¨ç«¯å¤„ç†æ•°æ®åŒ…\n    if (get_seq(pkt) < (sock->window.wnd_recv->expect_seq)){ //å‡½æ•°å‘é€ä¸€ä¸ª ACK å“åº”å·²ç¡®è®¤æ¥æ”¶\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if(get_seq(pkt) > (sock->window.wnd_recv->expect_seq)){ //æ•°æ®åŒ…ä¹±åºï¼Œå‡½æ•°å°†åŒ…æš‚å­˜ï¼Œå¹¶å‘é€ ACKï¼ŒåŒæ—¶æ›´æ–°æ¥æ”¶çª—å£\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n\n        if((sock->unolen) > MAX_PKT_IN_WINDOW)  return;\n        memcpy(sock->unorder[sock->unolen], pkt, get_plen(pkt));\n        sock->unolen++;\n    }\n    else{ //åˆšåˆšå¥½\n        sock->window.wnd_send->nextseq=get_ack(pkt);\n        sock->window.wnd_recv->expect_seq+=get_plen(pkt)-DEFAULT_HEADER_LEN;\n        pkt2buffer(sock,pkt);\n        if(sock->unolen == 0){\n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag,TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n        else{\n            int len = sock->unolen;\n\n            for(int i = 0; i < len; i++){\n                for(int j = i + 1; j < len; j++){\n                    if(get_seq(sock->unorder[i])>get_seq(sock->unorder[j])){\n                        my_swap(&sock->unorder[i], &sock->unorder[j]);\n                    }\n                }\n            }\n            int index = 0;\n            for(; index < len; index++){\n                if(get_seq(sock->unorder[index]) == sock->window.wnd_recv->expect_seq){\n                    sock->window.wnd_send->nextseq = get_ack(sock->unorder[index]);\n                    sock->window.wnd_recv->expect_seq += get_plen(sock->unorder[index]) - DEFAULT_HEADER_LEN;\n                    pkt2buffer(sock, sock->unorder[index]);\n                }\n                else if(get_seq(sock->unorder[index]) < (sock->window.wnd_recv->expect_seq)) continue;\n                else break;\n            }\n            for (int i = index; i < len; i++){\n                memcpy(sock->unorder[i - index], sock->unorder[i], sizeof(sock->unorder[i]));\n            }\n            sock->unolen -= index;\n           \n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n    }\n}\n```\n**4. my_swap( )**\n```C\nvoid my_swap(char** a, char** b){\n    char* tem = (char*)malloc(MAX_LEN);\n    memcpy(tem, a, get_plen(b));\n    memcpy(a, b, get_plen(b));\n    memcpy(b, tem, get_plen(tem));\n    free(tem);\n}\n```\n### å®ç°ç´¯è®¡åº”ç­”\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/vKkuC1ibGfmo2sM.png\" width=\"60%\" />\n\nFigure 1. ç´¯è®¡åº”ç­”\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )`å‡½æ•°ä¸­æ·»åŠ ç´¯è®¡åº”ç­”å¤„ç†ã€‚å½“å‘é€æ–¹æ”¶åˆ°ä»»æ„å¤§äºå½“å‰baseçš„ackæŠ¥æ–‡åï¼Œç›´æ¥æŠŠå½“å‰baseè¿›è¡Œæ›´æ–°å³å¯ã€‚\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // å®¢æˆ·ç«¯å¤„ç†æ•°æ®åŒ…\n    if (sock->window.wnd_send->base == sock->window.wnd_send->nextseq) return;\n    if (get_ack(pkt) < sock->window.wnd_send->base) return;\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        ``````\n        ``````\n        ``````\n        while(pthread_mutex_lock(&(sock->send_lock)) != 0); //åŠ é”\n        while(sock->window.wnd_send->base < get_ack(pkt) && sock->window.wnd_send->base < sock->window.wnd_send->nextseq ){   \n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            int datalen = pkt_len - DEFAULT_HEADER_LEN;\n            sock->sending_len -= datalen;\n            sock->window.wnd_send->base += datalen;\n            sock->packetl = (sock->packetl + 1) % TCP_SENDWN_SIZE;\n        }\n        pthread_mutex_unlock(&(sock->send_lock)); //è§£é”\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n### è¶…æ—¶é‡ä¼ \n**1. tju_send( )**\n`tju_send( )` ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹åˆ¤æ–­æ˜¯å¦è¦è¿›è¡Œé‡ä¼ ã€‚\n```C\nint resend_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    ``````\n    ``````\n    ``````\n    if (!resend_thread_flag){\n        resend_thread_flag = 1;\n        pthread_t resendthreadid;\n        int ret = pthread_create(&resendthreadid, NULL,resend_pkt, (void *)sock);\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n**2. resend_pkt( )**\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    struct timeval start_time,now_time;\n    gettimeofday(&start_time, NULL);\n    long deltatime = 0;\n    while (1){\n        if (sock->window.wnd_send->base < sock->window.wnd_send->nextseq){\n            gettimeofday(&now_time, NULL);\n            deltatime = now_time.tv_sec - start_time.tv_sec;\n            if (deltatime > 100) break; //ä¸ç†è§£\n            long nowtimeval = 1000000 * (now_time.tv_sec - sock->window.wnd_send->send_time.tv_sec) +  (now_time.tv_usec - sock->window.wnd_send->send_time.tv_usec);\n            long timeoutval = 1000000 * (sock->window.wnd_send->timeout.tv_sec) + (sock->window.wnd_send->timeout.tv_usec);\n            if (nowtimeval > timeoutval){ //è¶…æ—¶é‡ä¼ \n                while(pktlist[sock->packetl] == NULL);\n                uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n                uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n                uint8_t flag = ACK_FLAG_MASK;\n                int pkt_len = pktlist[sock->packetl]->header.plen;\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack,DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n                sendToLayer3(ACK, pkt_len);\n                gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);\n                gettimeofday(&sock->window.wnd_send->send_time, NULL);\n            }\n        }\n    }\n}\n```\n**3. clientrdt( )**\n`clientrdt( )` å‡½æ•°ä¸­æ·»åŠ åŠ¨æ€è®¾ç½®è¶…æ—¶é—´éš”çš„å®ç°ã€‚\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // å®¢æˆ·ç«¯å¤„ç†æ•°æ®åŒ…\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        //æ›´æ–°RTO\n        struct timeval nowtime;\n        gettimeofday(&nowtime, NULL);\n        long ntime = 1000000 * nowtime.tv_sec + nowtime.tv_usec;\n        long samplertt = 1000000 * (nowtime.tv_sec-pktlist[sock->packetl]->sent_time.tv_sec)+nowtime.tv_usec-pktlist[sock->packetl]->sent_time.tv_usec;\n        long estmatedrtt = sock->window.wnd_send->estmated_rtt;\n        long devrtt = sock->window.wnd_send->dev_rtt;\n        estmatedrtt = 1.0 * estmatedrtt * 7 / 8 + samplertt / 8;\n        devrtt = 1.0 * devrtt * 3 / 4 + (samplertt > 1.0 * estmatedrtt ? (samplertt - estmatedrtt) : (estmatedrtt - samplertt)) / 4;\n        sock->window.wnd_send->timeout.tv_usec = (estmatedrtt + 4 * devrtt) % 1000000;\n        sock->window.wnd_send->timeout.tv_sec = (estmatedrtt + 4 * devrtt) / 1000000;\n        sock->window.wnd_send->estmated_rtt = estmatedrtt;\n        sock->window.wnd_send->dev_rtt = devrtt;\n        double dsamplertt=(double)samplertt/(double)1000000;\n        double destmatedrtt=(double)estmatedrtt/(double)1000000;\n        double ddevrtt=(double)devrtt/(double)1000000;\n        double dtimegap=(double)(estmatedrtt + 4 * devrtt)/(double)1000000;\n        \n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt = 1;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n        ``````\n        ``````\n        ``````\n    }\n}\n```\n### å¿«é€Ÿé‡ä¼ \n<center>\n<img src=\"https://s2.loli.net/2024/10/11/cj2PfZsz8abBVW9.png\" width=\"60%\" />\n\nFigure 1. å¿«é€Ÿé‡ä¼ \n</center>\n\n**1. clientrdt( )**\n`clientrdt( )` å‡½æ•°ä¸­æ·»åŠ å¿«é€Ÿé‡ä¼ çš„å®ç°ã€‚\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // å®¢æˆ·ç«¯å¤„ç†æ•°æ®åŒ…\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) == sock->window.wnd_send->base){ //å†—ä½™ACK\n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt++;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n        if(sock->window.wnd_send->ack_cnt == 3){ //å¿«é€Ÿé‡ä¼  \n            ``````\n            uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n            uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n            uint8_t flag = ACK_FLAG_MASK;\n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, pkt_len, ACK_FLAG_MASK, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n            sendToLayer3(ACK, pkt_len);\n            sock->window.wnd_send->ack_cnt = 0;\n            gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);            \n        }\n        return;\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n## æµé‡æ§åˆ¶\n### æ¥æ”¶æ–¹è®¡ç®—æ¥å—ç¼“å†²åŒºå¤§å°\n**1. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){// æœåŠ¡ç«¯å¤„ç†æ•°æ®åŒ…\n    ``````\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_recv->expect_seq;\n    uint8_t flag = ACK_FLAG_MASK;\n    char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n    ``````\n}\n```\n### å‘é€æ–¹è°ƒæ•´å‘é€ç¼“å†²åŒºå¤§å°\n**1. clientrdt( )**\n`clientrdt( )`å‡½æ•°ç¡®å®šwindow_sizeå¤§å°ã€‚\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){\n    ``````\n    ``````get_advertised_window(pkt)``````\n    ``````\n}\n```\n**2. get_advertised_window( )**\n```C\nuint16_t get_advertised_window(char* msg){\n    int offset = 17;\n    uint16_t var;\n    memcpy(&var, msg+offset, SIZE16);\n    return ntohs(var);\n}\n```\n### 0çª—å£æ¢æµ‹\n**1. send_pkt( )**\n`send_pkt( )`å‘é€æ•°æ®çš„çº¿ç¨‹ä¸­åŠ å…¥ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶ã€‚\n0çª—å£æ¢æµ‹ç”¨äºåœ¨ADVERTISED WINDOWä¸º0çš„æƒ…å†µä¸‹ï¼Œå‘é€å¤§å°ä¸º1çš„æ•°æ®æŠ¥æ–‡ä»¥è·å¾—å®æ—¶çš„çª—å£è¿”å›å€¼ã€‚  \n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    ``````\n    if((sock->window.wnd_send->nextseq > sock->window.wnd_send->base)&&sock->window.wnd_send->rwnd == 0){\n        len = 1;\n    }\n    if (len > 0){\n        ``````\n        ``````\n        ``````        \n    }\n    ``````\n}\n```\n## æ‹¥å¡æ§åˆ¶\n### æ…¢å¯åŠ¨\n**1. å¥—æ¥å­—çš„åˆå§‹åŒ–ä½¿å¾—å‘é€æ–¹ä»å…¶ä»–çŠ¶æ€è¿›å…¥æ…¢å¯åŠ¨çŠ¶æ€ã€‚**\n```C\ntju_tcp_t* tju_socket(){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n**2. `resend_pkt( )`å‡½æ•°è¶…æ—¶äº‹ä»¶ä½¿å¾—å‘é€æ–¹ä»å…¶ä»–çŠ¶æ€è¿›å…¥æ…¢å¯åŠ¨çŠ¶æ€ã€‚**\n```C\nif (nowtimeval > timeoutval){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\nåœ¨æ…¢å¯åŠ¨çŠ¶æ€ä¸‹ï¼Œå‘é€æ–¹æ¯å½“æ¥æ”¶åˆ°æ­£ç¡®çš„ ACK æŠ¥æ–‡ï¼Œå°±ä¼šå°†å…¶æ‹¥å¡çª—å£å¢å¤§ 1 ä¸ª MSSï¼ˆMAX_DLENï¼‰ã€‚è™½ç„¶æ˜¯ä¸æ–­çš„è‡ªå¢ MSSï¼Œä½†æ˜¯ç”±äºæ‹¥å¡çª—å£çš„å¢å¤§ï¼ˆè¿›è€Œå¯¼è‡´å‘é€çª—å£çš„å¢å¤§ï¼‰ï¼Œæ¯æ¬¡è‡ªå¢çš„æ¬¡æ•°ä¸º 1->2->4->8 ç›´è‡³è¾¾åˆ°ssthreshï¼Œæ‰€ä»¥æ‹¥å¡çª—å£æ•´ä½“ä¸Šå‘ˆç°æŒ‡æ•°å¢é•¿çš„è¶‹åŠ¿ã€‚\n**3. clientrdt( )**\n`clientrdt( )` å‡½æ•°ä¸­å‘é€æ–¹æ¯å½“æ¥æ”¶åˆ°æ­£ç¡®çš„ ACK æŠ¥æ–‡ï¼Œå°±ä¼šå°†å…¶æ‹¥å¡çª—å£å¢å¤§ 1 ä¸ª MSSã€‚\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //æ…¢å¯åŠ¨\n        ``````    \n        else if(get_ack(pkt) > sock->window.wnd_send->base){ // new ack\n            sock->window.wnd_send->cwnd += MSS;\n            \n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            ``````\n        }\n        ``````\n    }\n    ``````\n}\n```\n**4. resend_pkt( )**\n`resend_pkt( )` å‡½æ•°ä¸­å¤„ç†è¶…æ—¶é‡ä¼ å¯¼è‡´æ…¢å¯åŠ¨å‚æ•°å˜åŒ–ã€‚\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    ``````\n    if (nowtimeval > timeoutval){\n        sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2; //æ‹¥å¡é˜ˆå€¼å˜æˆæ‹¥å¡çª—å£å¤§å°çš„ä¸€åŠ\n        if(sock->window.wnd_send->ssthresh < MAX_DLEN) sock->window.wnd_send->ssthresh = MSS; //è°ƒæ•´\n        sock->window.wnd_send->cwnd = MSS; //æ‹¥å¡çª—å£å˜æˆ1MSS\n        sock->window.wnd_send->congestion_status = SLOW_START; //æ‹¥å¡çŠ¶æ€ä¸å˜\n    }\n    ``````\n}\n```\n### æ‹¥å¡é¿å…\n**1. æ‹¥å¡çª—å£è¶…è¿‡ ssthresh è¿›å…¥æ‹¥å¡é¿å…çŠ¶æ€ã€‚**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //æ…¢å¯åŠ¨\n        ``````\n        if(sock->window.wnd_send->cwnd >= sock->window.wnd_send->ssthresh){ //cwndè¾¾åˆ°ssthreshï¼Œè½¬ä¸ºæ‹¥å¡é¿å…çŠ¶æ€\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n        ``````\n    }\n    ``````\n}\n```\n**2. å¿«é€Ÿæ¢å¤é˜¶æ®µæ”¶åˆ°æ­£ç¡®çš„ ACK ä½¿å¾—å‘é€æ–¹ä»å…¶ä»–çŠ¶æ€è¿›å…¥æ‹¥å¡é¿å…çŠ¶æ€ã€‚**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //å¿«é€Ÿæ¢å¤\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n          \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n}\n```\n**3. åœ¨æ‹¥å¡é¿å…çŠ¶æ€ä¸‹ï¼Œå‘é€æ–¹æ¯å½“æ”¶åˆ°ä¸€ä¸ªæ­£ç¡®çš„ ACK æŠ¥æ–‡ï¼Œæ‹¥å¡çª—å£å°±ä¼šå¢å¤§ï¼ˆ1/cwndï¼‰ä¸ª MSSã€‚æ‹¥å¡çª—å£æ•´ä½“ä¸Šå‘ˆç°çº¿æ€§å¢é•¿çš„è¶‹åŠ¿ã€‚**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    else if (sock->window.wnd_send->congestion_status == CONGESTION_AVOIDANCE) { //æ‹¥å¡é¿å…\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd += MSS * ((double)MSS / (double)sock->window.wnd_send->cwnd);\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n        }\n    }\n    ``````\n}\n```\n### å¿«é€Ÿæ¢å¤\n**1. `clientrdt( )` å‘é€æ–¹æ”¶åˆ° 3 ä¸ªå†—ä½™ ACK æ—¶ï¼Œè¿›å…¥å¿«é€Ÿæ¢å¤çŠ¶æ€ã€‚**\n```C\nif(sock->window.wnd_send->ack_cnt == 3){  //å¿«é€Ÿé‡ä¼ \n    sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2;\n    sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh + 3 * MSS;\n    sock->window.wnd_send->congestion_status = FAST_RECOVERY; //å¿«é€Ÿæ¢å¤\n    ``````\n}\n```\n**2. åœ¨å¿«é€Ÿæ¢å¤çŠ¶æ€ä¸‹ï¼Œå¦‚æœè¿˜æ˜¯æ”¶åˆ°å†—ä½™ ACKï¼Œé‚£ä¹ˆä¾ç„¶åœ¨æ­¤çŠ¶æ€ï¼Œcwnd+=MSSï¼›å½“æ”¶åˆ°æ­£ç¡® ACK æ—¶ï¼Œåˆ™è¿›å…¥æ‹¥å¡é¿å…çŠ¶æ€ ï¼Œcwnd=ssthreshï¼›å½“è¶…æ—¶æ—¶ï¼Œå›åˆ°æ…¢å¯åŠ¨ï¼Œcwnd=1MSSã€‚**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    ``````\n    ``````    \n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //å¿«é€Ÿæ¢å¤\n        if(get_ack(pkt) == sock->window.wnd_send->base){//dup ack\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt++;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n            sock->window.wnd_send->cwnd += MSS;\n                        \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = FAST_RECOVERY;\n            return;\n        }\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));  \n         \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n    ``````\n    ``````\n}\n```","tags":["å®è·µ","è®¡ç®—æœºç½‘ç»œ"]},{"title":"Cè¯­è¨€æ‰‹å†™Httpdç½‘ç«™æœåŠ¡å™¨","url":"/2024/09/26/Cè¯­è¨€æ‰‹å†™Httpdç½‘ç«™æœåŠ¡å™¨/","content":"\n---\n## æ‰§è¡ŒWEBæœåŠ¡å‰çš„å‡†å¤‡å·¥ä½œ\n### åˆ›å»ºé¡¹ç›®\n```C\n#include <stdio.h>\n\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port){\n    return 0;\n}\n\nint main(void){\n    //httpdé»˜è®¤çš„ç«¯å£æ˜¯80ï¼Œè¿™é‡ŒæŒ‡å®šäº†8000ç«¯å£ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å…¶å®ƒç«¯å£\n    unsigned short port = 8000;\n\n    // åˆå§‹åŒ–ç½‘ç»œï¼Œå¹¶ä½¿ç”¨æŒ‡å®šç«¯å£æ¥åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\n    int server_sock = startup(&port);\n    printf(\"httpd running on port %d\\n\", port);\n\n    return(0);\n}\n```\n### ç½‘ç»œé€šä¿¡åˆå§‹åŒ–\n```C\n//ç½‘ç»œé€šä¿¡éœ€è¦åŒ…å«çš„å¤´æ–‡ä»¶ã€éœ€è¦åŠ è½½çš„åº“æ–‡ä»¶\n#include <winsock2.h>\n#pragma comment (lib, \"WS2_32.lib\")\n\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port) {\n    WSADATA wsaData; // ç½‘ç»œé€šä¿¡ç›¸å…³çš„ç‰ˆæœ¬ç­‰ä¿¡æ¯\n    int ret = WSAStartup( // WSAStartup ç½‘ç»œé€šä¿¡åˆå§‹åŒ–ï¼Œ\n        MAKEWORD(1, 1),   // æŒ‡å®šä½¿ç”¨Windows Socketsè§„èŒƒçš„1.1ç‰ˆæœ¬\n        &wsaData);        // å­˜å‚¨åˆå§‹åŒ–åçš„ç‰ˆæœ¬ç­‰ä¿¡æ¯ç»“æœ\n    if (ret) {\n        return -1;\n    }\n\n    return 0;\n}\n```\n### åˆ›å»ºå¥—æ¥å­—\n```C\nvoid error_die(const char* sc) {\n    perror(sc); //æ‰“å°é”™è¯¯åŸå› \n    exit(1);\n}\n\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port) {\n    int server_socket = socket(PF_INET, //å¥—æ¥å­—çš„ç±»å‹ï¼ˆç½‘ç»œå¥—æ¥å­—ã€æ–‡ä»¶å¥—æ¥å­—ï¼Œæ­¤å¤„æ˜¯å‰è€…ï¼‰\n        SOCK_STREAM,  //æ•°æ®åŒ…çš„ç±»å‹ï¼ˆæ•°æ®æµã€æ•°æ®æŠ¥ï¼Œæ­¤å¤„æ˜¯å‰è€…ï¼‰               \n        IPPROTO_TCP); //å…·ä½“åè®®\n    if (server_socket == -1) { //æ‰“å°é”™è¯¯æç¤ºï¼Œå¹¶ç»“æŸç¨‹åº\n        error_die(\"socket\");\n    }\n}\n```\n### è®¾ç½®å¥—æ¥å­—å±æ€§--ç«¯å£å¯å¤ç”¨\n```C\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port) {\n    //è®¾ç½®ç«¯å£å¯å¤ç”¨ï¼ˆç«¯å£å¤ç”¨ï¼‰\n    int opt = 1;\n    ret = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n    if (ret == -1) {\n        error_die(\"setsockopt\");\n    }\n}\n```\n### ç»‘å®šå¥—æ¥å­—å’Œç½‘ç»œåœ°å€\n```C\nint startup(unsigned short* port) {\n    //é…ç½®æœåŠ¡å™¨çš„ç½‘ç»œåœ°å€\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(*port);\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    //ç»‘å®šå¥—æ¥å­—\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        error_die(\"[bind]\");\n    }\n}\n```\n### è·å–åŠ¨æ€ç«¯å£\n```C\nint startup(unsigned short* port) {\n    // åŠ¨æ€åˆ†é…ç«¯å£\n    if (*port == 0) {\n        int namelen = sizeof(server_addr);\n        if (getsockname(server_socket, (struct sockaddr*)&server_addr, &namelen) <0) {\n            error_die(\"getsockname\");\n        }\n        *port = ntohs(server_addr.sin_port);\n    }\n    return server_socket;\n}\n```\n### åˆ›å»ºç›‘å¬é˜Ÿåˆ—\n```C\nint startup(unsigned short* port) {\n    //åˆ›å»ºç›‘å¬é˜Ÿåˆ—\n    if (listen(server_socket, 5) < 0) {\n        error_die(\"listen\");\n    }\n    return server_socket;\n}\n```","tags":["c","æœåŠ¡å™¨"]},{"title":"Cè¯­è¨€æ‰‹å†™æ¤ç‰©å¤§æˆ˜åƒµå°¸","url":"/2024/09/26/Cè¯­è¨€æ‰‹å†™æ¤ç‰©å¤§æˆ˜åƒµå°¸/","content":"\n---\n## Cè¯­è¨€æ‰‹å†™æ¤ç‰©å¤§æˆ˜åƒµå°¸\n### åˆ›å»ºä¸»åœºæ™¯\n```C\n#include<stdio.h>\n#include<graphics.h>\n\n#define WIN_WIDTH 900\n#define WIN_HEIGHT 600\n\nIMAGE imgBg;\n\n//æ¸¸æˆåˆå§‹åŒ–\nvoid gameInit() {\n\tloadimage(&imgBg, \"res/bg.jpg\");\n\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT);\n}\n\n//æ›´æ–°çª—å£\nvoid updateWindow() {\n\tputimage(0, 0, &imgBg);\n}\n\nint main(void) {\n\t//æ¸¸æˆåˆå§‹åŒ–\n\tgameInit();\n\n\t//æ›´æ–°çª—å£\n\tupdateWindow();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### å®ç°æ¤ç‰©å¡ç‰Œ\n```C\n#include \"tools.h\"\n\n//#define ZHI_WU_CUNT 3\n\nenum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT };\n\nIMAGE imgBar;\nIMAGE imgCards[ZHI_WU_COUNT];\n\nvoid gameInit() {\n\tloadimage(&imgBar, \"res/bar.png\");\n\n\t//åˆå§‹åŒ–æ¤ç‰©å¡ç‰Œ\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\t//ç”Ÿæˆæ¤ç‰©å¡ç‰Œçš„æ–‡ä»¶å\n\t\tsprintf_s(name, sizeof(name), \"res/Cards/card_%d.png\", i + 1);\n\t\tloadimage(&imgCards[i], name);\n\t}\n}\n\nvoid updateWindow() {\n\t//putimage(250, 0, &imgBar); //æœ‰é»‘è¾¹\n\tputimagePNG(250, 0, &imgBar);\n\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tint x = 338 + i * 65;\n\t\tint y = 6;\n\t\tputimage(x, y, &imgCards[i]);\n\t}\n}\n```\n### å®ç°æ¤ç‰©çš„é€‰æ‹©å’Œæ‹–åŠ¨\n```C\nIMAGE* imgZhiWu[ZHI_WU_COUNT][20];\n\nint curX, curY; //å½“å‰é€‰ä¸­çš„æ¤ç‰©ï¼Œåœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­çš„ä½ç½®\nint curZhiWu; //0:æ²¡æœ‰é€‰ä¸­ï¼Œ1:é€‰æ‹©äº†ç¬¬ä¸€ç§æ¤ç‰© etc.\n\nbool fileExist(const char* name) {\n\tFILE* fp = fopen(name, \"r\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfclose(fp);\n\t\treturn true;\n\t}\n}\n\nvoid gameInit() {\n\tmemset(imgZhiWu, 0, sizeof(imgZhiWu));\n\n\t//åˆå§‹åŒ–æ¤ç‰©å¡ç‰Œ\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tsprintf_s(name, sizeof(name), \"res/zhiwu/%d/%d.png\", i, j + 1);\n\t\t\t//å…ˆåˆ¤æ–­è¿™ä¸ªæ–‡ä»¶æ˜¯å¦å­˜åœ¨\n\t\t\tif (fileExist(name)) {\n\t\t\t\timgZhiWu[i][j] = new IMAGE;\n\t\t\t\tloadimage(imgZhiWu[i][j], name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurZhiWu = 0;\n\t//åˆ›å»ºæ¸¸æˆçš„å›¾å½¢çª—å£\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT, 1); //åŠ ä¸€ä¸ªå‚æ•°1ï¼Œä¿ç•™åå°ç•Œé¢ï¼Œæ–¹ä¾¿è°ƒè¯•\n}\n\nvoid updateWindow() {\n\tBeginBatchDraw(); //å¼€å§‹ç¼“å†²ï¼ˆå…ˆæ‰“å°åˆ°å†…å­˜ä¸­ï¼‰\n\n\t//æ¸²æŸ“ æ‹–åŠ¨è¿‡ç¨‹ä¸­çš„æ¤ç‰©\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //ç»“æŸåŒç¼“å†²ï¼ˆå†ä¸€æ¬¡æ€§æ‰“å°åˆ°çª—å£ï¼‰\n}\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;//çŠ¶æ€å˜é‡ï¼ˆå…ˆç‚¹å‡»å†æ‹–åŠ¨ï¼‰\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //å·¦å‡»æŒ‰ä¸‹\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\t\t\t\tint index = (msg.x - 338) / 65; //é€‰æ‹©å¡ç‰Œåºå·\n\t\t\t\tprintf(\"%d\\n\", index);\n\t\t\t\tstatus = 1; //å¯ä»¥æ‹–åŠ¨\n\t\t\t\tcurZhiWu = index + 1;\n\t\t\t}\n\t\t}\n\t\telse if (msg.message == WM_MOUSEMOVE && status == 1) { //é¼ æ ‡ç§»åŠ¨\n\t\t\tcurX = msg.x;\n\t\t\tcurY = msg.y;\n\n\t\t}\n\t\telse if (msg.message == WM_LBUTTONUP) { //å·¦é”®æŠ¬èµ·\n\n\t\t}\n\t}\n\n}\nint main(void) {\n\tgameInit();\n\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### å®ç°æ¤ç‰©çš„ç§æ¤\n```C\nstruct zhiwu {\n\tint type;\t\t//0:æ²¡æœ‰é€‰ä¸­ï¼Œ1:ç¬¬ä¸€ç§æ¤ç‰©\tetc.\t\t\t\t\n\tint frameIndex; //åºåˆ—å¸§çš„åºå·\n};\n\nstruct zhiwu map[3][9];\n\nvoid gameInit() {\n\tmemset(map, 0, sizeof(map));\n}\n\nvoid updateWindow() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tint x = 256 + j * 81;\n\t\t\t\tint y = 179 + i * 102 + 14;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tputimagePNG(x, y, imgZhiWu[zhiWuType][index]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid userClick() {\n\tif (peekmessage(&msg)) {\n\t\telse if (msg.message == WM_LBUTTONUP) { //å·¦é”®æŠ¬èµ·\n\t\t\tif (msg.x > 256 && msg.y > 179 && msg.y < 489) {\n\t\t\t\tint row = (msg.y - 179) / 102;\n\t\t\t\tint col = (msg.x - 256) / 81;\n\t\t\t\t//printf(\"%d, %d\\n\", row, col);\n\t\t\t\tif (map[row][col].type == 0) {\n\t\t\t\t\tmap[row][col].type = curZhiWu;\n\t\t\t\t\tmap[row][col].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurZhiWu = 0;\n\t\t\tstatus = 0;\n\t\t}\n\t}\n}\n```\n### å®ç°æ¤ç‰©çš„æ‘‡æ‘†\n```C\n//æ›´æ–°æ¸¸æˆç›¸å…³æ•°æ®\nvoid updateGame() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tmap[i][j].frameIndex++;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tif (imgZhiWu[zhiWuType][index] == NULL) {\n\t\t\t\t\tmap[i][j].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t\tupdateGame(); //æ›´æ–°æ¸¸æˆç›¸å…³æ•°æ®\n\n\t\tSleep(10);//å¸§ç­‰å¾…\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### ä¼˜åŒ–æ¸¸æˆå¾ªç¯å’Œæ¸¸æˆæ¸²æŸ“å¾ªåº\n```C\nvoid updateWindow() {\n\tBeginBatchDraw(); //å¼€å§‹ç¼“å†²\n\n\t//æ¸²æŸ“ æ‹–åŠ¨è¿‡ç¨‹ä¸­çš„æ¤ç‰©ï¼ˆæ”¾åˆ°äº†æœ€åï¼‰\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //ç»“æŸåŒç¼“å†²\n}\n\nint main(void) {\n\tgameInit();\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### åˆ¶ä½œå¯åŠ¨èœå•\n```C\nvoid startUI() { //å¯åŠ¨èœå•\n\tIMAGE imgBg,imgMenu1,imgMenu2;\n\tloadimage(&imgBg, \"res/menu.png\");\n\tloadimage(&imgMenu1, \"res/menu1.png\");\n\tloadimage(&imgMenu2, \"res/menu2.png\");\n\n\tint flag = 0;\n\twhile (1) {\n\t\tBeginBatchDraw();\n\t\tputimage(0, 0, &imgBg);\n\t\tputimagePNG(474, 75, flag ? &imgMenu2: &imgMenu1);\n\n\t\tExMessage msg;\n\t\tif (peekmessage(&msg)) {\n\t\t\tif (msg.message == WM_LBUTTONDOWN&&\n\t\t\t\t\tmsg.x>474&&msg.x<474+300&&\n\t\t\t\t\tmsg.y>75&&msg.y<75+140){\n\t\t\t\tflag = 1;\n\t\t\t\t//EndBatchDraw();\n\t\t\t}\n\t\t\telse if (msg.message == WM_LBUTTONUP&&flag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEndBatchDraw();\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\n\tstartUI();\n\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\n\t\tSleep(10);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### åˆ›å»ºéšæœºé˜³å…‰\n```C\n#include<time.h>\n\nstruct sunshineBall {\n\tint x, y; //é˜³å…‰çƒåœ¨é£˜è½è¿‡ç¨‹ä¸­çš„åæ ‡ä½ç½®ï¼ˆxä¸å˜ï¼‰\n\tint frameIndex; //å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡å¸§çš„åºå·\n\tint destY; //é£˜è½çš„ç›®æ ‡ä½ç½®çš„yåæ ‡\n\tbool used; //æ˜¯å¦åœ¨ä½¿ç”¨\n};\n\n//é˜³å…‰æ± \nstruct sunshineBall balls[10];\nIMAGE imgSunshineBall[29];\n\n\nvoid gameInit() {\n\tmemset(balls, 0, sizeof(balls));\n\tfor (int i = 0; i < 29; i++) {\n\t\tsprintf_s(name, sizeof(name), \"res/sunshine/%d.png\", i + 1);\n\t\tloadimage(&imgSunshineBall[i], name);\n\t}\n\n\t//é…ç½®éšæœºç§å­\n\tsrand(time(NULL));\n}\n\nvoid creatSunshine() {\n\tstatic int count = 0;\n\tstatic int fre = 400;\n\tcount++;\n\tif (count >= fre) { //æ¯freå¸§åˆ›å»ºä¸€ä¸ªé˜³å…‰ï¼Œfreéšæœºæ”¹å˜\n\t\tfre = 200 + rand() % 200;\n\t\tcount = 0;\n\n\t\t//ä»é˜³å…‰æ± ä¸­å–ä¸€ä¸ªå¯ä»¥ä½¿ç”¨çš„\n\t\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\n\t\tint i;\n\t\tfor (i = 0; i < ballMax && balls[i].used; i++);\n\t\tif (i >= ballMax) return;\n\n\t\tballs[i].used = true;\n\t\tballs[i].frameIndex = 0;\n\t\tballs[i].x = 260 + rand() % (900 - 260);\n\t\tballs[i].y = 60;\n\t\tballs[i].destY = 200 + (rand() % 4) * 90;\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine();\n}\n```\n### æ˜¾ç¤ºéšæœºé˜³å…‰\n```C\nstruct sunshineBall {\n\tint x, y; //é˜³å…‰çƒåœ¨é£˜è½è¿‡ç¨‹ä¸­çš„åæ ‡ä½ç½®ï¼ˆxä¸å˜ï¼‰\n\tint frameIndex; //å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡å¸§çš„åºå·\n\tint destY; //é£˜è½çš„ç›®æ ‡ä½ç½®çš„yåæ ‡\n\tbool used; //æ˜¯å¦åœ¨ä½¿ç”¨\n\tint timer; //è®¡æ—¶å™¨\n};\n\nvoid updateWindow() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tIMAGE* img = &imgSunshineBall[balls[i].frameIndex];\n\t\t\tputimagePNG(balls[i].x, balls[i].y, img);\n\t\t}\n\t}\n}\n\t\nvoid creatSunshine() {\n\tif (count >= fre) {\n\t\tballs[i].timer = 0;\n\t}\n}\n\nvoid updateSunshine() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tballs[i].frameIndex = (balls[i].frameIndex + 1) % 29;\n\t\t\tif (balls[i].timer == 0) { //æœªåˆ°è¾¾åœ°é¢\n\t\t\t\tballs[i].y += 2;\n\t\t\t}\n\t\t\tif (balls[i].y >= balls[i].destY) {\n\t\t\t\t//balls[i].used = false;\n\t\t\t\tballs[i].timer++;\n\t\t\t\tif (balls[i].timer > 100) { //æ‰åˆ°åœ°é¢100å¸§ä¹‹å\n\t\t\t\t\tballs[i].used = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine(); //åˆ›å»ºé˜³å…‰\n\tupdateSunshine(); //æ›´æ–°é˜³å…‰çš„çŠ¶æ€\n}\n```\n### æ”¶é›†é˜³å…‰ã€æ˜¾ç¤ºé˜³å…‰å€¼\n```C\n#include<mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\nint sunshine; //æ€»é˜³å…‰å€¼\n\nvoid gameInit() {\n\tsunshine = 150;\n\n\t//è®¾ç½®å­—ä½“\n\tLOGFONT f;\n\tgettextstyle(&f);                     // è·å–å½“å‰å­—ä½“è®¾ç½®\n\tf.lfHeight = 30;                      // è®¾ç½®å­—ä½“é«˜åº¦ä¸º 48\n\tf.lfWidth = 15;\n\tstrcpy(f.lfFaceName, \"Segoe UI Black\"); \n\tf.lfQuality = ANTIALIASED_QUALITY;    // è®¾ç½®è¾“å‡ºæ•ˆæœä¸ºæŠ—é”¯é½¿  \n\tsettextstyle(&f);                     // è®¾ç½®å­—ä½“æ ·å¼\n\tsetbkmode(TRANSPARENT);\t\t\t\t  //èƒŒæ™¯æ¨¡å¼é€æ˜\n\tsetcolor(BLACK);\t\t\t\t\t  //å­—ä½“é¢œè‰²\n}\n\nvoid updateWindow() {\n\tchar scoreText[8];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", sunshine);\n\touttextxy(276, 67, scoreText); //åœ¨æŒ‡å®šä½ç½®è¾“å‡ºæ–‡æœ¬--åˆ†æ•°\n}\n\nvoid collectSunshine(ExMessage* msg) {\n\tint count = sizeof(balls) / sizeof(balls[0]);\n\tint w = imgSunshineBall[0].getwidth(); //é˜³å…‰çƒå®½åº¦\n\tint h = imgSunshineBall[0].getheight();//é˜³å…‰çƒé«˜åº¦\n\tfor (int i = 0; i < count; i++) {\n\t\tif (balls[i].used) {\n\t\t\tint x = balls[i].x;\n\t\t\tint y = balls[i].y;\n\t\t\tif (msg->x > x && msg->x < x + w && msg->y > y && msg->y < y + h) {\n\t\t\t\tballs[i].used = false;\n\t\t\t\tsunshine += 25;\n\t\t\t\tmciSendString(\"play res/sunshine.mp3\", 0, 0, 0); //æ·»åŠ éŸ³æ•ˆ\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //å·¦å‡»æŒ‰ä¸‹\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollectSunshine(&msg);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```","tags":["c","PvZ"]},{"title":"Java ç»¼åˆå®æˆ˜ï¼ˆä¸€ï¼‰","url":"/2024/09/24/Java ç»¼åˆå®æˆ˜/","content":"\n---\n## Java ç»¼åˆå®æˆ˜ï¼ˆä¸€ï¼‰\n### å¥åº·è®¡ç®—å™¨\n**éœ€æ±‚ï¼šå¼€å‘ä¸€ä¸ªç®€å•çš„å¥åº·è®¡ç®—å™¨åº”ç”¨ç¨‹åºï¼Œå®ƒå¯ä»¥æ¥å—ç”¨æˆ·çš„è¾“å…¥ï¼ˆå¦‚å¹´é¾„ã€æ€§åˆ«ã€ä½“é‡ã€èº«é«˜ï¼‰ï¼Œå¹¶è®¡ç®—å‡ºç”¨æˆ·çš„ BMIï¼ˆèº«ä½“è´¨é‡æŒ‡æ•°ï¼‰å’Œ BMRï¼ˆåŸºç¡€ä»£è°¢ç‡ï¼‰ã€‚**\n```Java\npackage test;\n\nimport java.util.Scanner;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„èº«é«˜ï¼š\");\n        double height=sc.nextDouble();\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„ä½“é‡ï¼š\");\n        double weight=sc.nextDouble();\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„æ€§åˆ«ï¼ˆç”·/å¥³ï¼‰ï¼š\");\n        String sex=sc.next();\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„å¹´é¾„ï¼š\");\n        int age=sc.nextInt();\n\n        double bmi=calcBMI(height,weight);\n        System.out.println(\"æ‚¨çš„BMIå€¼ä¸ºï¼š\"+bmi);\n\n        double bmr=calcBMR(height,weight,age,sex);\n        System.out.println(\"æ‚¨çš„BMRå€¼ä¸ºï¼š\"+bmr);\n    }\n\n    public static double calcBMI(double height,double weight){\n        return weight/(height*height);\n    }\n\n    public static double calcBMR(double height,double weight,int age,String sex){\n        double bmr=0;\n        if(sex.equals(\"ç”·\")){\n            bmr=88.362+13.397*weight+4.799*height-5.677*age;\n        }\n        else{\n            bmr=447.593+9.247*weight+3.098*height-4.330*age;\n        }\n        return bmr;\n    }\n}\n```\n### ç®€å•è®¡ç®—å™¨\n**éœ€æ±‚ï¼šè®¾è®¡ä¸€ä¸ªå¯ä»¥æ‰§è¡ŒåŸºæœ¬æ•°å­¦è¿ç®—ï¼ˆåŠ ã€å‡ã€ä¹˜ã€é™¤ï¼‰çš„è®¡ç®—å™¨ç¨‹åºã€‚** \n**åŠŸèƒ½æè¿°ï¼šç”¨æˆ·è¾“å…¥ä¸¤ä¸ªæ•°å­—ã€ä¸€ä¸ªè¿ç®—ç¬¦ï¼ˆ+ã€-ã€*ã€/ï¼‰ã€‚æ ¹æ®æ‰€é€‰è¿ç®—ç¬¦æ‰§è¡Œç›¸åº”çš„æ•°å­¦è¿ç®—ï¼Œæ˜¾ç¤ºè¿ç®—ç»“æœã€‚**\n```Java\npackage test1;\n\nimport java.util.Scanner;\n\npublic class test1 {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"è¯·è¾“å…¥ç¬¬ä¸€ä¸ªæ•°å­—ï¼š\");\n        double num1=sc.nextDouble();\n\n        System.out.println(\"è¯·è¾“å…¥ç¬¬äºŒä¸ªæ•°å­—ï¼š\");\n        double num2=sc.nextDouble();\n\n        System.out.println(\"è¯·è¾“å…¥è¿ç®—ç¬¦ï¼ˆ+ã€-ã€*ã€/ï¼‰ï¼š\");\n        String operator=sc.next();\n\n        double result=calculate(num1,num2,operator);\n        System.out.println(\"è®¡ç®—ç»“æœä¸ºï¼š\"+result);\n    }\n\n    public static double calculate(double num1,double num2,String operator){\n        double result=0;\n        switch (operator){\n            case \"+\":\n                result=num1+num2;\n                break;\n            case \"-\":\n                result=num1-num2;\n                break;\n            case \"*\":\n                result=num1*num2;\n                break;\n            case \"/\":\n                result=num1/num2;\n                break;\n            default:\n                System.out.println(\"è¾“å…¥çš„è¿ç®—ç¬¦æœ‰è¯¯ï¼\");\n        }\n        return result;\n    }\n}\n```\n### çŒœæ•°å­—å°æ¸¸æˆ\n**éœ€æ±‚ï¼šéšæœºç”Ÿæˆä¸€ä¸ª1-100ä¹‹é—´çš„æ•°æ®ï¼Œæç¤ºç”¨æˆ·çŒœæµ‹ï¼ŒçŒœå¤§æç¤ºè¿‡å¤§ï¼ŒçŒœå°æç¤ºè¿‡å°ï¼Œç›´åˆ°çŒœä¸­ç»“æŸæ¸¸æˆã€‚**\n```Java\npackage test1;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class test2 {\n    public static void main(String[] args) {\n        guessNumber();\n    }\n\n    public static void guessNumber(){\n        /*æ–¹æ³•ä¸€*/\n        //Math.random()è¿”å›[0,1)ä¹‹é—´çš„éšæœºå°æ•°\n        //(int)(Math.random()*100)==>[0,100)çš„æ•´æ•°==>[0,99]+1==>[1,100]\n        //int number=(int)(Math.random()*100)+1;\n\n        /*æ–¹æ³•äºŒ*/\n        Random r=new Random();\n        int number=r.nextInt(100)+1;\n\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            System.out.println(\"è¯·è¾“å…¥ä¸€ä¸ª1~100ä¹‹é—´çš„æ•°å­—ï¼š\");\n            int guess=sc.nextInt();\n            if(guess<number){\n                System.out.println(\"çŒœå°äº†ï¼Œå†è¯•è¯•å§ï¼\");\n            }\n            else if(guess>number){\n                System.out.println(\"çŒœå¤§äº†ï¼Œå†è¯•è¯•å§ï¼\");\n            }\n            else{\n                System.out.println(\"æ­å–œä½ çŒœå¯¹äº†ï¼\");\n                break;\n            }\n        }\n    }\n}\n```\n### å¼€å‘ä¸€ä¸ªéªŒè¯ç \n**éœ€æ±‚ï¼šå¼€å‘ä¸€ä¸ªç¨‹åºï¼Œå¯ä»¥ç”ŸæˆæŒ‡å®šä½æ•°çš„éªŒè¯ç ï¼Œæ¯ä½å¯ä»¥æ˜¯æ•°å­—ï¼Œå¤§å°å†™å­—æ¯ã€‚**\n```Java\npackage test1;\n\npublic class test3 {\n    public static void main(String[] args) {\n        System.out.println(getCode(6));\n    }\n\n    public static String getCode(int n){\n        String code=\"\";\n\n        for(int i=0;i<n;i++){\n            int type=(int)(Math.random()*3); //æ•°å­—0/å¤§å†™1/å°å†™2\n            \n            switch(type){\n                case 0:\n                    int num=(int)(Math.random()*10);\n                    code+=num;\n                    break;\n                case 1:\n                    int num1=(int)(Math.random()*26)+65;\n                    code+=(char)num1;\n                    break;\n                case 2:\n                    int num2=(int)(Math.random()*26)+97;\n                    code+=(char)num2;\n                    break;\n            }\n        }\n        return code;\n    }\n}\n```\n### æ‰¾ç´ æ•°\n**éœ€æ±‚ï¼šè¾“å‡º101-200ä¹‹é—´çš„æ‰€æœ‰ç´ æ•°ä»¥åŠæ€»ä¸ªæ•°ã€‚**\n```Java\npackage test1;\n\npublic class test4 {\n    public static void main(String[] args) {\n        //ç›®æ ‡ï¼šæ‰¾å‡º101-200ä¹‹é—´çš„å…¨éƒ¨ç´ æ•°\n        int count=0;\n        for(int i=101;i<=200;i++){\n            if(isPrime(i)){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println(\"ç´ æ•°çš„ä¸ªæ•°ä¸ºï¼š\"+count);\n    }\n\n    public static boolean isPrime(int num){\n        for(int i=2;i*i<=num;i++){\n            if(num%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n### æ–—åœ°ä¸»æ¸¸æˆ\n**éœ€æ±‚ï¼šå¼€å‘ä¸€ä¸ªç®€æ˜“ç‰ˆçš„æ–—åœ°ä¸»æ¸¸æˆï¼Œè¦æ±‚åªå®Œæˆåšç‰Œï¼ˆå­˜å‚¨54å¼ ç‰Œï¼‰ã€æ´—ç‰Œã€‚**\n```Java\npackage test2;\n\npublic class test1 {\n    public static void main(String[] args) {\n       start();\n    }\n    public static void start(){\n        String[] poker=new String[54];\n        String[] colors={\"â™ \",\"â™¥\",\"â™£\",\"â™¦\"};\n        String[] nums={\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"};\n\n        int index=0;\n        for(int i=0;i<colors.length;i++){\n            for(int j=0;j<nums.length;j++){\n                poker[index++]=colors[i]+nums[j];\n            }\n        }\n        poker[index++]=\"Big Joker\";\n        poker[index++]=\"Small Joker\";\n\n        //æ‰“å°ç‰Œ\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n\n        //æ´—ç‰Œ\n        for(int i=0;i<poker.length;i++){\n            int j=(int)(Math.random()*poker.length);\n            String temp=poker[i];\n            poker[i]=poker[j];\n            poker[j]=temp;\n        }\n\n        System.out.println(\"æ´—ç‰Œåï¼š\");\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n    }\n}\n```\n### çŸ³å¤´è¿·é˜µæ¸¸æˆ\n**éœ€æ±‚ï¼šåªéœ€å®Œæˆæ•°æ®åˆå§‹åŒ–**\n```Java\npackage test2;\n\npublic class test2 {\n    public static void main(String[] args) {\n        start(5);\n    }\n    public static void start(int n) {\n       int[][] arr=new int[n][n];\n\n       int count=1;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               arr[i][j]=count++;\n           }\n       }\n\n       print(arr);\n\n       //æ‰“ä¹±äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ é¡ºåº\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                int x=(int)(Math.random()*arr.length);\n                int y=(int)(Math.random()*arr[i].length);\n                int temp=arr[i][j];\n                arr[i][j]=arr[x][y];\n                arr[x][y]=temp;\n            }\n        }\n        System.out.println(\"------------------\");\n        System.out.println(\"æ‰“ä¹±åï¼š\");\n        print(arr);\n    }\n    public static void print(int[][] arr){\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                System.out.print(arr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```","tags":["Java"]},{"title":"Markdown è¯­æ³•","url":"/2024/09/09/Markdownè¯­æ³•/","content":"\n## Markdown æ ‡é¢˜\n``` markdown\n# ä¸€çº§æ ‡é¢˜\n\n## äºŒçº§æ ‡é¢˜\n\n### ä¸‰çº§æ ‡é¢˜\n\n#### å››çº§æ ‡é¢˜\n\n##### äº”çº§æ ‡é¢˜\n\n###### å…­çº§æ ‡é¢˜\n```\n&nbsp;**æˆ–è€…åœ¨æ–‡æœ¬ä¸‹æ–¹æ·»åŠ ä»»æ„æ•°é‡çš„ = æˆ– - åˆ†åˆ«ç”¨äºè¡¨ç¤ºä¸€çº§æ ‡é¢˜æˆ–äºŒçº§æ ‡é¢˜**\n``` markdown\nä¸€çº§æ ‡é¢˜\n=========\n\näºŒçº§æ ‡é¢˜\n---------\n```\n\n## Markdown å­—ä½“\n``` markdown\n*æ–œä½“æ–‡å­—*\n\n_æ–œä½“æ–‡å­—_\n\n**ç²—ä½“æ–‡å­—**\n\n__ç²—ä½“æ–‡å­—__\n\n***ç²—æ–œä½“æ–‡å­—***\n\n___ç²—æ–œä½“æ–‡å­—___\n```\n\n## Markdown å¼•ç”¨\n``` markdown\n>è¿™æ˜¯å¼•ç”¨çš„å†…å®¹\n\n>>è¿™æ˜¯å¼•ç”¨çš„å†…å®¹\n\n>>>>>>>>>>è¿™æ˜¯å¼•ç”¨çš„å†…å®¹\n```\n\n## Markdown åˆ†å‰²çº¿\n&nbsp;**ä¸‰ä¸ªæˆ–è€…ä¸‰ä¸ªä»¥ä¸Šçš„ - æˆ–è€… * æˆ–è€… _ éƒ½å¯ä»¥**\n``` markdown\n---\n\n****\n\n____\n```\n  \n## Markdown ä¸‹åˆ’çº¿\n``` markdown\n<u>å¸¦ä¸‹åˆ’çº¿æ–‡æœ¬</u>   \n```\n\n## Markdown åˆ é™¤çº¿\n``` markdown \n~~tencent.com~~\n```\n\n## Markdown å›¾ç‰‡\n### æ’å…¥äº’è”ç½‘ä¸Šå›¾ç‰‡\n``` markdown\n![å›¾ç‰‡æè¿°](å›¾ç‰‡é“¾æ¥ ''å›¾ç‰‡title'')\n```\n>å›¾ç‰‡æè¿°å°±æ˜¯æ˜¾ç¤ºåœ¨å›¾ç‰‡ä¸‹é¢çš„æ–‡å­—ï¼Œç›¸å½“äºå¯¹å›¾ç‰‡å†…å®¹çš„è§£é‡Šã€‚\nå›¾ç‰‡titleæ˜¯å›¾ç‰‡çš„æ ‡é¢˜ï¼Œå½“é¼ æ ‡ç§»åˆ°å›¾ç‰‡ä¸Šæ—¶æ˜¾ç¤ºçš„å†…å®¹ã€‚\næ³¨æ„ï¼štitleå¯åŠ å¯ä¸åŠ ï¼Œå›¾ç‰‡æè¿°å¯å†™å¯ä¸å†™ã€‚\n\n### æ’å…¥æœ¬åœ°å›¾ç‰‡\n``` markdown\n![å›¾ç‰‡æè¿°](å›¾ç‰‡æœ¬åœ°è·¯å¾„ ''å›¾ç‰‡title'')\n```\n>å›¾ç‰‡æè¿°å°±æ˜¯æ˜¾ç¤ºåœ¨å›¾ç‰‡ä¸‹é¢çš„æ–‡å­—ï¼Œç›¸å½“äºå¯¹å›¾ç‰‡å†…å®¹çš„è§£é‡Šã€‚\nå›¾ç‰‡titleæ˜¯å›¾ç‰‡çš„æ ‡é¢˜ï¼Œå½“é¼ æ ‡ç§»åˆ°å›¾ç‰‡ä¸Šæ—¶æ˜¾ç¤ºçš„å†…å®¹ã€‚\næ³¨æ„ï¼štitleå¯åŠ å¯ä¸åŠ ï¼Œå›¾ç‰‡æè¿°å¯å†™å¯ä¸å†™ã€‚\n\n## Markdown è¶…é“¾æ¥\n``` markdown\n[è¶…é“¾æ¥å](è¶…é“¾æ¥åœ°å€ \"è¶…é“¾æ¥title\")\n```\n&nbsp;**æ³¨ï¼štitleå¯åŠ å¯ä¸åŠ **\n\n## Markdown åˆ—è¡¨\n### æ— åºåˆ—è¡¨\n&nbsp;**æ— åºåˆ—è¡¨ç”¨ - + * ä»»ä½•ä¸€ç§éƒ½å¯ä»¥**\n``` markdown\n* ç¬¬ä¸€é¡¹\n* ç¬¬äºŒé¡¹\n* ç¬¬ä¸‰é¡¹\n\n+ ç¬¬ä¸€é¡¹\n+ ç¬¬äºŒé¡¹\n+ ç¬¬ä¸‰é¡¹\n\n- ç¬¬ä¸€é¡¹\n- ç¬¬äºŒé¡¹\n- ç¬¬ä¸‰é¡¹\n```\n### æœ‰åºåˆ—è¡¨\n``` markdown\n1. ç¬¬ä¸€é¡¹\n2. ç¬¬äºŒé¡¹\n3. ç¬¬ä¸‰é¡¹\n```\n### åµŒå¥—åˆ—è¡¨\n&nbsp;**ä¸Šä¸€çº§å’Œä¸‹ä¸€çº§ä¹‹é—´æ•²ä¸€ä¸ªTabé”®å³å¯**\n``` markdown\n1. ç¬¬ä¸€é¡¹ï¼š\n    - ç¬¬ä¸€é¡¹åµŒå¥—çš„ç¬¬ä¸€ä¸ªå…ƒç´ \n    - ç¬¬ä¸€é¡¹åµŒå¥—çš„ç¬¬äºŒä¸ªå…ƒç´ \n2. ç¬¬äºŒé¡¹ï¼š\n    - ç¬¬äºŒé¡¹åµŒå¥—çš„ç¬¬ä¸€ä¸ªå…ƒç´ \n    - ç¬¬äºŒé¡¹åµŒå¥—çš„ç¬¬äºŒä¸ªå…ƒç´ \n```\n\n## Markdown è¡¨æ ¼\n``` markdown\n|è¡¨å¤´|è¡¨å¤´|è¡¨å¤´|\n|---|:--:|---:|\n|å†…å®¹|å†…å®¹|å†…å®¹|\n|å†…å®¹|å†…å®¹|å†…å®¹|\n```\n\n>ç¬¬äºŒè¡Œåˆ†å‰²è¡¨å¤´å’Œå†…å®¹\n>-æœ‰ä¸€ä¸ªå°±è¡Œï¼Œä¸ºäº†å¯¹é½ï¼Œå¤šåŠ äº†å‡ ä¸ª\n>æ–‡å­—é»˜è®¤å±…å·¦\n>-ä¸¤è¾¹åŠ ï¼šè¡¨ç¤ºæ–‡å­—å±…ä¸­\n>-å³è¾¹åŠ ï¼šè¡¨ç¤ºæ–‡å­—å±…å³\n\n## Markdown ä»£ç \n### å•è¡Œä»£ç \n``` markdown\n`hello world`\n```\n\n### ä»£ç å—\n``` markdown\n(```)è¯­è¨€\n  ä»£ç å†…å®¹\n(```)\n```\n\n## Markdown æµç¨‹å›¾\n``` markdown\n(```)flow\nst=>start: å¼€å§‹\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n(```)\n```\n## Markdown æ¢è¡Œ\n``` markdown\nè¿ç»­ä¸¤ä¸ªä»¥ä¸Šç©ºæ ¼+å›è½¦\n```\n&nbsp;**æˆ–è€…**\n``` markdown\nä½¿ç”¨htmlè¯­è¨€æ¢è¡Œæ ‡ç­¾<br>\n```\n\n## Markdown ç¼©è¿›å­—ç¬¦\n``` markdown\n&nbsp;  ç¼©è¿›1/4ä¸­æ–‡\n&ensp;  ç¼©è¿›åŠä¸ªä¸­æ–‡ï¼Œä¸€ä¸ªå­—ç¬¦\n&emsp;  ç¼©è¿›ä¸€ä¸ªä¸­æ–‡ï¼Œ2ä¸ªå­—ç¬¦\n```","tags":["Markdown"]},{"title":"Hello World","url":"/2024/09/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]