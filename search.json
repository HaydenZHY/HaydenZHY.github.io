[{"title":"æ•°å€¼è®¡ç®—æ–¹æ³•","url":"/2024/10/08/æ•°å€¼è®¡ç®—æ–¹æ³•/","content":"## æ’å€¼æ³•\n**è¦æ±‚ï¼šå®ç°èŒƒå¾·è’™å¾·å¤šé¡¹å¼æ’å€¼ã€æ‹‰æ ¼æœ—æ—¥æ’å€¼ã€ç‰›é¡¿æ’å€¼ã€åˆ†æ®µçº¿æ€§ã€åˆ†æ®µä¸‰æ¬¡Hermiteæ’å€¼ï¼Œå¹¶å®Œæˆå„æ–¹æ³•ä¹‹é—´çš„å¯¹æ¯”ã€‚**\n<font color=red>è¾“å…¥</font>ï¼šæ’å€¼åŒºé—´$[a, b]$ï¼Œå‚æ•°$c, d, e, f$ä½œä¸ºæ ‡å‡†å‡½æ•°$f(x) = c \\cdot \\sin(dx) + e \\cdot \\cos(fx)$çš„å€¼ï¼Œå‚æ•°$n+1$ä½œä¸ºé‡‡æ ·ç‚¹çš„ä¸ªæ•°ï¼Œå‚æ•°$m$ä½œä¸ºå®éªŒç‚¹çš„ä¸ªæ•°ã€‚\n<font color=red>è¦æ±‚</font>ï¼šè¦æ±‚ï¼šåœ¨åŒºé—´$[a, b]$ä¸Šå‡åŒ€é‡‡é›†ä¸ªé‡‡é›†ç‚¹ï¼Œåˆ©ç”¨è¿™$n+1$ä¸ªé‡‡é›†ç‚¹ï¼Œåˆ†åˆ«ä½¿ç”¨èŒƒå¾·è’™å¾·å¤šé¡¹å¼æ’å€¼ã€æ‹‰æ ¼æœ—æ—¥æ’å€¼ã€ç‰›é¡¿æ’å€¼ã€åˆ†æ®µçº¿æ€§ã€åˆ†æ®µä¸‰æ¬¡Hermiteæ’å€¼è¿›è¡Œæ’å€¼ï¼Œæ±‚å‡º$L(x)$ï¼Œä¹‹åå†é€‰å–$m$ä¸ªç‚¹ä½œä¸ºå®éªŒç‚¹ï¼Œè®¡ç®—åœ¨è¿™$m$ä¸ªå®éªŒç‚¹ä¸Šæ’å€¼å‡½æ•°$L(x)$ä¸ç›®æ ‡å‡½æ•°$f(x)$çš„å¹³å‡è¯¯å·®ã€‚åŒæ—¶å¯¹æ¯”å„æ’å€¼æ–¹æ³•ä¹‹é—´çš„ç²¾åº¦å·®å¼‚ã€‚\n<font color=red>è¾“å‡º</font>ï¼šå¯¹æ¯”å‡½æ•°æ›²çº¿ï¼Œå¹³å‡è¯¯å·®ã€‚\n```Python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# èŒƒå¾·è’™å¾·å¤šé¡¹å¼æ’å€¼\ndef vandermonde_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    c = []\n    for i in range(n):\n        coeff = []\n        for j in range(n):\n            coeff.append(x[i]**j)\n        coefficients.append(coeff)\n        c.append(y[i])\n    A = np.array(coefficients)\n    inv_A = np.linalg.inv(A)\n    a = inv_A.dot(c)\n    sum = 0\n    for i in range(n):\n        sum += a[i] * x_values ** i\n    return sum\n\n# æ‹‰æ ¼æœ—æ—¥æ’å€¼\ndef lagrange_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n):\n        p = y[i]\n        for j in range(n):\n            if j != i:\n                p *= (x_values - x[j]) / (x[i] - x[j])\n        result += p\n    return result\n\n# ç‰›é¡¿æ’å€¼\ndef newton_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    for i in range(n-1, 0, -1):\n        divided_diff = (y[i] - y[i-1]) / (x[i] - x[i-1])\n        coefficients.append(divided_diff)\n        for j in range(n-i-1, 0, -1):\n            divided_diff = (-divided_diff + coefficients[j-1]) / (x[n-j] - x[i-1])\n            coefficients[j-1] = divided_diff\n    coefficients.append(y[0])\n    result = coefficients[0]\n    for i in range(n-2, -1, -1):\n        result = result * (x_values - x[i]) + coefficients[n-1-i]\n    return result\n\n# åˆ†æ®µçº¿æ€§æ’å€¼\ndef piecewise_linear_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        mask = (x[i] <= x_values) & (x_values < x[i+1])\n        slope = (y[i+1] - y[i]) / (x[i+1] - x[i])\n        result += ((y[i] + slope * (x_values - x[i]))*mask)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# åˆ†æ®µä¸‰æ¬¡Hermiteæ’å€¼\ndef piecewise_cubic_hermite_interpolation(x, y, yy, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        if ((x[i] <= x_values) & (x_values < x[i+1])):\n            ai = (1+2*(x_values-x[i])/(x[i+1]-x[i]))*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            bi = (x_values - x[i])*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            ai1 = (1+2*(x_values-x[i+1])/(x[i]-x[i+1]))*((x_values-x[i])/(x[i+1]-x[i]))**2\n            bi1 = (x_values - x[i+1])*((x_values-x[i])/(x[i+1]-x[i]))**2\n            result += (y[i] * ai +yy[i] * bi +y[i+1] * ai1 +yy[i+1] * bi1)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# ç›®æ ‡å‡½æ•°\ndef target_function(c,d,e,f,x):\n    return [(c*np.sin(d*val)+e*np.cos(f*val)) for val in x] \n\n# ç›®æ ‡å‡½æ•°å¯¼å‡½æ•°\ndef derivative_function(c,d,e,f,x):\n    return [(c*d*np.cos(d*val)-e*f*np.sin(f*val)) for val in x]\n\n# è®¡ç®—å¹³å‡è¯¯å·®\ndef compute_average_error(f, g, x_values):\n    return sum([abs(f[i] - g[i]) for i in range(len(x_values))]) / len(x_values)\n\n# è®¾ç½®æ’å€¼åŒºé—´å’Œå‚æ•°\na = float(input())\nb = float(input())\nc = float(input())\nd = float(input())\ne = float(input())\nf = float(input())\nnum_samples = int(input())\nnum_experiments = int(input())\nx_values = [a + (b - a) * i / (num_samples - 1) for i in range(num_samples)]\nys = target_function(c,d,e,f,x_values)\nyy = derivative_function(c,d,e,f,x_values)\n\n# è®¡ç®—å®éªŒç‚¹\nexperiment_points = [a + (b - a) * i / (num_experiments - 1) for i in range(num_experiments)]\n\n# è®¡ç®—å„æ’å€¼æ–¹æ³•çš„æ’å€¼ç»“æœå’Œå¹³å‡è¯¯å·®\nvandermonde_interpolated = [vandermonde_interpolation(x_values, ys, val) for val in experiment_points]\nvandermonde_error = compute_average_error(target_function(c,d,e,f,experiment_points), vandermonde_interpolated, experiment_points)\n\nlagrange_interpolated = [lagrange_interpolation(x_values, ys, val) for val in experiment_points]\nlagrange_error = compute_average_error(target_function(c,d,e,f,experiment_points), lagrange_interpolated, experiment_points)\n\nnewton_interpolated = [newton_interpolation(x_values, ys, val) for val in experiment_points]\nnewton_error = compute_average_error(target_function(c,d,e,f,experiment_points), newton_interpolated, experiment_points)\n\npiecewise_linear_interpolated = [piecewise_linear_interpolation(x_values, ys, val) for val in experiment_points]\npiecewise_linear_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_linear_interpolated, experiment_points)\n\npiecewise_cubic_hermite_interpolated = [piecewise_cubic_hermite_interpolation(x_values, ys, yy, val) for val in experiment_points]\npiecewise_cubic_hermite_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_cubic_hermite_interpolated, experiment_points)\n\nfig = plt.figure(num = 1,dpi = 120)\nax = plt.subplot(1,1,1)\n # åæ ‡è½´\nax = plt.gca()  # get current axis è·å¾—åæ ‡è½´å¯¹è±¡\nax.spines['right'].set_color('none')  # å°†å³è¾¹ è¾¹æ²¿çº¿é¢œè‰²è®¾ç½®ä¸ºç©º å…¶å®å°±ç›¸å½“äºæŠ¹æ‰è¿™æ¡è¾¹\nax.spines['top'].set_color('none')\nax.xaxis.set_ticks_position('bottom')\nax.yaxis.set_ticks_position('left')\n# è®¾ç½®ä¸­å¿ƒçš„ä¸ºï¼ˆ0ï¼Œ0ï¼‰çš„åæ ‡è½´\nax.spines['bottom'].set_position(('data', 0))  # æŒ‡å®š data è®¾ç½®çš„bottom(ä¹Ÿå°±æ˜¯æŒ‡å®šçš„xè½´)ç»‘å®šåˆ°yè½´çš„0è¿™ä¸ªç‚¹ä¸Š\nax.spines['left'].set_position(('data', 0))\n\nx=list(np.arange(a,b,0.01))#æ­¤å¤„å¯è°ƒæ•´è‡ªå˜é‡å–å€¼èŒƒå›´ï¼Œä»¥ä¾¿é€‰æ‹©åˆé€‚çš„è§‚å¯Ÿå°ºåº¦\ny=[]\ny1=[]\ny2=[]\ny3=[]\ny4=[]\ny5=[]\nfor i in range(len(x)):\n    y = target_function(c,d,e,f,x)\n    y1.append(vandermonde_interpolation(x_values, ys, x[i]))\n    y2.append(lagrange_interpolation(x_values, ys, x[i]))\n    y3.append(newton_interpolation(x_values, ys, x[i]))\n    y4.append(piecewise_linear_interpolation(x_values, ys, x[i]))\n    y5.append(piecewise_cubic_hermite_interpolation(x_values, ys, yy, x[i]))\n    \n\nax.plot(x,y,label = \"Target Function\",color =\"blueviolet\")\nax.plot(x_values,ys, marker = \"*\",linestyle = \"\", color = \"blueviolet\")\nax.plot(x,y1,label = \"vandermonde interpolation\\n average error=%f\"%vandermonde_error,color =\"red\")\nax.plot(experiment_points, vandermonde_interpolated, marker = \"o\",linestyle = \"\", color = \"red\")\nax.plot(x,y2,label = \"lagrange interpolation\\n average error=%f\"%lagrange_error,color =\"yellow\")\nax.plot(experiment_points, lagrange_interpolated, marker = \"o\",linestyle = \"\", color = \"yellow\")\nax.plot(x,y3,label = \"newton interpolation\\n average error=%f\"%newton_error,color =\"green\")\nax.plot(experiment_points, newton_interpolated, marker = \"o\",linestyle = \"\", color = \"green\")\nax.plot(x,y4,label = \"piecewise linear interpolation\\n average error=%f\"%piecewise_linear_error,color =\"blue\")\nax.plot(experiment_points, piecewise_linear_interpolated, marker = \"o\",linestyle = \"\", color = \"blue\")\nax.plot(x,y5,label = \"piecewise cubic hermite interpolation\\n average error=%f\"%piecewise_cubic_hermite_error,color =\"purple\")\nax.plot(experiment_points, piecewise_cubic_hermite_interpolated, marker = \"o\",linestyle = \"\", color = \"purple\")\n#ax.set_xlim(0,2)\n#plt.draw()\nplt.legend()\nplt.show()\n```\n","tags":["æ•°å€¼è®¡ç®—æ–¹æ³•","å®éªŒè®°å½•","Python"]},{"title":"å›¾è®ºç®—æ³•åšé¢˜æ€»ç»“","url":"/2024/10/07/å›¾è®ºç®—æ³•åšé¢˜æ€»ç»“/"},{"title":"å•è°ƒæ ˆåšé¢˜æ€»ç»“","url":"/2024/10/06/å•è°ƒæ ˆåšé¢˜æ€»ç»“/","content":"# åŸºç¡€\n## æ¯æ—¥æ¸©åº¦\n```C++\n/***** æ‰¾åé¢ç¬¬ä¸€ä¸ªå¤§ *****/\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n=temperatures.size();\n        vector<int> ans(n);\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&temperatures[s.top()]<temperatures[i]){ //æ ˆä¸­ç»´æŠ¤ä¸‹æ ‡å†™æ³•\n                ans[s.top()]=i-s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        return ans;\n    }\n};\n```\n## å•†å“æŠ˜æ‰£åçš„æœ€ç»ˆä»·æ ¼\n```C++\n/***** æ‰¾åé¢ç¬¬ä¸€ä¸ªå°äºç­‰äº *****/\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n=prices.size();\n        vector<int> ans(n);\n \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&prices[s.top()]>=prices[i]){\n                ans[s.top()]=prices[s.top()]-prices[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n        \n        while(!s.empty()){\n            ans[s.top()]=prices[s.top()];\n            s.pop();\n        }\n        return ans;\n    }\n};\n```\n## ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I\n```C++\n/***** æ‰¾åé¢ç¬¬ä¸€ä¸ªå¤§ *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        unordered_map<int,int> hashmap;\n        \n        //å¤„ç†nums2\n        stack<int> s;\n        for(int i=0;i<nums2.size();i++){\n            while(!s.empty()&&nums2[s.top()]<nums2[i]){\n                int temp=nums2[s.top()];\n                hashmap[temp]=nums2[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        for(int i=0;i<nums1.size();i++){\n            int temp=nums1[i];\n            if(hashmap[temp]) ans[i]=hashmap[temp];\n            else ans[i]=-1;\n        }\n        return ans;\n    }\n};\n```\n## ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II\n```C++\n/***** å¾ªç¯æ‰¾åé¢ç¬¬ä¸€ä¸ªå¤§ *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> ans(n,-1);\n \n        stack<int> s;\n        for(int i=0;i<2*n-1;i++){\n            while(!s.empty()&&nums[s.top()]<nums[i%n]){\n                ans[s.top()]=nums[i%n];\n                s.pop();\n            }\n            s.push(i%n);\n        }\n        \n        return ans;\n    }\n};\n```\n## æœ€å¤§å®½åº¦å¡\n```C++\n/*å•è°ƒé€’å‡æ ˆ*/\nclass Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        stack<int> s;\n        int n = nums.size();\n        for (int i = 0;i < n;i++) {\n            if (s.empty() || nums[s.top()] > nums[i]) {//è¦æŠŠç¬¬ä¸€ä¸ªæ•°æ®push\n                s.push(i);\n            }\n        }\n        int ans = 0;\n        for (int i = n - 1;i >= 0;i--) {\n            while (!s.empty() && nums[s.top()]<=nums[i]) {\n                ans = max(ans,i - s.top());\n                s.pop();\n            }\n        }\n        return ans;\n    }\n};\n```\n## è½¦é˜Ÿ\n```C++\n/***** æ’åº+å•è°ƒæ ˆ *****/\n/***** æ ¹æ®ä½ç½®ç”±å°åˆ°å¤§æ’åºï¼Œä½ç½®å¤§çš„å·¦ä¾§ï¼ˆä½ç½®å°ï¼‰çš„æ—¶é—´ä¸åº”æ›´å°ç­‰->ï¼ˆä¸¥æ ¼ï¼‰å•è°ƒé€’å‡æ ˆ *****/\nclass Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        map<int,int> ps; //è‡ªåŠ¨æ’åº\n        for(int i=0;i<position.size();i++){\n            ps[position[i]]=speed[i];\n        }\n\n        stack<double> s;\n        for(auto& [pos,spd]:ps){\n            double time=double(target-pos)/spd;\n            while(!s.empty()&&s.top()<=time){\n                s.pop();\n            }\n            s.push(time);\n        }\n        return s.size();\n    }\n};\n```\n# çŸ©å½¢é¢ç§¯ï¼ˆå®Œç»“ï¼‰\n## æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢\n```C++\n/***** å•è°ƒæ ˆçš„å…¶ä¸­ä¸€ç§å†™æ³•---å¤„ç†æ ˆä¸­å…ƒç´  *****/\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> left(n,-1), right(n,n); //å·¦è¾¹ç¬¬ä¸€ä¸ªå°çš„ä½ç½®ã€å³è¾¹ç¬¬ä¸€ä¸ªå°çš„ä½ç½®\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){ //å¤„ç†å³è¾¹\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tright[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n \n        s = stack<int> (); //æ¸…ç©ºæ ˆ\n        for(int i=n-1;i>=0;i--){ //å¤„ç†å·¦è¾¹\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tleft[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);\n        }\n        return ans;\n    }\n};\n```\n## å¥½å­æ•°ç»„çš„æœ€å¤§åˆ†æ•°\n```C++\n/***** å•è°ƒæ ˆçš„å¦ä¸€ç§å†™æ³•---å¤„ç†å½“å‰å…ƒç´  *****/\nclass Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> left(n,-1),right(n,n); //å·¦è¾¹ç¬¬ä¸€å°çš„ç¼–å·ã€å³è¾¹ç¬¬ä¸€å°çš„ç¼–å·\n \n        stack<int> s;\n        for(int i=0;i<n;i++){ //å¤„ç†å·¦è¾¹\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) left[i]=s.top();\n            s.push(i);\n        }\n \n        s=stack<int> ();\n        for(int i=n-1;i>=0;i--){ //å¤„ç†å³è¾¹\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) right[i]=s.top();\n            s.push(i);\n        }\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            int h=nums[i],l=left[i],r=right[i];\n            if(l<k&&r>k){ //å¤šäº†ä¸€ä¸ªåŒºé—´åˆ¤æ–­\n                ans=max(ans,h*(r-l-1));\n            }\n        }\n        return ans;\n    }   \n};\n```\n## æœ€å¤§çŸ©å½¢\n```C++\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int n=matrix.size(); //è¡Œæ•°\n        int m=matrix[0].size(); //åˆ—æ•°\n        vector<vector<int>> left(n,vector<int>(m,0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(matrix[i][j]=='1'){\n                    left[i][j]=(j==0?1:left[i][j-1]+1); //å¾€å·¦èƒ½å¤Ÿå»¶ç”³çš„æœ€å¤§é•¿åº¦\n                }\n            }\n        }\n        int ret=0;\n \n        //å¯¹äºæ¯ä¸€åˆ—ï¼Œä½¿ç”¨åŸºäºæŸ±çŠ¶å›¾æ±‚æœ€å¤§çŸ©å½¢çš„æ–¹æ³•\n        for(int j=0;j<m;j++){\n            vector<int> up(n,0),down(n,0);\n \n            stack<int> s;\n            for(int i=0;i<n;i++){ \n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                up[i]=s.empty()?-1:s.top(); //ä¸Šè¾¹ç¬¬ä¸€ä¸ªå°äºçš„ç¼–å·\n                s.push(i);\n            }\n            s=stack<int>();//æ¸…ç©ºæ ˆ\n            for(int i=n-1;i>=0;i--){\n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                down[i]=s.empty()?n:s.top(); //ä¸‹è¾¹ç¬¬ä¸€ä¸ªå°äºçš„ç¼–å·\n                s.push(i);\n            }\n            \n            for(int i=0;i<n;i++){\n                int width=down[i]-up[i]-1;\n                int area=width*left[i][j];\n                ret=max(ret,area);\n            }\n        }\n \n        return ret;\n    }\n};\n```\n## ç»Ÿè®¡å…¨ 1 å­çŸ©å½¢\n```C++\nclass Solution {\npublic:\n    int numSubmat(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<int> height(m);\n \n        /*å•è°ƒæ ˆæ±‚å·¦å³æ›´å°å€¼(åŒæ—¶å¤„ç†)*/\n        auto calc=[&]()->int{\n            vector<int> left(m,-1),right(m,m);\n \n            stack<int> s;\n            for(int i=0;i<m;i++){\n                while(!s.empty()&&height[s.top()]>height[i]){\n                    right[s.top()]=i;\n                    s.pop();\n                }\n                if(!s.empty()){\n                    left[i]=s.top();\n                }\n                s.push(i);\n            }\n \n            int ans=0;\n            /* è®¡ç®—ç»“æœæ—¶, ä¹˜æ³•åŸç† * çŸ©é˜µé«˜åº¦ */\n            for(int i=0;i<m;i++){\n                ans+=(right[i]-i)*(i-left[i])*height[i];\n            }\n            return ans;\n        };\n \n        int ans=0;\n        for(int i=0;i<n;i++){ /* éå†æ¯ä¸€è¡Œçš„é«˜åº¦, æ›´æ–°æ”¹è¡Œçš„é«˜åº¦å€¼ä½¿ç”¨å•è°ƒæ ˆè®¡ç®—å·¦ä¾§æ›´å°å€¼å’Œå³ä¾§æ›´å°å€¼,å†è®¡ç®—æ¯ä¸ªå°çŸ©é˜µå‡ºç°çš„æ¬¡æ•°*/\n            for(int j=0;j<m;j++){\n                if(mat[i][j]==0){\n                    height[j]=0;\n                }\n                else{\n                    height[j]++;\n                }\n            }\n            ans+=calc();\n        }\n        return ans;\n    }\n};\n```\n## æ¥é›¨æ°´\n```C++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans=0;\n        int n=height.size();\n\n        stack<int> s;\n        for (int i=0;i<n;i++) {\n            while (!s.empty() && height[s.top()]<height[i]) {\n                int top = s.top();\n                s.pop();\n                if (s.empty()) {\n                    break;\n                }\n                int left = s.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            s.push(i);\n        }\n        \n        return ans;\n    }\n};\n/***** ä¸èƒ½å•çº¯æ‰¾å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§ã€å³è¾¹ç¬¬ä¸€ä¸ªå¤§ *****/\n/*è¿™ç§æƒ…å†µä¼šå¤šç®—\n*   *\n** **\n** **\n*****\n*/\n```\n# æœ€å°å­—å…¸åº\n## ç§»æ‰ K ä½æ•°å­—\n","tags":["å•è°ƒæ ˆ","ç¼–ç¨‹","c++"]},{"title":"åŠ¨æ€è§„åˆ’åšé¢˜æ€»ç»“","url":"/2024/10/02/åŠ¨æ€è§„åˆ’åšé¢˜æ€»ç»“/","content":"# å…¥é—¨ DP\n## çˆ¬æ¥¼æ¢¯\n### çˆ¬æ¥¼æ¢¯\n```C\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> f(n+1);     \n        f[0]=1,f[1]=1;\n        for(int i=2;i<=n;i++){\n            f[i]=f[i-1]+f[i-2];\n        }\n        return f[n];\n    }\n};\n/*ç”±äºè¿™é‡Œçš„ f(x) åªå’Œ f(xâˆ’1) ä¸ f(xâˆ’2) æœ‰å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ã€Œæ»šåŠ¨æ•°ç»„æ€æƒ³ã€æŠŠç©ºé—´å¤æ‚åº¦ä¼˜åŒ–æˆ O(1)*/\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; i++) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n```\n### ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯\n```C\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n + 1);\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[n];\n    }\n};\n```\n### ç»„åˆæ€»å’Œ â…£\n```C\n/*æœ¬è´¨æ˜¯çˆ¬æ¥¼æ¢¯ï¼Œç›¸å½“äºæ¯æ¬¡å¾€ä¸Šçˆ¬ nums[i] æ­¥*/\nclass Solution {\npublic:\n    long long combinationSum4(vector<int>& nums, int target) {\n        vector<long long> dp(target + 1);\n        dp[0] = 1; //åªæœ‰å½“ä¸é€‰å–ä»»ä½•å…ƒç´ æ—¶ï¼Œå…ƒç´ ä¹‹å’Œæ‰ä¸º 0ï¼Œå› æ­¤åªæœ‰ 1 ç§æ–¹æ¡ˆã€‚\n        for (int i = 1; i <= target; i++) {\n            for (int& num : nums) {\n                if (num <= i&& dp[i - num] < INT_MAX - dp[i]) {\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n        return dp[target];\n    }\n};\n/*å¦ä¸€ç§å†™æ³•*/\nclass Solution {\npublic:\n    int combinationSum4(vector<int> &nums, int target) {\n        // ä½¿ç”¨ unsigned å¯ä»¥è®©æº¢å‡ºä¸æŠ¥é”™\n        // å¯¹äºæº¢å‡ºçš„æ•°æ®ï¼Œä¸ä¼šå½±å“ç­”æ¡ˆçš„æ­£ç¡®æ€§ï¼ˆé¢˜ç›®ä¿è¯ï¼‰\n        vector<unsigned> f(target + 1);\n        f[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int x : nums) {\n                if (x <= i) {\n                    f[i] += f[i - x];\n                }\n            }\n        }\n        return f[target];\n    }\n};\n```\n### ç»Ÿè®¡æ„é€ å¥½å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•°\n```C\nclass Solution {\npublic:\n    int countGoodStrings(int low, int high, int zero, int one) {\n        const int MOD = 1'000'000'007;\n        int ans = 0;\n        vector<int> f(high + 1); // f[i] è¡¨ç¤ºæ„é€ é•¿ä¸º i çš„å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•°\n        f[0] = 1; // æ„é€ ç©ºä¸²çš„æ–¹æ¡ˆæ•°ä¸º 1\n        for (int i = 1; i <= high; i++) {\n            if (i >= zero) f[i] = f[i - zero];\n            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;\n            if (i >= low)  ans = (ans + f[i]) % MOD;\n        }\n        return ans;\n    }\n};\n```\n### ç»Ÿè®¡æ‰“å­—æ–¹æ¡ˆæ•°\n```C\nclass Solution {\npublic:\n    int countTexts(string pressedKeys) {\n        int m = 1000000007;\n        vector<long long> dp3 = {1, 1, 2, 4};   // è¿ç»­æŒ‰å¤šæ¬¡ 3 ä¸ªå­—æ¯æŒ‰é”®å¯¹åº”çš„æ–¹æ¡ˆæ•°\n        vector<long long> dp4 = {1, 1, 2, 4};   // è¿ç»­æŒ‰å¤šæ¬¡ 4 ä¸ªå­—æ¯æŒ‰é”®å¯¹åº”çš„æ–¹æ¡ˆæ•°\n        int n = pressedKeys.size();\n        for (int i = 4; i < n + 1; ++i) {\n            dp3.push_back((dp3[i-1] + dp3[i-2] + dp3[i-3]) % m);\n            dp4.push_back((dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % m);\n        }\n        long long res = 1;   // æ€»æ–¹æ¡ˆæ•°\n        int cnt = 1;   // å½“å‰å­—ç¬¦è¿ç»­å‡ºç°çš„æ¬¡æ•°\n        for (int i = 1; i < n; ++i) {\n            if (pressedKeys[i] == pressedKeys[i-1]) {\n                ++cnt;\n            } else {\n                // å¯¹æŒ‰é”®å¯¹åº”å­—ç¬¦æ•°é‡è®¨è®ºå¹¶æ›´æ–°æ€»æ–¹æ¡ˆæ•°\n                if (pressedKeys[i-1] == '7' || pressedKeys[i-1] == '9') {\n                    res *= dp4[cnt];\n                } else {\n                    res *= dp3[cnt];\n                }\n                res %= m;\n                cnt = 1;\n            }\n        }\n        // æ›´æ–°æœ€åä¸€æ®µè¿ç»­å­—ç¬¦å­ä¸²å¯¹åº”çš„æ–¹æ¡ˆæ•°\n        if (pressedKeys[n-1] == '7' || pressedKeys[n-1] == '9') {\n            res *= dp4[cnt];\n        } else {\n            res *= dp3[cnt];\n        }\n        res %= m;\n        return res;\n    }\n};\n```\n## æ‰“å®¶åŠ«èˆ\n### æ‰“å®¶åŠ«èˆ\n```C\n/*é¢˜æ„è½¬åŒ–ä¸ºï¼šä»åºåˆ—ä¸­é€‰æ‹©å­åºåˆ—ä½¿å¾—å®ƒä»¬çš„å’Œæœ€å¤§ï¼Œæ•°ä¸èƒ½æœ‰ç›¸é‚»*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        vector<int> dp(n,0); //ç”¨ dp[i] è¡¨ç¤ºå‰ i é—´æˆ¿å±‹èƒ½å·çªƒåˆ°çš„æœ€é«˜æ€»é‡‘é¢\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n        }  \n        return dp[n-1];\n    }\n};\n/*ä¸Šè¿°æ–¹æ³•ä½¿ç”¨äº†æ•°ç»„å­˜å‚¨ç»“æœã€‚è€ƒè™‘åˆ°æ¯é—´æˆ¿å±‹çš„æœ€é«˜æ€»é‡‘é¢åªå’Œè¯¥æˆ¿å±‹çš„å‰ä¸¤é—´æˆ¿å±‹çš„æœ€é«˜æ€»é‡‘é¢ç›¸å…³ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ï¼Œåœ¨æ¯ä¸ªæ—¶åˆ»åªéœ€è¦å­˜å‚¨å‰ä¸¤é—´æˆ¿å±‹çš„æœ€é«˜æ€»é‡‘é¢ã€‚*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\n};\n```\n### åˆ é™¤å¹¶è·å¾—ç‚¹æ•°\n```C\nclass Solution {\nprivate:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxval=0;\n        for(int val:nums){\n            maxval=max(maxval,val);\n        }\n        vector<int>sum(maxval+1,0);\n        for(int val:nums){\n            sum[val]+=val;\n        }\n        return rob(sum);\n    }\n};\n```\n### ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•°\n```C\n/*å•ç‹¬è€ƒè™‘ä¸€ä¾§çš„æˆ¿å­ï¼Œå®šä¹‰ f[i] è¡¨ç¤ºå‰ i ä¸ªåœ°å—çš„æ”¾ç½®æ–¹æ¡ˆæ•°ï¼Œå…¶ä¸­ç¬¬ i ä¸ªåœ°å—å¯ä»¥æ”¾æˆ¿å­ï¼Œä¹Ÿå¯ä»¥ä¸æ”¾æˆ¿å­ã€‚*/\nconst int mod=1e9+7;\nclass Solution {\npublic:\n    int countHousePlacements(int n) {\n        vector<long long> f(n+1,0);\n        f[0]=1;\n        f[1]=2;\n        for(int i=2;i<=n;i++){\n            f[i]=(f[i-1]+f[i-2])%mod;\n        }\n        return f[n]*f[n]%mod;\n    }\n};\n```\n### æ‰“å®¶åŠ«èˆ II\n```C\n/*ç¬¬ä¸€é—´æˆ¿å±‹å’Œæœ€åä¸€é—´æˆ¿å±‹ä¸åŒæ—¶å·çªƒ*/\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        int first = nums[start], second = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n\n    int rob(vector<int>& nums) {\n        int length = nums.size();\n        if (length == 1) {\n            return nums[0];\n        } \n        else if (length == 2) {\n            return max(nums[0], nums[1]);\n        }\n        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n};\n```\n### æ–½å’’çš„æœ€å¤§æ€»ä¼¤å®³\n## æœ€å¤§å­æ•°ç»„å’Œ\n>*å®šä¹‰çŠ¶æ€ f[i] è¡¨ç¤ºä»¥ a[i] ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œï¼Œä¸å’Œ i å·¦è¾¹æ‹¼èµ·æ¥å°±æ˜¯f[i]=a[i]ï¼Œå’Œ i å·¦è¾¹æ‹¼èµ·æ¥å°±æ˜¯f[i]=f[iâˆ’1]+a[i]ï¼Œå–æœ€å¤§å€¼å°±å¾—åˆ°äº†çŠ¶æ€è½¬ç§»æ–¹ç¨‹ f[i]=max(f[iâˆ’1],0)+a[i]ï¼Œç­”æ¡ˆä¸º max(f)ã€‚è¿™ä¸ªåšæ³•ä¹Ÿå«åš Kadane ç®—æ³•ã€‚*\n### æœ€å¤§å­æ•°ç»„å’Œ\n```C\n/*æ¨¡æ¿é¢˜*/\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n        }\n        return ranges::max(dp);\n    }\n};\n```\n### æ‰¾åˆ°æœ€å¤§å¼€é”€çš„å­å­—ç¬¦ä¸²\n```C\n/*ä¸€ç‚¹è½¬åŒ–+æ¨¡æ¿é¢˜*/\nclass Solution {\npublic:\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\n        vector<int> m(26+1);\n        iota(m.begin(),m.end(),0);\n        for(int i=0;i<chars.size();i++){\n            m[chars[i]-'a'+1]=vals[i];\n        }\n \n        vector<int> dp(s.size());\n        dp[0]=m[s[0]-'a'+1];\n        int ans=max(0,dp[0]);\n        for(int i=1;i<s.size();i++){\n            dp[i]=max(dp[i-1],0)+m[s[i]-'a'+1];\n            ans=max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n```\n### ä»»æ„å­æ•°ç»„å’Œçš„ç»å¯¹å€¼çš„æœ€å¤§å€¼\n```C\n/*é¢˜ç›®è½¬åŒ–ä¸ºmax(æœ€å¤§å­æ•°ç»„å’Œï¼Œ-æœ€å°å­æ•°ç»„å’Œï¼Œ0)*/\nclass Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        int ans1=dp[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n            ans1=max(ans1,dp[i]);\n        }\n \n        vector<int> dp1(nums.size());\n        dp1[0]=nums[0];\n        int ans2=dp1[0];\n        for(int i=1;i<nums.size();i++){\n            dp1[i]=min(dp1[i-1],0)+nums[i];\n            ans2=min(ans2,dp1[i]);\n        }\n        int ans=max(0,ans1);\n        ans=max(ans,-ans2);\n        return ans;\n    }\n};\n```\n### K æ¬¡ä¸²è”åæœ€å¤§å­æ•°ç»„ä¹‹å’Œ\n```C\n/*\nè€ƒè™‘ä¸¤ç§æƒ…å†µï¼š\n\n1.å¦‚æœk=1ï¼Œé‚£å°±æ˜¯æ­£å¸¸DPã€‚\n\n2.k>1æ—¶ä¹Ÿè€ƒè™‘ä¸¤ç§æƒ…å†µï¼šæ•°ç»„æ‰€æœ‰å…ƒç´ å’Œå¤§äº0ï¼Œæ•°ç»„æ‰€æœ‰å…ƒç´ å’Œå°äºç­‰äº0ã€‚\né¦–å…ˆè®¡ç®—ä¸¤ä¸ªç›¸æ¥çš„DPä¹Ÿå°±æ˜¯k=2çš„æƒ…å†µï¼Œå¦‚æœæ•°ç»„å…ƒç´ å’Œå¤§äº0ï¼Œé‚£å¯ä»¥çœ‹æˆå†ç¬¬ä¸€æ®µç»“å°¾ç¬¬äºŒæ®µå¼€å¤´æ’å…¥k-2ä¸ªæ­£æ•°ï¼Œå¦‚æœæ•°ç»„æ‰€æœ‰å…ƒç´ å’Œä¸ºè´Ÿï¼Œé‚£k=2çš„æƒ…å†µå°±æ˜¯æœ€å¤§çš„æƒ…å†µã€‚\n*/\nclass Solution {\npublic:\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        const int mod=1e9+7;\n        int n=arr.size();\n        long long sum=0,presum=0,result=0;\n        for(int i=0;i<n*(k>1?2:1);i++){\n            long long num=arr[i%n];\n            presum=max(presum,0ll)+num;\n            result=max(result,presum);\n            if(i<n) sum+=num;\n        }\n        if(sum>0&&k>1){\n            result=(result+sum*(k-2)%mod)%mod;\n        }\n        return result;\n    }\n};\n/*\n1.sum>0ã€k=2æ—¶ï¼Œæœ€å¤§å­æ•°ç»„å’Œå¦‚æœæ²¡æœ‰è·¨è¿‡ä¸¤ä¸ªæ•°ç»„ï¼Œé‚£å²‚ä¸æ˜¯ä¸èƒ½åœ¨ä¸­é—´æ’å…¥k-2ä¸ªsumå—ï¼Ÿ\nåè¯æ³•ï¼Œåè®¾sum>0æ—¶ï¼Œå¦‚æœæœ€å¤§å­æ•°ç»„å’Œæ²¡æœ‰è·¨è¿‡ä¸¤ä¸ªæ•°ç»„ã€‚ä»Låˆ°Rçš„å­æ•°ç»„çš„å’Œæœ€å¤§ï¼ˆ0<=L<=R<n-1ï¼‰ï¼Œè€ƒè™‘Rå‘å³nä¸ªæ•°(R+1åˆ°R+n)ï¼Œè¿™nä¸ªæ•°ä¸€å®šæ˜¯å’Œarrçš„æ•°æ˜¯ä¸€æ ·çš„ï¼ˆå¾ªç¯äº†ï¼‰ï¼Œé‚£ä¹ˆè¿™nä¸ªæ•°çš„å’Œæ˜¯sumï¼Œå¤§äº0ã€‚æ‰€ä»¥ä»Låˆ°R+nçš„å­æ•°ç»„çš„å’Œè¦æ›´å¤§ï¼Œè€Œè¿™ä¸ªå­æ•°ç»„è·¨è¿‡äº†ä¸¤ä¸ªæ•°ç»„ï¼Œä¸åè®¾çŸ›ç›¾ã€‚æ‰€ä»¥è¿™æ ·åšæ˜¯å¯¹çš„ã€‚\n2.sum<=0æ—¶ï¼Œä¸ºä»€ä¹ˆå¯ä»¥åŒ–å½’åˆ°k=2çš„æƒ…å†µï¼Ÿ\nè¿˜æ˜¯åè¯æ³•ï¼Œå‡è®¾æœ€å¤§å­æ•°ç»„çš„é•¿åº¦>2nï¼Œé‚£ä¸€å®šåŒ…æ‹¬ä¸€ä¸ªå®Œæ•´çš„arræ•°ç»„ï¼Œé‚£ä¹ˆå› ä¸ºsum<=0ï¼Œæ‰€ä»¥æ‹¿æ‰è¿™ä¸€éƒ¨åˆ†ï¼ŒæŠŠå‰åæ‹¼æ¥åœ¨ä¸€èµ·ï¼ˆè¿™æ ·åšæ˜¾ç„¶æ˜¯åˆæ³•çš„ï¼‰ï¼Œè¿™æ ·åšç»“æœåªä¼šæ›´ä¼˜ï¼Œå¦‚æ­¤æ“ä½œä¸‹å»ï¼Œå°±å¯ä»¥åˆ’å½’åˆ°k=2çš„æƒ…å†µäº†ã€‚\n*/\n```\n### ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ\n```C\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> qianmax(n); //å‰ç¼€æœ€å¤§å€¼\n        int presum=nums[0];\n        qianmax[0]=nums[0];\n\n        int pre=nums[0];\n        int ans=pre;\n\n        for(int i=1;i<n;i++){\n            pre=max(pre,0)+nums[i];\n            ans=max(ans,pre);\n\n            presum+=nums[i];\n            qianmax[i]=max(qianmax[i-1],presum);\n        }\n\n        int housum=0;\n        for(int i=n-1;i>0;i--){ //æšä¸¾åç¼€å’Œ\n            housum+=nums[i];\n            ans=max(ans,housum+qianmax[i-1]);\n        }\n        return ans;\n    }\n};\n```\n### æ‹¼æ¥æ•°ç»„çš„æœ€å¤§åˆ†æ•°\n```C\n/*è½¬æ¢æˆæœ€å¤§å­æ•°ç»„å’Œ*/\nclass Solution {\n    int solve(vector<int> &nums1, vector<int> &nums2) {\n        int sum = 0, maxSum = 0;\n        for (int i = 0, s = 0; i < nums1.size(); i++) {\n            sum += nums1[i];\n            s = max(s,0)+(nums2[i] - nums1[i]);\n            maxSum = max(maxSum, s);\n        }\n        return sum + maxSum;\n    }\n\npublic:\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2) {\n        return max(solve(nums1, nums2), solve(nums2, nums1));\n    }\n};\n```\n### (æ‰©å±•ï¼‰ä¹˜ç§¯æœ€å¤§å­æ•°ç»„\n```C\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector <long> maxF(nums.begin(),nums.end()), minF(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            maxF[i] = max(maxF[i - 1] * nums[i], max((long)nums[i], minF[i - 1] * nums[i]));\n            minF[i] = min(minF[i - 1] * nums[i], min((long)nums[i], maxF[i - 1] * nums[i]));\n            if(minF[i]<INT_MIN) {\n                minF[i]=nums[i];\n            }\n        }\n        return *max_element(maxF.begin(), maxF.end());\n    }\n};\n/*ä¼˜åŒ–ç©ºé—´*/\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        long maxF = nums[0], minF = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            long mx = maxF, mn = minF;\n            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));\n            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));\n            if(minF<INT_MIN) {\n                minF=nums[i];\n            }\n            ans = max(maxF, ans);\n        }\n        return ans;\n    }\n};\n```\n# ç½‘æ ¼å›¾ DP\n## åŸºç¡€\n### ç å®çš„æœ€é«˜ä»·å€¼\n```C\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(n,vector<int>(m));\n        f[0][0]=frame[0][0];\n        for(int i=1;i<n;i++){ //å¤„ç†ç¬¬ä¸€åˆ—\n            f[i][0]=f[i-1][0]+frame[i][0];\n        }\n        for(int j=1;j<m;j++){ //å¤„ç†ç¬¬ä¸€è¡Œ\n            f[0][j]=f[0][j-1]+frame[0][j];\n        }\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                f[i][j]=max(f[i-1][j],f[i][j-1])+frame[i][j];\n            }\n        }\n        return f[n-1][m-1];\n    }\n};\n \n/*æ³¨æ„åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­ï¼Œf(i,j) åªä¼šä» f(iâˆ’1,j) å’Œ f(i,jâˆ’1) è½¬ç§»è€Œæ¥ï¼Œè€Œä¸ f(iâˆ’2,â‹¯) ä»¥åŠæ›´æ—©çš„çŠ¶æ€æ— å…³ï¼Œå› æ­¤æˆ‘ä»¬åŒä¸€æ—¶åˆ»åªéœ€è¦å­˜å‚¨æœ€åä¸¤è¡Œçš„çŠ¶æ€ï¼Œå³ä½¿ç”¨ä¸¤ä¸ªé•¿åº¦ä¸º n çš„ä¸€ä½æ•°ç»„ä»£æ›¿ nÃ—m çš„äºŒç»´æ•°ç»„ fï¼Œäº¤æ›¿åœ°è¿›è¡ŒçŠ¶æ€è½¬ç§»ï¼Œå‡å°‘ç©ºé—´å¤æ‚åº¦ã€‚*/\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(2,vector<int>(m));\n        for(int i=0;i<n;i++){\n            int pos=i%2;\n            for(int j=0;j<m;j++){\n                f[pos][j]=0;\n                if(i>0) f[pos][j]=max(f[pos][j],f[1-pos][j]);\n                if(j>0) f[pos][j]=max(f[pos][j],f[pos][j-1]);\n                f[pos][j]+=frame[i][j];\n            }\n        }\n        return f[(n-1)%2][m-1];\n    }\n};\n```\n### ä¸åŒè·¯å¾„\n```C\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++) f[i][0]=1;\n        for(int j=0;j<n;j++) f[0][j]=1;\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n/*æ­¤å¤–ï¼Œç”±äº f(i,j) ä»…ä¸ç¬¬ i è¡Œå’Œç¬¬ iâˆ’1 è¡Œçš„çŠ¶æ€æœ‰å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä»£æ›¿ä»£ç ä¸­çš„äºŒç»´æ•°ç»„ï¼Œä½¿ç©ºé—´å¤æ‚åº¦é™ä½ä¸º O(n)ã€‚*/\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> f(n,1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                f[j]+=f[j-1];\n            }\n        }\n        return f[n - 1];\n    }\n};\n```\n### ä¸åŒè·¯å¾„ II\n```C\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++){ //å¤„ç†ç¬¬ä¸€åˆ—\n            if(obstacleGrid[i][0]==1){ //æœ‰éšœç¢ \n                f[i][0]=0; \n                break; //åé¢éƒ½åˆ°è¾¾ä¸äº†\n            }\n            else f[i][0]=1;\n        }\n        for(int j=0;j<n;j++){  //å¤„ç†ç¬¬ä¸€è¡Œ\n            if(obstacleGrid[0][j]==1){ //æœ‰éšœç¢\n                f[0][j]=0; \n                break; //åé¢éƒ½åˆ°è¾¾ä¸äº†\n            }\n            else f[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(obstacleGrid[i][j]==1) f[i][j]=0;\n                else f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n```\n### æœ€å°è·¯å¾„å’Œ\n```C\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m));\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<n;i++) dp[i][0]=dp[i-1][0]+grid[i][0];\n        for(int j=1;j<m;j++) dp[0][j]=dp[0][j-1]+grid[0][j];\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};\n```\n### ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ\n```C\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            dp[i][0]=dp[i-1][0]+triangle[i][0]; //ç¬¬ä¸€åˆ—åªèƒ½ä»ä¸Šé¢è½¬ç§»\n            for(int j=1;j<i;j++){\n                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n            }\n            dp[i][i]=dp[i-1][i-1]+triangle[i][i];//æœ€åä¸€åˆ—åªèƒ½ä»å·¦ä¸Šè½¬ç§»\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n/*å¯ä»¥å‘ç°ï¼Œdp[i][j] åªä¸ dp[iâˆ’1][..] æœ‰å…³ï¼Œè€Œä¸ dp[iâˆ’2][..] åŠä¹‹å‰çš„çŠ¶æ€æ— å…³ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¿…å­˜å‚¨è¿™äº›æ— å…³çš„çŠ¶æ€ã€‚å…·ä½“åœ°ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªé•¿åº¦ä¸º n çš„ä¸€ç»´æ•°ç»„è¿›è¡Œè½¬ç§»ï¼Œå°† i æ ¹æ®å¥‡å¶æ€§æ˜ å°„åˆ°å…¶ä¸­ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œé‚£ä¹ˆ iâˆ’1 å°±æ˜ å°„åˆ°äº†å¦ä¸€ä¸ªä¸€ç»´æ•°ç»„ã€‚è¿™æ ·æˆ‘ä»¬ä½¿ç”¨è¿™ä¸¤ä¸ªä¸€ç»´æ•°ç»„ï¼Œäº¤æ›¿åœ°è¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚*/\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            int cur=i%2; //å½“å‰è¡Œ\n            int pre=1-cur; //ä¸Šä¸€è¡Œ\n            dp[cur][0]=dp[pre][0]+triangle[i][0]; //ç¬¬ä¸€åˆ—åªèƒ½ä»ä¸Šé¢è½¬ç§»\n            for(int j=1;j<i;j++){\n                dp[cur][j]=min(dp[pre][j-1],dp[pre][j])+triangle[i][j];\n            }\n            dp[cur][i]=dp[pre][i-1]+triangle[i][i];//æœ€åä¸€åˆ—åªèƒ½ä»å·¦ä¸Šè½¬ç§»\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n### ä¸‹é™è·¯å¾„æœ€å°å’Œ\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        copy(matrix[0].begin(),matrix[0].end(),dp[0].begin());\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++){\n                int minn=dp[i-1][j]; //éƒ½èƒ½ä»æ­£ä¸Šæ–¹è½¬ç§»\n                if(j>0){ //å¯ä»¥ä»å·¦ä¸Šæ–¹è½¬ç§»\n                    minn=min(minn,dp[i-1][j-1]);\n                }\n                if(j<n-1){ //å¯ä»¥ä»å³ä¸Šæ–¹è½¬ç§»\n                    minn=min(minn,dp[i-1][j+1]);\n                }\n                dp[i][j]=minn+matrix[i][j];\n            }\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n```\n### çŸ©é˜µä¸­ç§»åŠ¨çš„æœ€å¤§æ¬¡æ•°\n```C\nclass Solution {\npublic:\n    int maxMoves(vector<vector<int>>& grid) {\n        int ans=0; bool flag=1;\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m)); //dp[i][j]==1è¡¨ç¤º(i,j)ä½ç½®å¯åˆ°è¾¾\n        for(int i=0;i<n;i++) dp[i][0]=1; \n        for(int j=1;j<m;j++){\n            if(!flag) return ans;\n            flag=0;\n            for(int i=0;i<n;i++){\n                if(grid[i][j-1]<grid[i][j]&&dp[i][j-1]){\n                    dp[i][j]=1;\n                }\n                if(i>0){\n                    if(grid[i-1][j-1]<grid[i][j]&&dp[i-1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(i<n-1){\n                    if(grid[i+1][j-1]<grid[i][j]&&dp[i+1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(dp[i][j]){\n                    flag=1;\n                    ans=j;\n                }\n            }\n        }\n        //ans+=1;\n        return ans;\n    }\n};\n```\n### ç½‘æ ¼ä¸­çš„æœ€å°è·¯å¾„ä»£ä»·\n```C\nclass Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0]=grid[0];\n        for(int i=1;i<m;i++){\n            int cur=i%2; //å½“å‰è¡Œ\n            int pre=1-cur; //ä¸Šä¸€è¡Œ\n            for(int j=0;j<n;j++){ //å½“å‰è¡Œæ¯ä¸€åˆ—\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<n;k++){ //ä¸Šä¸€è¡Œæ¯ä¸€åˆ—\n                    dp[cur][j]=min(dp[cur][j],dp[pre][k]+moveCost[grid[i-1][k]][j]+grid[i][j]);\n                }\n            }\n        }\n        return *min_element(dp[(m-1)%2].begin(),dp[(m-1)%2].end());\n    }\n};\n```\n### ä¸‹é™è·¯å¾„æœ€å°å’Œ II\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(m));\n        dp[0]=grid[0];\n        for(int i=1;i<n;i++){ \n            int cur=i%2; //å½“å‰è¡Œ\n            int pre=1-cur; //ä¸Šä¸€è¡Œ\n            for(int j=0;j<m;j++){ //å½“å‰è¡Œæ¯ä¸€åˆ—\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<m;k++){ //ä¸Šä¸€è¡Œæ¯ä¸€åˆ—\n                    if(j!=k){\n                        dp[cur][j]=min(dp[cur][j],dp[pre][k]+grid[i][j]);\n                    }\n                }\n            }\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n## è¿›é˜¶\n### çŸ©é˜µçš„æœ€å¤§éè´Ÿç§¯\n```C\nclass Solution {\npublic:\n    int maxProductPath(vector<vector<int>>& grid) {\n        const int mod=1e9+7;\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<long long>> maxgt(m,vector<long long>(n));\n        vector<vector<long long>> minlt(m,vector<long long>(n));\n        maxgt[0][0]=minlt[0][0]=grid[0][0];\n        for(int j=1;j<n;j++){ //å¤„ç†ç¬¬ä¸€è¡Œ\n            maxgt[0][j]=minlt[0][j]=maxgt[0][j-1]*grid[0][j];\n        }\n        for(int i=1;i<m;i++){ //å¤„ç†ç¬¬ä¸€åˆ—\n            maxgt[i][0]=minlt[i][0]=maxgt[i-1][0]*grid[i][0];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(grid[i][j]>=0){\n                    maxgt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                    minlt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                }\n                else{\n                    maxgt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                    minlt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                }\n            }\n        }\n        if(maxgt[m-1][n-1]<0) return -1;\n        else{\n            return maxgt[m-1][n-1]%mod;\n        }\n    }\n};\n```\n### æœ€å¤§å¾—åˆ†çš„è·¯å¾„æ•°ç›®\n```C\nusing PII = pair<int, int>;\n\nclass Solution {\nprivate:\n    static constexpr int mod = (int)1e9 + 7;\n\npublic:\n    void update(vector<vector<PII>>& dp, int n, int x, int y, int u, int v) {\n        if (u >= n || v >= n || dp[u][v].first == -1) {\n            return;\n        }\n        if (dp[u][v].first > dp[x][y].first) {\n            dp[x][y] = dp[u][v];\n        }\n        else if (dp[u][v].first == dp[x][y].first) {\n            dp[x][y].second += dp[u][v].second;\n            if (dp[x][y].second >= mod) {\n                dp[x][y].second -= mod;\n            }\n        }\n    }\n\n    vector<int> pathsWithMaxScore(vector<string>& board) {\n        int n = board.size();\n        vector<vector<PII>> dp(n, vector<PII>(n, {-1, 0}));\n        dp[n - 1][n - 1] = {0, 1};\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (!(i == n - 1 && j == n - 1) && board[i][j] != 'X') {\n                    update(dp, n, i, j, i + 1, j);\n                    update(dp, n, i, j, i, j + 1);\n                    update(dp, n, i, j, i + 1, j + 1);\n                    if (dp[i][j].first != -1) {\n                        dp[i][j].first += (board[i][j] == 'E' ? 0 : board[i][j] - '0');\n                    }\n                }\n            }\n        }\n        return dp[0][0].first == -1 ? vector<int>{0, 0} : vector<int>{dp[0][0].first, dp[0][0].second};\n    }\n};\n```\n### çŸ©é˜µä¸­å’Œèƒ½è¢« K æ•´é™¤çš„è·¯å¾„\n```C\n/*æŠŠè·¯å¾„å’Œæ¨¡ k çš„ç»“æœå½“æˆä¸€ä¸ªæ‰©å±•ç»´åº¦*/\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>> &grid, int k) {\n        const int mod = 1e9 + 7;\n        int m = grid.size(), n = grid[0].size(), f[m + 1][n + 1][k];\n        memset(f, 0, sizeof(f)); // f[i][j][v] è¡¨ç¤ºä»å·¦ä¸Šèµ°åˆ° (i,j)ï¼Œä¸”è·¯å¾„å’Œæ¨¡ k çš„ç»“æœä¸º v æ—¶çš„è·¯å¾„æ•°\n        f[0][1][0] = 1;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                for (int v = 0; v < k; ++v)\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\n        return f[m][n][0];\n    }\n};\n/*ä»£ç å®ç°æ—¶ï¼Œä¸ºäº†é¿å…åˆ¤æ–­æ˜¯å¦è¶Šç•Œï¼Œå¯ä»¥æŠŠä¸‹æ ‡éƒ½åŠ ä¸€ã€‚æ­¤æ—¶å¯ä»¥è®¾åˆå§‹å€¼ f[0][1][0]=1ï¼ˆæˆ–è€… f[1][0][0]=1ï¼‰ç®€åŒ–ä¸€ç‚¹ç‚¹ä»£ç ã€‚*/\n```\n### åœ°ä¸‹åŸæ¸¸æˆ\n```C\n\n```\n# èƒŒåŒ…\n## 0-1 èƒŒåŒ…\n>*æ¯ä¸ªç‰©å“åªèƒ½é€‰ä¸€æ¬¡*\n### å’Œä¸ºç›®æ ‡å€¼çš„æœ€é•¿å­åºåˆ—çš„é•¿åº¦\n```C\n\n```\n## å®Œå…¨èƒŒåŒ…\n## å¤šé‡èƒŒåŒ…\n## åˆ†ç»„èƒŒåŒ…\n# ç»å…¸çº¿æ€§ DP\n## æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰\n>*ä¸€èˆ¬å®šä¹‰f[i][j]è¡¨ç¤ºå¯¹(s[:i],t[:j])çš„æ±‚è§£ç»“æœã€‚*\n### æœ€é•¿å…¬å…±å­åºåˆ—\n```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.size(),n=text2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1)); \n        for(int i=1;i<=m;i++){\n            char c1=text1[i-1];\n            for(int j=1;j<=n;j++){\n                char c2=text2[j-1];\n                if(c1==c2){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                else{\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n### ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ\n```C++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; i++) {\n            char c1 = word1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = word2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        int lcs = dp[m][n];\n        return m - lcs + n - lcs;\n    }\n};\n```\n### ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å°ASCIIåˆ é™¤å’Œ\n```C++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int m = s1.size();\n        int n = s2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; ++i) {\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\n        }\n        for (int j = 1; j <= n; ++j) {\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\n        }\n        for (int i = 1; i <= m; i++) {\n            char c1 = s1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = s2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n```\n### ç¼–è¾‘è·ç¦»\n```C++\n\n```\n## æœ€é•¿é€’å¢å­åºåˆ—ï¼ˆLISï¼‰\n","tags":["ç¼–ç¨‹","åŠ¨æ€è§„åˆ’"]},{"title":"è½¯ä»¶å·¥ç¨‹ç»¼åˆå®è·µ","url":"/2024/10/01/è½¯ä»¶å·¥ç¨‹ç»¼åˆå®è·µ/","content":"## æ•…äº‹åœºæ™¯\n>ä½ ä»¬æ˜¯å‡ ååˆ°æŸè½¯ä»¶å¼€å‘å…¬å¸ï¼ˆä»¥ä¸‹ç®€ç§°Tè½¯ï¼‰å®ä¹ çš„å­¦ç”Ÿã€‚ä¸Šç­ç¬¬ä¸€å¤©ï¼Œè€æ¿å‘Šè¯‰ä½ ä»¬ï¼Œå…¬å¸ç°åœ¨æœ‰ä¸ªç´§æ€¥é¡¹ç›®ï¼Œè¦æ±‚ä¸‰å‘¨åä¸Šçº¿ï¼Œä½†æ˜¯â€¦â€¦ä¸Šå‘¨æœ«ï¼Œè¿™ä¸ªé¡¹ç›®å”¯ä¸€çš„ç¨‹åºå‘˜ï¼Œå°ä¸œï¼Œå› ä¸æ»¡å…¬å¸çš„è–ªæ°´å¾…é‡è¿‡ä½è€Œç¦»èŒäº†ï¼Œç°åœ¨ç•™ä¸‹äº†ä¸€ä¸ªåŠæˆå“çš„çƒ‚æ‘Šå­ï¼Œé‡æ‹…è½åœ¨äº†ä½ ä»¬å‡ ä¸ªæ¯«æ— å¼€å‘ç»éªŒçš„å®ä¹ ç”Ÿèº«ä¸Šâ€¦â€¦\n## JDBC é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ JDBC å°è£…æ•°æ®å±‚ï¼Œå¹¶å®ç°å¢åˆ æ”¹æŸ¥â€çš„é—®é¢˜ã€‚**\n## å‰ç«¯é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ HTML5+CSS3+JavaScript å¼€å‘ä¼ä¸šçº§å‰ç«¯é™æ€é¡µé¢â€çš„é—®é¢˜ã€‚**\n## JavaWeb é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ Vueï¼ˆå‰ç«¯ï¼‰+Servletï¼ˆæœåŠ¡ç«¯ï¼‰å¼€å‘åŸºäºå‰åç«¯åˆ†ç¦»æ¶æ„åº”ç”¨ç¨‹åºâ€çš„é—®é¢˜ã€‚**\n## SpringBoot é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ Vueï¼ˆå‰ç«¯ï¼‰+SpringBootï¼ˆæœåŠ¡ç«¯ï¼‰å¼€å‘åŸºäºå‰åç«¯åˆ†ç¦»æ¶æ„åº”ç”¨ç¨‹åºâ€çš„é—®é¢˜ã€‚**\n## SpringCloud é¡¹ç›®\n**ä¸»è¦ç›®æ ‡ï¼šè§£å†³â€œä½¿ç”¨ Vueï¼ˆå‰ç«¯ï¼‰+SpringCloudï¼ˆæœåŠ¡ç«¯ï¼‰å¼€å‘åŸºäºå¾®æœåŠ¡çš„äº’è”ç½‘åº”ç”¨ç¨‹åºâ€çš„é—®é¢˜ã€‚**","tags":["å¼€å‘"]},{"title":"è®¡ç®—æœºç½‘ç»œå®è·µè®°å½•","url":"/2024/09/28/è®¡ç®—æœºç½‘ç»œå®è·µè®°å½•/","content":"\n---\n- å¤©æ´¥å¤§å­¦ 2024 è®¡ç®—æœºç½‘ç»œ TCP è¯¾ç¨‹å®è·µ\n- Lab Memberï¼šæµ·æ£ æœªé›¨ï¼Œæ¢¨èŠ±å…ˆé›ª\n- æœ€ç»ˆæˆç»© +âˆ åˆ†æ ğŸ˜‹\n\n# æ–‡ä»¶ç»“æ„è¯´æ˜\n```markdown\ntju_tcp ----------------- é¡¹ç›®æ ¹ç›®å½• \nâ”œâ”€ build ---------------- å­˜æ”¾æ‰€æœ‰ç¼–è¯‘çš„ä¸­é—´æ–‡ä»¶\nâ”‚  â”œâ”€ kernel.o\nâ”‚  â”œâ”€ log.o\nâ”‚  â”œâ”€ operation.o\nâ”‚  â”œâ”€ rtt.o\nâ”‚  â”œâ”€ time_thread.o\nâ”‚  â”œâ”€ tju_packet.o\nâ”‚  â””â”€ tju_tcp.o\nâ”œâ”€ inc ------------------ å­˜æ”¾æ‰€æœ‰å¤´æ–‡ä»¶\nâ”‚  â”œâ”€ global.h ---------- å®šä¹‰ä¸€äº›å…¨å±€éƒ½ä¼šç”¨åˆ°çš„å˜é‡å’Œç»“æ„\nâ”‚  â”œâ”€ kernel.h ---------- æ¨¡æ‹Ÿä¸€éƒ¨åˆ†linuxå†…æ ¸è¡Œä¸º æ¯”å¦‚å¦‚ä½•å‘é€æ•°æ®åˆ°ä¸‹ä¸€å±‚ æ ¹æ®äº”å…ƒç»„æŸ¥æ‰¾socketç­‰\nâ”‚  â”œâ”€ tju_packet.h ------ å®šä¹‰TCPæ‰€ç”¨åˆ°çš„æ•°æ®åŒ…æ ¼å¼ æä¾›å„ç§æ•°æ®åŒ…çš„æ“ä½œ(åˆ›å»º è·å¾—å­—æ®µç­‰)\nâ”‚  â”œâ”€ tju_tcp.h --------- éœ€è¦å®ç°çš„TCPçš„å„ç§ç»“æ„å’ŒåŠŸèƒ½çš„å®šä¹‰\nâ”‚  â”œâ”€ log.h\nâ”‚  â”œâ”€ operation.h\nâ”‚  â”œâ”€ rtt.h\nâ”‚  â””â”€ time_thread.h\nâ”œâ”€ src ------------------ å­˜æ”¾æ‰€æœ‰æºä»£ç æ–‡ä»¶\nâ”‚  â”œâ”€ client.c ---------- å®¢æˆ·ç«¯ä¸»å‡½æ•°å®ç°\nâ”‚  â”œâ”€ server.c ---------- æœåŠ¡ç«¯ä¸»å‡½æ•°å®ç°\nâ”‚  â”œâ”€ kernel.c ---------- è™šæ‹Ÿå†…æ ¸å®ç°\nâ”‚  â”œâ”€ tju_packet.c ------ å¯é å±‚åŒ…å°è£…å®ç°\nâ”‚  â”œâ”€ tju_tcp.c --------- å¯é å±‚å®ç°\nâ”‚  â”œâ”€ log.c ------------- æ—¥å¿—å®ç°\nâ”‚  â”œâ”€ operation.c ------- æ•°æ®åŒ…åŠç¼“å†²åŒºæ“ä½œ\nâ”‚  â”œâ”€ rtt.c ------------- RTTè®¡ç®—å®ç°\nâ”‚  â””â”€ time_thread.c ----- è®¡æ—¶çº¿ç¨‹å‡½æ•°å®ç°\nâ”œâ”€ Makefile ------------- ç”Ÿæˆè„šæœ¬\nâ”œâ”€ README.md ------------ æ–‡ä»¶è¯´æ˜\nâ””â”€ bin\n   â”œâ”€ client\n   â””â”€ server\n```\n\n# å…·ä½“å®éªŒè®°å½•\n\n## è¿æ¥ç®¡ç†\n### ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿æ¥\n**1. tju_connect( )**\ntju_connect( )å‡½æ•°æ˜¯ä¸‰æ¬¡æ¡æ‰‹çš„å¼€ç«¯ã€‚åœ¨è¯¥å‡½æ•°ä¸­ï¼Œå®¢æˆ·ç«¯çš„sockç»‘å®šå¥½æœ¬åœ°çš„ipå’Œportåå‘æœåŠ¡å™¨ç«¯å‘é€SYNåŒ…ï¼ŒåŒæ—¶æŠŠå½“å‰çš„çŠ¶æ€å˜åŒ–ä¸ºSYN_SENTå¹¶å°†sockæ”¾å…¥ESTABLISHEDçš„hashè¡¨ä¸­ã€‚\n```C\nint tju_connect(tju_tcp_t* sock, tju_sock_addr target_addr){\n\n    sock->established_remote_addr = target_addr;\n\n    tju_sock_addr local_addr;\n    local_addr.ip = inet_network(CLIENT_IP);\n    local_addr.port = 5678; // è¿æ¥æ–¹è¿›è¡Œconnectè¿æ¥çš„æ—¶å€™ å†…æ ¸ä¸­æ˜¯éšæœºåˆ†é…ä¸€ä¸ªå¯ç”¨çš„ç«¯å£\n    sock->established_local_addr = local_addr;\n\n    // è¿™é‡Œä¹Ÿä¸èƒ½ç›´æ¥å»ºç«‹è¿æ¥ éœ€è¦ç»è¿‡ä¸‰æ¬¡æ¡æ‰‹\n    // å®é™…åœ¨linuxä¸­ connectè°ƒç”¨å ä¼šè¿›å…¥ä¸€ä¸ªwhileå¾ªç¯\n    // å¾ªç¯è·³å‡ºçš„æ¡ä»¶æ˜¯socketçš„çŠ¶æ€å˜ä¸ºESTABLISHED è¡¨é¢çœ‹ä¸Šå»å°±æ˜¯ æ­£åœ¨è¿æ¥ä¸­ é˜»å¡\n    // è€ŒçŠ¶æ€çš„æ”¹å˜åœ¨åˆ«çš„åœ°æ–¹è¿›è¡Œ åœ¨æˆ‘ä»¬è¿™å°±æ˜¯tju_handle_packet\n    uint32_t seq = 0;  // åºåˆ—å·\n    uint32_t ack = 0;  // ç¡®è®¤å·\n    uint8_t flag=SYN_FLAG_MASK; //flagæ ‡è®°ä¸ºï¼šè¿æ¥çŠ¶æ€è¿›è¡Œåˆ°å“ªä¸€æ­¥\n\n    char *SYN = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n    sendToLayer3(SYN, DEFAULT_HEADER_LEN); //å®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯å‘é€åŒæ­¥æŠ¥æ–‡\n    change_sock_state(sock, SYN_SENT);\n    // printf(\"clientå‘é€SYN\\n\");\n    \n    int hashval1 = cal_hash(local_addr.ip, local_addr.port, 0, 0); //å¥½åƒå¤šä½™\n    listen_socks[hashval1] = sock; //å¥½åƒå¤šä½™\n    while (sock->state != ESTABLISHED) ; //é˜»å¡ç­‰å¾…ï¼Œç›´åˆ°sockè¢«å»ºç«‹\n    int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n    established_socks[hashval] = sock;\n    return 0;\n}\n```\n**2. tju_tcp_t ***tju_accept()**\ntju_accept( )å‡½æ•°ä¸­æ·»åŠ äº†ä¸€ä¸ªé˜»å¡ï¼Œä½¿å¾—åªæœ‰å½“å…¨è¿æ¥hashè¡¨ä¸­å­˜åœ¨è¿™ä¸€ä¸ªsockï¼ŒæœåŠ¡å™¨ç«¯æ‰ç®—è¿æ¥å®Œæˆï¼Œæ‰èƒ½æŠŠæ–°çš„sockåŠ å…¥åˆ°ESTABLISHEDçš„hashè¡¨ä¸­ã€‚\n```C\ntju_tcp_t *tju_accept(tju_tcp_t *listen_sock){\n    tju_tcp_t* new_conn = (tju_tcp_t*)malloc(sizeof(tju_tcp_t));\n    memcpy(new_conn, listen_sock, sizeof(tju_tcp_t));\n\n    tju_sock_addr local_addr, remote_addr;\n    /*\n     è¿™é‡Œæ¶‰åŠåˆ°TCPè¿æ¥çš„å»ºç«‹\n     æ­£å¸¸æ¥è¯´åº”è¯¥æ˜¯æ”¶åˆ°å®¢æˆ·ç«¯å‘æ¥çš„SYNæŠ¥æ–‡\n     ä»ä¸­æ‹¿åˆ°å¯¹ç«¯çš„IPå’ŒPORT\n     æ¢å¥è¯è¯´ ä¸‹é¢çš„å¤„ç†æµç¨‹å…¶å®ä¸åº”è¯¥æ”¾åœ¨è¿™é‡Œ åº”è¯¥åœ¨tju_handle_packetä¸­\n    */\n    remote_addr.ip = inet_network(CLIENT_IP);  //å…·ä½“çš„IPåœ°å€\n    remote_addr.port = 5678;  //ç«¯å£\n\n    local_addr.ip = listen_sock->bind_addr.ip;  //å…·ä½“çš„IPåœ°å€\n    local_addr.port = listen_sock->bind_addr.port;  //ç«¯å£\n\n    new_conn->established_local_addr = local_addr;\n    new_conn->established_remote_addr = remote_addr;\n\n    while (listen_sock->state != ESTABLISHED) ;\n    change_sock_state(new_conn, ESTABLISHED);\n    int hashval = cal_hash(local_addr.ip, local_addr.port, remote_addr.ip,remote_addr.port);\n    established_socks[hashval] = new_conn;\n    return new_conn;\n}\n```\n**3. int tju_handle_packet( )**\ntju_handle_packet( )å‡½æ•°ä¸­éœ€è¦è§£å†³å¯¹å„ç§æŠ¥æ–‡çš„è§£æã€‚onTCPPocket()å‡½æ•°å¦‚æœä»established_hashæˆ–listen_hashä¸­æ‰¾åˆ°äº†å¯¹åº”çš„socketï¼Œå°±ä¼šè°ƒç”¨ tju_handle_packet( )å‡½æ•°å¯¹æ”¶åˆ°çš„æ•°æ®åŒ…è¿›è¡Œå¤„ç†ã€‚\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    if (sock->state == LISTEN && get_flags(pkt) == SYN_FLAG_MASK){ //ç¬¬äºŒæ¬¡æ¡æ‰‹\n        tju_sock_addr remote;\n        remote.ip = inet_network(CLIENT_IP);\n        remote.port = get_src(pkt);\n\n        sock->established_local_addr = sock->bind_addr;\n        sock->established_remote_addr = remote;\n\n        int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, remote.ip, remote.port);\n        half_connection[hashval] = sock;  //æ”¶åˆ°SYNæŠ¥æ–‡åæ”¾è¿›LISTENçš„åŠè¿æ¥é˜Ÿåˆ—ä¸­\n        established_socks[hashval] = sock; //è¿˜ä¼šå°†è¯¥æ–°å»ºçš„socketæ”¾åˆ°ehashä¸­\n        \n        uint32_t seq = 0;  \n        uint32_t ack = get_seq(pkt) + 1; //ç¡®è®¤å·æ˜¯SYNæŠ¥æ–‡åºåˆ—å·+1\n        uint8_t flag = SYN_FLAG_MASK | ACK_FLAG_MASK; //çŠ¶æ€è®°ä¸ºSYN+ACKï¼Œè¿™é‡Œé‡‡ç”¨ä½è¿ç®—|\n\n        char *SYNACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port, seq, ack,DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(SYNACK, DEFAULT_HEADER_LEN);\n\n        change_sock_state(sock, SYN_RECV);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == (ACK_FLAG_MASK | SYN_FLAG_MASK)){ //ç¬¬ä¸‰æ¬¡æ¡æ‰‹\n        // printf(\"clientæ”¶åˆ°SYCACK, å‡†å¤‡å‘é€ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == SYN_FLAG_MASK){ //ç¬¬ä¸‰æ¬¡æ¡æ‰‹ï¼ˆå¥‡æ€ªï¼‰\n        // printf(\"clientæ”¶åˆ°SYCACK, å‡†å¤‡å‘é€ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        \n        change_sock_state(sock, SYN_RECV);\n    }\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == (SYN_FLAG_MASK | ACK_FLAG_MASK)){  //ä¸‰æ¬¡æ¡æ‰‹ç¬¬ä¸‰ä¸ªåŒ…çš„é‡ä¼ \n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        return 0;\n    }\n    else if (sock->state == SYN_RECV && get_flags(pkt) == ACK_FLAG_MASK){\n        // printf(\"serveræ”¶åˆ°ACK\\n\");\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        com_connection[hash] = sock;\n        half_connection[hash] = NULL;\n        change_sock_state(sock, ESTABLISHED);\n    }\n```\n### å››æ¬¡æŒ¥æ‰‹å…³é—­è¿æ¥\n**1. int tju_close ( )**\nå››æ¬¡æŒ¥æ‰‹æœ‰ä¸¤ç§æƒ…å†µï¼Œåˆ†åˆ«ä¸ºå…ˆåå…³é—­å’ŒåŒæ—¶å…³é—­ï¼Œä¸¤ç§æ–¹å¼é¦–å…ˆéƒ½éœ€è¦è°ƒç”¨tju_close( )å‡½æ•°ï¼Œå› æ­¤ï¼Œåœ¨tju_close( )å‡½æ•°ä¸­ï¼Œéœ€è¦æ„é€ ä¸€ä¸ªFINæŠ¥æ–‡ï¼Œseqå’Œackéƒ½æ˜¯å½“å‰æŠ¥æ–‡çª—å£çš„ä¸‹ä¸€ä¸ªæ•°å€¼ï¼Œå¹¶æŠŠè‡ªèº«çŠ¶æ€å˜ä¸ºFIN-WAIT1ã€‚\n```C\nint tju_close (tju_tcp_t* sock){\n    uint16_t flag = FIN_FLAG_MASK | ACK_FLAG_MASK;\n    uint32_t seq = 1;\n    uint32_t ack = 1;\n\n    char* FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n    sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n    change_sock_state(sock, FIN_WAIT_1);\n    \n    while (sock->state != CLOSED) ;\n    printf(\"è¿æ¥å®Œå…¨å…³é—­\\n\");\n    return 0;\n}\n```\n**2. int tju_handle_packet( )**\næ¥ä¸‹æ¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä½†å¤„ç†è¿‡ç¨‹å‡åœ¨tju_handle_packet( )ä¸­å®Œæˆï¼Œtju_handle_packet( )ä½œä¸ºå¯¹æ”¶åˆ°çš„åŒ…è¿›è¡Œå“åº”çš„å‡½æ•°ï¼Œå……å½“äº†å¤„ç†å„ç§æƒ…å†µçš„è§’è‰²ï¼Œç”¨if elseè¯­å¥å¯¹æ¯ç§æƒ…å†µåˆ†åˆ«å¤„ç†å³å¯ã€‚\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    ``````\n    ``````\n    ``````\n    else if (sock->state == ESTABLISHED && get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK)){ // serveræ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼Œå¹¶è¿›è¡Œç¬¬äºŒæ¬¡æŒ¥æ‰‹å’Œç¬¬ä¸‰æ¬¡æŒ¥æ‰‹\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        printf(\"å‘é€ç¬¬äºŒæ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n\n        change_sock_state(sock, CLOSE_WAIT);\n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        printf(\"å‘é€ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n\n        change_sock_state(sock, LAST_ACK);\n    } \n    else if (sock->state == ESTABLISHED && get_flags(pkt) == FIN_FLAG_MASK){ // serveræ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼Œå¹¶è¿›è¡Œç¬¬äºŒæ¬¡æŒ¥æ‰‹å’Œç¬¬ä¸‰æ¬¡æŒ¥æ‰‹\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        printf(\"å‘é€ç¬¬äºŒæ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n\n        change_sock_state(sock, CLOSE_WAIT);\n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        printf(\"å‘é€ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n        \n        change_sock_state(sock, LAST_ACK);\n    } \n    else if (sock->state == FIN_WAIT_1 && get_flags(pkt) == ACK_FLAG_MASK){ // clientæ”¶åˆ°ç¬¬äºŒæ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, FIN_WAIT_2);\n        printf(\"æ”¶åˆ°ç¬¬äºŒæ¬¡æŒ¥æ‰‹æŠ¥æ–‡\\n\");\n    } \n    else if (sock->state == FIN_WAIT_2 && (get_flags(pkt) == (ACK_FLAG_MASK | FIN_FLAG_MASK))){ // clientæ”¶åˆ°ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹è¿›è¡Œç¬¬å››æ¬¡æŒ¥æ‰‹å¹¶å…³é—­è¿æ¥\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint32_t flag = ACK_FLAG_MASK;\n\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag, 1, 0, NULL, 0);\n\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        printf(\"æ”¶åˆ°ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹æŠ¥æ–‡, å¹¶å‘å‡ºç¬¬å››æ¬¡æŒ¥æ‰‹\\n\");\n\n        change_sock_state(sock, TIME_WAIT);\n\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        //è¿™é‡Œè¦ç­‰å¾…2MSL\n        change_sock_state(sock, CLOSED);\n        established_socks[hash] = NULL;\n        printf(\"å…³é—­è¿æ¥\\n\");\n    } \n    else if (sock->state == LAST_ACK && (get_flags(pkt) == ACK_FLAG_MASK)){ // serveræ”¶åˆ°ç¬¬å››æ¬¡æŒ¥æ‰‹å¹¶å…³é—­è¿æ¥\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        printf(\"å…³é—­è¿æ¥\\n\");\n    }\n    else if (sock->state == FIN_WAIT_1 && (get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK))){ // åŒæ—¶å…³é—­æ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK,DEFAULT_HEADER_LEN);\n        // printf(\"åŒæ—¶å…³é—­å‘å‡ºACK\\n\");\n    } \n    else if(sock->state == FIN_WAIT_1 && get_flags(pkt) == FIN_FLAG_MASK){ // åŒæ—¶å…³é—­æ”¶åˆ°ç¬¬ä¸€æ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == CLOSING && get_flags(pkt) == ACK_FLAG_MASK){ // åŒæ—¶å…³é—­æ—¶æ”¶åˆ°ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹\n        change_sock_state(sock, TIME_WAIT);\n        //ç­‰å¾…2MSL\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        printf(\"åŒæ—¶å…³é—­å½»åº•å…³é—­\\n\");\n    }\n}\n```\n## å¯é æ•°æ®ä¼ è¾“\n### å‘é€ç¼“å†²åŒºç®¡ç†\n1.**global.h** ä¸­æ·»åŠ \n```C\n#define TCP_SENDWN_SIZE 1000 \n```\n2.**tju_packet.h** ä¸­æ·»åŠ å‘é€ç¼“å†²åŒºé•¿åº¦ä¸º1000çš„å¾ªç¯é˜Ÿåˆ—\n```C\n// TCP æŠ¥æ–‡çš„ç»“æ„å®šä¹‰\ntypedef struct {\n\ttju_header_t header;\n\tstruct timeval sent_time;\n\tchar* data;\n} tju_packet_t;\ntju_packet_t* pktlist[TCP_SENDWN_SIZE]; //æ·»åŠ ï¼šå‘é€ç¼“å†²åŒºé•¿åº¦ä¸º1000çš„å¾ªç¯é˜Ÿåˆ—\n```\n3.ä¸Šå±‚è°ƒç”¨ **tju_send( )** æ—¶ï¼Œæˆ‘ä»¬åªæŠŠå‘é€æ•°æ®å­˜å…¥ç¼“å†²åŒºä¸­ã€‚\n```C\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    // è¿™é‡Œå½“ç„¶ä¸èƒ½ç›´æ¥ç®€å•åœ°è°ƒç”¨sendToLayer\n    while (pthread_mutex_lock(&(sock->send_lock)) != 0) ;\n    memcpy(sock->sending_buf + sock->index, (char*)buffer, len);\n    sock->sending_len += len;\n    sock->index += len;\n    pthread_mutex_unlock(&(sock->send_lock));\n    return 0;\n}\n```\n4.ç„¶åé¢å¤–åœ¨ **tju_connect( )** å‡½æ•°ä¸­åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å‘é€æ•°æ®ã€‚\nå…ˆäº†è§£ä¸€ä¸‹åˆ›å»ºçº¿ç¨‹ pthread_create( )å‡½æ•°\n\n>int pthread_create(pthread_t* restrict tidp,const >pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),>void *restrict arg);\n>- tidpï¼šäº‹å…ˆåˆ›å»ºå¥½çš„pthread_tç±»å‹çš„å‚æ•°ã€‚æˆåŠŸæ—¶tidpæŒ‡å‘çš„å†…å­˜å•å…ƒè¢«è®¾ç½®ä¸ºæ–°åˆ›å»ºçº¿ç¨‹çš„çº¿ç¨‹IDã€‚\n>- attrï¼šç”¨äºå®šåˆ¶å„ç§ä¸åŒçš„çº¿ç¨‹å±æ€§ã€‚APUEçš„12.3èŠ‚è®¨è®ºäº†çº¿ç¨‹å±æ€§ã€‚é€šå¸¸ç›´æ¥è®¾ä¸ºNULLã€‚\n>- start_rtnï¼šæ–°åˆ›å»ºçº¿ç¨‹ä»æ­¤å‡½æ•°å¼€å§‹è¿è¡Œã€‚æ— å‚æ•°æ˜¯argè®¾ä¸ºNULLå³å¯ã€‚\n>- argï¼šstart_rtnå‡½æ•°çš„å‚æ•°ã€‚æ— å‚æ•°æ—¶è®¾ä¸ºNULLå³å¯ã€‚æœ‰å‚æ•°æ—¶è¾“å…¥å‚æ•°çš„åœ°å€ã€‚å½“å¤šäºä¸€ä¸ªå‚æ•°æ—¶åº”å½“ä½¿ç”¨ç»“æ„ä½“ä¼ å…¥ã€‚\n\n```C\nwhile(1){\n    pthread_t send;\n    int pid = pthread_create(&send, NULL, send_pkt, (void*)sock);\n    if (!pid) break;\n}\n```\n5.**send_pkt( )** å‡½æ•°çš„å®ç°\n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    printf(\"bg4\\n\");\n    struct timeval start_time, now_time;\n    gettimeofday(&start_time, NULL);\n    long deltatime = 0;\n    while (1){\n        if (sock->window.wnd_send->nextseq < sock->index){\n            gettimeofday(&now_time, NULL);\n            deltatime = now_time.tv_sec - start_time.tv_sec;\n\n            while (pthread_mutex_lock(&(sock->send_lock)) != 0);\n            int unlen = sock->sending_len - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base);\n            int len = min(unlen, MAX_DLEN);\n            pthread_mutex_unlock(&(sock->send_lock));\n\n            if (sock->window.wnd_send->nextseq - sock->window.wnd_send->base + len <= sock->window.wnd_send->rwnd) {\n                uint32_t seq = sock->window.wnd_send->nextseq;\n                uint32_t ack = seq + len;\n                uint8_t flag = ACK_FLAG_MASK;\n                uint16_t pkt_len = len + DEFAULT_HEADER_LEN;\n                char *data = (char *)malloc(MAX_DLEN);\n                memcpy(data, sock->sending_buf + sock->window.wnd_send->nextseq, len);\n                tju_packet_t *datapacket = create_packet(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n\n                if (serverfp == NULL || clientfp == NULL) {\n                    clientfp =fopen(\"/vagrant/tju_tcp/test/client.event.trace\", \"a\");\n                    serverfp =fopen(\"/vagrant/tju_tcp/test/server.event.trace\", \"a\");\n                }\n                fprintf(clientfp, \"[%ld] [SWND] [size:%d]\\n\", getCurrentTime(),sock->window.wnd_send->nextseq - sock->window.wnd_send->base);\n                fflush(clientfp);\n                fflush(serverfp);\n                sendToLayer3(ACK, pkt_len);\n                if (serverfp == NULL || clientfp == NULL) {\n                    clientfp =fopen(\"/vagrant/tju_tcp/test/client.event.trace\", \"a\");\n                    serverfp =fopen(\"/vagrant/tju_tcp/test/server.event.trace\", \"a\");\n                }\n                fprintf(clientfp, \"[%ld] [SEND] [seq:%d ack:%d flag:%d length:%d]\\n\", getCurrentTime(), seq, ack, flag, pkt_len);\n                fflush(clientfp);\n                fflush(serverfp);\n                sock->window.wnd_send->nextseq += len;\n                pktlist[sock->packetr] = datapacket;\n                gettimeofday(&pktlist[sock->packetr]->sent_time, NULL);\n                sock->packetr = (sock->packetr + 1) % TCP_SENDWN_SIZE;\n                if (len == (int)(sock->window.wnd_send->nextseq - sock->window.wnd_send->base)){\n                    gettimeofday(&(sock->window.wnd_send->send_time), NULL);\n                    sock->window.wnd_send->ack_cnt = 0;\n                }\n            }\n        }\n    }\n    printf(\"ed4\\n\");\n}\n```\n**2. å¤±åºæŠ¥æ–‡æ•°ç»„çš„ç®¡ç†**\n\n## æµé‡æ§åˆ¶\n\n## æ‹¥å¡æ§åˆ¶","tags":["è®¡ç®—æœºç½‘ç»œ"]},{"title":"Cè¯­è¨€æ‰‹å†™Httpdç½‘ç«™æœåŠ¡å™¨","url":"/2024/09/26/Cè¯­è¨€æ‰‹å†™Httpdç½‘ç«™æœåŠ¡å™¨/","content":"\n---\n## æ‰§è¡ŒWEBæœåŠ¡å‰çš„å‡†å¤‡å·¥ä½œ\n### åˆ›å»ºé¡¹ç›®\n```C\n#include <stdio.h>\n\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port){\n    return 0;\n}\n\nint main(void){\n    //httpdé»˜è®¤çš„ç«¯å£æ˜¯80ï¼Œè¿™é‡ŒæŒ‡å®šäº†8000ç«¯å£ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å…¶å®ƒç«¯å£\n    unsigned short port = 8000;\n\n    // åˆå§‹åŒ–ç½‘ç»œï¼Œå¹¶ä½¿ç”¨æŒ‡å®šç«¯å£æ¥åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\n    int server_sock = startup(&port);\n    printf(\"httpd running on port %d\\n\", port);\n\n    return(0);\n}\n```\n### ç½‘ç»œé€šä¿¡åˆå§‹åŒ–\n```C\n//ç½‘ç»œé€šä¿¡éœ€è¦åŒ…å«çš„å¤´æ–‡ä»¶ã€éœ€è¦åŠ è½½çš„åº“æ–‡ä»¶\n#include <winsock2.h>\n#pragma comment (lib, \"WS2_32.lib\")\n\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port) {\n    WSADATA wsaData; // ç½‘ç»œé€šä¿¡ç›¸å…³çš„ç‰ˆæœ¬ç­‰ä¿¡æ¯\n    int ret = WSAStartup( // WSAStartup ç½‘ç»œé€šä¿¡åˆå§‹åŒ–ï¼Œ\n        MAKEWORD(1, 1),   // æŒ‡å®šä½¿ç”¨Windows Socketsè§„èŒƒçš„1.1ç‰ˆæœ¬\n        &wsaData);        // å­˜å‚¨åˆå§‹åŒ–åçš„ç‰ˆæœ¬ç­‰ä¿¡æ¯ç»“æœ\n    if (ret) {\n        return -1;\n    }\n\n    return 0;\n}\n```\n### åˆ›å»ºå¥—æ¥å­—\n```C\nvoid error_die(const char* sc) {\n    perror(sc); //æ‰“å°é”™è¯¯åŸå› \n    exit(1);\n}\n\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port) {\n    int server_socket = socket(PF_INET, //å¥—æ¥å­—çš„ç±»å‹ï¼ˆç½‘ç»œå¥—æ¥å­—ã€æ–‡ä»¶å¥—æ¥å­—ï¼Œæ­¤å¤„æ˜¯å‰è€…ï¼‰\n        SOCK_STREAM,  //æ•°æ®åŒ…çš„ç±»å‹ï¼ˆæ•°æ®æµã€æ•°æ®æŠ¥ï¼Œæ­¤å¤„æ˜¯å‰è€…ï¼‰               \n        IPPROTO_TCP); //å…·ä½“åè®®\n    if (server_socket == -1) { //æ‰“å°é”™è¯¯æç¤ºï¼Œå¹¶ç»“æŸç¨‹åº\n        error_die(\"socket\");\n    }\n}\n```\n### è®¾ç½®å¥—æ¥å­—å±æ€§--ç«¯å£å¯å¤ç”¨\n```C\n// åˆå§‹åŒ–ç½‘ç»œå¹¶åˆ›å»ºæœåŠ¡ç«¯çš„å¥—æ¥å­—\nint startup(unsigned short* port) {\n    //è®¾ç½®ç«¯å£å¯å¤ç”¨ï¼ˆç«¯å£å¤ç”¨ï¼‰\n    int opt = 1;\n    ret = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n    if (ret == -1) {\n        error_die(\"setsockopt\");\n    }\n}\n```\n### ç»‘å®šå¥—æ¥å­—å’Œç½‘ç»œåœ°å€\n```C\nint startup(unsigned short* port) {\n    //é…ç½®æœåŠ¡å™¨çš„ç½‘ç»œåœ°å€\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(*port);\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    //ç»‘å®šå¥—æ¥å­—\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        error_die(\"[bind]\");\n    }\n}\n```\n### è·å–åŠ¨æ€ç«¯å£\n```C\nint startup(unsigned short* port) {\n    // åŠ¨æ€åˆ†é…ç«¯å£\n    if (*port == 0) {\n        int namelen = sizeof(server_addr);\n        if (getsockname(server_socket, (struct sockaddr*)&server_addr, &namelen) <0) {\n            error_die(\"getsockname\");\n        }\n        *port = ntohs(server_addr.sin_port);\n    }\n    return server_socket;\n}\n```\n### åˆ›å»ºç›‘å¬é˜Ÿåˆ—\n```C\nint startup(unsigned short* port) {\n    //åˆ›å»ºç›‘å¬é˜Ÿåˆ—\n    if (listen(server_socket, 5) < 0) {\n        error_die(\"listen\");\n    }\n    return server_socket;\n}\n```","tags":["c","æœåŠ¡å™¨"]},{"title":"Cè¯­è¨€æ‰‹å†™æ¤ç‰©å¤§æˆ˜åƒµå°¸","url":"/2024/09/26/Cè¯­è¨€æ‰‹å†™æ¤ç‰©å¤§æˆ˜åƒµå°¸/","content":"\n---\n## Cè¯­è¨€æ‰‹å†™æ¤ç‰©å¤§æˆ˜åƒµå°¸\n### åˆ›å»ºä¸»åœºæ™¯\n```C\n#include<stdio.h>\n#include<graphics.h>\n\n#define WIN_WIDTH 900\n#define WIN_HEIGHT 600\n\nIMAGE imgBg;\n\n//æ¸¸æˆåˆå§‹åŒ–\nvoid gameInit() {\n\tloadimage(&imgBg, \"res/bg.jpg\");\n\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT);\n}\n\n//æ›´æ–°çª—å£\nvoid updateWindow() {\n\tputimage(0, 0, &imgBg);\n}\n\nint main(void) {\n\t//æ¸¸æˆåˆå§‹åŒ–\n\tgameInit();\n\n\t//æ›´æ–°çª—å£\n\tupdateWindow();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### å®ç°æ¤ç‰©å¡ç‰Œ\n```C\n#include \"tools.h\"\n\n//#define ZHI_WU_CUNT 3\n\nenum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT };\n\nIMAGE imgBar;\nIMAGE imgCards[ZHI_WU_COUNT];\n\nvoid gameInit() {\n\tloadimage(&imgBar, \"res/bar.png\");\n\n\t//åˆå§‹åŒ–æ¤ç‰©å¡ç‰Œ\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\t//ç”Ÿæˆæ¤ç‰©å¡ç‰Œçš„æ–‡ä»¶å\n\t\tsprintf_s(name, sizeof(name), \"res/Cards/card_%d.png\", i + 1);\n\t\tloadimage(&imgCards[i], name);\n\t}\n}\n\nvoid updateWindow() {\n\t//putimage(250, 0, &imgBar); //æœ‰é»‘è¾¹\n\tputimagePNG(250, 0, &imgBar);\n\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tint x = 338 + i * 65;\n\t\tint y = 6;\n\t\tputimage(x, y, &imgCards[i]);\n\t}\n}\n```\n### å®ç°æ¤ç‰©çš„é€‰æ‹©å’Œæ‹–åŠ¨\n```C\nIMAGE* imgZhiWu[ZHI_WU_COUNT][20];\n\nint curX, curY; //å½“å‰é€‰ä¸­çš„æ¤ç‰©ï¼Œåœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­çš„ä½ç½®\nint curZhiWu; //0:æ²¡æœ‰é€‰ä¸­ï¼Œ1:é€‰æ‹©äº†ç¬¬ä¸€ç§æ¤ç‰© etc.\n\nbool fileExist(const char* name) {\n\tFILE* fp = fopen(name, \"r\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfclose(fp);\n\t\treturn true;\n\t}\n}\n\nvoid gameInit() {\n\tmemset(imgZhiWu, 0, sizeof(imgZhiWu));\n\n\t//åˆå§‹åŒ–æ¤ç‰©å¡ç‰Œ\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tsprintf_s(name, sizeof(name), \"res/zhiwu/%d/%d.png\", i, j + 1);\n\t\t\t//å…ˆåˆ¤æ–­è¿™ä¸ªæ–‡ä»¶æ˜¯å¦å­˜åœ¨\n\t\t\tif (fileExist(name)) {\n\t\t\t\timgZhiWu[i][j] = new IMAGE;\n\t\t\t\tloadimage(imgZhiWu[i][j], name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurZhiWu = 0;\n\t//åˆ›å»ºæ¸¸æˆçš„å›¾å½¢çª—å£\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT, 1); //åŠ ä¸€ä¸ªå‚æ•°1ï¼Œä¿ç•™åå°ç•Œé¢ï¼Œæ–¹ä¾¿è°ƒè¯•\n}\n\nvoid updateWindow() {\n\tBeginBatchDraw(); //å¼€å§‹ç¼“å†²ï¼ˆå…ˆæ‰“å°åˆ°å†…å­˜ä¸­ï¼‰\n\n\t//æ¸²æŸ“ æ‹–åŠ¨è¿‡ç¨‹ä¸­çš„æ¤ç‰©\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //ç»“æŸåŒç¼“å†²ï¼ˆå†ä¸€æ¬¡æ€§æ‰“å°åˆ°çª—å£ï¼‰\n}\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;//çŠ¶æ€å˜é‡ï¼ˆå…ˆç‚¹å‡»å†æ‹–åŠ¨ï¼‰\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //å·¦å‡»æŒ‰ä¸‹\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\t\t\t\tint index = (msg.x - 338) / 65; //é€‰æ‹©å¡ç‰Œåºå·\n\t\t\t\tprintf(\"%d\\n\", index);\n\t\t\t\tstatus = 1; //å¯ä»¥æ‹–åŠ¨\n\t\t\t\tcurZhiWu = index + 1;\n\t\t\t}\n\t\t}\n\t\telse if (msg.message == WM_MOUSEMOVE && status == 1) { //é¼ æ ‡ç§»åŠ¨\n\t\t\tcurX = msg.x;\n\t\t\tcurY = msg.y;\n\n\t\t}\n\t\telse if (msg.message == WM_LBUTTONUP) { //å·¦é”®æŠ¬èµ·\n\n\t\t}\n\t}\n\n}\nint main(void) {\n\tgameInit();\n\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### å®ç°æ¤ç‰©çš„ç§æ¤\n```C\nstruct zhiwu {\n\tint type;\t\t//0:æ²¡æœ‰é€‰ä¸­ï¼Œ1:ç¬¬ä¸€ç§æ¤ç‰©\tetc.\t\t\t\t\n\tint frameIndex; //åºåˆ—å¸§çš„åºå·\n};\n\nstruct zhiwu map[3][9];\n\nvoid gameInit() {\n\tmemset(map, 0, sizeof(map));\n}\n\nvoid updateWindow() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tint x = 256 + j * 81;\n\t\t\t\tint y = 179 + i * 102 + 14;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tputimagePNG(x, y, imgZhiWu[zhiWuType][index]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid userClick() {\n\tif (peekmessage(&msg)) {\n\t\telse if (msg.message == WM_LBUTTONUP) { //å·¦é”®æŠ¬èµ·\n\t\t\tif (msg.x > 256 && msg.y > 179 && msg.y < 489) {\n\t\t\t\tint row = (msg.y - 179) / 102;\n\t\t\t\tint col = (msg.x - 256) / 81;\n\t\t\t\t//printf(\"%d, %d\\n\", row, col);\n\t\t\t\tif (map[row][col].type == 0) {\n\t\t\t\t\tmap[row][col].type = curZhiWu;\n\t\t\t\t\tmap[row][col].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurZhiWu = 0;\n\t\t\tstatus = 0;\n\t\t}\n\t}\n}\n```\n### å®ç°æ¤ç‰©çš„æ‘‡æ‘†\n```C\n//æ›´æ–°æ¸¸æˆç›¸å…³æ•°æ®\nvoid updateGame() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tmap[i][j].frameIndex++;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tif (imgZhiWu[zhiWuType][index] == NULL) {\n\t\t\t\t\tmap[i][j].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t\tupdateGame(); //æ›´æ–°æ¸¸æˆç›¸å…³æ•°æ®\n\n\t\tSleep(10);//å¸§ç­‰å¾…\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### ä¼˜åŒ–æ¸¸æˆå¾ªç¯å’Œæ¸¸æˆæ¸²æŸ“å¾ªåº\n```C\nvoid updateWindow() {\n\tBeginBatchDraw(); //å¼€å§‹ç¼“å†²\n\n\t//æ¸²æŸ“ æ‹–åŠ¨è¿‡ç¨‹ä¸­çš„æ¤ç‰©ï¼ˆæ”¾åˆ°äº†æœ€åï¼‰\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //ç»“æŸåŒç¼“å†²\n}\n\nint main(void) {\n\tgameInit();\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### åˆ¶ä½œå¯åŠ¨èœå•\n```C\nvoid startUI() { //å¯åŠ¨èœå•\n\tIMAGE imgBg,imgMenu1,imgMenu2;\n\tloadimage(&imgBg, \"res/menu.png\");\n\tloadimage(&imgMenu1, \"res/menu1.png\");\n\tloadimage(&imgMenu2, \"res/menu2.png\");\n\n\tint flag = 0;\n\twhile (1) {\n\t\tBeginBatchDraw();\n\t\tputimage(0, 0, &imgBg);\n\t\tputimagePNG(474, 75, flag ? &imgMenu2: &imgMenu1);\n\n\t\tExMessage msg;\n\t\tif (peekmessage(&msg)) {\n\t\t\tif (msg.message == WM_LBUTTONDOWN&&\n\t\t\t\t\tmsg.x>474&&msg.x<474+300&&\n\t\t\t\t\tmsg.y>75&&msg.y<75+140){\n\t\t\t\tflag = 1;\n\t\t\t\t//EndBatchDraw();\n\t\t\t}\n\t\t\telse if (msg.message == WM_LBUTTONUP&&flag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEndBatchDraw();\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\n\tstartUI();\n\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\n\t\tSleep(10);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### åˆ›å»ºéšæœºé˜³å…‰\n```C\n#include<time.h>\n\nstruct sunshineBall {\n\tint x, y; //é˜³å…‰çƒåœ¨é£˜è½è¿‡ç¨‹ä¸­çš„åæ ‡ä½ç½®ï¼ˆxä¸å˜ï¼‰\n\tint frameIndex; //å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡å¸§çš„åºå·\n\tint destY; //é£˜è½çš„ç›®æ ‡ä½ç½®çš„yåæ ‡\n\tbool used; //æ˜¯å¦åœ¨ä½¿ç”¨\n};\n\n//é˜³å…‰æ± \nstruct sunshineBall balls[10];\nIMAGE imgSunshineBall[29];\n\n\nvoid gameInit() {\n\tmemset(balls, 0, sizeof(balls));\n\tfor (int i = 0; i < 29; i++) {\n\t\tsprintf_s(name, sizeof(name), \"res/sunshine/%d.png\", i + 1);\n\t\tloadimage(&imgSunshineBall[i], name);\n\t}\n\n\t//é…ç½®éšæœºç§å­\n\tsrand(time(NULL));\n}\n\nvoid creatSunshine() {\n\tstatic int count = 0;\n\tstatic int fre = 400;\n\tcount++;\n\tif (count >= fre) { //æ¯freå¸§åˆ›å»ºä¸€ä¸ªé˜³å…‰ï¼Œfreéšæœºæ”¹å˜\n\t\tfre = 200 + rand() % 200;\n\t\tcount = 0;\n\n\t\t//ä»é˜³å…‰æ± ä¸­å–ä¸€ä¸ªå¯ä»¥ä½¿ç”¨çš„\n\t\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\n\t\tint i;\n\t\tfor (i = 0; i < ballMax && balls[i].used; i++);\n\t\tif (i >= ballMax) return;\n\n\t\tballs[i].used = true;\n\t\tballs[i].frameIndex = 0;\n\t\tballs[i].x = 260 + rand() % (900 - 260);\n\t\tballs[i].y = 60;\n\t\tballs[i].destY = 200 + (rand() % 4) * 90;\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine();\n}\n```\n### æ˜¾ç¤ºéšæœºé˜³å…‰\n```C\nstruct sunshineBall {\n\tint x, y; //é˜³å…‰çƒåœ¨é£˜è½è¿‡ç¨‹ä¸­çš„åæ ‡ä½ç½®ï¼ˆxä¸å˜ï¼‰\n\tint frameIndex; //å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡å¸§çš„åºå·\n\tint destY; //é£˜è½çš„ç›®æ ‡ä½ç½®çš„yåæ ‡\n\tbool used; //æ˜¯å¦åœ¨ä½¿ç”¨\n\tint timer; //è®¡æ—¶å™¨\n};\n\nvoid updateWindow() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tIMAGE* img = &imgSunshineBall[balls[i].frameIndex];\n\t\t\tputimagePNG(balls[i].x, balls[i].y, img);\n\t\t}\n\t}\n}\n\t\nvoid creatSunshine() {\n\tif (count >= fre) {\n\t\tballs[i].timer = 0;\n\t}\n}\n\nvoid updateSunshine() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tballs[i].frameIndex = (balls[i].frameIndex + 1) % 29;\n\t\t\tif (balls[i].timer == 0) { //æœªåˆ°è¾¾åœ°é¢\n\t\t\t\tballs[i].y += 2;\n\t\t\t}\n\t\t\tif (balls[i].y >= balls[i].destY) {\n\t\t\t\t//balls[i].used = false;\n\t\t\t\tballs[i].timer++;\n\t\t\t\tif (balls[i].timer > 100) { //æ‰åˆ°åœ°é¢100å¸§ä¹‹å\n\t\t\t\t\tballs[i].used = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine(); //åˆ›å»ºé˜³å…‰\n\tupdateSunshine(); //æ›´æ–°é˜³å…‰çš„çŠ¶æ€\n}\n```\n### æ”¶é›†é˜³å…‰ã€æ˜¾ç¤ºé˜³å…‰å€¼\n```C\n#include<mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\nint sunshine; //æ€»é˜³å…‰å€¼\n\nvoid gameInit() {\n\tsunshine = 150;\n\n\t//è®¾ç½®å­—ä½“\n\tLOGFONT f;\n\tgettextstyle(&f);                     // è·å–å½“å‰å­—ä½“è®¾ç½®\n\tf.lfHeight = 30;                      // è®¾ç½®å­—ä½“é«˜åº¦ä¸º 48\n\tf.lfWidth = 15;\n\tstrcpy(f.lfFaceName, \"Segoe UI Black\"); \n\tf.lfQuality = ANTIALIASED_QUALITY;    // è®¾ç½®è¾“å‡ºæ•ˆæœä¸ºæŠ—é”¯é½¿  \n\tsettextstyle(&f);                     // è®¾ç½®å­—ä½“æ ·å¼\n\tsetbkmode(TRANSPARENT);\t\t\t\t  //èƒŒæ™¯æ¨¡å¼é€æ˜\n\tsetcolor(BLACK);\t\t\t\t\t  //å­—ä½“é¢œè‰²\n}\n\nvoid updateWindow() {\n\tchar scoreText[8];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", sunshine);\n\touttextxy(276, 67, scoreText); //åœ¨æŒ‡å®šä½ç½®è¾“å‡ºæ–‡æœ¬--åˆ†æ•°\n}\n\nvoid collectSunshine(ExMessage* msg) {\n\tint count = sizeof(balls) / sizeof(balls[0]);\n\tint w = imgSunshineBall[0].getwidth(); //é˜³å…‰çƒå®½åº¦\n\tint h = imgSunshineBall[0].getheight();//é˜³å…‰çƒé«˜åº¦\n\tfor (int i = 0; i < count; i++) {\n\t\tif (balls[i].used) {\n\t\t\tint x = balls[i].x;\n\t\t\tint y = balls[i].y;\n\t\t\tif (msg->x > x && msg->x < x + w && msg->y > y && msg->y < y + h) {\n\t\t\t\tballs[i].used = false;\n\t\t\t\tsunshine += 25;\n\t\t\t\tmciSendString(\"play res/sunshine.mp3\", 0, 0, 0); //æ·»åŠ éŸ³æ•ˆ\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //å·¦å‡»æŒ‰ä¸‹\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollectSunshine(&msg);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```","tags":["c","PvZ"]},{"title":"Java ç»¼åˆå®æˆ˜ï¼ˆä¸€ï¼‰","url":"/2024/09/24/Java ç»¼åˆå®æˆ˜/","content":"\n---\n## Java ç»¼åˆå®æˆ˜ï¼ˆä¸€ï¼‰\n### å¥åº·è®¡ç®—å™¨\n**éœ€æ±‚ï¼šå¼€å‘ä¸€ä¸ªç®€å•çš„å¥åº·è®¡ç®—å™¨åº”ç”¨ç¨‹åºï¼Œå®ƒå¯ä»¥æ¥å—ç”¨æˆ·çš„è¾“å…¥ï¼ˆå¦‚å¹´é¾„ã€æ€§åˆ«ã€ä½“é‡ã€èº«é«˜ï¼‰ï¼Œå¹¶è®¡ç®—å‡ºç”¨æˆ·çš„ BMIï¼ˆèº«ä½“è´¨é‡æŒ‡æ•°ï¼‰å’Œ BMRï¼ˆåŸºç¡€ä»£è°¢ç‡ï¼‰ã€‚**\n```Java\npackage test;\n\nimport java.util.Scanner;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„èº«é«˜ï¼š\");\n        double height=sc.nextDouble();\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„ä½“é‡ï¼š\");\n        double weight=sc.nextDouble();\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„æ€§åˆ«ï¼ˆç”·/å¥³ï¼‰ï¼š\");\n        String sex=sc.next();\n\n        System.out.println(\"è¯·æ‚¨è¾“å…¥æ‚¨çš„å¹´é¾„ï¼š\");\n        int age=sc.nextInt();\n\n        double bmi=calcBMI(height,weight);\n        System.out.println(\"æ‚¨çš„BMIå€¼ä¸ºï¼š\"+bmi);\n\n        double bmr=calcBMR(height,weight,age,sex);\n        System.out.println(\"æ‚¨çš„BMRå€¼ä¸ºï¼š\"+bmr);\n    }\n\n    public static double calcBMI(double height,double weight){\n        return weight/(height*height);\n    }\n\n    public static double calcBMR(double height,double weight,int age,String sex){\n        double bmr=0;\n        if(sex.equals(\"ç”·\")){\n            bmr=88.362+13.397*weight+4.799*height-5.677*age;\n        }\n        else{\n            bmr=447.593+9.247*weight+3.098*height-4.330*age;\n        }\n        return bmr;\n    }\n}\n```\n### ç®€å•è®¡ç®—å™¨\n**éœ€æ±‚ï¼šè®¾è®¡ä¸€ä¸ªå¯ä»¥æ‰§è¡ŒåŸºæœ¬æ•°å­¦è¿ç®—ï¼ˆåŠ ã€å‡ã€ä¹˜ã€é™¤ï¼‰çš„è®¡ç®—å™¨ç¨‹åºã€‚** \n**åŠŸèƒ½æè¿°ï¼šç”¨æˆ·è¾“å…¥ä¸¤ä¸ªæ•°å­—ã€ä¸€ä¸ªè¿ç®—ç¬¦ï¼ˆ+ã€-ã€*ã€/ï¼‰ã€‚æ ¹æ®æ‰€é€‰è¿ç®—ç¬¦æ‰§è¡Œç›¸åº”çš„æ•°å­¦è¿ç®—ï¼Œæ˜¾ç¤ºè¿ç®—ç»“æœã€‚**\n```Java\npackage test1;\n\nimport java.util.Scanner;\n\npublic class test1 {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"è¯·è¾“å…¥ç¬¬ä¸€ä¸ªæ•°å­—ï¼š\");\n        double num1=sc.nextDouble();\n\n        System.out.println(\"è¯·è¾“å…¥ç¬¬äºŒä¸ªæ•°å­—ï¼š\");\n        double num2=sc.nextDouble();\n\n        System.out.println(\"è¯·è¾“å…¥è¿ç®—ç¬¦ï¼ˆ+ã€-ã€*ã€/ï¼‰ï¼š\");\n        String operator=sc.next();\n\n        double result=calculate(num1,num2,operator);\n        System.out.println(\"è®¡ç®—ç»“æœä¸ºï¼š\"+result);\n    }\n\n    public static double calculate(double num1,double num2,String operator){\n        double result=0;\n        switch (operator){\n            case \"+\":\n                result=num1+num2;\n                break;\n            case \"-\":\n                result=num1-num2;\n                break;\n            case \"*\":\n                result=num1*num2;\n                break;\n            case \"/\":\n                result=num1/num2;\n                break;\n            default:\n                System.out.println(\"è¾“å…¥çš„è¿ç®—ç¬¦æœ‰è¯¯ï¼\");\n        }\n        return result;\n    }\n}\n```\n### çŒœæ•°å­—å°æ¸¸æˆ\n**éœ€æ±‚ï¼šéšæœºç”Ÿæˆä¸€ä¸ª1-100ä¹‹é—´çš„æ•°æ®ï¼Œæç¤ºç”¨æˆ·çŒœæµ‹ï¼ŒçŒœå¤§æç¤ºè¿‡å¤§ï¼ŒçŒœå°æç¤ºè¿‡å°ï¼Œç›´åˆ°çŒœä¸­ç»“æŸæ¸¸æˆã€‚**\n```Java\npackage test1;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class test2 {\n    public static void main(String[] args) {\n        guessNumber();\n    }\n\n    public static void guessNumber(){\n        /*æ–¹æ³•ä¸€*/\n        //Math.random()è¿”å›[0,1)ä¹‹é—´çš„éšæœºå°æ•°\n        //(int)(Math.random()*100)==>[0,100)çš„æ•´æ•°==>[0,99]+1==>[1,100]\n        //int number=(int)(Math.random()*100)+1;\n\n        /*æ–¹æ³•äºŒ*/\n        Random r=new Random();\n        int number=r.nextInt(100)+1;\n\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            System.out.println(\"è¯·è¾“å…¥ä¸€ä¸ª1~100ä¹‹é—´çš„æ•°å­—ï¼š\");\n            int guess=sc.nextInt();\n            if(guess<number){\n                System.out.println(\"çŒœå°äº†ï¼Œå†è¯•è¯•å§ï¼\");\n            }\n            else if(guess>number){\n                System.out.println(\"çŒœå¤§äº†ï¼Œå†è¯•è¯•å§ï¼\");\n            }\n            else{\n                System.out.println(\"æ­å–œä½ çŒœå¯¹äº†ï¼\");\n                break;\n            }\n        }\n    }\n}\n```\n### å¼€å‘ä¸€ä¸ªéªŒè¯ç \n**éœ€æ±‚ï¼šå¼€å‘ä¸€ä¸ªç¨‹åºï¼Œå¯ä»¥ç”ŸæˆæŒ‡å®šä½æ•°çš„éªŒè¯ç ï¼Œæ¯ä½å¯ä»¥æ˜¯æ•°å­—ï¼Œå¤§å°å†™å­—æ¯ã€‚**\n```Java\npackage test1;\n\npublic class test3 {\n    public static void main(String[] args) {\n        System.out.println(getCode(6));\n    }\n\n    public static String getCode(int n){\n        String code=\"\";\n\n        for(int i=0;i<n;i++){\n            int type=(int)(Math.random()*3); //æ•°å­—0/å¤§å†™1/å°å†™2\n            \n            switch(type){\n                case 0:\n                    int num=(int)(Math.random()*10);\n                    code+=num;\n                    break;\n                case 1:\n                    int num1=(int)(Math.random()*26)+65;\n                    code+=(char)num1;\n                    break;\n                case 2:\n                    int num2=(int)(Math.random()*26)+97;\n                    code+=(char)num2;\n                    break;\n            }\n        }\n        return code;\n    }\n}\n```\n### æ‰¾ç´ æ•°\n**éœ€æ±‚ï¼šè¾“å‡º101-200ä¹‹é—´çš„æ‰€æœ‰ç´ æ•°ä»¥åŠæ€»ä¸ªæ•°ã€‚**\n```Java\npackage test1;\n\npublic class test4 {\n    public static void main(String[] args) {\n        //ç›®æ ‡ï¼šæ‰¾å‡º101-200ä¹‹é—´çš„å…¨éƒ¨ç´ æ•°\n        int count=0;\n        for(int i=101;i<=200;i++){\n            if(isPrime(i)){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println(\"ç´ æ•°çš„ä¸ªæ•°ä¸ºï¼š\"+count);\n    }\n\n    public static boolean isPrime(int num){\n        for(int i=2;i*i<=num;i++){\n            if(num%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n### æ–—åœ°ä¸»æ¸¸æˆ\n**éœ€æ±‚ï¼šå¼€å‘ä¸€ä¸ªç®€æ˜“ç‰ˆçš„æ–—åœ°ä¸»æ¸¸æˆï¼Œè¦æ±‚åªå®Œæˆåšç‰Œï¼ˆå­˜å‚¨54å¼ ç‰Œï¼‰ã€æ´—ç‰Œã€‚**\n```Java\npackage test2;\n\npublic class test1 {\n    public static void main(String[] args) {\n       start();\n    }\n    public static void start(){\n        String[] poker=new String[54];\n        String[] colors={\"â™ \",\"â™¥\",\"â™£\",\"â™¦\"};\n        String[] nums={\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"};\n\n        int index=0;\n        for(int i=0;i<colors.length;i++){\n            for(int j=0;j<nums.length;j++){\n                poker[index++]=colors[i]+nums[j];\n            }\n        }\n        poker[index++]=\"Big Joker\";\n        poker[index++]=\"Small Joker\";\n\n        //æ‰“å°ç‰Œ\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n\n        //æ´—ç‰Œ\n        for(int i=0;i<poker.length;i++){\n            int j=(int)(Math.random()*poker.length);\n            String temp=poker[i];\n            poker[i]=poker[j];\n            poker[j]=temp;\n        }\n\n        System.out.println(\"æ´—ç‰Œåï¼š\");\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n    }\n}\n```\n### çŸ³å¤´è¿·é˜µæ¸¸æˆ\n**éœ€æ±‚ï¼šåªéœ€å®Œæˆæ•°æ®åˆå§‹åŒ–**\n```Java\npackage test2;\n\npublic class test2 {\n    public static void main(String[] args) {\n        start(5);\n    }\n    public static void start(int n) {\n       int[][] arr=new int[n][n];\n\n       int count=1;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               arr[i][j]=count++;\n           }\n       }\n\n       print(arr);\n\n       //æ‰“ä¹±äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ é¡ºåº\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                int x=(int)(Math.random()*arr.length);\n                int y=(int)(Math.random()*arr[i].length);\n                int temp=arr[i][j];\n                arr[i][j]=arr[x][y];\n                arr[x][y]=temp;\n            }\n        }\n        System.out.println(\"------------------\");\n        System.out.println(\"æ‰“ä¹±åï¼š\");\n        print(arr);\n    }\n    public static void print(int[][] arr){\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                System.out.print(arr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```","tags":["Java"]},{"title":"Markdown è¯­æ³•","url":"/2024/09/09/Markdownè¯­æ³•/","content":"\n## Markdown æ ‡é¢˜\n``` markdown\n# ä¸€çº§æ ‡é¢˜\n\n## äºŒçº§æ ‡é¢˜\n\n### ä¸‰çº§æ ‡é¢˜\n\n#### å››çº§æ ‡é¢˜\n\n##### äº”çº§æ ‡é¢˜\n\n###### å…­çº§æ ‡é¢˜\n```\n&nbsp;**æˆ–è€…åœ¨æ–‡æœ¬ä¸‹æ–¹æ·»åŠ ä»»æ„æ•°é‡çš„ = æˆ– - åˆ†åˆ«ç”¨äºè¡¨ç¤ºä¸€çº§æ ‡é¢˜æˆ–äºŒçº§æ ‡é¢˜**\n``` markdown\nä¸€çº§æ ‡é¢˜\n=========\n\näºŒçº§æ ‡é¢˜\n---------\n```\n\n## Markdown å­—ä½“\n``` markdown\n*æ–œä½“æ–‡å­—*\n\n_æ–œä½“æ–‡å­—_\n\n**ç²—ä½“æ–‡å­—**\n\n__ç²—ä½“æ–‡å­—__\n\n***ç²—æ–œä½“æ–‡å­—***\n\n___ç²—æ–œä½“æ–‡å­—___\n```\n\n## Markdown å¼•ç”¨\n``` markdown\n>è¿™æ˜¯å¼•ç”¨çš„å†…å®¹\n\n>>è¿™æ˜¯å¼•ç”¨çš„å†…å®¹\n\n>>>>>>>>>>è¿™æ˜¯å¼•ç”¨çš„å†…å®¹\n```\n\n## Markdown åˆ†å‰²çº¿\n&nbsp;**ä¸‰ä¸ªæˆ–è€…ä¸‰ä¸ªä»¥ä¸Šçš„ - æˆ–è€… * æˆ–è€… _ éƒ½å¯ä»¥**\n``` markdown\n---\n\n****\n\n____\n```\n  \n## Markdown ä¸‹åˆ’çº¿\n``` markdown\n<u>å¸¦ä¸‹åˆ’çº¿æ–‡æœ¬</u>   \n```\n\n## Markdown åˆ é™¤çº¿\n``` markdown \n~~tencent.com~~\n```\n\n## Markdown å›¾ç‰‡\n### æ’å…¥äº’è”ç½‘ä¸Šå›¾ç‰‡\n``` markdown\n![å›¾ç‰‡æè¿°](å›¾ç‰‡é“¾æ¥ ''å›¾ç‰‡title'')\n```\n>å›¾ç‰‡æè¿°å°±æ˜¯æ˜¾ç¤ºåœ¨å›¾ç‰‡ä¸‹é¢çš„æ–‡å­—ï¼Œç›¸å½“äºå¯¹å›¾ç‰‡å†…å®¹çš„è§£é‡Šã€‚\nå›¾ç‰‡titleæ˜¯å›¾ç‰‡çš„æ ‡é¢˜ï¼Œå½“é¼ æ ‡ç§»åˆ°å›¾ç‰‡ä¸Šæ—¶æ˜¾ç¤ºçš„å†…å®¹ã€‚\næ³¨æ„ï¼štitleå¯åŠ å¯ä¸åŠ ï¼Œå›¾ç‰‡æè¿°å¯å†™å¯ä¸å†™ã€‚\n\n### æ’å…¥æœ¬åœ°å›¾ç‰‡\n``` markdown\n![å›¾ç‰‡æè¿°](å›¾ç‰‡æœ¬åœ°è·¯å¾„ ''å›¾ç‰‡title'')\n```\n>å›¾ç‰‡æè¿°å°±æ˜¯æ˜¾ç¤ºåœ¨å›¾ç‰‡ä¸‹é¢çš„æ–‡å­—ï¼Œç›¸å½“äºå¯¹å›¾ç‰‡å†…å®¹çš„è§£é‡Šã€‚\nå›¾ç‰‡titleæ˜¯å›¾ç‰‡çš„æ ‡é¢˜ï¼Œå½“é¼ æ ‡ç§»åˆ°å›¾ç‰‡ä¸Šæ—¶æ˜¾ç¤ºçš„å†…å®¹ã€‚\næ³¨æ„ï¼štitleå¯åŠ å¯ä¸åŠ ï¼Œå›¾ç‰‡æè¿°å¯å†™å¯ä¸å†™ã€‚\n\n## Markdown è¶…é“¾æ¥\n``` markdown\n[è¶…é“¾æ¥å](è¶…é“¾æ¥åœ°å€ \"è¶…é“¾æ¥title\")\n```\n&nbsp;**æ³¨ï¼štitleå¯åŠ å¯ä¸åŠ **\n\n## Markdown åˆ—è¡¨\n### æ— åºåˆ—è¡¨\n&nbsp;**æ— åºåˆ—è¡¨ç”¨ - + * ä»»ä½•ä¸€ç§éƒ½å¯ä»¥**\n``` markdown\n* ç¬¬ä¸€é¡¹\n* ç¬¬äºŒé¡¹\n* ç¬¬ä¸‰é¡¹\n\n+ ç¬¬ä¸€é¡¹\n+ ç¬¬äºŒé¡¹\n+ ç¬¬ä¸‰é¡¹\n\n- ç¬¬ä¸€é¡¹\n- ç¬¬äºŒé¡¹\n- ç¬¬ä¸‰é¡¹\n```\n### æœ‰åºåˆ—è¡¨\n``` markdown\n1. ç¬¬ä¸€é¡¹\n2. ç¬¬äºŒé¡¹\n3. ç¬¬ä¸‰é¡¹\n```\n### åµŒå¥—åˆ—è¡¨\n&nbsp;**ä¸Šä¸€çº§å’Œä¸‹ä¸€çº§ä¹‹é—´æ•²ä¸€ä¸ªTabé”®å³å¯**\n``` markdown\n1. ç¬¬ä¸€é¡¹ï¼š\n    - ç¬¬ä¸€é¡¹åµŒå¥—çš„ç¬¬ä¸€ä¸ªå…ƒç´ \n    - ç¬¬ä¸€é¡¹åµŒå¥—çš„ç¬¬äºŒä¸ªå…ƒç´ \n2. ç¬¬äºŒé¡¹ï¼š\n    - ç¬¬äºŒé¡¹åµŒå¥—çš„ç¬¬ä¸€ä¸ªå…ƒç´ \n    - ç¬¬äºŒé¡¹åµŒå¥—çš„ç¬¬äºŒä¸ªå…ƒç´ \n```\n\n## Markdown è¡¨æ ¼\n``` markdown\n|è¡¨å¤´|è¡¨å¤´|è¡¨å¤´|\n|---|:--:|---:|\n|å†…å®¹|å†…å®¹|å†…å®¹|\n|å†…å®¹|å†…å®¹|å†…å®¹|\n```\n\n>ç¬¬äºŒè¡Œåˆ†å‰²è¡¨å¤´å’Œå†…å®¹\n>-æœ‰ä¸€ä¸ªå°±è¡Œï¼Œä¸ºäº†å¯¹é½ï¼Œå¤šåŠ äº†å‡ ä¸ª\n>æ–‡å­—é»˜è®¤å±…å·¦\n>-ä¸¤è¾¹åŠ ï¼šè¡¨ç¤ºæ–‡å­—å±…ä¸­\n>-å³è¾¹åŠ ï¼šè¡¨ç¤ºæ–‡å­—å±…å³\n\n## Markdown ä»£ç \n### å•è¡Œä»£ç \n``` markdown\n`hello world`\n```\n\n### ä»£ç å—\n``` markdown\n(```)è¯­è¨€\n  ä»£ç å†…å®¹\n(```)\n```\n\n## Markdown æµç¨‹å›¾\n``` markdown\n(```)flow\nst=>start: å¼€å§‹\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n(```)\n```\n## Markdown æ¢è¡Œ\n``` markdown\nè¿ç»­ä¸¤ä¸ªä»¥ä¸Šç©ºæ ¼+å›è½¦\n```\n&nbsp;**æˆ–è€…**\n``` markdown\nä½¿ç”¨htmlè¯­è¨€æ¢è¡Œæ ‡ç­¾<br>\n```\n\n## Markdown ç¼©è¿›å­—ç¬¦\n``` markdown\n&nbsp;  ç¼©è¿›1/4ä¸­æ–‡\n&ensp;  ç¼©è¿›åŠä¸ªä¸­æ–‡ï¼Œä¸€ä¸ªå­—ç¬¦\n&emsp;  ç¼©è¿›ä¸€ä¸ªä¸­æ–‡ï¼Œ2ä¸ªå­—ç¬¦\n```","tags":["Markdown"]},{"title":"Hello World","url":"/2024/09/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]