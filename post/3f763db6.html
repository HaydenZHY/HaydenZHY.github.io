<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络实践记录 | 梨花先雪</title><meta name="author" content="梨花先雪"><meta name="copyright" content="梨花先雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络实践记录">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络实践记录">
<meta property="og:url" content="https://haydenzhy.github.io/post/3f763db6">
<meta property="og:site_name" content="梨花先雪">
<meta property="og:description" content="计算机网络实践记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/avatar/avatar2.jpg">
<meta property="article:published_time" content="2024-09-28T12:21:31.000Z">
<meta property="article:modified_time" content="2025-01-06T03:17:41.822Z">
<meta property="article:author" content="梨花先雪">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="实践">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/avatar/avatar2.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/avatar/avatar2.jpg"><link rel="canonical" href="https://haydenzhy.github.io/post/3f763db6"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 梨花先雪","link":"链接: ","source":"来源: 梨花先雪","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络实践记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-06 11:17:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 13 || hour >= 13
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/avatar/avatar2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa-solid fa-book"></i><span> 书单</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fa-solid fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa-solid fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background: #626079"><nav id="nav"><span id="blog-info"><a href="/" title="梨花先雪"><span class="site-name">梨花先雪</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa-solid fa-book"></i><span> 书单</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fa-solid fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa-solid fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络实践记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-28T12:21:31.000Z" title="发表于 2024-09-28 20:21:31">2024-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-06T03:17:41.822Z" title="更新于 2025-01-06 11:17:41">2025-01-06</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<ul>
<li>天津大学 2024 计算机网络 TCP 课程实践</li>
<li>Lab Member：海棠未雨，梨花先雪</li>
<li>最终成绩 93 分捏 😋</li>
</ul>
<hr>
<h1>文件结构说明</h1>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tju<span class="emphasis">_tcp ----------------- 项目根目录 </span></span><br><span class="line"><span class="emphasis">├─ build ---------------- 存放所有编译的中间文件</span></span><br><span class="line"><span class="emphasis">│  ├─ kernel.o</span></span><br><span class="line"><span class="emphasis">│  ├─ tju_</span>packet.o  </span><br><span class="line">│  └─ tju<span class="emphasis">_tcp.o</span></span><br><span class="line"><span class="emphasis">├─ inc ------------------ 存放所有头文件</span></span><br><span class="line"><span class="emphasis">│  ├─ global.h ---------- 定义一些全局都会用到的变量和结构</span></span><br><span class="line"><span class="emphasis">│  ├─ kernel.h ---------- 模拟一部分linux内核行为 比如如何发送数据到下一层 根据五元组查找socket等</span></span><br><span class="line"><span class="emphasis">│  ├─ tju_</span>packet.h ------ 定义TCP所用到的数据包格式 提供各种数据包的操作(创建 获得字段等)</span><br><span class="line">│  └─ tju<span class="emphasis">_tcp.h --------- 需要实现的TCP的各种结构和功能的定义</span></span><br><span class="line"><span class="emphasis">├─ src ------------------ 存放所有源代码文件</span></span><br><span class="line"><span class="emphasis">│  ├─ client.c ---------- 客户端主函数实现</span></span><br><span class="line"><span class="emphasis">│  ├─ server.c ---------- 服务端主函数实现</span></span><br><span class="line"><span class="emphasis">│  ├─ kernel.c ---------- 虚拟内核实现</span></span><br><span class="line"><span class="emphasis">│  ├─ tju_</span>packet.c ------ 可靠层包封装实现</span><br><span class="line">│  └─ tju<span class="emphasis">_tcp.c --------- 可靠层实现</span></span><br><span class="line"><span class="emphasis">├─ Makefile ------------- 生成脚本</span></span><br><span class="line"><span class="emphasis">├─ README.md ------------ 文件说明</span></span><br><span class="line"><span class="emphasis">└─ bin</span></span><br><span class="line"><span class="emphasis">   ├─ client</span></span><br><span class="line"><span class="emphasis">   └─ server</span></span><br></pre></td></tr></table></figure>
<hr>
<h1>系统环境信息</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">neofetch</span><br><span class="line">--------------</span><br><span class="line">OS: Ubuntu 20.04.2 LTS x86_64</span><br><span class="line">Host: Oracle Corporation VirtualBox</span><br><span class="line">Kernel: 5.4.0-80-generic</span><br><span class="line">Uptime: 3 mins</span><br><span class="line">Packages: 676 (dpkg), 4 (snap)</span><br><span class="line">Shell: bash 5.0.17</span><br><span class="line">Resolution: 800x600</span><br><span class="line">Terminal: /dev/pts/0</span><br><span class="line">CPU: 11th Gen Intel i7-11800H (2) @ 2.304GHz</span><br><span class="line">GPU: VirtualBox Graphics Adapter</span><br><span class="line">Memory: 294MiB / 981MiB</span><br></pre></td></tr></table></figure>
<hr>
<h1>具体实验记录</h1>
<h2 id="连接管理">连接管理</h2>
<center>
<img src="https://s2.loli.net/2024/10/11/t2LOxSBZgRkiblj.png" width="60%" />
</center>
<h3 id="三次握手建立连接">三次握手建立连接</h3>
<p><strong>1. tju_connect( )</strong><br>
<code>tju_connect( )</code>函数是三次握手的开端。在该函数中，客户端的sock绑定好本地的ip和port后向服务器端发送SYN包，同时把当前的状态变化为SYN_SENT。成功建立连接后将sock放入ESTABLISHED的hash表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tju_connect</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, tju_sock_addr target_addr)</span>&#123;</span><br><span class="line">    sock-&gt;established_remote_addr = target_addr;</span><br><span class="line"></span><br><span class="line">    tju_sock_addr local_addr;</span><br><span class="line">    local_addr.ip = inet_network(CLIENT_IP);</span><br><span class="line">    local_addr.port = <span class="number">5678</span>; <span class="comment">// 连接方进行connect连接的时候 内核中是随机分配一个可用的端口</span></span><br><span class="line">    sock-&gt;established_local_addr = local_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里也不能直接建立连接 需要经过三次握手</span></span><br><span class="line">    <span class="comment">// 实际在linux中 connect调用后 会进入一个while循环</span></span><br><span class="line">    <span class="comment">// 循环跳出的条件是socket的状态变为ESTABLISHED 表面看上去就是 正在连接中 阻塞</span></span><br><span class="line">    <span class="comment">// 而状态的改变在别的地方进行 在我们这就是tju_handle_packet</span></span><br><span class="line">    <span class="type">uint32_t</span> seq = <span class="number">0</span>;  <span class="comment">// 序列号</span></span><br><span class="line">    <span class="type">uint32_t</span> ack = <span class="number">0</span>;  <span class="comment">// 确认号</span></span><br><span class="line">    <span class="type">uint8_t</span> flag=SYN_FLAG_MASK; <span class="comment">//flag标记为：连接状态进行到哪一步</span></span><br><span class="line">    <span class="type">char</span> *SYN = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    sendToLayer3(SYN, DEFAULT_HEADER_LEN); <span class="comment">//客户端向服务器端发送同步报文--第一次握手</span></span><br><span class="line">    change_sock_state(sock, SYN_SENT);</span><br><span class="line">    <span class="comment">// printf(&quot;client发送SYN\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    Timeout_retransmission(sock, ESTABLISHED, SYN, DEFAULT_HEADER_LEN); <span class="comment">//阻塞等待，直到sock被建立</span></span><br><span class="line">    <span class="type">int</span> hashval = cal_hash(sock-&gt;established_local_addr.ip, sock-&gt;established_local_addr.port,sock-&gt;established_remote_addr.ip, sock-&gt;established_remote_addr.port);</span><br><span class="line">    established_socks[hashval] = sock;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. Timeout_retransmission( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timeout_retransmission</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">int</span> exp_state, <span class="type">char</span>* pkt, <span class="type">int</span> pktlen)</span> &#123; <span class="comment">//超时重传发包函数</span></span><br><span class="line">    <span class="comment">//printf(&quot;bg1\n&quot;);</span></span><br><span class="line">    <span class="type">long</span> timeout = <span class="number">100000L</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start_time</span>, <span class="title">end_time</span>;</span></span><br><span class="line">    gettimeofday(&amp;start_time, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (sock-&gt;state != exp_state)&#123;</span><br><span class="line">        gettimeofday(&amp;end_time, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">long</span> Time = <span class="number">1000000L</span> * (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_usec - start_time.tv_usec);</span><br><span class="line">        <span class="keyword">if</span> (Time &gt;= timeout) &#123; <span class="comment">//超时重传</span></span><br><span class="line">            gettimeofday(&amp;start_time, <span class="literal">NULL</span>);</span><br><span class="line">            sendToLayer3(pkt, pktlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;ed1\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. change_sock_state( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change_sock_state</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">int</span> state)</span> &#123;  <span class="comment">//添加：sock状态改变</span></span><br><span class="line">    <span class="keyword">while</span> (pthread_mutex_lock(&amp;(sock-&gt;state_lock)) != <span class="number">0</span>) ; <span class="comment">//改变sock状态前先加锁</span></span><br><span class="line">    sock-&gt;state = state;  </span><br><span class="line">    pthread_mutex_unlock(&amp;(sock-&gt;state_lock)); <span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. tju_accept()</strong><br>
<code>tju_accept( )</code>函数中添加了一个阻塞，使得只有当全连接hash表中存在这一个sock，服务器端才算连接完成，才能把新的sock加入到ESTABLISHED的hash表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tju_tcp_t</span> *<span class="title function_">tju_accept</span><span class="params">(<span class="type">tju_tcp_t</span> *listen_sock)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (listen_sock-&gt;received_len &lt; DEFAULT_HEADER_LEN);</span><br><span class="line">    <span class="type">char</span> *header = <span class="built_in">malloc</span>(DEFAULT_HEADER_LEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(header, listen_sock-&gt;received_buf, DEFAULT_HEADER_LEN);</span><br><span class="line">    <span class="built_in">memset</span>(listen_sock-&gt;received_buf, <span class="number">0</span>, DEFAULT_HEADER_LEN);</span><br><span class="line">    listen_sock-&gt;received_buf = <span class="literal">NULL</span>;</span><br><span class="line">    listen_sock-&gt;received_len = listen_sock-&gt;received_len - DEFAULT_HEADER_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="type">tju_tcp_t</span>* new_conn = (<span class="type">tju_tcp_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">tju_tcp_t</span>));</span><br><span class="line">    pthread_mutex_init(&amp;(new_conn-&gt;state_lock), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(new_conn, listen_sock, <span class="keyword">sizeof</span>(<span class="type">tju_tcp_t</span>));</span><br><span class="line"></span><br><span class="line">    tju_sock_addr local_addr, remote_addr;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     这里涉及到TCP连接的建立</span></span><br><span class="line"><span class="comment">     正常来说应该是收到客户端发来的SYN报文</span></span><br><span class="line"><span class="comment">     从中拿到对端的IP和PORT</span></span><br><span class="line"><span class="comment">     换句话说 下面的处理流程其实不应该放在这里 应该在tju_handle_packet中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    remote_addr.ip = inet_network(CLIENT_IP);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    remote_addr.port = <span class="number">5678</span>;  <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    local_addr.ip = listen_sock-&gt;bind_addr.ip;  <span class="comment">//具体的IP地址</span></span><br><span class="line">    local_addr.port = listen_sock-&gt;bind_addr.port;  <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    new_conn-&gt;established_local_addr = local_addr;</span><br><span class="line">    new_conn-&gt;established_remote_addr = remote_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listen_sock-&gt;state != ESTABLISHED) ;</span><br><span class="line">    change_sock_state(new_conn, ESTABLISHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的conn放到内核建立连接的socket哈希表中</span></span><br><span class="line">    <span class="type">int</span> hashval = cal_hash(local_addr.ip, local_addr.port, remote_addr.ip, remote_addr.port);</span><br><span class="line">    established_socks[hashval] = new_conn;</span><br><span class="line">    <span class="keyword">return</span> new_conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. tju_handle_packet( )</strong><br>
<code>tju_handle_packet( )</code>函数中需要解决对各种报文的解析。<code>onTCPPocket( )</code>函数如果从established_hash或listen_hash中找到了对应的socket，就会调用 <code>tju_handle_packet( )</code>函数对收到的数据包进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tju_handle_packet</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;state == LISTEN &amp;&amp; get_flags(pkt) == SYN_FLAG_MASK)&#123; <span class="comment">//第二次握手</span></span><br><span class="line">        <span class="keyword">while</span> (pthread_mutex_lock(&amp;(sock-&gt;recv_lock)) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sock-&gt;received_buf == <span class="literal">NULL</span>) sock-&gt;received_buf = <span class="built_in">malloc</span>(DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="keyword">else</span> sock-&gt;received_buf = <span class="built_in">realloc</span>(sock-&gt;received_buf, sock-&gt;received_len + DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="built_in">memcpy</span>(sock-&gt;received_buf + sock-&gt;received_len, pkt, DEFAULT_HEADER_LEN);</span><br><span class="line">        sock-&gt;received_len += DEFAULT_HEADER_LEN;</span><br><span class="line">        pthread_mutex_unlock(&amp;(sock-&gt;recv_lock));</span><br><span class="line"></span><br><span class="line">        tju_sock_addr remote;</span><br><span class="line">        remote.ip = inet_network(CLIENT_IP);</span><br><span class="line">        remote.port = get_src(pkt);</span><br><span class="line"></span><br><span class="line">        sock-&gt;established_local_addr = sock-&gt;bind_addr;</span><br><span class="line">        sock-&gt;established_remote_addr = remote;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hashval = cal_hash(sock-&gt;established_local_addr.ip, sock-&gt;established_local_addr.port, remote.ip, remote.port);</span><br><span class="line">        half_connection[hashval] = sock;  <span class="comment">//收到SYN报文后放进LISTEN的半连接队列中</span></span><br><span class="line">        established_socks[hashval] = sock; <span class="comment">//还会将该新建的socket放到ehash中</span></span><br><span class="line"></span><br><span class="line">        <span class="type">uint32_t</span> seq = <span class="number">0</span>;  </span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>; <span class="comment">//确认号是SYN报文序列号+1</span></span><br><span class="line">        <span class="type">uint8_t</span> flag = SYN_FLAG_MASK | ACK_FLAG_MASK; <span class="comment">//状态记为SYN+ACK，这里采用位运算|</span></span><br><span class="line">        <span class="type">char</span> *SYNACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(SYNACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        change_sock_state(sock, SYN_RECV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == SYN_SENT &amp;&amp; get_flags(pkt) == (ACK_FLAG_MASK | SYN_FLAG_MASK))&#123; <span class="comment">//第三次握手</span></span><br><span class="line">        <span class="comment">//printf(&quot;client收到SYCACK, 准备发送ACK\n&quot;);</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt);</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;base = seq;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;nextseq = seq;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        change_sock_state(sock, ESTABLISHED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == SYN_SENT &amp;&amp; get_flags(pkt) == SYN_FLAG_MASK)&#123; <span class="comment">//第三次握手（奇怪）</span></span><br><span class="line">        <span class="comment">// //printf(&quot;client收到SYCACK, 准备发送ACK\n&quot;);</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt);</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;base = seq;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;nextseq = seq;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        change_sock_state(sock, ESTABLISHED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sock-&gt;state == ESTABLISHED &amp;&amp; get_flags(pkt) == (SYN_FLAG_MASK | ACK_FLAG_MASK))&#123;  <span class="comment">//三次握手第三个包的重传</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt);</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == SYN_RECV &amp;&amp; get_flags(pkt) == ACK_FLAG_MASK)&#123;</span><br><span class="line">        <span class="comment">// //printf(&quot;server收到ACK\n&quot;);</span></span><br><span class="line">        sock-&gt;window.wnd_recv-&gt;expect_seq = get_seq(pkt) + get_plen(pkt) - DEFAULT_HEADER_LEN;</span><br><span class="line">        <span class="type">int</span> hash = cal_hash(sock-&gt;established_local_addr.ip, sock-&gt;established_local_addr.port,sock-&gt;established_remote_addr.ip, sock-&gt;established_remote_addr.port);</span><br><span class="line">        com_connection[hash] = sock;</span><br><span class="line">        half_connection[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        change_sock_state(sock, ESTABLISHED);</span><br><span class="line">        <span class="keyword">if</span> (get_plen(pkt) &gt; DEFAULT_HEADER_LEN) &#123; <span class="comment">//ACK包携带信息</span></span><br><span class="line">            pkt2buffer(sock, pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>6. pkt2buffer( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pkt2buffer</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span> &#123;</span><br><span class="line">    <span class="comment">//printf(&quot;bg6\n&quot;);</span></span><br><span class="line">    <span class="type">uint32_t</span> data_len = get_plen(pkt) - DEFAULT_HEADER_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pthread_mutex_lock(&amp;(sock-&gt;recv_lock)) != <span class="number">0</span>); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;received_buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        sock-&gt;received_buf = <span class="built_in">malloc</span>(data_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sock-&gt;received_buf = <span class="built_in">realloc</span>(sock-&gt;received_buf, sock-&gt;received_len + data_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(sock-&gt;received_buf + sock-&gt;received_len, pkt + DEFAULT_HEADER_LEN, data_len);    </span><br><span class="line">    sock-&gt;received_len += data_len;</span><br><span class="line">    pthread_mutex_unlock(&amp;(sock-&gt;recv_lock)); <span class="comment">// 解锁</span></span><br><span class="line">    <span class="comment">//printf(&quot;ed6\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四次挥手关闭连接">四次挥手关闭连接</h3>
<p><strong>1. tju_close ( )</strong><br>
四次挥手有两种情况，分别为先后关闭和同时关闭，两种方式首先都需要调用<code>tju_close( )</code>函数，因此，在<code>tju_close( )</code>函数中，需要构造一个 FIN+ACK 报文，seq和ack都是当前报文窗口的下一个数值，并把自身状态变为 FIN-WAIT1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tju_close</span> <span class="params">(<span class="type">tju_tcp_t</span>* sock)</span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> flag = FIN_FLAG_MASK | ACK_FLAG_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">    <span class="type">uint32_t</span> ack = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">    <span class="type">char</span>* FINACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    sendToLayer3(FINACK, DEFAULT_HEADER_LEN);</span><br><span class="line">    change_sock_state(sock, FIN_WAIT_1);</span><br><span class="line">    sock-&gt;window.wnd_send-&gt;nextseq++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sock-&gt;state != CLOSED) ;</span><br><span class="line">    <span class="comment">//printf(&quot;连接完全关闭\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. tju_handle_packet( )</strong><br>
接下来分为两种情况，但处理过程均在<code>tju_handle_packet( )</code>中完成，<code>tju_handle_packet( )</code>作为对收到的包进行响应的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tju_handle_packet</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == ESTABLISHED &amp;&amp; get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK))&#123; <span class="comment">// server收到第一次挥手，并进行第二次挥手和第三次挥手</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt);</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint16_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="comment">//printf(&quot;发送第二次挥手报文\n&quot;);</span></span><br><span class="line">        change_sock_state(sock, CLOSE_WAIT);</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;</span><br><span class="line">        seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">        ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> *FINACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="comment">//printf(&quot;发送第三次挥手报文\n&quot;);</span></span><br><span class="line">        change_sock_state(sock, LAST_ACK);</span><br><span class="line">        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == ESTABLISHED &amp;&amp; get_flags(pkt) == FIN_FLAG_MASK)&#123; <span class="comment">// server收到第一次挥手，并进行第二次挥手和第三次挥手</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt);</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint16_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        change_sock_state(sock, CLOSE_WAIT);</span><br><span class="line">        <span class="comment">//printf(&quot;发送第二次挥手报文\n&quot;);</span></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *FINACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="comment">//printf(&quot;发送第三次挥手报文\n&quot;);</span></span><br><span class="line">        change_sock_state(sock, LAST_ACK);</span><br><span class="line">        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == FIN_WAIT_1 &amp;&amp; get_flags(pkt) == ACK_FLAG_MASK)&#123; <span class="comment">// client收到第二次挥手</span></span><br><span class="line">        change_sock_state(sock, FIN_WAIT_2);</span><br><span class="line">        <span class="comment">//printf(&quot;收到第二次挥手报文\n&quot;);</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == FIN_WAIT_2 &amp;&amp; (get_flags(pkt) == (ACK_FLAG_MASK | FIN_FLAG_MASK)))&#123; <span class="comment">// client收到第三次挥手进行第四次挥手并关闭连接</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt);</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN,flag, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="comment">//printf(&quot;收到第三次挥手报文, 并发出第四次挥手\n&quot;);</span></span><br><span class="line">        change_sock_state(sock, TIME_WAIT);</span><br><span class="line">        <span class="type">int</span> hash = cal_hash(sock-&gt;established_local_addr.ip, sock-&gt;established_local_addr.port,    sock-&gt;established_remote_addr.ip, sock-&gt;established_remote_addr.port);</span><br><span class="line">        <span class="comment">//这里要等待2MSL</span></span><br><span class="line">        change_sock_state(sock, CLOSED);</span><br><span class="line">        established_socks[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;关闭连接\n&quot;);</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == LAST_ACK &amp;&amp; (get_flags(pkt) == ACK_FLAG_MASK))&#123; <span class="comment">// server收到第四次挥手并关闭连接</span></span><br><span class="line">        <span class="type">int</span> hash = cal_hash(sock-&gt;established_local_addr.ip, sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.ip, sock-&gt;established_remote_addr.port);</span><br><span class="line">        established_socks[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        half_connection[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        com_connection[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        change_sock_state(sock, CLOSED);</span><br><span class="line">        <span class="comment">//printf(&quot;关闭连接\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == FIN_WAIT_1 &amp;&amp; (get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK)))&#123; <span class="comment">// 同时关闭收到第一次挥手</span></span><br><span class="line">        change_sock_state(sock, CLOSING);</span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint16_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span>* ACK = create_packet_buf(sock-&gt;established_local_addr.port,sock-&gt;established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK,DEFAULT_HEADER_LEN);</span><br><span class="line">        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        <span class="comment">// //printf(&quot;同时关闭发出ACK\n&quot;);</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sock-&gt;state == FIN_WAIT_1 &amp;&amp; get_flags(pkt) == FIN_FLAG_MASK)&#123; <span class="comment">// 同时关闭收到第一次挥手</span></span><br><span class="line">        change_sock_state(sock, CLOSING);</span><br><span class="line">        <span class="type">uint32_t</span> seq = get_ack(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> ack = get_seq(pkt) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint16_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span>* ACK = create_packet_buf(sock-&gt;established_local_addr.port,sock-&gt;established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;state == CLOSING &amp;&amp; get_flags(pkt) == ACK_FLAG_MASK)&#123; <span class="comment">// 同时关闭时收到第三次挥手</span></span><br><span class="line">        change_sock_state(sock, TIME_WAIT);</span><br><span class="line">        <span class="comment">//等待2MSL</span></span><br><span class="line">        <span class="type">int</span> hash = cal_hash(sock-&gt;established_local_addr.ip, sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.ip, sock-&gt;established_remote_addr.port);</span><br><span class="line">        established_socks[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        half_connection[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        com_connection[hash] = <span class="literal">NULL</span>;</span><br><span class="line">        change_sock_state(sock, CLOSED);</span><br><span class="line">        <span class="comment">//printf(&quot;同时关闭彻底关闭\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可靠数据传输">可靠数据传输</h2>
<h3 id="发送缓冲区管理">发送缓冲区管理</h3>
<p><strong>1. <code>global.h</code> 中宏定义 TCP 发送窗口大小。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_SENDWN_SIZE 1000 </span></span><br></pre></td></tr></table></figure>
<p><strong>2. <code>tju_packet.h</code> 中为发送缓冲区创建1000个报文长度的循环队列，方便数据包超时重传。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 报文的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">tju_header_t</span> header;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">sent_time</span>;</span></span><br><span class="line">	<span class="type">char</span>* data;</span><br><span class="line">&#125; <span class="type">tju_packet_t</span>;</span><br><span class="line"><span class="type">tju_packet_t</span>* pktlist[TCP_SENDWN_SIZE];</span><br></pre></td></tr></table></figure>
<p><strong>3. tju_send( )</strong><br>
上层调用 <code>tju_send( )</code> 时，我们在 <code>tju_send( )</code>函数内创建发送线程并把发送数据存入缓冲区中。<br>
 这里我们先了解一下创建线程 <code>pthread_create( )</code>函数。</p>
<blockquote>
<p>int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (<em>start_rtn)(void</em>),void *restrict arg);</p>
<ul>
<li>tidp：事先创建好的pthread_t类型的参数。成功时tidp指向的内存单元被设置为新创建线程的线程ID。</li>
<li>attr：用于定制各种不同的线程属性。APUE的12.3节讨论了线程属性。通常直接设为NULL。</li>
<li>start_rtn：新创建线程从此函数开始运行。无参数是arg设为NULL即可。</li>
<li>arg：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。</li>
<li>返回值为 0（表示线程成功创建）。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> send_thread_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tju_send</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里当然不能直接简单地调用sendToLayer</span></span><br><span class="line">    <span class="keyword">if</span>(!send_thread_flag)&#123;</span><br><span class="line">        send_thread_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">pthread_t</span> sendthreadid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;sendthreadid, <span class="literal">NULL</span>, send_pkt, (<span class="type">void</span> *)sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pthread_mutex_lock(&amp;(sock-&gt;send_lock)) != <span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(sock-&gt;sending_buf + sock-&gt;index, (<span class="type">char</span>*)buffer, len);</span><br><span class="line">    sock-&gt;sending_len += len;</span><br><span class="line">    sock-&gt;index += len;</span><br><span class="line">    pthread_mutex_unlock(&amp;(sock-&gt;send_lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. send_pkt( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">send_pkt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock)</span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;bg4\n&quot;);</span></span><br><span class="line">    <span class="comment">//struct timeval start_time, now_time;</span></span><br><span class="line">    <span class="comment">//gettimeofday(&amp;start_time, NULL);</span></span><br><span class="line">    <span class="comment">//long deltatime = 0; //时间差</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123; <span class="comment">//不断检查和发送数据包</span></span><br><span class="line">        <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;nextseq &lt; sock-&gt;index)&#123; <span class="comment">//检查发送窗口：检查当前发送序列号是否小于索引，确保有数据需要发送。</span></span><br><span class="line">            <span class="comment">//gettimeofday(&amp;now_time, NULL);</span></span><br><span class="line">            <span class="comment">//deltatime = now_time.tv_sec - start_time.tv_sec;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pthread_mutex_lock(&amp;(sock-&gt;send_lock)) != <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> unlen = sock-&gt;sending_len - (sock-&gt;window.wnd_send-&gt;nextseq - sock-&gt;window.wnd_send-&gt;base); <span class="comment">//计算当前未发送的数据长度。 </span></span><br><span class="line">            <span class="type">int</span> len = min(unlen, MAX_DLEN); <span class="comment">//确定本次发送的长度，取未发送长度和最大数据长度中的最小值。 </span></span><br><span class="line">            pthread_mutex_unlock(&amp;(sock-&gt;send_lock));</span><br><span class="line">            <span class="type">int</span> leftlen = sock-&gt;window.wnd_send-&gt;rwnd - (sock-&gt;window.wnd_send-&gt;nextseq - sock-&gt;window.wnd_send-&gt;base);</span><br><span class="line">            len =len&gt;leftlen?leftlen:len;            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;nextseq - sock-&gt;window.wnd_send-&gt;base + len &lt;= sock-&gt;window.wnd_send-&gt;rwnd) &#123; <span class="comment">//检查窗口大小：检查当前已发送的长度加上本次发送长度是否在接收窗口范围内。 </span></span><br><span class="line">                <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">                <span class="type">uint32_t</span> ack = seq + len; <span class="comment">//不理解 </span></span><br><span class="line">                <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">                <span class="type">uint16_t</span> pkt_len = len + DEFAULT_HEADER_LEN;</span><br><span class="line">                <span class="type">char</span> *data = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAX_DLEN);</span><br><span class="line">                <span class="built_in">memcpy</span>(data, sock-&gt;sending_buf + sock-&gt;window.wnd_send-&gt;nextseq, len);</span><br><span class="line">                <span class="type">tju_packet_t</span> *datapacket = create_packet(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, <span class="number">0</span>, <span class="number">0</span>, data, len);</span><br><span class="line">                <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, <span class="number">0</span>, <span class="number">0</span>, data, len);</span><br><span class="line"></span><br><span class="line">                sendToLayer3(ACK, pkt_len);</span><br><span class="line">                </span><br><span class="line">                sock-&gt;window.wnd_send-&gt;nextseq += len;</span><br><span class="line">                pktlist[sock-&gt;packetr] = datapacket;</span><br><span class="line">                gettimeofday(&amp;pktlist[sock-&gt;packetr]-&gt;sent_time, <span class="literal">NULL</span>);</span><br><span class="line">                sock-&gt;packetr = (sock-&gt;packetr + <span class="number">1</span>) % TCP_SENDWN_SIZE;</span><br><span class="line">                <span class="keyword">if</span> (len == (<span class="type">int</span>)(sock-&gt;window.wnd_send-&gt;nextseq - sock-&gt;window.wnd_send-&gt;base))&#123;</span><br><span class="line">                    gettimeofday(&amp;(sock-&gt;window.wnd_send-&gt;send_time), <span class="literal">NULL</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">                    sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">0</span>;</span><br><span class="line">                    pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ed4\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="失序报文数组的管理">失序报文数组的管理</h3>
<p><strong>1. tju_handle_packet( )</strong><br>
<code>tju_handle_packet( )</code>中添加建立连接后收到数据包的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tju_handle_packet</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123;</span><br><span class="line">    `````` 建立连接 ``````</span><br><span class="line">    ````````````````````</span><br><span class="line">    ````````````````````</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sock-&gt;state == ESTABLISHED &amp;&amp; get_flags(pkt) == ACK_FLAG_MASK)&#123; <span class="comment">//收到数据包</span></span><br><span class="line">        <span class="type">char</span> hostname[<span class="number">8</span>];</span><br><span class="line">        gethostname(hostname, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(hostname, <span class="string">&quot;server&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            serverrdt(sock, pkt);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            clientrdt(sock, pkt);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    `````` 关闭连接 ``````</span><br><span class="line">    ````````````````````</span><br><span class="line">    ````````````````````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. <code>tju_tcp_t</code> 结构体中创建空间用来存储失序报文并记录失序报文的个数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TJU_TCP 结构体 保存TJU_TCP用到的各种数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> unorder[<span class="number">100</span>][MAX_LEN]; <span class="comment">//失序报文数组</span></span><br><span class="line">	<span class="type">int</span> unolen; <span class="comment">//失序报文个数</span></span><br><span class="line">&#125; <span class="type">tju_tcp_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. serverrdt( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serverrdt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123; <span class="comment">// 服务器端处理数据包</span></span><br><span class="line">    <span class="keyword">if</span> (get_seq(pkt) &lt; (sock-&gt;window.wnd_recv-&gt;expect_seq))&#123; <span class="comment">//函数发送一个 ACK 响应已确认接收</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">        <span class="type">uint32_t</span> ack = sock-&gt;window.wnd_recv-&gt;expect_seq;</span><br><span class="line">        <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock-&gt;unolen)*MAX_DLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(get_seq(pkt) &gt; (sock-&gt;window.wnd_recv-&gt;expect_seq))&#123; <span class="comment">//数据包乱序，函数将包暂存，并发送 ACK，同时更新接收窗口</span></span><br><span class="line">        <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">        <span class="type">uint32_t</span> ack = sock-&gt;window.wnd_recv-&gt;expect_seq;</span><br><span class="line">        <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">        <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock-&gt;unolen)*MAX_DLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((sock-&gt;unolen) &gt; MAX_PKT_IN_WINDOW)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(sock-&gt;unorder[sock-&gt;unolen], pkt, get_plen(pkt));</span><br><span class="line">        sock-&gt;unolen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//刚刚好</span></span><br><span class="line">        sock-&gt;window.wnd_send-&gt;nextseq=get_ack(pkt);</span><br><span class="line">        sock-&gt;window.wnd_recv-&gt;expect_seq+=get_plen(pkt)-DEFAULT_HEADER_LEN;</span><br><span class="line">        pkt2buffer(sock,pkt);</span><br><span class="line">        <span class="keyword">if</span>(sock-&gt;unolen == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">            <span class="type">uint32_t</span> ack = sock-&gt;window.wnd_recv-&gt;expect_seq;</span><br><span class="line">            <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">            <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag,TCP_RECVWN_SIZE-(sock-&gt;unolen)*MAX_DLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> len = sock-&gt;unolen;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(get_seq(sock-&gt;unorder[i])&gt;get_seq(sock-&gt;unorder[j]))&#123;</span><br><span class="line">                        my_swap(&amp;sock-&gt;unorder[i], &amp;sock-&gt;unorder[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; index &lt; len; index++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(get_seq(sock-&gt;unorder[index]) == sock-&gt;window.wnd_recv-&gt;expect_seq)&#123;</span><br><span class="line">                    sock-&gt;window.wnd_send-&gt;nextseq = get_ack(sock-&gt;unorder[index]);</span><br><span class="line">                    sock-&gt;window.wnd_recv-&gt;expect_seq += get_plen(sock-&gt;unorder[index]) - DEFAULT_HEADER_LEN;</span><br><span class="line">                    pkt2buffer(sock, sock-&gt;unorder[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(get_seq(sock-&gt;unorder[index]) &lt; (sock-&gt;window.wnd_recv-&gt;expect_seq)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(sock-&gt;unorder[i - index], sock-&gt;unorder[i], <span class="keyword">sizeof</span>(sock-&gt;unorder[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            sock-&gt;unolen -= index;</span><br><span class="line">           </span><br><span class="line">            <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">            <span class="type">uint32_t</span> ack = sock-&gt;window.wnd_recv-&gt;expect_seq;</span><br><span class="line">            <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">            <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock-&gt;unolen)*MAX_DLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            sendToLayer3(ACK, DEFAULT_HEADER_LEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. my_swap( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_swap</span><span class="params">(<span class="type">char</span>** a, <span class="type">char</span>** b)</span>&#123;</span><br><span class="line">    <span class="type">char</span>* tem = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MAX_LEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(tem, a, get_plen(b));</span><br><span class="line">    <span class="built_in">memcpy</span>(a, b, get_plen(b));</span><br><span class="line">    <span class="built_in">memcpy</span>(b, tem, get_plen(tem));</span><br><span class="line">    <span class="built_in">free</span>(tem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现累计应答">实现累计应答</h3>
<center>
<img src="https://s2.loli.net/2024/10/11/vKkuC1ibGfmo2sM.png" width="60%" />
<p>Figure 1. 累计应答</p>
</center>
<p><strong>1. clientrdt( )</strong><br>
<code>clientrdt( )</code>函数中添加累计应答处理。当发送方收到任意大于当前base的ack报文后，直接把当前base进行更新即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123; <span class="comment">// 客户端处理数据包</span></span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;base == sock-&gt;window.wnd_send-&gt;nextseq) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (get_ack(pkt) &lt; sock-&gt;window.wnd_send-&gt;base) <span class="keyword">return</span>;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span>(get_ack(pkt) &gt; sock-&gt;window.wnd_send-&gt;base)&#123;</span><br><span class="line">        ``````</span><br><span class="line">        ``````</span><br><span class="line">        ``````</span><br><span class="line">        <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;send_lock)) != <span class="number">0</span>); <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">while</span>(sock-&gt;window.wnd_send-&gt;base &lt; get_ack(pkt) &amp;&amp; sock-&gt;window.wnd_send-&gt;base &lt; sock-&gt;window.wnd_send-&gt;nextseq )&#123;   </span><br><span class="line">            <span class="type">int</span> pkt_len = pktlist[sock-&gt;packetl]-&gt;header.plen;</span><br><span class="line">            <span class="type">int</span> datalen = pkt_len - DEFAULT_HEADER_LEN;</span><br><span class="line">            sock-&gt;sending_len -= datalen;</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;base += datalen;</span><br><span class="line">            sock-&gt;packetl = (sock-&gt;packetl + <span class="number">1</span>) % TCP_SENDWN_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;(sock-&gt;send_lock)); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时重传">超时重传</h3>
<p><strong>1. tju_send( )</strong><br>
<code>tju_send( )</code> 中创建了一个新的线程判断是否要进行重传。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> resend_thread_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tju_send</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span> (!resend_thread_flag)&#123;</span><br><span class="line">        resend_thread_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">pthread_t</span> resendthreadid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;resendthreadid, <span class="literal">NULL</span>,resend_pkt, (<span class="type">void</span> *)sock);</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. resend_pkt( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">resend_pkt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start_time</span>,<span class="title">now_time</span>;</span></span><br><span class="line">    gettimeofday(&amp;start_time, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">long</span> deltatime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;base &lt; sock-&gt;window.wnd_send-&gt;nextseq)&#123;</span><br><span class="line">            gettimeofday(&amp;now_time, <span class="literal">NULL</span>);</span><br><span class="line">            deltatime = now_time.tv_sec - start_time.tv_sec;</span><br><span class="line">            <span class="keyword">if</span> (deltatime &gt; <span class="number">100</span>) <span class="keyword">break</span>; <span class="comment">//不理解</span></span><br><span class="line">            <span class="type">long</span> nowtimeval = <span class="number">1000000</span> * (now_time.tv_sec - sock-&gt;window.wnd_send-&gt;send_time.tv_sec) +  (now_time.tv_usec - sock-&gt;window.wnd_send-&gt;send_time.tv_usec);</span><br><span class="line">            <span class="type">long</span> timeoutval = <span class="number">1000000</span> * (sock-&gt;window.wnd_send-&gt;timeout.tv_sec) + (sock-&gt;window.wnd_send-&gt;timeout.tv_usec);</span><br><span class="line">            <span class="keyword">if</span> (nowtimeval &gt; timeoutval)&#123; <span class="comment">//超时重传</span></span><br><span class="line">                <span class="keyword">while</span>(pktlist[sock-&gt;packetl] == <span class="literal">NULL</span>);</span><br><span class="line">                <span class="type">uint32_t</span> seq = pktlist[sock-&gt;packetl]-&gt;header.seq_num;</span><br><span class="line">                <span class="type">uint32_t</span> ack = pktlist[sock-&gt;packetl]-&gt;header.ack_num;</span><br><span class="line">                <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">                <span class="type">int</span> pkt_len = pktlist[sock-&gt;packetl]-&gt;header.plen;</span><br><span class="line">                <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack,DEFAULT_HEADER_LEN, pkt_len, flag, <span class="number">0</span>, <span class="number">0</span>, pktlist[sock-&gt;packetl]-&gt;data, pkt_len - DEFAULT_HEADER_LEN);</span><br><span class="line">                sendToLayer3(ACK, pkt_len);</span><br><span class="line">                gettimeofday(&amp;pktlist[sock-&gt;packetl]-&gt;sent_time, <span class="literal">NULL</span>);</span><br><span class="line">                gettimeofday(&amp;sock-&gt;window.wnd_send-&gt;send_time, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. clientrdt( )</strong><br>
<code>clientrdt( )</code> 函数中添加动态设置超时间隔的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123; <span class="comment">// 客户端处理数据包</span></span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span>(get_ack(pkt) &gt; sock-&gt;window.wnd_send-&gt;base)&#123;</span><br><span class="line">        <span class="comment">//更新RTO</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">nowtime</span>;</span></span><br><span class="line">        gettimeofday(&amp;nowtime, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">long</span> ntime = <span class="number">1000000</span> * nowtime.tv_sec + nowtime.tv_usec;</span><br><span class="line">        <span class="type">long</span> samplertt = <span class="number">1000000</span> * (nowtime.tv_sec-pktlist[sock-&gt;packetl]-&gt;sent_time.tv_sec)+nowtime.tv_usec-pktlist[sock-&gt;packetl]-&gt;sent_time.tv_usec;</span><br><span class="line">        <span class="type">long</span> estmatedrtt = sock-&gt;window.wnd_send-&gt;estmated_rtt;</span><br><span class="line">        <span class="type">long</span> devrtt = sock-&gt;window.wnd_send-&gt;dev_rtt;</span><br><span class="line">        estmatedrtt = <span class="number">1.0</span> * estmatedrtt * <span class="number">7</span> / <span class="number">8</span> + samplertt / <span class="number">8</span>;</span><br><span class="line">        devrtt = <span class="number">1.0</span> * devrtt * <span class="number">3</span> / <span class="number">4</span> + (samplertt &gt; <span class="number">1.0</span> * estmatedrtt ? (samplertt - estmatedrtt) : (estmatedrtt - samplertt)) / <span class="number">4</span>;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;timeout.tv_usec = (estmatedrtt + <span class="number">4</span> * devrtt) % <span class="number">1000000</span>;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;timeout.tv_sec = (estmatedrtt + <span class="number">4</span> * devrtt) / <span class="number">1000000</span>;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;estmated_rtt = estmatedrtt;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;dev_rtt = devrtt;</span><br><span class="line">        <span class="type">double</span> dsamplertt=(<span class="type">double</span>)samplertt/(<span class="type">double</span>)<span class="number">1000000</span>;</span><br><span class="line">        <span class="type">double</span> destmatedrtt=(<span class="type">double</span>)estmatedrtt/(<span class="type">double</span>)<span class="number">1000000</span>;</span><br><span class="line">        <span class="type">double</span> ddevrtt=(<span class="type">double</span>)devrtt/(<span class="type">double</span>)<span class="number">1000000</span>;</span><br><span class="line">        <span class="type">double</span> dtimegap=(<span class="type">double</span>)(estmatedrtt + <span class="number">4</span> * devrtt)/(<span class="type">double</span>)<span class="number">1000000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line">        ``````</span><br><span class="line">        ``````</span><br><span class="line">        ``````</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速重传">快速重传</h3>
<center>
<img src="https://s2.loli.net/2024/10/11/cj2PfZsz8abBVW9.png" width="60%" />
<p>Figure 1. 快速重传</p>
</center>
<p><strong>1. clientrdt( )</strong><br>
<code>clientrdt( )</code> 函数中添加快速重传的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123; <span class="comment">// 客户端处理数据包</span></span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span>(get_ack(pkt) == sock-&gt;window.wnd_send-&gt;base)&#123; <span class="comment">//冗余ACK</span></span><br><span class="line">        <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;ack_cnt++;</span><br><span class="line">        pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sock-&gt;window.wnd_send-&gt;ack_cnt == <span class="number">3</span>)&#123; <span class="comment">//快速重传 </span></span><br><span class="line">            ``````</span><br><span class="line">            <span class="type">uint32_t</span> seq = pktlist[sock-&gt;packetl]-&gt;header.seq_num;</span><br><span class="line">            <span class="type">uint32_t</span> ack = pktlist[sock-&gt;packetl]-&gt;header.ack_num;</span><br><span class="line">            <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">            <span class="type">int</span> pkt_len = pktlist[sock-&gt;packetl]-&gt;header.plen;</span><br><span class="line">            <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, pkt_len, ACK_FLAG_MASK, <span class="number">0</span>, <span class="number">0</span>, pktlist[sock-&gt;packetl]-&gt;data, pkt_len - DEFAULT_HEADER_LEN);</span><br><span class="line">            sendToLayer3(ACK, pkt_len);</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">0</span>;</span><br><span class="line">            gettimeofday(&amp;pktlist[sock-&gt;packetl]-&gt;sent_time, <span class="literal">NULL</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流量控制">流量控制</h2>
<h3 id="接收方计算接受缓冲区大小">接收方计算接受缓冲区大小</h3>
<p><strong>1. serverrdt( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serverrdt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock, <span class="type">char</span>* pkt)</span>&#123;<span class="comment">// 服务端处理数据包</span></span><br><span class="line">    ``````</span><br><span class="line">    <span class="type">uint32_t</span> seq = sock-&gt;window.wnd_send-&gt;nextseq;</span><br><span class="line">    <span class="type">uint32_t</span> ack = sock-&gt;window.wnd_recv-&gt;expect_seq;</span><br><span class="line">    <span class="type">uint8_t</span> flag = ACK_FLAG_MASK;</span><br><span class="line">    <span class="type">char</span> *ACK = create_packet_buf(sock-&gt;established_local_addr.port, sock-&gt;established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock-&gt;unolen)*MAX_DLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送方调整发送缓冲区大小">发送方调整发送缓冲区大小</h3>
<p><strong>1. clientrdt( )</strong><br>
<code>clientrdt( )</code>函数确定window_size大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span> *sock, <span class="type">char</span> *pkt)</span>&#123;</span><br><span class="line">    ``````</span><br><span class="line">    ``````get_advertised_window(pkt)``````</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. get_advertised_window( )</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">get_advertised_window</span><span class="params">(<span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">17</span>;</span><br><span class="line">    <span class="type">uint16_t</span> var;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;var, msg+offset, SIZE16);</span><br><span class="line">    <span class="keyword">return</span> ntohs(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0窗口探测">0窗口探测</h3>
<p><strong>1. send_pkt( )</strong><br>
<code>send_pkt( )</code>发送数据的线程中加入一个判断条件。<br>
0窗口探测用于在ADVERTISED WINDOW为0的情况下，发送大小为1的数据报文以获得实时的窗口返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">send_pkt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock)</span>&#123;</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span>((sock-&gt;window.wnd_send-&gt;nextseq &gt; sock-&gt;window.wnd_send-&gt;base)&amp;&amp;sock-&gt;window.wnd_send-&gt;rwnd == <span class="number">0</span>)&#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ``````</span><br><span class="line">        ``````</span><br><span class="line">        ``````        </span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拥塞控制">拥塞控制</h2>
<h3 id="慢启动">慢启动</h3>
<p><strong>1. 套接字的初始化使得发送方从其他状态进入慢启动状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tju_tcp_t</span>* <span class="title function_">tju_socket</span><span class="params">()</span>&#123;</span><br><span class="line">    sock-&gt;window.wnd_send-&gt;congestion_status = SLOW_START;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. <code>resend_pkt( )</code>函数超时事件使得发送方从其他状态进入慢启动状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nowtimeval &gt; timeoutval)&#123;</span><br><span class="line">    sock-&gt;window.wnd_send-&gt;congestion_status = SLOW_START;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在慢启动状态下，发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS（MAX_DLEN）。虽然是不断的自增 MSS，但是由于拥塞窗口的增大（进而导致发送窗口的增大），每次自增的次数为 1-&gt;2-&gt;4-&gt;8 直至达到ssthresh，所以拥塞窗口整体上呈现指数增长的趋势。<br>
<strong>3. clientrdt( )</strong><br>
<code>clientrdt( )</code> 函数中发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span> *sock, <span class="type">char</span> *pkt)</span>&#123;   </span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span>(sock-&gt;window.wnd_send-&gt;congestion_status == SLOW_START)&#123; <span class="comment">//慢启动</span></span><br><span class="line">        ``````    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(get_ack(pkt) &gt; sock-&gt;window.wnd_send-&gt;base)&#123; <span class="comment">// new ack</span></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;cwnd += MSS;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">0</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line">            ``````</span><br><span class="line">        &#125;</span><br><span class="line">        ``````</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. resend_pkt( )</strong><br>
<code>resend_pkt( )</code> 函数中处理超时重传导致慢启动参数变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">resend_pkt</span><span class="params">(<span class="type">tju_tcp_t</span>* sock)</span>&#123;</span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span> (nowtimeval &gt; timeoutval)&#123;</span><br><span class="line">        sock-&gt;window.wnd_send-&gt;ssthresh = sock-&gt;window.wnd_send-&gt;cwnd / <span class="number">2</span>; <span class="comment">//拥塞阈值变成拥塞窗口大小的一半</span></span><br><span class="line">        <span class="keyword">if</span>(sock-&gt;window.wnd_send-&gt;ssthresh &lt; MAX_DLEN) sock-&gt;window.wnd_send-&gt;ssthresh = MSS; <span class="comment">//调整</span></span><br><span class="line">        sock-&gt;window.wnd_send-&gt;cwnd = MSS; <span class="comment">//拥塞窗口变成1MSS</span></span><br><span class="line">        sock-&gt;window.wnd_send-&gt;congestion_status = SLOW_START; <span class="comment">//拥塞状态不变</span></span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拥塞避免">拥塞避免</h3>
<p><strong>1. 拥塞窗口超过 ssthresh 进入拥塞避免状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span> *sock, <span class="type">char</span> *pkt)</span>&#123; </span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">if</span>(sock-&gt;window.wnd_send-&gt;congestion_status == SLOW_START)&#123; <span class="comment">//慢启动</span></span><br><span class="line">        ``````</span><br><span class="line">        <span class="keyword">if</span>(sock-&gt;window.wnd_send-&gt;cwnd &gt;= sock-&gt;window.wnd_send-&gt;ssthresh)&#123; <span class="comment">//cwnd达到ssthresh，转为拥塞避免状态</span></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;congestion_status = CONGESTION_AVOIDANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        ``````</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 快速恢复阶段收到正确的 ACK 使得发送方从其他状态进入拥塞避免状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span> *sock, <span class="type">char</span> *pkt)</span>&#123; </span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;congestion_status == FAST_RECOVERY)&#123; <span class="comment">//快速恢复</span></span><br><span class="line">        ``````</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(get_ack(pkt) &gt; sock-&gt;window.wnd_send-&gt;base)&#123; <span class="comment">//new ack</span></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;cwnd = sock-&gt;window.wnd_send-&gt;ssthresh;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">0</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line">          </span><br><span class="line">            sock-&gt;window.wnd_send-&gt;window_size = min(get_advertised_window(pkt), sock-&gt;window.wnd_send-&gt;cwnd);</span><br><span class="line"></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;congestion_status = CONGESTION_AVOIDANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 在拥塞避免状态下，发送方每当收到一个正确的 ACK 报文，拥塞窗口就会增大（1/cwnd）个 MSS。拥塞窗口整体上呈现线性增长的趋势。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span> *sock, <span class="type">char</span> *pkt)</span>&#123;   </span><br><span class="line">    ``````</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;congestion_status == CONGESTION_AVOIDANCE) &#123; <span class="comment">//拥塞避免</span></span><br><span class="line">        ``````</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(get_ack(pkt) &gt; sock-&gt;window.wnd_send-&gt;base)&#123; <span class="comment">//new ack</span></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;cwnd += MSS * ((<span class="type">double</span>)MSS / (<span class="type">double</span>)sock-&gt;window.wnd_send-&gt;cwnd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">0</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line">            </span><br><span class="line">            sock-&gt;window.wnd_send-&gt;window_size = min(get_advertised_window(pkt), sock-&gt;window.wnd_send-&gt;cwnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速恢复">快速恢复</h3>
<p><strong>1. <code>clientrdt( )</code> 发送方收到 3 个冗余 ACK 时，进入快速恢复状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sock-&gt;window.wnd_send-&gt;ack_cnt == <span class="number">3</span>)&#123;  <span class="comment">//快速重传</span></span><br><span class="line">    sock-&gt;window.wnd_send-&gt;ssthresh = sock-&gt;window.wnd_send-&gt;cwnd / <span class="number">2</span>;</span><br><span class="line">    sock-&gt;window.wnd_send-&gt;cwnd = sock-&gt;window.wnd_send-&gt;ssthresh + <span class="number">3</span> * MSS;</span><br><span class="line">    sock-&gt;window.wnd_send-&gt;congestion_status = FAST_RECOVERY; <span class="comment">//快速恢复</span></span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 在快速恢复状态下，如果还是收到冗余 ACK，那么依然在此状态，cwnd+=MSS；当收到正确 ACK 时，则进入拥塞避免状态 ，cwnd=ssthresh；当超时时，回到慢启动，cwnd=1MSS。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientrdt</span><span class="params">(<span class="type">tju_tcp_t</span> *sock, <span class="type">char</span> *pkt)</span>&#123; </span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;window.wnd_send-&gt;congestion_status == FAST_RECOVERY)&#123; <span class="comment">//快速恢复</span></span><br><span class="line">        <span class="keyword">if</span>(get_ack(pkt) == sock-&gt;window.wnd_send-&gt;base)&#123;<span class="comment">//dup ack</span></span><br><span class="line">            <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;ack_cnt++;</span><br><span class="line">            pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));</span><br><span class="line"></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;cwnd += MSS;</span><br><span class="line">                        </span><br><span class="line">            sock-&gt;window.wnd_send-&gt;window_size = min(get_advertised_window(pkt), sock-&gt;window.wnd_send-&gt;cwnd);</span><br><span class="line"></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;congestion_status = FAST_RECOVERY;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(get_ack(pkt) &gt; sock-&gt;window.wnd_send-&gt;base)&#123; <span class="comment">//new ack</span></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;cwnd = sock-&gt;window.wnd_send-&gt;ssthresh;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(pthread_mutex_lock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock)) != <span class="number">0</span>);</span><br><span class="line">            sock-&gt;window.wnd_send-&gt;ack_cnt = <span class="number">0</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;(sock-&gt;window.wnd_send-&gt;ack_cnt_lock));  </span><br><span class="line">         </span><br><span class="line">            sock-&gt;window.wnd_send-&gt;window_size = min(get_advertised_window(pkt), sock-&gt;window.wnd_send-&gt;cwnd);</span><br><span class="line"></span><br><span class="line">            sock-&gt;window.wnd_send-&gt;congestion_status = CONGESTION_AVOIDANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">    ``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://haydenzhy.github.io/">梨花先雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://haydenzhy.github.io/post/3f763db6">https://haydenzhy.github.io/post/3f763db6</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://HaydenZHY.github.io" target="_blank">梨花先雪</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E8%B7%B5/">实践</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/avatar/avatar2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/c29c4a94" title="C语言手写Httpd网站服务器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言手写Httpd网站服务器</div></div></a></div><div class="next-post pull-right"><a href="/post/7f61ed21" title="软件工程综合实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">软件工程综合实践</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/7f61ed21" title="软件工程综合实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="title">软件工程综合实践</div></div></a></div><div><a href="/post/73de793a" title="数据库课程实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-06</div><div class="title">数据库课程实践</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/HaydenZHY/jsdelivr@main/image/avatar/avatar2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梨花先雪</div><div class="author-info__description">言必信，行必果</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HaydenZHY"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HaydenZHY" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:243038409@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">文件结构说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">系统环境信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">具体实验记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">三次握手建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">四次挥手关闭连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.2.</span> <span class="toc-text">可靠数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">发送缓冲区管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B1%E5%BA%8F%E6%8A%A5%E6%96%87%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">失序报文数组的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B4%AF%E8%AE%A1%E5%BA%94%E7%AD%94"><span class="toc-number">3.2.3.</span> <span class="toc-text">实现累计应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">3.2.4.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">3.2.5.</span> <span class="toc-text">快速重传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E8%AE%A1%E7%AE%97%E6%8E%A5%E5%8F%97%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">接收方计算接受缓冲区大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E8%B0%83%E6%95%B4%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">发送方调整发送缓冲区大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">0窗口探测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">3.4.2.</span> <span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">3.4.3.</span> <span class="toc-text">快速恢复</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/289f3202" title="Windows---CMD常用指令">Windows---CMD常用指令</a><time datetime="2025-03-01T14:55:18.000Z" title="发表于 2025-03-01 22:55:18">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/8c98b106" title="配置 Git 使用 Clash 代理">配置 Git 使用 Clash 代理</a><time datetime="2025-03-01T00:41:48.000Z" title="发表于 2025-03-01 08:41:48">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/2161ae63" title="Anaconda新手安装和配置环境">Anaconda新手安装和配置环境</a><time datetime="2025-02-25T13:07:49.000Z" title="发表于 2025-02-25 21:07:49">2025-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/aaf29fca" title="电脑基础操作">电脑基础操作</a><time datetime="2025-02-23T14:14:23.000Z" title="发表于 2025-02-23 22:14:23">2025-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/6e3f7550" title="VSCode中运行Python程序">VSCode中运行Python程序</a><time datetime="2025-02-23T09:42:44.000Z" title="发表于 2025-02-23 17:42:44">2025-02-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: #626079"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 梨花先雪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'HaydenZHY/HaydenZHY.github.io',
      'data-repo-id': 'R_kgDOMtPJmQ',
      'data-category-id': 'DIC_kwDOMtPJmc4ClrGo',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script id="canvas_nest" defer="defer" color="121,206,226" opacity="0.7" zIndex="-1" count="88" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/movies/"]):not([href="/books/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404')
  }
})</script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'a996012aef93459d8c1f716106a6a684';
  var gaud_map_key = 'd85e2aaaa9c353eeacde11351c3f7484';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>